/* tslint:disable */
/* eslint-disable */
/**
 * Hoster API
 * Hosting automation. The easy way
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Accepted notification methods for the user.
 * @export
 * @interface AcceptedNotificationMethods
 */
export interface AcceptedNotificationMethods {
    /**
     * 
     * @type {boolean}
     * @memberof AcceptedNotificationMethods
     */
    'email': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AcceptedNotificationMethods
     */
    'sms': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AcceptedNotificationMethods
     */
    'push': boolean;
}
/**
 * 
 * @export
 * @interface AcceptedNotificationMethodsDto
 */
export interface AcceptedNotificationMethodsDto {
    /**
     * 
     * @type {boolean}
     * @memberof AcceptedNotificationMethodsDto
     */
    'email': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AcceptedNotificationMethodsDto
     */
    'sms': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AcceptedNotificationMethodsDto
     */
    'push': boolean;
}
/**
 * 
 * @export
 * @interface ActionFieldDto
 */
export interface ActionFieldDto {
    /**
     * The unique identifiers of the addon field.
     * @type {string}
     * @memberof ActionFieldDto
     */
    'id'?: string;
    /**
     * A label for the certain addon field.
     * @type {string}
     * @memberof ActionFieldDto
     */
    'label'?: string;
    /**
     * 
     * @type {Value}
     * @memberof ActionFieldDto
     */
    'value'?: Value;
    /**
     * The type of the addon field.
     * @type {string}
     * @memberof ActionFieldDto
     */
    'type'?: ActionFieldDtoTypeEnum;
    /**
     * Indicates if a field is required or not
     * @type {boolean}
     * @memberof ActionFieldDto
     */
    'required'?: boolean;
    /**
     * Indicates if the field is disabled.
     * @type {boolean}
     * @memberof ActionFieldDto
     */
    'disabled'?: boolean;
    /**
     * Indicates if the field will be hidden.
     * @type {boolean}
     * @memberof ActionFieldDto
     */
    'hidden'?: boolean;
    /**
     * A string representing a regular expression for validation.
     * @type {string}
     * @memberof ActionFieldDto
     */
    'regexValidation'?: string;
    /**
     * Indicates if the field needs remote validation.
     * @type {boolean}
     * @memberof ActionFieldDto
     */
    'remoteValidation'?: boolean;
    /**
     * A string that represents an error message.
     * @type {string}
     * @memberof ActionFieldDto
     */
    'error'?: string;
}

export const ActionFieldDtoTypeEnum = {
    TextBox: 'TEXT_BOX',
    TextArea: 'TEXT_AREA',
    Select: 'SELECT',
    MultiSelect: 'MULTI_SELECT',
    Description: 'DESCRIPTION',
    RadioBox: 'RADIO_BOX',
    Checkbox: 'CHECKBOX',
    Slider: 'SLIDER'
} as const;

export type ActionFieldDtoTypeEnum = typeof ActionFieldDtoTypeEnum[keyof typeof ActionFieldDtoTypeEnum];

/**
 * 
 * @export
 * @interface AddonDto
 */
export interface AddonDto {
    /**
     * The unique identifier of the addon.
     * @type {string}
     * @memberof AddonDto
     */
    'id'?: string;
    /**
     * The name of the addon.
     * @type {string}
     * @memberof AddonDto
     */
    'name': string;
    /**
     * An array of the addon title in all supported languages.
     * @type {Array<MultilangTextDto>}
     * @memberof AddonDto
     */
    'title': Array<MultilangTextDto>;
    /**
     * An array that holds a brief text that describes the addon in all supported languages.
     * @type {Array<MultilangTextDto>}
     * @memberof AddonDto
     */
    'description': Array<MultilangTextDto>;
    /**
     * A url that holds the icon of the addon.
     * @type {string}
     * @memberof AddonDto
     */
    'icon_url': string;
    /**
     * An enum that describes the type of the addon.
     * @type {string}
     * @memberof AddonDto
     */
    'type': AddonDtoTypeEnum;
    /**
     * Indicates if the addon is required or not.
     * @type {boolean}
     * @memberof AddonDto
     */
    'required': boolean;
    /**
     * Indicate if the addon is active or not.
     * @type {boolean}
     * @memberof AddonDto
     */
    'active': boolean;
    /**
     * An array that holds all the price policies applied to the addon.
     * @type {Array<PricePolicyDto>}
     * @memberof AddonDto
     */
    'pricePolicies'?: Array<PricePolicyDto>;
    /**
     * An array that holda all the options for the addon.
     * @type {Array<AddonOptionsDto>}
     * @memberof AddonDto
     */
    'options'?: Array<AddonOptionsDto>;
    /**
     * Indicates if the addon can be deleted or not.
     * @type {boolean}
     * @memberof AddonDto
     */
    'deletable'?: boolean;
    /**
     * Indicates if the addon is able to be eddited or not.
     * @type {boolean}
     * @memberof AddonDto
     */
    'editable'?: boolean;
}

export const AddonDtoTypeEnum = {
    TextBox: 'TEXT_BOX',
    TextArea: 'TEXT_AREA',
    List: 'LIST',
    RadioBox: 'RADIO_BOX',
    Checkbox: 'CHECKBOX',
    Slider: 'SLIDER'
} as const;

export type AddonDtoTypeEnum = typeof AddonDtoTypeEnum[keyof typeof AddonDtoTypeEnum];

/**
 * 
 * @export
 * @interface AddonOptionsDto
 */
export interface AddonOptionsDto {
    /**
     * The unique identifier of the option
     * @type {string}
     * @memberof AddonOptionsDto
     */
    'id'?: string;
    /**
     * An array of the addon option title in all supported languages.
     * @type {Array<MultilangTextDto>}
     * @memberof AddonOptionsDto
     */
    'title': Array<MultilangTextDto>;
    /**
     * An array that holds all the price policies applied to the addon option.
     * @type {Array<PricePolicyDto>}
     * @memberof AddonOptionsDto
     */
    'pricePolicies': Array<PricePolicyDto>;
}
/**
 * Details of the affiliate associated with the item
 * @export
 * @interface AffiliateData
 */
export interface AffiliateData {
    /**
     * The identifier of the user supplies affiliate.
     * @type {string}
     * @memberof AffiliateData
     */
    'affiliateId': string;
    /**
     * The type of affiliate,
     * @type {string}
     * @memberof AffiliateData
     */
    'affiliateType': AffiliateDataAffiliateTypeEnum;
    /**
     * The percent or amount.
     * @type {number}
     * @memberof AffiliateData
     */
    'percentOrAmount': number;
    /**
     * Indicates if the item has been paid or not.
     * @type {boolean}
     * @memberof AffiliateData
     */
    'paid': boolean;
    /**
     * The date and time when the payment was made.
     * @type {string}
     * @memberof AffiliateData
     */
    'paidAt': string;
    /**
     * The monetary value to be paid.
     * @type {number}
     * @memberof AffiliateData
     */
    'value': number;
    /**
     * 
     * @type {string}
     * @memberof AffiliateData
     */
    'status': AffiliateDataStatusEnum;
}

export const AffiliateDataAffiliateTypeEnum = {
    Fixed: 'fixed',
    Percentage: 'percentage'
} as const;

export type AffiliateDataAffiliateTypeEnum = typeof AffiliateDataAffiliateTypeEnum[keyof typeof AffiliateDataAffiliateTypeEnum];
export const AffiliateDataStatusEnum = {
    Pending: 'pending',
    Accepted: 'accepted',
    Rejected: 'rejected'
} as const;

export type AffiliateDataStatusEnum = typeof AffiliateDataStatusEnum[keyof typeof AffiliateDataStatusEnum];

/**
 * 
 * @export
 * @interface AffiliateDto
 */
export interface AffiliateDto {
    /**
     * The unique identifier of the affiliate
     * @type {string}
     * @memberof AffiliateDto
     */
    'id'?: string;
    /**
     * The unique identifier of the product.
     * @type {string}
     * @memberof AffiliateDto
     */
    'productId': string;
    /**
     * The unique identifier of the company.
     * @type {string}
     * @memberof AffiliateDto
     */
    'companyId': string;
    /**
     * Data about the product.
     * @type {ProductAffiliateDto}
     * @memberof AffiliateDto
     */
    'data': ProductAffiliateDto;
    /**
     * The date when the policy was created.
     * @type {string}
     * @memberof AffiliateDto
     */
    'createdAt'?: string;
    /**
     * The date when the policy was updated.
     * @type {string}
     * @memberof AffiliateDto
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface AfnicAdditionalDataDto
 */
export interface AfnicAdditionalDataDto {
    /**
     * This field represents the date of birth of the contact in ISO format.
     * @type {string}
     * @memberof AfnicAdditionalDataDto
     */
    'birthDate': string;
    /**
     * This field represents the ISO country code for the contact\'s birthplace.
     * @type {string}
     * @memberof AfnicAdditionalDataDto
     */
    'birthCc': AfnicAdditionalDataDtoBirthCcEnum;
    /**
     * This field represents the birth city of the contact.
     * @type {string}
     * @memberof AfnicAdditionalDataDto
     */
    'birthCity'?: string;
    /**
     * This field represents the postal code of the contact\'s birthplace.
     * @type {string}
     * @memberof AfnicAdditionalDataDto
     */
    'birthPc'?: string;
}

export const AfnicAdditionalDataDtoBirthCcEnum = {
    Af: 'AF',
    Al: 'AL',
    Dz: 'DZ',
    As: 'AS',
    Ad: 'AD',
    Ao: 'AO',
    Ai: 'AI',
    Aq: 'AQ',
    Ag: 'AG',
    Ar: 'AR',
    Am: 'AM',
    Aw: 'AW',
    Au: 'AU',
    At: 'AT',
    Az: 'AZ',
    Bs: 'BS',
    Bh: 'BH',
    Bd: 'BD',
    Bb: 'BB',
    By: 'BY',
    Be: 'BE',
    Bz: 'BZ',
    Bj: 'BJ',
    Bm: 'BM',
    Bt: 'BT',
    Bo: 'BO',
    Bq: 'BQ',
    Ba: 'BA',
    Bw: 'BW',
    Bv: 'BV',
    Br: 'BR',
    Io: 'IO',
    Bn: 'BN',
    Bg: 'BG',
    Bf: 'BF',
    Bi: 'BI',
    Kh: 'KH',
    Cm: 'CM',
    Ca: 'CA',
    Cv: 'CV',
    Ky: 'KY',
    Cf: 'CF',
    Td: 'TD',
    Cl: 'CL',
    Cn: 'CN',
    Cx: 'CX',
    Cc: 'CC',
    Co: 'CO',
    Km: 'KM',
    Cg: 'CG',
    Cd: 'CD',
    Ck: 'CK',
    Cr: 'CR',
    Ci: 'CI',
    Hr: 'HR',
    Cu: 'CU',
    Cw: 'CW',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Dj: 'DJ',
    Dm: 'DM',
    Do: 'DO',
    Ec: 'EC',
    Eg: 'EG',
    Sv: 'SV',
    Gq: 'GQ',
    Er: 'ER',
    Ee: 'EE',
    Et: 'ET',
    Fk: 'FK',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Gf: 'GF',
    Pf: 'PF',
    Tf: 'TF',
    Ga: 'GA',
    Gm: 'GM',
    Ge: 'GE',
    De: 'DE',
    Gh: 'GH',
    Gi: 'GI',
    Gr: 'GR',
    Gl: 'GL',
    Gd: 'GD',
    Gp: 'GP',
    Gu: 'GU',
    Gt: 'GT',
    Gg: 'GG',
    Gn: 'GN',
    Gw: 'GW',
    Gy: 'GY',
    Ht: 'HT',
    Hm: 'HM',
    Va: 'VA',
    Hn: 'HN',
    Hk: 'HK',
    Hu: 'HU',
    Is: 'IS',
    In: 'IN',
    Id: 'ID',
    Ir: 'IR',
    Iq: 'IQ',
    Ie: 'IE',
    Im: 'IM',
    Il: 'IL',
    It: 'IT',
    Jm: 'JM',
    Jp: 'JP',
    Je: 'JE',
    Jo: 'JO',
    Kz: 'KZ',
    Ke: 'KE',
    Ki: 'KI',
    Kp: 'KP',
    Kr: 'KR',
    Kw: 'KW',
    Kg: 'KG',
    La: 'LA',
    Lv: 'LV',
    Lb: 'LB',
    Ls: 'LS',
    Lr: 'LR',
    Ly: 'LY',
    Li: 'LI',
    Lt: 'LT',
    Lu: 'LU',
    Mo: 'MO',
    Mk: 'MK',
    Mg: 'MG',
    Mw: 'MW',
    My: 'MY',
    Mv: 'MV',
    Ml: 'ML',
    Mt: 'MT',
    Mh: 'MH',
    Mq: 'MQ',
    Mr: 'MR',
    Mu: 'MU',
    Tn: 'TN',
    Tr: 'TR',
    Tm: 'TM',
    Tc: 'TC',
    Tv: 'TV',
    Ug: 'UG',
    Ua: 'UA',
    Ae: 'AE',
    Gb: 'GB',
    Us: 'US',
    Um: 'UM',
    Uy: 'UY',
    Uz: 'UZ',
    Vu: 'VU',
    Ve: 'VE',
    Vn: 'VN',
    Vg: 'VG',
    Vi: 'VI',
    Wf: 'WF',
    Eh: 'EH',
    Ye: 'YE',
    Zm: 'ZM',
    Zw: 'ZW',
    Yt: 'YT',
    Mx: 'MX',
    Fm: 'FM',
    Md: 'MD',
    Mc: 'MC',
    Mn: 'MN',
    Me: 'ME',
    Ms: 'MS',
    Ma: 'MA',
    Mz: 'MZ',
    Mm: 'MM',
    Na: 'NA',
    Nr: 'NR',
    Np: 'NP',
    Nl: 'NL',
    Nc: 'NC',
    Nz: 'NZ',
    Ni: 'NI',
    Ne: 'NE',
    Ng: 'NG',
    Nu: 'NU',
    Nf: 'NF',
    Mp: 'MP',
    No: 'NO',
    Om: 'OM',
    Pk: 'PK',
    Pw: 'PW',
    Ps: 'PS',
    Pa: 'PA',
    Pg: 'PG',
    Py: 'PY',
    Pe: 'PE',
    Ph: 'PH',
    Pn: 'PN',
    Pl: 'PL',
    Pt: 'PT',
    Pr: 'PR',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Ru: 'RU',
    Rw: 'RW',
    Bl: 'BL',
    Sh: 'SH',
    Kn: 'KN',
    Lc: 'LC',
    Mf: 'MF',
    Pm: 'PM',
    Vc: 'VC',
    Ws: 'WS',
    Sm: 'SM',
    St: 'ST',
    Sa: 'SA',
    Sn: 'SN',
    Rs: 'RS',
    Sc: 'SC',
    Sl: 'SL',
    Sg: 'SG',
    Sx: 'SX',
    Sk: 'SK',
    Si: 'SI',
    Sb: 'SB',
    So: 'SO',
    Za: 'ZA',
    Gs: 'GS',
    Ss: 'SS',
    Es: 'ES',
    Lk: 'LK',
    Sd: 'SD',
    Sr: 'SR',
    Sj: 'SJ',
    Sz: 'SZ',
    Se: 'SE',
    Ch: 'CH',
    Sy: 'SY',
    Tw: 'TW',
    Tj: 'TJ',
    Tz: 'TZ',
    Th: 'TH',
    Tl: 'TL',
    Tg: 'TG',
    Tk: 'TK',
    To: 'TO',
    Tt: 'TT'
} as const;

export type AfnicAdditionalDataDtoBirthCcEnum = typeof AfnicAdditionalDataDtoBirthCcEnum[keyof typeof AfnicAdditionalDataDtoBirthCcEnum];

/**
 * 
 * @export
 * @interface Attachment
 */
export interface Attachment {
    /**
     * The filename of the attachment
     * @type {string}
     * @memberof Attachment
     */
    'filename': string;
    /**
     * The base64-encoded content of the attachment
     * @type {string}
     * @memberof Attachment
     */
    'content': string;
    /**
     * The content type of the attachment
     * @type {string}
     * @memberof Attachment
     */
    'contentType'?: string;
}
/**
 * 
 * @export
 * @interface CalculatedPriceDto
 */
export interface CalculatedPriceDto {
    /**
     * The percentage profit margin applied to the price.
     * @type {number}
     * @memberof CalculatedPriceDto
     */
    'percentageProfitMargin'?: number;
    /**
     * The maximum profit margin allowed for the price.
     * @type {number}
     * @memberof CalculatedPriceDto
     */
    'maxProfitMargin'?: number;
}
/**
 * 
 * @export
 * @interface CatAdditionalDataDto
 */
export interface CatAdditionalDataDto {
    /**
     * This field represents the language of the contact in the form of an enum.
     * @type {string}
     * @memberof CatAdditionalDataDto
     */
    'language': CatAdditionalDataDtoLanguageEnum;
    /**
     * The name of the person responsible for maintaining this contact.
     * @type {string}
     * @memberof CatAdditionalDataDto
     */
    'maintainer'?: string;
}

export const CatAdditionalDataDtoLanguageEnum = {
    Aa: 'aa',
    Af: 'af',
    Ak: 'ak',
    Sq: 'sq',
    Am: 'am',
    Ar: 'ar',
    An: 'an',
    Hy: 'hy',
    As: 'as',
    Av: 'av',
    Ae: 'ae',
    Ay: 'ay',
    Az: 'az',
    Bm: 'bm',
    Ba: 'ba',
    Eu: 'eu',
    Be: 'be',
    Bn: 'bn',
    Bh: 'bh',
    Bi: 'bi',
    Bs: 'bs',
    Br: 'br',
    Bg: 'bg',
    My: 'my',
    Ca: 'ca',
    Ch: 'ch',
    Ce: 'ce',
    Ny: 'ny',
    Zh: 'zh',
    Cv: 'cv',
    Kw: 'kw',
    Co: 'co',
    Cr: 'cr',
    Hr: 'hr',
    Cs: 'cs',
    Da: 'da',
    Dv: 'dv',
    Nl: 'nl',
    Dz: 'dz',
    En: 'en',
    Eo: 'eo',
    Et: 'et',
    Ee: 'ee',
    Fo: 'fo',
    Fj: 'fj',
    Fi: 'fi',
    Fr: 'fr',
    Ff: 'ff',
    Gl: 'gl',
    Ka: 'ka',
    De: 'de',
    El: 'el',
    Gn: 'gn',
    Gu: 'gu',
    Ht: 'ht',
    Ha: 'ha',
    He: 'he',
    Hz: 'hz',
    Hi: 'hi',
    Ho: 'ho',
    Hu: 'hu',
    Ia: 'ia',
    Id: 'id',
    Ie: 'ie',
    Ga: 'ga',
    Ig: 'ig',
    Ik: 'ik',
    Io: 'io',
    Is: 'is',
    It: 'it',
    Iu: 'iu',
    Ja: 'ja',
    Jv: 'jv',
    Kl: 'kl',
    Kn: 'kn',
    Kr: 'kr',
    Ks: 'ks',
    Kk: 'kk',
    Km: 'km',
    Ki: 'ki',
    Rw: 'rw',
    Ky: 'ky',
    Kv: 'kv',
    Kg: 'kg',
    Ko: 'ko',
    Ku: 'ku',
    Kj: 'kj',
    La: 'la',
    Lb: 'lb',
    Lg: 'lg',
    Li: 'li',
    Ln: 'ln',
    Lo: 'lo',
    Lt: 'lt',
    Lu: 'lu',
    Lv: 'lv',
    Gv: 'gv',
    Mk: 'mk',
    Mg: 'mg',
    Ms: 'ms',
    Ml: 'ml',
    Mt: 'mt',
    Mi: 'mi',
    Mr: 'mr',
    Mh: 'mh',
    Mn: 'mn',
    Na: 'na',
    Nv: 'nv',
    Nd: 'nd',
    Ne: 'ne',
    Ng: 'ng',
    Nb: 'nb',
    Nn: 'nn',
    No: 'no',
    Ii: 'ii',
    Nr: 'nr',
    Oc: 'oc',
    Oj: 'oj',
    Cu: 'cu',
    Om: 'om',
    Or: 'or',
    Os: 'os',
    Pa: 'pa',
    Pi: 'pi',
    Fa: 'fa',
    Pl: 'pl',
    Ps: 'ps',
    Pt: 'pt',
    Qu: 'qu',
    Rm: 'rm',
    Rn: 'rn',
    Ro: 'ro',
    Rh: 'rh',
    Ru: 'ru',
    Sa: 'sa',
    Sc: 'sc',
    Sd: 'sd',
    Se: 'se',
    Sm: 'sm',
    Sg: 'sg',
    Sr: 'sr',
    Gd: 'gd',
    Sn: 'sn',
    Si: 'si',
    Sk: 'sk',
    Sl: 'sl',
    So: 'so',
    St: 'st',
    Es: 'es',
    Su: 'su',
    Sw: 'sw',
    Ss: 'ss',
    Sv: 'sv',
    Ta: 'ta',
    Te: 'te',
    Tg: 'tg',
    Th: 'th',
    Ti: 'ti',
    Bo: 'bo',
    Tk: 'tk',
    Tl: 'tl',
    Tn: 'tn',
    To: 'to',
    Tr: 'tr',
    Ts: 'ts',
    Tt: 'tt',
    Tw: 'tw',
    Ty: 'ty',
    Ug: 'ug',
    Uk: 'uk',
    Ur: 'ur',
    Uz: 'uz',
    Ve: 've',
    Vi: 'vi',
    Vo: 'vo',
    Wa: 'wa',
    Cy: 'cy',
    Wo: 'wo',
    Fy: 'fy',
    Xh: 'xh',
    Yi: 'yi',
    Yo: 'yo',
    Za: 'za',
    Zu: 'zu'
} as const;

export type CatAdditionalDataDtoLanguageEnum = typeof CatAdditionalDataDtoLanguageEnum[keyof typeof CatAdditionalDataDtoLanguageEnum];

/**
 * 
 * @export
 * @interface CatParameterDataDto
 */
export interface CatParameterDataDto {
    /**
     * A string containing maintainer information. Maximum length 128 characters.
     * @type {string}
     * @memberof CatParameterDataDto
     */
    'maintainer': string;
    /**
     * A string describing the intended use for the domain. Maximum length 250 characters.
     * @type {string}
     * @memberof CatParameterDataDto
     */
    'intendedUse': string;
}
/**
 * 
 * @export
 * @interface ChallengeParametersDataDto
 */
export interface ChallengeParametersDataDto {
    /**
     * A collection of challenge questions and their corresponding answers for domain verification.
     * @type {Array<ChallengeQuestionAnswerDto>}
     * @memberof ChallengeParametersDataDto
     */
    'challenges'?: Array<ChallengeQuestionAnswerDto>;
}
/**
 * 
 * @export
 * @interface ChallengeQuestionAnswerDto
 */
export interface ChallengeQuestionAnswerDto {
    /**
     * The question associated with the domain challenge.
     * @type {string}
     * @memberof ChallengeQuestionAnswerDto
     */
    'question': string;
    /**
     * The answer to the challenge question.
     * @type {string}
     * @memberof ChallengeQuestionAnswerDto
     */
    'answer': string;
}
/**
 * 
 * @export
 * @interface CheckDomainNameAvailability200Response
 */
export interface CheckDomainNameAvailability200Response {
    /**
     * 
     * @type {number}
     * @memberof CheckDomainNameAvailability200Response
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof CheckDomainNameAvailability200Response
     */
    'message': string;
    /**
     * 
     * @type {Array<DomainAvailabilityDto>}
     * @memberof CheckDomainNameAvailability200Response
     */
    'data': Array<DomainAvailabilityDto>;
    /**
     * 
     * @type {number}
     * @memberof CheckDomainNameAvailability200Response
     */
    'currentPage': number;
    /**
     * 
     * @type {number}
     * @memberof CheckDomainNameAvailability200Response
     */
    'totalPages': number;
    /**
     * 
     * @type {number}
     * @memberof CheckDomainNameAvailability200Response
     */
    'perPage': number;
}
/**
 * 
 * @export
 * @interface CheckDomainNameAvailabilitySockets200Response
 */
export interface CheckDomainNameAvailabilitySockets200Response {
    /**
     * 
     * @type {number}
     * @memberof CheckDomainNameAvailabilitySockets200Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof CheckDomainNameAvailabilitySockets200Response
     */
    'message'?: string;
    /**
     * 
     * @type {DomainAvailabilityWebsocketsDto}
     * @memberof CheckDomainNameAvailabilitySockets200Response
     */
    'data'?: DomainAvailabilityWebsocketsDto;
}
/**
 * 
 * @export
 * @interface ClaimsTokenDataDto
 */
export interface ClaimsTokenDataDto {
    /**
     * A unique token associated with trademark claims for a domain.
     * @type {string}
     * @memberof ClaimsTokenDataDto
     */
    'claimsToken': string;
}
/**
 * 
 * @export
 * @interface CompanyDto
 */
export interface CompanyDto {
    /**
     * A unique identifier for the company.
     * @type {string}
     * @memberof CompanyDto
     */
    'id'?: string;
    /**
     * The title of the company.
     * @type {string}
     * @memberof CompanyDto
     */
    'title': string;
    /**
     * The username of the company. Must have a unique value. Accepts only lowercase letters and numbers.
     * @type {string}
     * @memberof CompanyDto
     */
    'username': string;
    /**
     * A unique identifier for the owner of the company.
     * @type {string}
     * @memberof CompanyDto
     */
    'ownerId'?: string;
    /**
     * An array which contains the accesses a company can give to it\'s users 
     * @type {Array<CompanyRolesDto>}
     * @memberof CompanyDto
     */
    'roles'?: Array<CompanyRolesDto>;
    /**
     * This array contains unique identifiers for service integrations attached to this.
     * @type {Array<object>}
     * @memberof CompanyDto
     */
    'integrationIds'?: Array<object>;
    /**
     * The url of the company Logo
     * @type {string}
     * @memberof CompanyDto
     */
    'logoUrl'?: string;
    /**
     * The url of the company icon
     * @type {string}
     * @memberof CompanyDto
     */
    'iconUrl'?: string;
    /**
     * A unique identifier key for google tag manager.
     * @type {string}
     * @memberof CompanyDto
     */
    'googleTagManagerId'?: string;
    /**
     * The url of the company\'s privacy policy
     * @type {string}
     * @memberof CompanyDto
     */
    'privacyPolicyUrl': string;
    /**
     * A unique identifier for a tenant asssociated with the company.
     * @type {string}
     * @memberof CompanyDto
     */
    'tenantId'?: string;
    /**
     * An enum that defines the default language.
     * @type {string}
     * @memberof CompanyDto
     */
    'defaultLanguage'?: CompanyDtoDefaultLanguageEnum;
    /**
     * An array that contains all languages that will be used for products.
     * @type {Array<number>}
     * @memberof CompanyDto
     */
    'productLanguages'?: Array<CompanyDtoProductLanguagesEnum>;
    /**
     * The date a product created.
     * @type {string}
     * @memberof CompanyDto
     */
    'createdAt'?: string;
    /**
     * The date a product updated.
     * @type {string}
     * @memberof CompanyDto
     */
    'updatedAt'?: string;
}

export const CompanyDtoDefaultLanguageEnum = {
    Aa: 'aa',
    Af: 'af',
    Ak: 'ak',
    Sq: 'sq',
    Am: 'am',
    Ar: 'ar',
    An: 'an',
    Hy: 'hy',
    As: 'as',
    Av: 'av',
    Ae: 'ae',
    Ay: 'ay',
    Az: 'az',
    Bm: 'bm',
    Ba: 'ba',
    Eu: 'eu',
    Be: 'be',
    Bn: 'bn',
    Bh: 'bh',
    Bi: 'bi',
    Bs: 'bs',
    Br: 'br',
    Bg: 'bg',
    My: 'my',
    Ca: 'ca',
    Ch: 'ch',
    Ce: 'ce',
    Ny: 'ny',
    Zh: 'zh',
    Cv: 'cv',
    Kw: 'kw',
    Co: 'co',
    Cr: 'cr',
    Hr: 'hr',
    Cs: 'cs',
    Da: 'da',
    Dv: 'dv',
    Nl: 'nl',
    Dz: 'dz',
    En: 'en',
    Eo: 'eo',
    Et: 'et',
    Ee: 'ee',
    Fo: 'fo',
    Fj: 'fj',
    Fi: 'fi',
    Fr: 'fr',
    Ff: 'ff',
    Gl: 'gl',
    Ka: 'ka',
    De: 'de',
    El: 'el',
    Gn: 'gn',
    Gu: 'gu',
    Ht: 'ht',
    Ha: 'ha',
    He: 'he',
    Hz: 'hz',
    Hi: 'hi',
    Ho: 'ho',
    Hu: 'hu',
    Ia: 'ia',
    Id: 'id',
    Ie: 'ie',
    Ga: 'ga',
    Ig: 'ig',
    Ik: 'ik',
    Io: 'io',
    Is: 'is',
    It: 'it',
    Iu: 'iu',
    Ja: 'ja',
    Jv: 'jv',
    Kl: 'kl',
    Kn: 'kn',
    Kr: 'kr',
    Ks: 'ks',
    Kk: 'kk',
    Km: 'km',
    Ki: 'ki',
    Rw: 'rw',
    Ky: 'ky',
    Kv: 'kv',
    Kg: 'kg',
    Ko: 'ko',
    Ku: 'ku',
    Kj: 'kj',
    La: 'la',
    Lb: 'lb',
    Lg: 'lg',
    Li: 'li',
    Ln: 'ln',
    Lo: 'lo',
    Lt: 'lt',
    Lu: 'lu',
    Lv: 'lv',
    Gv: 'gv',
    Mk: 'mk',
    Mg: 'mg',
    Ms: 'ms',
    Ml: 'ml',
    Mt: 'mt',
    Mi: 'mi',
    Mr: 'mr',
    Mh: 'mh',
    Mn: 'mn',
    Na: 'na',
    Nv: 'nv',
    Nd: 'nd',
    Ne: 'ne',
    Ng: 'ng',
    Nb: 'nb',
    Nn: 'nn',
    No: 'no',
    Ii: 'ii',
    Nr: 'nr',
    Oc: 'oc',
    Oj: 'oj',
    Cu: 'cu',
    Om: 'om',
    Or: 'or',
    Os: 'os',
    Pa: 'pa',
    Pi: 'pi',
    Fa: 'fa',
    Pl: 'pl',
    Ps: 'ps',
    Pt: 'pt',
    Qu: 'qu',
    Rm: 'rm',
    Rn: 'rn',
    Ro: 'ro',
    Rh: 'rh',
    Ru: 'ru',
    Sa: 'sa',
    Sc: 'sc',
    Sd: 'sd',
    Se: 'se',
    Sm: 'sm',
    Sg: 'sg',
    Sr: 'sr',
    Gd: 'gd',
    Sn: 'sn',
    Si: 'si',
    Sk: 'sk',
    Sl: 'sl',
    So: 'so',
    St: 'st',
    Es: 'es',
    Su: 'su',
    Sw: 'sw',
    Ss: 'ss',
    Sv: 'sv',
    Ta: 'ta',
    Te: 'te',
    Tg: 'tg',
    Th: 'th',
    Ti: 'ti',
    Bo: 'bo',
    Tk: 'tk',
    Tl: 'tl',
    Tn: 'tn',
    To: 'to',
    Tr: 'tr',
    Ts: 'ts',
    Tt: 'tt',
    Tw: 'tw',
    Ty: 'ty',
    Ug: 'ug',
    Uk: 'uk',
    Ur: 'ur',
    Uz: 'uz',
    Ve: 've',
    Vi: 'vi',
    Vo: 'vo',
    Wa: 'wa',
    Cy: 'cy',
    Wo: 'wo',
    Fy: 'fy',
    Xh: 'xh',
    Yi: 'yi',
    Yo: 'yo',
    Za: 'za',
    Zu: 'zu'
} as const;

export type CompanyDtoDefaultLanguageEnum = typeof CompanyDtoDefaultLanguageEnum[keyof typeof CompanyDtoDefaultLanguageEnum];
export const CompanyDtoProductLanguagesEnum = {
    NUMBER_null: null
} as const;

export type CompanyDtoProductLanguagesEnum = typeof CompanyDtoProductLanguagesEnum[keyof typeof CompanyDtoProductLanguagesEnum];

/**
 * 
 * @export
 * @interface CompanyFindResponseDto
 */
export interface CompanyFindResponseDto {
    /**
     * An array that contains objects with company informations.
     * @type {Array<CompanyDto>}
     * @memberof CompanyFindResponseDto
     */
    'results'?: Array<CompanyDto>;
    /**
     * A number that indicates the current page being shown.
     * @type {number}
     * @memberof CompanyFindResponseDto
     */
    'currentPage'?: number;
    /**
     * A number that indicates the number of results per page.
     * @type {number}
     * @memberof CompanyFindResponseDto
     */
    'perPage'?: number;
    /**
     * A number that indicates the total pages will be shown.
     * @type {number}
     * @memberof CompanyFindResponseDto
     */
    'totalPages'?: number;
}
/**
 * 
 * @export
 * @interface CompanyRolesDto
 */
export interface CompanyRolesDto {
    /**
     * A unique identifier for user.
     * @type {string}
     * @memberof CompanyRolesDto
     */
    'userId'?: string;
    /**
     * A enum that describes the role and rights a user has to company.
     * @type {Array<number>}
     * @memberof CompanyRolesDto
     */
    'roles'?: Array<CompanyRolesDtoRolesEnum>;
}

export const CompanyRolesDtoRolesEnum = {
    NUMBER_null: null
} as const;

export type CompanyRolesDtoRolesEnum = typeof CompanyRolesDtoRolesEnum[keyof typeof CompanyRolesDtoRolesEnum];

/**
 * 
 * @export
 * @interface ContactAdditionalDto
 */
export interface ContactAdditionalDto {
    /**
     * Additional data for Afnic contact.
     * @type {AfnicAdditionalDataDto}
     * @memberof ContactAdditionalDto
     */
    'afnicAdditionalData': AfnicAdditionalDataDto;
    /**
     * Additional data for DE contact.
     * @type {DeAdditionalDataDto}
     * @memberof ContactAdditionalDto
     */
    'deAdditionalData': DeAdditionalDataDto;
    /**
     * Additional data for Cat contact.
     * @type {CatAdditionalDataDto}
     * @memberof ContactAdditionalDto
     */
    'catAdditionalData': CatAdditionalDataDto;
    /**
     * Additional data for ES contact.
     * @type {EsAdditionalDataDto}
     * @memberof ContactAdditionalDto
     */
    'esAdditionalData': EsAdditionalDataDto;
    /**
     * Additional data for EU/BE contact.
     * @type {EuBeAdditionalDataDto}
     * @memberof ContactAdditionalDto
     */
    'euAdditionalData': EuBeAdditionalDataDto;
    /**
     * Additional data for IT contact.
     * @type {ItAdditionalDataDto}
     * @memberof ContactAdditionalDto
     */
    'itAdditionalData': ItAdditionalDataDto;
    /**
     * Additional data for LV contact.
     * @type {LvAdditionalDataDto}
     * @memberof ContactAdditionalDto
     */
    'lvAdditionalData': LvAdditionalDataDto;
    /**
     * Additional data for NL contact.
     * @type {NlAdditionalDataDto}
     * @memberof ContactAdditionalDto
     */
    'nlAdditionalData': NlAdditionalDataDto;
    /**
     * Additional data for PRO contact.
     * @type {ProAdditionalDataDto}
     * @memberof ContactAdditionalDto
     */
    'proAdditionalData': ProAdditionalDataDto;
    /**
     * Additional data for UK contact.
     * @type {UkAdditionalDataDto}
     * @memberof ContactAdditionalDto
     */
    'ukAdditionalData': UkAdditionalDataDto;
    /**
     * Additional data for US contact.
     * @type {UsAdditionalDataDto}
     * @memberof ContactAdditionalDto
     */
    'usAdditionalData'?: UsAdditionalDataDto;
}
/**
 * 
 * @export
 * @interface CouponDto
 */
export interface CouponDto {
    /**
     * The unique identifier of the coupon.
     * @type {string}
     * @memberof CouponDto
     */
    'id'?: string;
    /**
     * The code associated with the coupon.
     * @type {string}
     * @memberof CouponDto
     */
    'couponCode'?: string;
    /**
     * The ID of the company associated with the coupon.
     * @type {string}
     * @memberof CouponDto
     */
    'companyId'?: string;
    /**
     * The ID of the user associated with the coupon.
     * @type {string}
     * @memberof CouponDto
     */
    'userId'?: string;
    /**
     * Indicates whether the coupon is hidden from the user.
     * @type {boolean}
     * @memberof CouponDto
     */
    'hiddenFromUser'?: boolean;
    /**
     * An array of coupon products.
     * @type {Array<CouponProductsDto>}
     * @memberof CouponDto
     */
    'couponProducts': Array<CouponProductsDto>;
    /**
     * The start date of the coupon\'s validity.
     * @type {string}
     * @memberof CouponDto
     */
    'startDate'?: string;
    /**
     * The end date of the coupon\'s validity.
     * @type {string}
     * @memberof CouponDto
     */
    'endDate'?: string;
    /**
     * The date when the coupon was created.
     * @type {string}
     * @memberof CouponDto
     */
    'createdAt'?: string;
    /**
     * The date when the coupon was last updated.
     * @type {string}
     * @memberof CouponDto
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface CouponProductsDto
 */
export interface CouponProductsDto {
    /**
     * An array of product IDs where the coupon will apply.
     * @type {Array<string>}
     * @memberof CouponProductsDto
     */
    'productΙds'?: Array<string>;
    /**
     * Indicates whether the coupon can be applied to only one Item per order.
     * @type {boolean}
     * @memberof CouponProductsDto
     */
    'oneProductPerOrder': boolean;
    /**
     * Select all durations that the coupon can be applied to.
     * @type {Array<string>}
     * @memberof CouponProductsDto
     */
    'appliedOnDurations': Array<CouponProductsDtoAppliedOnDurationsEnum>;
    /**
     * Select the action where the coupon will apply.
     * @type {string}
     * @memberof CouponProductsDto
     */
    'appliedOnActions': CouponProductsDtoAppliedOnActionsEnum;
    /**
     * If true, the coupon is applied to any addons that apply to the item. If false addons price is not affected by the coupon
     * @type {boolean}
     * @memberof CouponProductsDto
     */
    'appliedOnAddons'?: boolean;
    /**
     * The type of coupon associated with the product.
     * @type {CouponTypeDto}
     * @memberof CouponProductsDto
     */
    'couponType': CouponTypeDto;
    /**
     * The total number of times a coupon can be applied.
     * @type {number}
     * @memberof CouponProductsDto
     */
    'timesCanBeAppliedTotal'?: number;
    /**
     * The number of times a coupon can be applied per user.
     * @type {number}
     * @memberof CouponProductsDto
     */
    'timesCanBeAppliedPerUser'?: number;
}

export const CouponProductsDtoAppliedOnDurationsEnum = {
    _1: '1',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5',
    _6: '6',
    _7: '7',
    _8: '8',
    _9: '9',
    _10: '10',
    _11: '11',
    _12: '12',
    _24: '24',
    _36: '36',
    _48: '48',
    _60: '60',
    _72: '72',
    _84: '84',
    _96: '96',
    _108: '108',
    _120: '120'
} as const;

export type CouponProductsDtoAppliedOnDurationsEnum = typeof CouponProductsDtoAppliedOnDurationsEnum[keyof typeof CouponProductsDtoAppliedOnDurationsEnum];
export const CouponProductsDtoAppliedOnActionsEnum = {
    Create: 'CREATE',
    Renew: 'RENEW',
    Setup: 'SETUP'
} as const;

export type CouponProductsDtoAppliedOnActionsEnum = typeof CouponProductsDtoAppliedOnActionsEnum[keyof typeof CouponProductsDtoAppliedOnActionsEnum];

/**
 * 
 * @export
 * @interface CouponTypeDto
 */
export interface CouponTypeDto {
    /**
     * The type of the coupon (e.g., FIXED).
     * @type {string}
     * @memberof CouponTypeDto
     */
    'type': CouponTypeDtoTypeEnum;
    /**
     * any coupon type from enum, must have a value
     * @type {number}
     * @memberof CouponTypeDto
     */
    'value': number;
    /**
     * An array of product IDs where the coupon will apply.
     * @type {Array<string>}
     * @memberof CouponTypeDto
     */
    'otherProductIds'?: Array<string>;
    /**
     * Select where to apply the coupon (e.g., EVERYTHING).
     * @type {string}
     * @memberof CouponTypeDto
     */
    'whichToApply'?: CouponTypeDtoWhichToApplyEnum;
}

export const CouponTypeDtoTypeEnum = {
    Percentage: 'PERCENTAGE',
    Fixed: 'FIXED',
    CustomPrice: 'CUSTOM_PRICE',
    ExtraMonths: 'EXTRA_MONTHS',
    OtherItemPercentage: 'OTHER_ITEM_PERCENTAGE'
} as const;

export type CouponTypeDtoTypeEnum = typeof CouponTypeDtoTypeEnum[keyof typeof CouponTypeDtoTypeEnum];
export const CouponTypeDtoWhichToApplyEnum = {
    All: 'ALL',
    LowestPrice: 'LOWEST_PRICE',
    HighestPrice: 'HIGHEST_PRICE'
} as const;

export type CouponTypeDtoWhichToApplyEnum = typeof CouponTypeDtoWhichToApplyEnum[keyof typeof CouponTypeDtoWhichToApplyEnum];

/**
 * 
 * @export
 * @interface CreateAffiliate200Response
 */
export interface CreateAffiliate200Response {
    /**
     * 
     * @type {number}
     * @memberof CreateAffiliate200Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateAffiliate200Response
     */
    'message'?: string;
    /**
     * 
     * @type {AffiliateDto}
     * @memberof CreateAffiliate200Response
     */
    'data'?: AffiliateDto;
}
/**
 * 
 * @export
 * @interface CreateCompany200Response
 */
export interface CreateCompany200Response {
    /**
     * 
     * @type {number}
     * @memberof CreateCompany200Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateCompany200Response
     */
    'message'?: string;
    /**
     * 
     * @type {CompanyDto}
     * @memberof CreateCompany200Response
     */
    'data'?: CompanyDto;
}
/**
 * 
 * @export
 * @interface CreateDomainCategory201Response
 */
export interface CreateDomainCategory201Response {
    /**
     * 
     * @type {number}
     * @memberof CreateDomainCategory201Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateDomainCategory201Response
     */
    'message'?: string;
    /**
     * 
     * @type {DomainCategoryDto}
     * @memberof CreateDomainCategory201Response
     */
    'data'?: DomainCategoryDto;
}
/**
 * 
 * @export
 * @interface CreateDomainContact200Response
 */
export interface CreateDomainContact200Response {
    /**
     * 
     * @type {number}
     * @memberof CreateDomainContact200Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateDomainContact200Response
     */
    'message'?: string;
    /**
     * 
     * @type {DomainContactDto}
     * @memberof CreateDomainContact200Response
     */
    'data'?: DomainContactDto;
}
/**
 * 
 * @export
 * @interface CreateIntegration201Response
 */
export interface CreateIntegration201Response {
    /**
     * 
     * @type {number}
     * @memberof CreateIntegration201Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateIntegration201Response
     */
    'message'?: string;
    /**
     * 
     * @type {IntegrationDto}
     * @memberof CreateIntegration201Response
     */
    'data'?: IntegrationDto;
}
/**
 * 
 * @export
 * @interface CreateInvoiceContact200Response
 */
export interface CreateInvoiceContact200Response {
    /**
     * 
     * @type {number}
     * @memberof CreateInvoiceContact200Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateInvoiceContact200Response
     */
    'message'?: string;
    /**
     * 
     * @type {InvoiceContactDto}
     * @memberof CreateInvoiceContact200Response
     */
    'data'?: InvoiceContactDto;
}
/**
 * 
 * @export
 * @interface CreateIpGroup200Response
 */
export interface CreateIpGroup200Response {
    /**
     * 
     * @type {number}
     * @memberof CreateIpGroup200Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateIpGroup200Response
     */
    'message'?: string;
    /**
     * 
     * @type {IpGroupDto}
     * @memberof CreateIpGroup200Response
     */
    'data'?: IpGroupDto;
}
/**
 * 
 * @export
 * @interface CreateIssue201Response
 */
export interface CreateIssue201Response {
    /**
     * 
     * @type {number}
     * @memberof CreateIssue201Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateIssue201Response
     */
    'message'?: string;
    /**
     * 
     * @type {IssueDto}
     * @memberof CreateIssue201Response
     */
    'data'?: IssueDto;
}
/**
 * 
 * @export
 * @interface CreateOrder201Response
 */
export interface CreateOrder201Response {
    /**
     * 
     * @type {number}
     * @memberof CreateOrder201Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateOrder201Response
     */
    'message'?: string;
    /**
     * 
     * @type {OrderDto}
     * @memberof CreateOrder201Response
     */
    'data'?: OrderDto;
}
/**
 * 
 * @export
 * @interface CreatePayment200Response
 */
export interface CreatePayment200Response {
    /**
     * 
     * @type {number}
     * @memberof CreatePayment200Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreatePayment200Response
     */
    'message'?: string;
    /**
     * 
     * @type {PaymentRedirectUrlResponseDto}
     * @memberof CreatePayment200Response
     */
    'data'?: PaymentRedirectUrlResponseDto;
}
/**
 * 
 * @export
 * @interface CreatePolicy200Response
 */
export interface CreatePolicy200Response {
    /**
     * 
     * @type {number}
     * @memberof CreatePolicy200Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreatePolicy200Response
     */
    'message'?: string;
    /**
     * 
     * @type {PolicyDto}
     * @memberof CreatePolicy200Response
     */
    'data'?: PolicyDto;
}
/**
 * 
 * @export
 * @interface CreateProduct201Response
 */
export interface CreateProduct201Response {
    /**
     * 
     * @type {number}
     * @memberof CreateProduct201Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateProduct201Response
     */
    'message'?: string;
    /**
     * 
     * @type {ProductDto}
     * @memberof CreateProduct201Response
     */
    'data'?: ProductDto;
}
/**
 * 
 * @export
 * @interface CreateProductCategory201Response
 */
export interface CreateProductCategory201Response {
    /**
     * 
     * @type {number}
     * @memberof CreateProductCategory201Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateProductCategory201Response
     */
    'message'?: string;
    /**
     * 
     * @type {ProductCategoryDto}
     * @memberof CreateProductCategory201Response
     */
    'data'?: ProductCategoryDto;
}
/**
 * 
 * @export
 * @interface CreateTemplate201Response
 */
export interface CreateTemplate201Response {
    /**
     * 
     * @type {number}
     * @memberof CreateTemplate201Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateTemplate201Response
     */
    'message'?: string;
    /**
     * 
     * @type {TemplateDto}
     * @memberof CreateTemplate201Response
     */
    'data'?: TemplateDto;
}
/**
 * 
 * @export
 * @interface CreateTld200Response
 */
export interface CreateTld200Response {
    /**
     * 
     * @type {number}
     * @memberof CreateTld200Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateTld200Response
     */
    'message'?: string;
    /**
     * 
     * @type {TldDto}
     * @memberof CreateTld200Response
     */
    'data'?: TldDto;
}
/**
 * Currency user uses.
 * @export
 * @interface Currency
 */
export interface Currency {
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    'threeLetterCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    'symbol'?: string;
}
/**
 * 
 * @export
 * @interface CurrencyDto
 */
export interface CurrencyDto {
    /**
     * 
     * @type {string}
     * @memberof CurrencyDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CurrencyDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CurrencyDto
     */
    'threeLetterCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof CurrencyDto
     */
    'symbol'?: string;
}
/**
 * An array of custom addon price policies for this user.
 * @export
 * @interface CustomAddonPricePolicies
 */
export interface CustomAddonPricePolicies {
    /**
     * The unique identifier of the policy.
     * @type {string}
     * @memberof CustomAddonPricePolicies
     */
    'policyId': string;
    /**
     * The unique identifier of the addon.
     * @type {string}
     * @memberof CustomAddonPricePolicies
     */
    'addonId': string;
    /**
     * 
     * @type {PolicyData}
     * @memberof CustomAddonPricePolicies
     */
    'policy'?: PolicyData;
    /**
     * An array of calculated prices.
     * @type {Array<CalculatedPriceDto>}
     * @memberof CustomAddonPricePolicies
     */
    'calculatedPrices'?: Array<CalculatedPriceDto>;
    /**
     * An array of PriceDto objects.
     * @type {Array<PriceDto>}
     * @memberof CustomAddonPricePolicies
     */
    'prices'?: Array<PriceDto>;
}
/**
 * An array containing affiliates related to the user.
 * @export
 * @interface CustomAffiliates
 */
export interface CustomAffiliates {
    /**
     * The unique identifier of the affiliate
     * @type {string}
     * @memberof CustomAffiliates
     */
    'id'?: string;
    /**
     * The unique identifier of the product.
     * @type {string}
     * @memberof CustomAffiliates
     */
    'productId': string;
    /**
     * The unique identifier of the company.
     * @type {string}
     * @memberof CustomAffiliates
     */
    'companyId': string;
    /**
     * Data about the product.
     * @type {ProductAffiliateDto}
     * @memberof CustomAffiliates
     */
    'data': ProductAffiliateDto;
    /**
     * The date when the policy was created.
     * @type {string}
     * @memberof CustomAffiliates
     */
    'createdAt'?: string;
    /**
     * The date when the policy was updated.
     * @type {string}
     * @memberof CustomAffiliates
     */
    'updatedAt'?: string;
}
/**
 * An array of custom price policies for this user.
 * @export
 * @interface CustomPricePolicies
 */
export interface CustomPricePolicies {
    /**
     * The unique identifier of the policy.
     * @type {string}
     * @memberof CustomPricePolicies
     */
    'policyId': string;
    /**
     * The unique identifier of the product.
     * @type {string}
     * @memberof CustomPricePolicies
     */
    'productId': string;
    /**
     * 
     * @type {Policy}
     * @memberof CustomPricePolicies
     */
    'policy'?: Policy;
    /**
     * An array of calculated prices.
     * @type {Array<CalculatedPriceDto>}
     * @memberof CustomPricePolicies
     */
    'calculatedPrices'?: Array<CalculatedPriceDto>;
    /**
     * An array of price objects.
     * @type {Array<PriceDto>}
     * @memberof CustomPricePolicies
     */
    'prices'?: Array<PriceDto>;
}
/**
 * 
 * @export
 * @interface CustomToken200Response
 */
export interface CustomToken200Response {
    /**
     * 
     * @type {number}
     * @memberof CustomToken200Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof CustomToken200Response
     */
    'message'?: string;
    /**
     * 
     * @type {CustomTokenDto}
     * @memberof CustomToken200Response
     */
    'data'?: CustomTokenDto;
}
/**
 * 
 * @export
 * @interface CustomTokenDto
 */
export interface CustomTokenDto {
    /**
     * Custom token for the user.
     * @type {string}
     * @memberof CustomTokenDto
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface DeAdditionalDataDto
 */
export interface DeAdditionalDataDto {
    /**
     * Accepted values: PERSON - ROLE - ORG
     * @type {string}
     * @memberof DeAdditionalDataDto
     */
    'contactType': DeAdditionalDataDtoContactTypeEnum;
}

export const DeAdditionalDataDtoContactTypeEnum = {
    Person: 'PERSON',
    Role: 'ROLE',
    Org: 'ORG'
} as const;

export type DeAdditionalDataDtoContactTypeEnum = typeof DeAdditionalDataDtoContactTypeEnum[keyof typeof DeAdditionalDataDtoContactTypeEnum];

/**
 * Invoice contact user uses by default.
 * @export
 * @interface DefaultInvoiceContact
 */
export interface DefaultInvoiceContact {
    /**
     * The unique identifier for the contact.
     * @type {string}
     * @memberof DefaultInvoiceContact
     */
    'id'?: string;
    /**
     * The unique identifier of the company associated with this contact.
     * @type {string}
     * @memberof DefaultInvoiceContact
     */
    'companyId': string;
    /**
     * The unique identifier of the company associated with this contact.
     * @type {string}
     * @memberof DefaultInvoiceContact
     */
    'userId': string;
    /**
     * The email address of the contact.
     * @type {string}
     * @memberof DefaultInvoiceContact
     */
    'email': string;
    /**
     * The first name of the contact.
     * @type {string}
     * @memberof DefaultInvoiceContact
     */
    'firstName': string;
    /**
     * The last name of the contact.
     * @type {string}
     * @memberof DefaultInvoiceContact
     */
    'lastName': string;
    /**
     * Indicates if the contact represents a company.
     * @type {boolean}
     * @memberof DefaultInvoiceContact
     */
    'isCompany': boolean;
    /**
     * The name of the company if the contact represents a company.
     * @type {string}
     * @memberof DefaultInvoiceContact
     */
    'companyName'?: string;
    /**
     * The telephone number of the contact.
     * @type {string}
     * @memberof DefaultInvoiceContact
     */
    'telephone': string;
    /**
     * The mobile number of the contact.
     * @type {string}
     * @memberof DefaultInvoiceContact
     */
    'mobile'?: string;
    /**
     * The first address line.
     * @type {string}
     * @memberof DefaultInvoiceContact
     */
    'address1': string;
    /**
     * The second address line.
     * @type {string}
     * @memberof DefaultInvoiceContact
     */
    'address2'?: string;
    /**
     * The third address line.
     * @type {string}
     * @memberof DefaultInvoiceContact
     */
    'address3'?: string;
    /**
     * The postal code or ZIP code.
     * @type {string}
     * @memberof DefaultInvoiceContact
     */
    'postcode': string;
    /**
     * The city where the contact is located.
     * @type {string}
     * @memberof DefaultInvoiceContact
     */
    'city': string;
    /**
     * The country where the contact is located.
     * @type {string}
     * @memberof DefaultInvoiceContact
     */
    'country': DefaultInvoiceContactCountryEnum;
    /**
     * The state or region where the contact is located.
     * @type {string}
     * @memberof DefaultInvoiceContact
     */
    'state'?: string;
    /**
     * The Value Added Tax (VAT) number of the contact.
     * @type {string}
     * @memberof DefaultInvoiceContact
     */
    'vat'?: string;
    /**
     * The tax office related to the contact.
     * @type {string}
     * @memberof DefaultInvoiceContact
     */
    'taxOffice'?: string;
    /**
     * The date and time when the contact was created.
     * @type {string}
     * @memberof DefaultInvoiceContact
     */
    'createdAt'?: string;
    /**
     * The date and time when the contact was last updated.
     * @type {string}
     * @memberof DefaultInvoiceContact
     */
    'updatedAt'?: string;
}

export const DefaultInvoiceContactCountryEnum = {
    Af: 'AF',
    Al: 'AL',
    Dz: 'DZ',
    As: 'AS',
    Ad: 'AD',
    Ao: 'AO',
    Ai: 'AI',
    Aq: 'AQ',
    Ag: 'AG',
    Ar: 'AR',
    Am: 'AM',
    Aw: 'AW',
    Au: 'AU',
    At: 'AT',
    Az: 'AZ',
    Bs: 'BS',
    Bh: 'BH',
    Bd: 'BD',
    Bb: 'BB',
    By: 'BY',
    Be: 'BE',
    Bz: 'BZ',
    Bj: 'BJ',
    Bm: 'BM',
    Bt: 'BT',
    Bo: 'BO',
    Bq: 'BQ',
    Ba: 'BA',
    Bw: 'BW',
    Bv: 'BV',
    Br: 'BR',
    Io: 'IO',
    Bn: 'BN',
    Bg: 'BG',
    Bf: 'BF',
    Bi: 'BI',
    Kh: 'KH',
    Cm: 'CM',
    Ca: 'CA',
    Cv: 'CV',
    Ky: 'KY',
    Cf: 'CF',
    Td: 'TD',
    Cl: 'CL',
    Cn: 'CN',
    Cx: 'CX',
    Cc: 'CC',
    Co: 'CO',
    Km: 'KM',
    Cg: 'CG',
    Cd: 'CD',
    Ck: 'CK',
    Cr: 'CR',
    Ci: 'CI',
    Hr: 'HR',
    Cu: 'CU',
    Cw: 'CW',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Dj: 'DJ',
    Dm: 'DM',
    Do: 'DO',
    Ec: 'EC',
    Eg: 'EG',
    Sv: 'SV',
    Gq: 'GQ',
    Er: 'ER',
    Ee: 'EE',
    Et: 'ET',
    Fk: 'FK',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Gf: 'GF',
    Pf: 'PF',
    Tf: 'TF',
    Ga: 'GA',
    Gm: 'GM',
    Ge: 'GE',
    De: 'DE',
    Gh: 'GH',
    Gi: 'GI',
    Gr: 'GR',
    Gl: 'GL',
    Gd: 'GD',
    Gp: 'GP',
    Gu: 'GU',
    Gt: 'GT',
    Gg: 'GG',
    Gn: 'GN',
    Gw: 'GW',
    Gy: 'GY',
    Ht: 'HT',
    Hm: 'HM',
    Va: 'VA',
    Hn: 'HN',
    Hk: 'HK',
    Hu: 'HU',
    Is: 'IS',
    In: 'IN',
    Id: 'ID',
    Ir: 'IR',
    Iq: 'IQ',
    Ie: 'IE',
    Im: 'IM',
    Il: 'IL',
    It: 'IT',
    Jm: 'JM',
    Jp: 'JP',
    Je: 'JE',
    Jo: 'JO',
    Kz: 'KZ',
    Ke: 'KE',
    Ki: 'KI',
    Kp: 'KP',
    Kr: 'KR',
    Kw: 'KW',
    Kg: 'KG',
    La: 'LA',
    Lv: 'LV',
    Lb: 'LB',
    Ls: 'LS',
    Lr: 'LR',
    Ly: 'LY',
    Li: 'LI',
    Lt: 'LT',
    Lu: 'LU',
    Mo: 'MO',
    Mk: 'MK',
    Mg: 'MG',
    Mw: 'MW',
    My: 'MY',
    Mv: 'MV',
    Ml: 'ML',
    Mt: 'MT',
    Mh: 'MH',
    Mq: 'MQ',
    Mr: 'MR',
    Mu: 'MU',
    Tn: 'TN',
    Tr: 'TR',
    Tm: 'TM',
    Tc: 'TC',
    Tv: 'TV',
    Ug: 'UG',
    Ua: 'UA',
    Ae: 'AE',
    Gb: 'GB',
    Us: 'US',
    Um: 'UM',
    Uy: 'UY',
    Uz: 'UZ',
    Vu: 'VU',
    Ve: 'VE',
    Vn: 'VN',
    Vg: 'VG',
    Vi: 'VI',
    Wf: 'WF',
    Eh: 'EH',
    Ye: 'YE',
    Zm: 'ZM',
    Zw: 'ZW',
    Yt: 'YT',
    Mx: 'MX',
    Fm: 'FM',
    Md: 'MD',
    Mc: 'MC',
    Mn: 'MN',
    Me: 'ME',
    Ms: 'MS',
    Ma: 'MA',
    Mz: 'MZ',
    Mm: 'MM',
    Na: 'NA',
    Nr: 'NR',
    Np: 'NP',
    Nl: 'NL',
    Nc: 'NC',
    Nz: 'NZ',
    Ni: 'NI',
    Ne: 'NE',
    Ng: 'NG',
    Nu: 'NU',
    Nf: 'NF',
    Mp: 'MP',
    No: 'NO',
    Om: 'OM',
    Pk: 'PK',
    Pw: 'PW',
    Ps: 'PS',
    Pa: 'PA',
    Pg: 'PG',
    Py: 'PY',
    Pe: 'PE',
    Ph: 'PH',
    Pn: 'PN',
    Pl: 'PL',
    Pt: 'PT',
    Pr: 'PR',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Ru: 'RU',
    Rw: 'RW',
    Bl: 'BL',
    Sh: 'SH',
    Kn: 'KN',
    Lc: 'LC',
    Mf: 'MF',
    Pm: 'PM',
    Vc: 'VC',
    Ws: 'WS',
    Sm: 'SM',
    St: 'ST',
    Sa: 'SA',
    Sn: 'SN',
    Rs: 'RS',
    Sc: 'SC',
    Sl: 'SL',
    Sg: 'SG',
    Sx: 'SX',
    Sk: 'SK',
    Si: 'SI',
    Sb: 'SB',
    So: 'SO',
    Za: 'ZA',
    Gs: 'GS',
    Ss: 'SS',
    Es: 'ES',
    Lk: 'LK',
    Sd: 'SD',
    Sr: 'SR',
    Sj: 'SJ',
    Sz: 'SZ',
    Se: 'SE',
    Ch: 'CH',
    Sy: 'SY',
    Tw: 'TW',
    Tj: 'TJ',
    Tz: 'TZ',
    Th: 'TH',
    Tl: 'TL',
    Tg: 'TG',
    Tk: 'TK',
    To: 'TO',
    Tt: 'TT'
} as const;

export type DefaultInvoiceContactCountryEnum = typeof DefaultInvoiceContactCountryEnum[keyof typeof DefaultInvoiceContactCountryEnum];

/**
 * 
 * @export
 * @interface DomainAdditionalDto
 */
export interface DomainAdditionalDto {
    /**
     * Additional parameters for Cat domains.cat is the sponsored generic top-level domain (TLD) for the Catalan language. It isn\'t territorial, however, so anyone in the world can register a . cat domain name—the only requirement is that you belong to the linguistic community for Catalan speakers.
     * @type {CatParameterDataDto}
     * @memberof DomainAdditionalDto
     */
    'catParameterData'?: CatParameterDataDto;
    /**
     * Parameters for domain challenges.
     * @type {ChallengeParametersDataDto}
     * @memberof DomainAdditionalDto
     */
    'challengeParametersData'?: ChallengeParametersDataDto;
    /**
     * Data for trademark claims token.
     * @type {ClaimsTokenDataDto}
     * @memberof DomainAdditionalDto
     */
    'claimsTokenData'?: ClaimsTokenDataDto;
    /**
     * Additional parameters for Donuts premium domains.
     * @type {DonutsPriceCategoryDataDto}
     * @memberof DomainAdditionalDto
     */
    'donutsPriceCategoryData'?: DonutsPriceCategoryDataDto;
    /**
     * Intended use parameters for domain registration.
     * @type {IntendedUseParamsDataDto}
     * @memberof DomainAdditionalDto
     */
    'intendedUseParamsData'?: IntendedUseParamsDataDto;
    /**
     * If set to true and if the Proxy service is supported, the domain will have the Proxy service enabled when registered
     * @type {ProxyServiceDataDto}
     * @memberof DomainAdditionalDto
     */
    'proxyServiceData'?: ProxyServiceDataDto;
    /**
     * This is only required for domains that the registry specify have a premium price category associated with,Premium domain names are high-quality domains that have been previously registered but are available for sale at today\'s market value. A domain is considered to be high quality if the name is shorter, regularly searched, closely associated to the actual service or industry, and typically uses a TLD
     * @type {PremiumPriceCategoryDataDto}
     * @memberof DomainAdditionalDto
     */
    'premiumPriceCategory'?: PremiumPriceCategoryDataDto;
    /**
     * The SunriseData parameter must be supplied when sending the RegisterDomain command with a LaunchPhase of SR. A Sunrise Phase refers to a period during which, the trademark holders can register domain names corresponding to their marks before names are accessible to the general public.
     * @type {SunriseDataDto}
     * @memberof DomainAdditionalDto
     */
    'sunriseData'?: SunriseDataDto;
    /**
     * Additional data for .xxx domain names.
     * @type {XXXMemberDataDto}
     * @memberof DomainAdditionalDto
     */
    'xxxMemberData'?: XXXMemberDataDto;
    /**
     * Additional data for .uk direct domains.
     * @type {UKDirectDataDto}
     * @memberof DomainAdditionalDto
     */
    'ukDirectData'?: UKDirectDataDto;
}
/**
 * 
 * @export
 * @interface DomainAvailabilityDto
 */
export interface DomainAvailabilityDto {
    /**
     * The name of the domain.
     * @type {string}
     * @memberof DomainAvailabilityDto
     */
    'domainName': string;
    /**
     * Indicates whether the domain is available for registration.
     * @type {boolean}
     * @memberof DomainAvailabilityDto
     */
    'available': boolean;
}
/**
 * 
 * @export
 * @interface DomainAvailabilityWebsocketsDto
 */
export interface DomainAvailabilityWebsocketsDto {
    /**
     * The unique identifier of the WebSocket channel for domain availability updates.
     * @type {string}
     * @memberof DomainAvailabilityWebsocketsDto
     */
    'channelId': string;
}
/**
 * 
 * @export
 * @interface DomainBundleDto
 */
export interface DomainBundleDto {
    /**
     * The name of the domain bundle.
     * @type {string}
     * @memberof DomainBundleDto
     */
    'domainBundleName': string;
    /**
     * Indicates whether the domain bundle is chargeable or not.
     * @type {boolean}
     * @memberof DomainBundleDto
     */
    'chargeable': boolean;
    /**
     * The type of record associated with the domain bundle.
     * @type {string}
     * @memberof DomainBundleDto
     */
    'recordType': DomainBundleDtoRecordTypeEnum;
}

export const DomainBundleDtoRecordTypeEnum = {
    Domain: 'DOMAIN',
    Dname: 'DNAME'
} as const;

export type DomainBundleDtoRecordTypeEnum = typeof DomainBundleDtoRecordTypeEnum[keyof typeof DomainBundleDtoRecordTypeEnum];

/**
 * 
 * @export
 * @interface DomainCategoryDto
 */
export interface DomainCategoryDto {
    /**
     * The unique identifier of the domain category.
     * @type {string}
     * @memberof DomainCategoryDto
     */
    'id'?: string;
    /**
     * An array that holds a brief text that describes the domain category in all supported languages.
     * @type {Array<MultilangTextDto>}
     * @memberof DomainCategoryDto
     */
    'description': Array<MultilangTextDto>;
    /**
     * A url that holds the icon of the domain category.
     * @type {string}
     * @memberof DomainCategoryDto
     */
    'icon_url': string;
    /**
     * The date when the domain category was created.
     * @type {string}
     * @memberof DomainCategoryDto
     */
    'createdAt'?: string;
    /**
     * The date when the domain category was updated.
     * @type {string}
     * @memberof DomainCategoryDto
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface DomainCheckAvailabilityRequestDto
 */
export interface DomainCheckAvailabilityRequestDto {
    /**
     * An array of domain names to check for availability. Each label of a domain must have a maximum of 63 characters.
     * @type {Array<string>}
     * @memberof DomainCheckAvailabilityRequestDto
     */
    'domainNames': Array<string>;
    /**
     * Enabling fast search mode for quicker results but with potentially less accuracy.
     * @type {boolean}
     * @memberof DomainCheckAvailabilityRequestDto
     */
    'fastSearch'?: boolean;
}
/**
 * 
 * @export
 * @interface DomainContactDto
 */
export interface DomainContactDto {
    /**
     * The unique identifier of the contact.
     * @type {string}
     * @memberof DomainContactDto
     */
    'id'?: string;
    /**
     * A custom code associated with the contact.
     * @type {string}
     * @memberof DomainContactDto
     */
    'contactCode'?: string;
    /**
     * The identifier of the integration associated with this contact.
     * @type {string}
     * @memberof DomainContactDto
     */
    'integrationId'?: string;
    /**
     * The first name of the contact.
     * @type {string}
     * @memberof DomainContactDto
     */
    'firstName': string;
    /**
     * The last name of the contact.
     * @type {string}
     * @memberof DomainContactDto
     */
    'lastName': string;
    /**
     * The contact’s company or organization name.
     * @type {string}
     * @memberof DomainContactDto
     */
    'organization'?: string;
    /**
     * The first line of the contact\'s address.
     * @type {string}
     * @memberof DomainContactDto
     */
    'street1': string;
    /**
     * The second line of the contact\'s address.
     * @type {string}
     * @memberof DomainContactDto
     */
    'street2'?: string;
    /**
     * The third line of the contact\'s address.
     * @type {string}
     * @memberof DomainContactDto
     */
    'street3'?: string;
    /**
     * The contact\'s city.,Required string with max length 250 chars
     * @type {string}
     * @memberof DomainContactDto
     */
    'city': string;
    /**
     * The contact’s State or Province.
     * @type {string}
     * @memberof DomainContactDto
     */
    'state': string;
    /**
     * The contact\'s Zip Code or Postal Code.
     * @type {string}
     * @memberof DomainContactDto
     */
    'postcode': string;
    /**
     * The ISO 3166-1-alpha-2 code for the country of the contact.
     * @type {string}
     * @memberof DomainContactDto
     */
    'countryCode': DomainContactDtoCountryCodeEnum;
    /**
     * The Telephone number of the contact. +<InternationalDialingCode>.<TelephoneNumber>
     * @type {string}
     * @memberof DomainContactDto
     */
    'telephone': string;
    /**
     * The Fax number of the contact. +<InternationalDialingCode>.<TelephoneNumber>
     * @type {string}
     * @memberof DomainContactDto
     */
    'fax'?: string;
    /**
     * The contact\'s Email Address.
     * @type {string}
     * @memberof DomainContactDto
     */
    'email': string;
    /**
     * The type of contact.
     * @type {string}
     * @memberof DomainContactDto
     */
    'contactType'?: DomainContactDtoContactTypeEnum;
    /**
     * Additional data associated with the contact.
     * @type {ContactAdditionalDto}
     * @memberof DomainContactDto
     */
    'additional'?: ContactAdditionalDto;
    /**
     * The date and time when the contact was created.
     * @type {string}
     * @memberof DomainContactDto
     */
    'createdAt'?: string;
    /**
     * The date and time when the contact was last updated.
     * @type {string}
     * @memberof DomainContactDto
     */
    'updatedAt'?: string;
}

export const DomainContactDtoCountryCodeEnum = {
    Af: 'AF',
    Al: 'AL',
    Dz: 'DZ',
    As: 'AS',
    Ad: 'AD',
    Ao: 'AO',
    Ai: 'AI',
    Aq: 'AQ',
    Ag: 'AG',
    Ar: 'AR',
    Am: 'AM',
    Aw: 'AW',
    Au: 'AU',
    At: 'AT',
    Az: 'AZ',
    Bs: 'BS',
    Bh: 'BH',
    Bd: 'BD',
    Bb: 'BB',
    By: 'BY',
    Be: 'BE',
    Bz: 'BZ',
    Bj: 'BJ',
    Bm: 'BM',
    Bt: 'BT',
    Bo: 'BO',
    Bq: 'BQ',
    Ba: 'BA',
    Bw: 'BW',
    Bv: 'BV',
    Br: 'BR',
    Io: 'IO',
    Bn: 'BN',
    Bg: 'BG',
    Bf: 'BF',
    Bi: 'BI',
    Kh: 'KH',
    Cm: 'CM',
    Ca: 'CA',
    Cv: 'CV',
    Ky: 'KY',
    Cf: 'CF',
    Td: 'TD',
    Cl: 'CL',
    Cn: 'CN',
    Cx: 'CX',
    Cc: 'CC',
    Co: 'CO',
    Km: 'KM',
    Cg: 'CG',
    Cd: 'CD',
    Ck: 'CK',
    Cr: 'CR',
    Ci: 'CI',
    Hr: 'HR',
    Cu: 'CU',
    Cw: 'CW',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Dj: 'DJ',
    Dm: 'DM',
    Do: 'DO',
    Ec: 'EC',
    Eg: 'EG',
    Sv: 'SV',
    Gq: 'GQ',
    Er: 'ER',
    Ee: 'EE',
    Et: 'ET',
    Fk: 'FK',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Gf: 'GF',
    Pf: 'PF',
    Tf: 'TF',
    Ga: 'GA',
    Gm: 'GM',
    Ge: 'GE',
    De: 'DE',
    Gh: 'GH',
    Gi: 'GI',
    Gr: 'GR',
    Gl: 'GL',
    Gd: 'GD',
    Gp: 'GP',
    Gu: 'GU',
    Gt: 'GT',
    Gg: 'GG',
    Gn: 'GN',
    Gw: 'GW',
    Gy: 'GY',
    Ht: 'HT',
    Hm: 'HM',
    Va: 'VA',
    Hn: 'HN',
    Hk: 'HK',
    Hu: 'HU',
    Is: 'IS',
    In: 'IN',
    Id: 'ID',
    Ir: 'IR',
    Iq: 'IQ',
    Ie: 'IE',
    Im: 'IM',
    Il: 'IL',
    It: 'IT',
    Jm: 'JM',
    Jp: 'JP',
    Je: 'JE',
    Jo: 'JO',
    Kz: 'KZ',
    Ke: 'KE',
    Ki: 'KI',
    Kp: 'KP',
    Kr: 'KR',
    Kw: 'KW',
    Kg: 'KG',
    La: 'LA',
    Lv: 'LV',
    Lb: 'LB',
    Ls: 'LS',
    Lr: 'LR',
    Ly: 'LY',
    Li: 'LI',
    Lt: 'LT',
    Lu: 'LU',
    Mo: 'MO',
    Mk: 'MK',
    Mg: 'MG',
    Mw: 'MW',
    My: 'MY',
    Mv: 'MV',
    Ml: 'ML',
    Mt: 'MT',
    Mh: 'MH',
    Mq: 'MQ',
    Mr: 'MR',
    Mu: 'MU',
    Tn: 'TN',
    Tr: 'TR',
    Tm: 'TM',
    Tc: 'TC',
    Tv: 'TV',
    Ug: 'UG',
    Ua: 'UA',
    Ae: 'AE',
    Gb: 'GB',
    Us: 'US',
    Um: 'UM',
    Uy: 'UY',
    Uz: 'UZ',
    Vu: 'VU',
    Ve: 'VE',
    Vn: 'VN',
    Vg: 'VG',
    Vi: 'VI',
    Wf: 'WF',
    Eh: 'EH',
    Ye: 'YE',
    Zm: 'ZM',
    Zw: 'ZW',
    Yt: 'YT',
    Mx: 'MX',
    Fm: 'FM',
    Md: 'MD',
    Mc: 'MC',
    Mn: 'MN',
    Me: 'ME',
    Ms: 'MS',
    Ma: 'MA',
    Mz: 'MZ',
    Mm: 'MM',
    Na: 'NA',
    Nr: 'NR',
    Np: 'NP',
    Nl: 'NL',
    Nc: 'NC',
    Nz: 'NZ',
    Ni: 'NI',
    Ne: 'NE',
    Ng: 'NG',
    Nu: 'NU',
    Nf: 'NF',
    Mp: 'MP',
    No: 'NO',
    Om: 'OM',
    Pk: 'PK',
    Pw: 'PW',
    Ps: 'PS',
    Pa: 'PA',
    Pg: 'PG',
    Py: 'PY',
    Pe: 'PE',
    Ph: 'PH',
    Pn: 'PN',
    Pl: 'PL',
    Pt: 'PT',
    Pr: 'PR',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Ru: 'RU',
    Rw: 'RW',
    Bl: 'BL',
    Sh: 'SH',
    Kn: 'KN',
    Lc: 'LC',
    Mf: 'MF',
    Pm: 'PM',
    Vc: 'VC',
    Ws: 'WS',
    Sm: 'SM',
    St: 'ST',
    Sa: 'SA',
    Sn: 'SN',
    Rs: 'RS',
    Sc: 'SC',
    Sl: 'SL',
    Sg: 'SG',
    Sx: 'SX',
    Sk: 'SK',
    Si: 'SI',
    Sb: 'SB',
    So: 'SO',
    Za: 'ZA',
    Gs: 'GS',
    Ss: 'SS',
    Es: 'ES',
    Lk: 'LK',
    Sd: 'SD',
    Sr: 'SR',
    Sj: 'SJ',
    Sz: 'SZ',
    Se: 'SE',
    Ch: 'CH',
    Sy: 'SY',
    Tw: 'TW',
    Tj: 'TJ',
    Tz: 'TZ',
    Th: 'TH',
    Tl: 'TL',
    Tg: 'TG',
    Tk: 'TK',
    To: 'TO',
    Tt: 'TT'
} as const;

export type DomainContactDtoCountryCodeEnum = typeof DomainContactDtoCountryCodeEnum[keyof typeof DomainContactDtoCountryCodeEnum];
export const DomainContactDtoContactTypeEnum = {
    Admin: 'ADMIN',
    Billing: 'BILLING',
    Tech: 'TECH',
    Registrant: 'REGISTRANT'
} as const;

export type DomainContactDtoContactTypeEnum = typeof DomainContactDtoContactTypeEnum[keyof typeof DomainContactDtoContactTypeEnum];

/**
 * 
 * @export
 * @interface DomainNameDto
 */
export interface DomainNameDto {
    /**
     * Billing code provided by hoster.ai.
     * @type {string}
     * @memberof DomainNameDto
     */
    'id'?: string;
    /**
     * The domain name to be registered.
     * @type {string}
     * @memberof DomainNameDto
     */
    'domainName': string;
    /**
     * The registration duration for the domain in months.
     * @type {string}
     * @memberof DomainNameDto
     */
    'duration': DomainNameDtoDurationEnum;
    /**
     * The ID of the top-level domain associated with the domain name.
     * @type {string}
     * @memberof DomainNameDto
     */
    'tldId': string;
    /**
     * Registry contacts associated with the domain.
     * @type {RegistryContactsDto}
     * @memberof DomainNameDto
     */
    'contacts': RegistryContactsDto;
    /**
     * Name servers associated with the domain.
     * @type {Array<NameServerDto>}
     * @memberof DomainNameDto
     */
    'nameServers'?: Array<NameServerDto>;
    /**
     * The password associated with the domain (if applicable).
     * @type {string}
     * @memberof DomainNameDto
     */
    'password'?: string;
    /**
     * Indicates if the domain is locked.
     * @type {boolean}
     * @memberof DomainNameDto
     */
    'locked'?: boolean;
    /**
     * Indicates if the domain has ID shield enabled.
     * @type {boolean}
     * @memberof DomainNameDto
     */
    'idShield'?: boolean;
    /**
     * Indicates whether owner details should be copied on transfer.
     * @type {boolean}
     * @memberof DomainNameDto
     */
    'copyOwnerOnTransfer'?: boolean;
    /**
     * Bundles associated with the domain.
     * @type {Array<DomainBundleDto>}
     * @memberof DomainNameDto
     */
    'bundles'?: Array<DomainBundleDto>;
    /**
     * Categories associated with the domain.
     * @type {Array<string>}
     * @memberof DomainNameDto
     */
    'domainCategories'?: Array<string>;
    /**
     * Additional data associated with the domain.
     * @type {DomainAdditionalDto}
     * @memberof DomainNameDto
     */
    'additional'?: DomainAdditionalDto;
    /**
     * Addons Associated with the Domain
     * @type {Array<string>}
     * @memberof DomainNameDto
     */
    'addonIds'?: Array<string>;
    /**
     * Date when the domain record was created.
     * @type {string}
     * @memberof DomainNameDto
     */
    'createdAt'?: string;
    /**
     * Date when the domain record was last updated.
     * @type {string}
     * @memberof DomainNameDto
     */
    'updatedAt'?: string;
}

export const DomainNameDtoDurationEnum = {
    _1: '1',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5',
    _6: '6',
    _7: '7',
    _8: '8',
    _9: '9',
    _10: '10',
    _11: '11',
    _12: '12',
    _24: '24',
    _36: '36',
    _48: '48',
    _60: '60',
    _72: '72',
    _84: '84',
    _96: '96',
    _108: '108',
    _120: '120'
} as const;

export type DomainNameDtoDurationEnum = typeof DomainNameDtoDurationEnum[keyof typeof DomainNameDtoDurationEnum];

/**
 * 
 * @export
 * @interface DomainPricesDto
 */
export interface DomainPricesDto {
    /**
     * The price for domain transfer in cents.
     * @type {number}
     * @memberof DomainPricesDto
     */
    'transferPrice'?: number;
    /**
     * The price for domain lock in cents.
     * @type {number}
     * @memberof DomainPricesDto
     */
    'lockPrice'?: number;
    /**
     * The price for ID shield in cents.
     * @type {number}
     * @memberof DomainPricesDto
     */
    'idShieldPrice'?: number;
    /**
     * The price for domain proxy service in cents.
     * @type {number}
     * @memberof DomainPricesDto
     */
    'proxyPrice'?: number;
    /**
     * The soft quarantine fee for the domain in cents.
     * @type {number}
     * @memberof DomainPricesDto
     */
    'softQuarantineFee'?: number;
    /**
     * 
     * @type {number}
     * @memberof DomainPricesDto
     */
    'hardQuarantineFee'?: number;
}
/**
 * 
 * @export
 * @interface DonutsPriceCategoryDataDto
 */
export interface DonutsPriceCategoryDataDto {
    /**
     * An additional parameter if the domain checked is a Donuts premium domain
     * @type {string}
     * @memberof DonutsPriceCategoryDataDto
     */
    'priceCategory': DonutsPriceCategoryDataDtoPriceCategoryEnum;
}

export const DonutsPriceCategoryDataDtoPriceCategoryEnum = {
    Category1: 'Category1',
    Category2: 'Category2',
    Category3: 'Category3',
    Category4: 'Category4',
    Category5: 'Category5',
    Category6: 'Category6',
    Category7: 'Category7',
    Category8: 'Category8',
    Category9: 'Category9',
    Category10: 'Category10',
    Category11: 'Category11',
    Category12: 'Category12'
} as const;

export type DonutsPriceCategoryDataDtoPriceCategoryEnum = typeof DonutsPriceCategoryDataDtoPriceCategoryEnum[keyof typeof DonutsPriceCategoryDataDtoPriceCategoryEnum];

/**
 * 
 * @export
 * @interface DynamicPriceDto
 */
export interface DynamicPriceDto {
    /**
     * Indicates the time a price occurred . Measured in Unix epoch time in seconds.
     * @type {number}
     * @memberof DynamicPriceDto
     */
    'timestamp': number;
    /**
     * Product prices by unique identifiers and currency.
     * @type {{ [key: string]: string; }}
     * @memberof DynamicPriceDto
     */
    'prices': { [key: string]: string; };
    /**
     * Indicates if product has been paid.
     * @type {boolean}
     * @memberof DynamicPriceDto
     */
    'paid'?: boolean;
}
/**
 * 
 * @export
 * @interface DynamicPriceInfoDto
 */
export interface DynamicPriceInfoDto {
    /**
     * The key representing a dynamic price factor.
     * @type {string}
     * @memberof DynamicPriceInfoDto
     */
    'key'?: string;
    /**
     * The number that count the interval of a charge in minutes.
     * @type {number}
     * @memberof DynamicPriceInfoDto
     */
    'fetchChargesInterval'?: number;
    /**
     * A brief text that describes a dynamic price.
     * @type {string}
     * @memberof DynamicPriceInfoDto
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface EmailPayloadDto
 */
export interface EmailPayloadDto {
    /**
     * The subject of the email
     * @type {string}
     * @memberof EmailPayloadDto
     */
    'subject': string;
    /**
     * The email message content
     * @type {string}
     * @memberof EmailPayloadDto
     */
    'body': string;
    /**
     * An array of attachments
     * @type {Array<Attachment>}
     * @memberof EmailPayloadDto
     */
    'attachments'?: Array<Attachment>;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {number}
     * @memberof ErrorResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'message': string;
    /**
     * 
     * @type {object}
     * @memberof ErrorResponse
     */
    'details': object;
}
/**
 * 
 * @export
 * @interface EsAdditionalDataDto
 */
export interface EsAdditionalDataDto {
    /**
     * - 0: Generic ID (a number than is not a Spanish DNI-NIF or NIE, eg passports foreign ID documents, company numbers) - 1: Spanish national personal ID/ company VAT numbers (DNI-NIF) (DNIs and NIFs can be recognized as they are comprised of an alphabetic control character plus a chain of eight numeric characters) - 3: Spanish resident alien ID Number (NIE) 
     * @type {number}
     * @memberof EsAdditionalDataDto
     */
    'identificationType': number;
    /**
     * The personal or corporate ID number of the contact. If the IdentificationType is 1 (DNI-NFI) or 3 (NIE), then this field will be validated to ensure the format is correct.
     * @type {number}
     * @memberof EsAdditionalDataDto
     */
    'identificationNumber': EsAdditionalDataDtoIdentificationNumberEnum;
    /**
     *  These entities are grouped into two types:  - Contacts type \'natural person\': Contacts registered to natural persons or individuals, that is, real persons capable of assuming rights and liabilities, capable of signing documents.  - Contacts type \'juridical person\': Contacts registered to organizations or juridical persons, that is, collective entities that may assume rights and liabilities, though in a limited fashion, such companies, associations, governmental agencies and organizations, etc.  For Contacts type \'natural person\' this field must be set to 1.  For ContactsValue type \'juridical person\' this field must be set to one of the following values:  value - Legal Entity Type * 39 - Economic Interest Grouping * 47 - Association * 59 - Sports Association * 68 - Trade Association * 124 - Savings Bank * 150 - Community Property * 152 - Condominium * 164 - Religious Order or Institution * 181 - Consulate * 197 - Public Law Association * 203 - Embassy * 229 - Municipality * 269 - Sports Federation * 286 - Foundation * 365 - Mutual Insurance Company * 434 - Provincial Government Body * 436 - National Government Body * 439 - Political Party * 476 - Trade Union * 510 - Farm Partnership * 524 - Public Limited Company / Corporation * 525 - Sports Public Limited Company * 554 - Partnership * 560 - General Partnership * 562 - Limited Partnership * 566 - Cooperative * 608 - Worker-owned Company * 612 - Limited Liability Company * 713 - Spanish (company) Branch * 717 - Temporary Consortium / Joint Venture * 744 - Worker-owned Limited Company * 745 - Provincial Government Entity * 746 - National Government Entity * 747 - Local Government Entity * 877 - Others * 878 - Designation of Origin Regulatory Council 
     * @type {number}
     * @memberof EsAdditionalDataDto
     */
    'contactType': EsAdditionalDataDtoContactTypeEnum;
}

export const EsAdditionalDataDtoIdentificationNumberEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_3: 3
} as const;

export type EsAdditionalDataDtoIdentificationNumberEnum = typeof EsAdditionalDataDtoIdentificationNumberEnum[keyof typeof EsAdditionalDataDtoIdentificationNumberEnum];
export const EsAdditionalDataDtoContactTypeEnum = {
    NUMBER_1: 1,
    NUMBER_39: 39,
    NUMBER_47: 47,
    NUMBER_59: 59,
    NUMBER_68: 68,
    NUMBER_124: 124,
    NUMBER_150: 150,
    NUMBER_152: 152,
    NUMBER_164: 164,
    NUMBER_181: 181,
    NUMBER_197: 197,
    NUMBER_203: 203,
    NUMBER_229: 229,
    NUMBER_269: 269,
    NUMBER_286: 286,
    NUMBER_365: 365,
    NUMBER_434: 434,
    NUMBER_436: 436,
    NUMBER_439: 439,
    NUMBER_476: 476,
    NUMBER_510: 510,
    NUMBER_524: 524,
    NUMBER_525: 525,
    NUMBER_554: 554,
    NUMBER_560: 560,
    NUMBER_562: 562,
    NUMBER_566: 566,
    NUMBER_508: 508,
    NUMBER_612: 612,
    NUMBER_713: 713,
    NUMBER_717: 717,
    NUMBER_744: 744,
    NUMBER_745: 745,
    NUMBER_746: 746,
    NUMBER_747: 747,
    NUMBER_877: 877,
    NUMBER_878: 878,
    NUMBER_879: 879
} as const;

export type EsAdditionalDataDtoContactTypeEnum = typeof EsAdditionalDataDtoContactTypeEnum[keyof typeof EsAdditionalDataDtoContactTypeEnum];

/**
 * 
 * @export
 * @interface EuBeAdditionalDataDto
 */
export interface EuBeAdditionalDataDto {
    /**
     * Accepted values: bg, cs, da, de, el, en, es, et, fi, fr, ga, hr, hu, it, lt, lv, mt, nl, pl, pt, ro, sk, sl, sv
     * @type {string}
     * @memberof EuBeAdditionalDataDto
     */
    'language': EuBeAdditionalDataDtoLanguageEnum;
    /**
     * A required string with a maximum length of 20 characters
     * @type {string}
     * @memberof EuBeAdditionalDataDto
     */
    'vatNumber'?: string;
    /**
     * Accepted values: registrant - tech - billing - on-site - reseller
     * @type {string}
     * @memberof EuBeAdditionalDataDto
     */
    'contactType': string;
    /**
     * Indicates whether the contact is a natural person
     * @type {boolean}
     * @memberof EuBeAdditionalDataDto
     */
    'naturalPerson': boolean;
    /**
     * Accepted values: AT, BE, BG, HR, CY, CZ, DK, EE, FI, FR, DE, GR, HU, IE, IT, LV, LT, LU, MT, NL, PL, PT, RO, SK, SI, ES, SE
     * @type {string}
     * @memberof EuBeAdditionalDataDto
     */
    'countryOfCitizenship'?: EuBeAdditionalDataDtoCountryOfCitizenshipEnum;
}

export const EuBeAdditionalDataDtoLanguageEnum = {
    Bg: 'bg',
    Cs: 'cs',
    Da: 'da',
    De: 'de',
    El: 'el',
    En: 'en',
    Es: 'es',
    Et: 'et',
    Fi: 'fi',
    Fr: 'fr',
    Ga: 'ga',
    Hr: 'hr',
    Hu: 'hu',
    It: 'it',
    Lt: 'lt',
    Lv: 'lv',
    Mt: 'mt',
    Nl: 'nl',
    Pl: 'pl',
    Pt: 'pt',
    Ro: 'ro',
    Sk: 'sk',
    Sl: 'sl',
    Sv: 'sv'
} as const;

export type EuBeAdditionalDataDtoLanguageEnum = typeof EuBeAdditionalDataDtoLanguageEnum[keyof typeof EuBeAdditionalDataDtoLanguageEnum];
export const EuBeAdditionalDataDtoCountryOfCitizenshipEnum = {
    At: 'AT',
    Be: 'BE',
    Bg: 'BG',
    Hr: 'HR',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Ee: 'EE',
    Fi: 'FI',
    Fr: 'FR',
    De: 'DE',
    Gr: 'GR',
    Hu: 'HU',
    Ie: 'IE',
    It: 'IT',
    Lv: 'LV',
    Lt: 'LT',
    Lu: 'LU',
    Mt: 'MT',
    Nl: 'NL',
    Pl: 'PL',
    Pt: 'PT',
    Ro: 'RO',
    Sk: 'SK',
    Si: 'SI',
    Es: 'ES',
    Se: 'SE'
} as const;

export type EuBeAdditionalDataDtoCountryOfCitizenshipEnum = typeof EuBeAdditionalDataDtoCountryOfCitizenshipEnum[keyof typeof EuBeAdditionalDataDtoCountryOfCitizenshipEnum];

/**
 * 
 * @export
 * @interface FindAddons200Response
 */
export interface FindAddons200Response {
    /**
     * 
     * @type {number}
     * @memberof FindAddons200Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof FindAddons200Response
     */
    'message'?: string;
    /**
     * 
     * @type {AddonDto}
     * @memberof FindAddons200Response
     */
    'data'?: AddonDto;
}
/**
 * 
 * @export
 * @interface FindAffiliate200Response
 */
export interface FindAffiliate200Response {
    /**
     * 
     * @type {number}
     * @memberof FindAffiliate200Response
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof FindAffiliate200Response
     */
    'message': string;
    /**
     * 
     * @type {Array<AffiliateDto>}
     * @memberof FindAffiliate200Response
     */
    'data': Array<AffiliateDto>;
    /**
     * 
     * @type {number}
     * @memberof FindAffiliate200Response
     */
    'currentPage': number;
    /**
     * 
     * @type {number}
     * @memberof FindAffiliate200Response
     */
    'totalPages': number;
    /**
     * 
     * @type {number}
     * @memberof FindAffiliate200Response
     */
    'perPage': number;
}
/**
 * 
 * @export
 * @interface FindCompanies200Response
 */
export interface FindCompanies200Response {
    /**
     * 
     * @type {number}
     * @memberof FindCompanies200Response
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof FindCompanies200Response
     */
    'message': string;
    /**
     * 
     * @type {Array<CompanyDto>}
     * @memberof FindCompanies200Response
     */
    'data': Array<CompanyDto>;
    /**
     * 
     * @type {number}
     * @memberof FindCompanies200Response
     */
    'currentPage': number;
    /**
     * 
     * @type {number}
     * @memberof FindCompanies200Response
     */
    'totalPages': number;
    /**
     * 
     * @type {number}
     * @memberof FindCompanies200Response
     */
    'perPage': number;
}
/**
 * 
 * @export
 * @interface FindCoupons200Response
 */
export interface FindCoupons200Response {
    /**
     * 
     * @type {number}
     * @memberof FindCoupons200Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof FindCoupons200Response
     */
    'message'?: string;
    /**
     * 
     * @type {CouponDto}
     * @memberof FindCoupons200Response
     */
    'data'?: CouponDto;
}
/**
 * 
 * @export
 * @interface FindDomainCategories200Response
 */
export interface FindDomainCategories200Response {
    /**
     * 
     * @type {number}
     * @memberof FindDomainCategories200Response
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof FindDomainCategories200Response
     */
    'message': string;
    /**
     * 
     * @type {Array<DomainCategoryDto>}
     * @memberof FindDomainCategories200Response
     */
    'data': Array<DomainCategoryDto>;
    /**
     * 
     * @type {number}
     * @memberof FindDomainCategories200Response
     */
    'currentPage': number;
    /**
     * 
     * @type {number}
     * @memberof FindDomainCategories200Response
     */
    'totalPages': number;
    /**
     * 
     * @type {number}
     * @memberof FindDomainCategories200Response
     */
    'perPage': number;
}
/**
 * 
 * @export
 * @interface FindDomainContacts200Response
 */
export interface FindDomainContacts200Response {
    /**
     * 
     * @type {number}
     * @memberof FindDomainContacts200Response
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof FindDomainContacts200Response
     */
    'message': string;
    /**
     * 
     * @type {Array<DomainContactDto>}
     * @memberof FindDomainContacts200Response
     */
    'data': Array<DomainContactDto>;
    /**
     * 
     * @type {number}
     * @memberof FindDomainContacts200Response
     */
    'currentPage': number;
    /**
     * 
     * @type {number}
     * @memberof FindDomainContacts200Response
     */
    'totalPages': number;
    /**
     * 
     * @type {number}
     * @memberof FindDomainContacts200Response
     */
    'perPage': number;
}
/**
 * 
 * @export
 * @interface FindDomainNames200Response
 */
export interface FindDomainNames200Response {
    /**
     * 
     * @type {number}
     * @memberof FindDomainNames200Response
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof FindDomainNames200Response
     */
    'message': string;
    /**
     * 
     * @type {Array<DomainNameDto>}
     * @memberof FindDomainNames200Response
     */
    'data': Array<DomainNameDto>;
    /**
     * 
     * @type {number}
     * @memberof FindDomainNames200Response
     */
    'currentPage': number;
    /**
     * 
     * @type {number}
     * @memberof FindDomainNames200Response
     */
    'totalPages': number;
    /**
     * 
     * @type {number}
     * @memberof FindDomainNames200Response
     */
    'perPage': number;
}
/**
 * 
 * @export
 * @interface FindIPs200Response
 */
export interface FindIPs200Response {
    /**
     * 
     * @type {number}
     * @memberof FindIPs200Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof FindIPs200Response
     */
    'message'?: string;
    /**
     * 
     * @type {IpDto}
     * @memberof FindIPs200Response
     */
    'data'?: IpDto;
}
/**
 * 
 * @export
 * @interface FindIntegrations200Response
 */
export interface FindIntegrations200Response {
    /**
     * 
     * @type {number}
     * @memberof FindIntegrations200Response
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof FindIntegrations200Response
     */
    'message': string;
    /**
     * 
     * @type {Array<IntegrationDto>}
     * @memberof FindIntegrations200Response
     */
    'data': Array<IntegrationDto>;
    /**
     * 
     * @type {number}
     * @memberof FindIntegrations200Response
     */
    'currentPage': number;
    /**
     * 
     * @type {number}
     * @memberof FindIntegrations200Response
     */
    'totalPages': number;
    /**
     * 
     * @type {number}
     * @memberof FindIntegrations200Response
     */
    'perPage': number;
}
/**
 * 
 * @export
 * @interface FindInvoiceContacts200Response
 */
export interface FindInvoiceContacts200Response {
    /**
     * 
     * @type {number}
     * @memberof FindInvoiceContacts200Response
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof FindInvoiceContacts200Response
     */
    'message': string;
    /**
     * 
     * @type {Array<InvoiceContactDto>}
     * @memberof FindInvoiceContacts200Response
     */
    'data': Array<InvoiceContactDto>;
    /**
     * 
     * @type {number}
     * @memberof FindInvoiceContacts200Response
     */
    'currentPage': number;
    /**
     * 
     * @type {number}
     * @memberof FindInvoiceContacts200Response
     */
    'totalPages': number;
    /**
     * 
     * @type {number}
     * @memberof FindInvoiceContacts200Response
     */
    'perPage': number;
}
/**
 * 
 * @export
 * @interface FindInvoices200Response
 */
export interface FindInvoices200Response {
    /**
     * 
     * @type {number}
     * @memberof FindInvoices200Response
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof FindInvoices200Response
     */
    'message': string;
    /**
     * 
     * @type {Array<any>}
     * @memberof FindInvoices200Response
     */
    'data': Array<any>;
    /**
     * 
     * @type {number}
     * @memberof FindInvoices200Response
     */
    'currentPage': number;
    /**
     * 
     * @type {number}
     * @memberof FindInvoices200Response
     */
    'totalPages': number;
    /**
     * 
     * @type {number}
     * @memberof FindInvoices200Response
     */
    'perPage': number;
}
/**
 * 
 * @export
 * @interface FindIpGroups200Response
 */
export interface FindIpGroups200Response {
    /**
     * 
     * @type {number}
     * @memberof FindIpGroups200Response
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof FindIpGroups200Response
     */
    'message': string;
    /**
     * 
     * @type {Array<IpGroupDto>}
     * @memberof FindIpGroups200Response
     */
    'data': Array<IpGroupDto>;
    /**
     * 
     * @type {number}
     * @memberof FindIpGroups200Response
     */
    'currentPage': number;
    /**
     * 
     * @type {number}
     * @memberof FindIpGroups200Response
     */
    'totalPages': number;
    /**
     * 
     * @type {number}
     * @memberof FindIpGroups200Response
     */
    'perPage': number;
}
/**
 * 
 * @export
 * @interface FindIssues200Response
 */
export interface FindIssues200Response {
    /**
     * 
     * @type {number}
     * @memberof FindIssues200Response
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof FindIssues200Response
     */
    'message': string;
    /**
     * 
     * @type {Array<IssueDto>}
     * @memberof FindIssues200Response
     */
    'data': Array<IssueDto>;
    /**
     * 
     * @type {number}
     * @memberof FindIssues200Response
     */
    'currentPage': number;
    /**
     * 
     * @type {number}
     * @memberof FindIssues200Response
     */
    'totalPages': number;
    /**
     * 
     * @type {number}
     * @memberof FindIssues200Response
     */
    'perPage': number;
}
/**
 * 
 * @export
 * @interface FindItems200Response
 */
export interface FindItems200Response {
    /**
     * 
     * @type {number}
     * @memberof FindItems200Response
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof FindItems200Response
     */
    'message': string;
    /**
     * 
     * @type {Array<ItemDto>}
     * @memberof FindItems200Response
     */
    'data': Array<ItemDto>;
    /**
     * 
     * @type {number}
     * @memberof FindItems200Response
     */
    'currentPage': number;
    /**
     * 
     * @type {number}
     * @memberof FindItems200Response
     */
    'totalPages': number;
    /**
     * 
     * @type {number}
     * @memberof FindItems200Response
     */
    'perPage': number;
}
/**
 * 
 * @export
 * @interface FindOrders200Response
 */
export interface FindOrders200Response {
    /**
     * 
     * @type {number}
     * @memberof FindOrders200Response
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof FindOrders200Response
     */
    'message': string;
    /**
     * 
     * @type {Array<OrderDto>}
     * @memberof FindOrders200Response
     */
    'data': Array<OrderDto>;
    /**
     * 
     * @type {number}
     * @memberof FindOrders200Response
     */
    'currentPage': number;
    /**
     * 
     * @type {number}
     * @memberof FindOrders200Response
     */
    'totalPages': number;
    /**
     * 
     * @type {number}
     * @memberof FindOrders200Response
     */
    'perPage': number;
}
/**
 * 
 * @export
 * @interface FindPayments200Response
 */
export interface FindPayments200Response {
    /**
     * 
     * @type {number}
     * @memberof FindPayments200Response
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof FindPayments200Response
     */
    'message': string;
    /**
     * 
     * @type {Array<PaymentDto>}
     * @memberof FindPayments200Response
     */
    'data': Array<PaymentDto>;
    /**
     * 
     * @type {number}
     * @memberof FindPayments200Response
     */
    'currentPage': number;
    /**
     * 
     * @type {number}
     * @memberof FindPayments200Response
     */
    'totalPages': number;
    /**
     * 
     * @type {number}
     * @memberof FindPayments200Response
     */
    'perPage': number;
}
/**
 * 
 * @export
 * @interface FindPolicies200Response
 */
export interface FindPolicies200Response {
    /**
     * 
     * @type {number}
     * @memberof FindPolicies200Response
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof FindPolicies200Response
     */
    'message': string;
    /**
     * 
     * @type {Array<PolicyDto>}
     * @memberof FindPolicies200Response
     */
    'data': Array<PolicyDto>;
    /**
     * 
     * @type {number}
     * @memberof FindPolicies200Response
     */
    'currentPage': number;
    /**
     * 
     * @type {number}
     * @memberof FindPolicies200Response
     */
    'totalPages': number;
    /**
     * 
     * @type {number}
     * @memberof FindPolicies200Response
     */
    'perPage': number;
}
/**
 * 
 * @export
 * @interface FindProductCategories200Response
 */
export interface FindProductCategories200Response {
    /**
     * 
     * @type {number}
     * @memberof FindProductCategories200Response
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof FindProductCategories200Response
     */
    'message': string;
    /**
     * 
     * @type {Array<ProductCategoryDto>}
     * @memberof FindProductCategories200Response
     */
    'data': Array<ProductCategoryDto>;
    /**
     * 
     * @type {number}
     * @memberof FindProductCategories200Response
     */
    'currentPage': number;
    /**
     * 
     * @type {number}
     * @memberof FindProductCategories200Response
     */
    'totalPages': number;
    /**
     * 
     * @type {number}
     * @memberof FindProductCategories200Response
     */
    'perPage': number;
}
/**
 * 
 * @export
 * @interface FindProducts200Response
 */
export interface FindProducts200Response {
    /**
     * 
     * @type {number}
     * @memberof FindProducts200Response
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof FindProducts200Response
     */
    'message': string;
    /**
     * 
     * @type {Array<ProductDto>}
     * @memberof FindProducts200Response
     */
    'data': Array<ProductDto>;
    /**
     * 
     * @type {number}
     * @memberof FindProducts200Response
     */
    'currentPage': number;
    /**
     * 
     * @type {number}
     * @memberof FindProducts200Response
     */
    'totalPages': number;
    /**
     * 
     * @type {number}
     * @memberof FindProducts200Response
     */
    'perPage': number;
}
/**
 * 
 * @export
 * @interface FindTemplates200Response
 */
export interface FindTemplates200Response {
    /**
     * 
     * @type {number}
     * @memberof FindTemplates200Response
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof FindTemplates200Response
     */
    'message': string;
    /**
     * 
     * @type {Array<TemplateDto>}
     * @memberof FindTemplates200Response
     */
    'data': Array<TemplateDto>;
    /**
     * 
     * @type {number}
     * @memberof FindTemplates200Response
     */
    'currentPage': number;
    /**
     * 
     * @type {number}
     * @memberof FindTemplates200Response
     */
    'totalPages': number;
    /**
     * 
     * @type {number}
     * @memberof FindTemplates200Response
     */
    'perPage': number;
}
/**
 * 
 * @export
 * @interface FindTlds200Response
 */
export interface FindTlds200Response {
    /**
     * 
     * @type {number}
     * @memberof FindTlds200Response
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof FindTlds200Response
     */
    'message': string;
    /**
     * 
     * @type {Array<TldDto>}
     * @memberof FindTlds200Response
     */
    'data': Array<TldDto>;
    /**
     * 
     * @type {number}
     * @memberof FindTlds200Response
     */
    'currentPage': number;
    /**
     * 
     * @type {number}
     * @memberof FindTlds200Response
     */
    'totalPages': number;
    /**
     * 
     * @type {number}
     * @memberof FindTlds200Response
     */
    'perPage': number;
}
/**
 * 
 * @export
 * @interface FindUsers200Response
 */
export interface FindUsers200Response {
    /**
     * 
     * @type {number}
     * @memberof FindUsers200Response
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof FindUsers200Response
     */
    'message': string;
    /**
     * 
     * @type {Array<UserDto>}
     * @memberof FindUsers200Response
     */
    'data': Array<UserDto>;
    /**
     * 
     * @type {number}
     * @memberof FindUsers200Response
     */
    'currentPage': number;
    /**
     * 
     * @type {number}
     * @memberof FindUsers200Response
     */
    'totalPages': number;
    /**
     * 
     * @type {number}
     * @memberof FindUsers200Response
     */
    'perPage': number;
}
/**
 * 
 * @export
 * @interface FreeTldDto
 */
export interface FreeTldDto {
    /**
     * An array of the tld\'s unique identifiers.
     * @type {Array<string>}
     * @memberof FreeTldDto
     */
    'tldIds': Array<string>;
    /**
     * An array that holds the duration of each free tld.
     * @type {Array<string>}
     * @memberof FreeTldDto
     */
    'durations': Array<FreeTldDtoDurationsEnum>;
}

export const FreeTldDtoDurationsEnum = {
    _1: '1',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5',
    _6: '6',
    _7: '7',
    _8: '8',
    _9: '9',
    _10: '10',
    _11: '11',
    _12: '12',
    _24: '24',
    _36: '36',
    _48: '48',
    _60: '60',
    _72: '72',
    _84: '84',
    _96: '96',
    _108: '108',
    _120: '120'
} as const;

export type FreeTldDtoDurationsEnum = typeof FreeTldDtoDurationsEnum[keyof typeof FreeTldDtoDurationsEnum];

/**
 * 
 * @export
 * @interface GetDomainName200Response
 */
export interface GetDomainName200Response {
    /**
     * 
     * @type {number}
     * @memberof GetDomainName200Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetDomainName200Response
     */
    'message'?: string;
    /**
     * 
     * @type {DomainNameDto}
     * @memberof GetDomainName200Response
     */
    'data'?: DomainNameDto;
}
/**
 * 
 * @export
 * @interface GetInvoice200Response
 */
export interface GetInvoice200Response {
    /**
     * 
     * @type {number}
     * @memberof GetInvoice200Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetInvoice200Response
     */
    'message'?: string;
    /**
     * 
     * @type {any}
     * @memberof GetInvoice200Response
     */
    'data'?: any;
}
/**
 * 
 * @export
 * @interface GetItem200Response
 */
export interface GetItem200Response {
    /**
     * 
     * @type {number}
     * @memberof GetItem200Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetItem200Response
     */
    'message'?: string;
    /**
     * 
     * @type {ItemDto}
     * @memberof GetItem200Response
     */
    'data'?: ItemDto;
}
/**
 * 
 * @export
 * @interface GetPayment200Response
 */
export interface GetPayment200Response {
    /**
     * 
     * @type {number}
     * @memberof GetPayment200Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetPayment200Response
     */
    'message'?: string;
    /**
     * 
     * @type {PaymentDto}
     * @memberof GetPayment200Response
     */
    'data'?: PaymentDto;
}
/**
 * 
 * @export
 * @interface GetUser200Response
 */
export interface GetUser200Response {
    /**
     * 
     * @type {number}
     * @memberof GetUser200Response
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetUser200Response
     */
    'message'?: string;
    /**
     * 
     * @type {UserDto}
     * @memberof GetUser200Response
     */
    'data'?: UserDto;
}
/**
 * Details of the integration
 * @export
 * @interface Integration
 */
export interface Integration {
    /**
     * The unique identifier of the service integration.
     * @type {string}
     * @memberof Integration
     */
    'id'?: string;
    /**
     * The title of the service integration.
     * @type {string}
     * @memberof Integration
     */
    'title': string;
    /**
     * The type of the service integration.
     * @type {string}
     * @memberof Integration
     */
    'type': IntegrationTypeEnum;
    /**
     * An array that holds the events that this service integration will listen to.
     * @type {Array<string>}
     * @memberof Integration
     */
    'listenEvents': Array<IntegrationListenEventsEnum>;
    /**
     * Indicates whether the integration is public or not.
     * @type {boolean}
     * @memberof Integration
     */
    'isPublic'?: boolean;
    /**
     * Indicates whether the integration is email integration or not.
     * @type {boolean}
     * @memberof Integration
     */
    'isEmailIntegration'?: boolean;
    /**
     * A token used for authentication and authorization.
     * @type {string}
     * @memberof Integration
     */
    'token'?: string;
    /**
     * Service integration\'s url
     * @type {string}
     * @memberof Integration
     */
    'url': string;
    /**
     * An array that holds all the price policies for the integration.
     * @type {Array<PricePolicyDto>}
     * @memberof Integration
     */
    'prices'?: Array<PricePolicyDto>;
    /**
     * An array of IP addresses that are allowed to access the resource.
     * @type {Array<string>}
     * @memberof Integration
     */
    'allowedIps'?: Array<string>;
    /**
     * An array of Top-Level Domain (TLD) identifiers.
     * @type {Array<string>}
     * @memberof Integration
     */
    'tldIds'?: Array<string>;
    /**
     * The category to which the product belongs.
     * @type {string}
     * @memberof Integration
     */
    'productCategory'?: IntegrationProductCategoryEnum;
    /**
     * The date that the maintenance will occur.
     * @type {string}
     * @memberof Integration
     */
    'maintenanceStartDate'?: string;
    /**
     * The date that the maintenance will end.
     * @type {string}
     * @memberof Integration
     */
    'maintenanceEndDate'?: string;
    /**
     * The date and time when the service integration was created.
     * @type {string}
     * @memberof Integration
     */
    'createdAt'?: string;
    /**
     * The date and time when the service integration was updated.
     * @type {string}
     * @memberof Integration
     */
    'updatedAt'?: string;
}

export const IntegrationTypeEnum = {
    Product: 'product',
    Registry: 'registry',
    Application: 'application',
    Dns: 'dns',
    Payment: 'payment',
    Notification: 'notification',
    Invoice: 'invoice'
} as const;

export type IntegrationTypeEnum = typeof IntegrationTypeEnum[keyof typeof IntegrationTypeEnum];
export const IntegrationListenEventsEnum = {
    UserCreated: 'user/created',
    UserUpdated: 'user/updated',
    UserDeleted: 'user/deleted',
    UserBanned: 'user/banned',
    UserUnbanned: 'user/unbanned',
    UserCompanyAccessAdded: 'user/company/access/added',
    UserCompanyAccessRemoved: 'user/company/access/removed',
    UserLocked: 'user/locked',
    UserCreditBalanceUpdated: 'user/credit-balance/updated',
    UserUnlocked: 'user/unlocked',
    UserPasswordUpdated: 'user/password/updated',
    UserEmailUpdated: 'user/email/updated',
    UserCurrencyUpdated: 'user/currency/updated',
    UserInvoiceContactUpdated: 'user/invoice-contact/updated',
    UserPolicyUpdated: 'user/policy/updated',
    UserLanguagesUpdated: 'user/languages/updated',
    UserCustomPricePoliciesUpdated: 'user/custom-price-policies/updated',
    UserCustomAddonPricePoliciesUpdated: 'user/custom-addon-price-policies/updated',
    UserCustomAffiliateAdded: 'user/custom-affiliate/added',
    UserCustomAffiliateRemoved: 'user/custom-affiliate/removed',
    UserInvoiceIntervalUpdated: 'user/invoice-interval/updated',
    UserAdditionalNotificationEmailRemoved: 'user/additional-notification-email/removed',
    UserAdditionalNotificationEmailAdded: 'user/additional-notification-email/added',
    UserCommentAdded: 'user/comment/added',
    UserCommentRemoved: 'user/comment/removed',
    UserCommentUpdated: 'user/comment/updated',
    UserTagsUpdated: 'user/tags/updated',
    UserSettingAdded: 'user/setting/added',
    UserSettingRemoved: 'user/setting/removed',
    UserSettingUpdated: 'user/setting/updated',
    UserStartSelling: 'user/start-selling',
    UserRolesUpdated: 'user/roles/updated',
    MessageCreated: 'message/created',
    MessageUpdated: 'message/updated',
    MessageDeleted: 'message/deleted',
    NotificationSent: 'notification/sent',
    PolicyCreated: 'policy/created',
    PolicyUpdated: 'policy/updated',
    PolicyDeleted: 'policy/deleted',
    ProductCategoryCreated: 'product-category/created',
    ProductCategoryUpdated: 'product-category/updated',
    ProductCategoryDeleted: 'product-category/deleted',
    InvoiceContactCreated: 'invoice-contact/created',
    InvoiceContactUpdated: 'invoice-contact/updated',
    InvoiceContactDeleted: 'invoice-contact/deleted',
    InvoiceCreated: 'invoice/created',
    InvoiceUpdated: 'invoice/updated',
    InvoiceDeleted: 'invoice/deleted',
    CurrencyCreated: 'currency/created',
    CurrencyUpdated: 'currency/updated',
    CurrencyDeleted: 'currency/deleted',
    AffiliateCreated: 'affiliate/created',
    AffiliateUpdated: 'affiliate/updated',
    AffiliateDeleted: 'affiliate/deleted',
    CompanyCreated: 'company/created',
    CompanyUpdated: 'company/updated',
    CompanyDeleted: 'company/deleted',
    OrganizationIntegrationAttached: 'organization/integration/attached',
    OrganizationIntegrationDetached: 'organization/integration/detached',
    TldCreated: 'tld/created',
    TldUpdated: 'tld/updated',
    TldDeleted: 'tld/deleted',
    IntegrationCreated: 'integration/created',
    IntegrationUpdated: 'integration/updated',
    IntegrationDeleted: 'integration/deleted',
    IntegrationInstalled: 'integration/installed',
    IntegrationUninstalled: 'integration/uninstalled',
    DomainContactCreated: 'domain-contact/created',
    DomainContactUpdated: 'domain-contact/updated',
    DomainContactDeleted: 'domain-contact/deleted',
    DomainCategoryCreated: 'domain-category/created',
    DomainCategoryUpdated: 'domain-category/updated',
    DomainCategoryDeleted: 'domain-category/deleted',
    AddonCreated: 'addon/created',
    AddonUpdated: 'addon/updated',
    AddonDeleted: 'addon/deleted',
    PaymentCreated: 'payment/created',
    PaymentCanceled: 'payment/canceled',
    PaymentFailed: 'payment/failed',
    PaymentSubscribed: 'payment/subscribed',
    PaymentUnsubscribed: 'payment/unsubscribed',
    PaymentUpdated: 'payment/updated',
    PaymentDeleted: 'payment/deleted',
    PaymentCompleted: 'payment/completed',
    TemplateCreated: 'template/created',
    TemplateUpdated: 'template/updated',
    TemplateDeleted: 'template/deleted',
    CouponCreated: 'coupon/created',
    CouponUpdated: 'coupon/updated',
    CouponDeleted: 'coupon/deleted',
    TemplateIntegrationCreated: 'template-integration/created',
    TemplateIntegrationUpdated: 'template-integration/updated',
    TemplateIntegrationDeleted: 'template-integration/deleted',
    OrderCreated: 'order/created',
    OrderStatusInProgress: 'order/status/in-progress',
    OrderStatusCompleted: 'order/status/completed',
    OrderStatusCanceled: 'order/status/canceled',
    OrderStatusRefunded: 'order/status/refunded',
    OrderInsufficientBalance: 'order/insufficient-balance',
    OrderUpdated: 'order/updated',
    OrderDeleted: 'order/deleted',
    SettingCreated: 'setting/created',
    SettingUpdated: 'setting/updated',
    SettingDeleted: 'setting/deleted',
    IssueCreated: 'issue/created',
    IssueUpdated: 'issue/updated',
    IssueDeleted: 'issue/deleted',
    TaskCreated: 'task/created',
    TaskUpdated: 'task/updated',
    TaskDeleted: 'task/deleted',
    TaskCanceled: 'task/canceled',
    TaskInProgress: 'task/in-progress',
    TaskCompleted: 'task/completed',
    TaskPercentageUpdated: 'task/percentage/updated',
    ProductCreated: 'product/created',
    ProductUpdated: 'product/updated',
    ProductDeleted: 'product/deleted',
    ProductAutoRenewUpdated: 'product/auto-renew/updated',
    ProductEnabled: 'product/enabled',
    ProductDisabled: 'product/disabled',
    ProductVersionCreated: 'product/version-created',
    IpGroupCreated: 'ip-group/created',
    IpGroupUpdated: 'ip-group/updated',
    IpGroupDeleted: 'ip-group/deleted',
    IpCreated: 'ip/created',
    IpUpdated: 'ip/updated',
    IpDeleted: 'ip/deleted',
    DomainNameCreated: 'domain-name/created',
    DomainNameUpdated: 'domain-name/updated',
    DomainNameDeleted: 'domain-name/deleted',
    DomainNameLocked: 'domain-name/locked',
    DomainNameUnlocked: 'domain-name/unlocked',
    DomainNameIdshieldActivated: 'domain-name/idshield-activated',
    DomainNameIdshieldDeactivated: 'domain-name/idshield-deactivated',
    DomainNameBundleAdded: 'domain-name/bundle-added',
    DomainNameBundleRemoved: 'domain-name/bundle-removed',
    DomainNameRegistrantUpdated: 'domain-name/registrant-updated',
    DomainNameAdminUpdated: 'domain-name/admin-updated',
    DomainNameTechUpdated: 'domain-name/tech-updated',
    DomainNameBillingUpdated: 'domain-name/billing-updated',
    DomainNameAdditionalUpdated: 'domain-name/additional-updated',
    ItemCreated: 'item/created',
    ItemUpdated: 'item/updated',
    ItemDeleted: 'item/deleted',
    ItemRenewed: 'item/renewed',
    ItemUpgraded: 'item/upgraded',
    ItemDowngraded: 'item/downgraded',
    ItemIpAttached: 'item/ip-attached',
    ItemIpDetached: 'item/ip-detached',
    ItemDetachedFromOrder: 'item/detached-from-order',
    ItemPostponed: 'item/postponed',
    ItemTransferredIn: 'item/transferred-in',
    ItemCanceled: 'item/canceled',
    ItemSuspended: 'item/suspended',
    ItemUnsuspended: 'item/unsuspended',
    ItemAffiliateAdded: 'item/affiliate/added',
    ItemBundleAttached: 'item/bundle/attached',
    ItemBundleDetached: 'item/bundle/detached',
    ItemActivated: 'item/activated',
    ItemSetInactive: 'item/set-inactive',
    ItemProcessed: 'item/processed',
    OrderPaid: 'order/paid',
    Test: 'test'
} as const;

export type IntegrationListenEventsEnum = typeof IntegrationListenEventsEnum[keyof typeof IntegrationListenEventsEnum];
export const IntegrationProductCategoryEnum = {
    Ssl: 'SSL',
    Vps: 'VPS',
    Dedicated: 'DEDICATED',
    WebHosting: 'WEB HOSTING',
    Other: 'OTHER'
} as const;

export type IntegrationProductCategoryEnum = typeof IntegrationProductCategoryEnum[keyof typeof IntegrationProductCategoryEnum];

/**
 * 
 * @export
 * @interface IntegrationDto
 */
export interface IntegrationDto {
    /**
     * The unique identifier of the service integration.
     * @type {string}
     * @memberof IntegrationDto
     */
    'id'?: string;
    /**
     * The title of the service integration.
     * @type {string}
     * @memberof IntegrationDto
     */
    'title': string;
    /**
     * The type of the service integration.
     * @type {string}
     * @memberof IntegrationDto
     */
    'type': IntegrationDtoTypeEnum;
    /**
     * An array that holds the events that this service integration will listen to.
     * @type {Array<string>}
     * @memberof IntegrationDto
     */
    'listenEvents': Array<IntegrationDtoListenEventsEnum>;
    /**
     * Indicates whether the integration is public or not.
     * @type {boolean}
     * @memberof IntegrationDto
     */
    'isPublic'?: boolean;
    /**
     * Indicates whether the integration is email integration or not.
     * @type {boolean}
     * @memberof IntegrationDto
     */
    'isEmailIntegration'?: boolean;
    /**
     * A token used for authentication and authorization.
     * @type {string}
     * @memberof IntegrationDto
     */
    'token'?: string;
    /**
     * Service integration\'s url
     * @type {string}
     * @memberof IntegrationDto
     */
    'url': string;
    /**
     * An array that holds all the price policies for the integration.
     * @type {Array<PricePolicyDto>}
     * @memberof IntegrationDto
     */
    'prices'?: Array<PricePolicyDto>;
    /**
     * An array of IP addresses that are allowed to access the resource.
     * @type {Array<string>}
     * @memberof IntegrationDto
     */
    'allowedIps'?: Array<string>;
    /**
     * An array of Top-Level Domain (TLD) identifiers.
     * @type {Array<string>}
     * @memberof IntegrationDto
     */
    'tldIds'?: Array<string>;
    /**
     * The category to which the product belongs.
     * @type {string}
     * @memberof IntegrationDto
     */
    'productCategory'?: IntegrationDtoProductCategoryEnum;
    /**
     * The date that the maintenance will occur.
     * @type {string}
     * @memberof IntegrationDto
     */
    'maintenanceStartDate'?: string;
    /**
     * The date that the maintenance will end.
     * @type {string}
     * @memberof IntegrationDto
     */
    'maintenanceEndDate'?: string;
    /**
     * The date and time when the service integration was created.
     * @type {string}
     * @memberof IntegrationDto
     */
    'createdAt'?: string;
    /**
     * The date and time when the service integration was updated.
     * @type {string}
     * @memberof IntegrationDto
     */
    'updatedAt'?: string;
}

export const IntegrationDtoTypeEnum = {
    Product: 'product',
    Registry: 'registry',
    Application: 'application',
    Dns: 'dns',
    Payment: 'payment',
    Notification: 'notification',
    Invoice: 'invoice'
} as const;

export type IntegrationDtoTypeEnum = typeof IntegrationDtoTypeEnum[keyof typeof IntegrationDtoTypeEnum];
export const IntegrationDtoListenEventsEnum = {
    UserCreated: 'user/created',
    UserUpdated: 'user/updated',
    UserDeleted: 'user/deleted',
    UserBanned: 'user/banned',
    UserUnbanned: 'user/unbanned',
    UserCompanyAccessAdded: 'user/company/access/added',
    UserCompanyAccessRemoved: 'user/company/access/removed',
    UserLocked: 'user/locked',
    UserCreditBalanceUpdated: 'user/credit-balance/updated',
    UserUnlocked: 'user/unlocked',
    UserPasswordUpdated: 'user/password/updated',
    UserEmailUpdated: 'user/email/updated',
    UserCurrencyUpdated: 'user/currency/updated',
    UserInvoiceContactUpdated: 'user/invoice-contact/updated',
    UserPolicyUpdated: 'user/policy/updated',
    UserLanguagesUpdated: 'user/languages/updated',
    UserCustomPricePoliciesUpdated: 'user/custom-price-policies/updated',
    UserCustomAddonPricePoliciesUpdated: 'user/custom-addon-price-policies/updated',
    UserCustomAffiliateAdded: 'user/custom-affiliate/added',
    UserCustomAffiliateRemoved: 'user/custom-affiliate/removed',
    UserInvoiceIntervalUpdated: 'user/invoice-interval/updated',
    UserAdditionalNotificationEmailRemoved: 'user/additional-notification-email/removed',
    UserAdditionalNotificationEmailAdded: 'user/additional-notification-email/added',
    UserCommentAdded: 'user/comment/added',
    UserCommentRemoved: 'user/comment/removed',
    UserCommentUpdated: 'user/comment/updated',
    UserTagsUpdated: 'user/tags/updated',
    UserSettingAdded: 'user/setting/added',
    UserSettingRemoved: 'user/setting/removed',
    UserSettingUpdated: 'user/setting/updated',
    UserStartSelling: 'user/start-selling',
    UserRolesUpdated: 'user/roles/updated',
    MessageCreated: 'message/created',
    MessageUpdated: 'message/updated',
    MessageDeleted: 'message/deleted',
    NotificationSent: 'notification/sent',
    PolicyCreated: 'policy/created',
    PolicyUpdated: 'policy/updated',
    PolicyDeleted: 'policy/deleted',
    ProductCategoryCreated: 'product-category/created',
    ProductCategoryUpdated: 'product-category/updated',
    ProductCategoryDeleted: 'product-category/deleted',
    InvoiceContactCreated: 'invoice-contact/created',
    InvoiceContactUpdated: 'invoice-contact/updated',
    InvoiceContactDeleted: 'invoice-contact/deleted',
    InvoiceCreated: 'invoice/created',
    InvoiceUpdated: 'invoice/updated',
    InvoiceDeleted: 'invoice/deleted',
    CurrencyCreated: 'currency/created',
    CurrencyUpdated: 'currency/updated',
    CurrencyDeleted: 'currency/deleted',
    AffiliateCreated: 'affiliate/created',
    AffiliateUpdated: 'affiliate/updated',
    AffiliateDeleted: 'affiliate/deleted',
    CompanyCreated: 'company/created',
    CompanyUpdated: 'company/updated',
    CompanyDeleted: 'company/deleted',
    OrganizationIntegrationAttached: 'organization/integration/attached',
    OrganizationIntegrationDetached: 'organization/integration/detached',
    TldCreated: 'tld/created',
    TldUpdated: 'tld/updated',
    TldDeleted: 'tld/deleted',
    IntegrationCreated: 'integration/created',
    IntegrationUpdated: 'integration/updated',
    IntegrationDeleted: 'integration/deleted',
    IntegrationInstalled: 'integration/installed',
    IntegrationUninstalled: 'integration/uninstalled',
    DomainContactCreated: 'domain-contact/created',
    DomainContactUpdated: 'domain-contact/updated',
    DomainContactDeleted: 'domain-contact/deleted',
    DomainCategoryCreated: 'domain-category/created',
    DomainCategoryUpdated: 'domain-category/updated',
    DomainCategoryDeleted: 'domain-category/deleted',
    AddonCreated: 'addon/created',
    AddonUpdated: 'addon/updated',
    AddonDeleted: 'addon/deleted',
    PaymentCreated: 'payment/created',
    PaymentCanceled: 'payment/canceled',
    PaymentFailed: 'payment/failed',
    PaymentSubscribed: 'payment/subscribed',
    PaymentUnsubscribed: 'payment/unsubscribed',
    PaymentUpdated: 'payment/updated',
    PaymentDeleted: 'payment/deleted',
    PaymentCompleted: 'payment/completed',
    TemplateCreated: 'template/created',
    TemplateUpdated: 'template/updated',
    TemplateDeleted: 'template/deleted',
    CouponCreated: 'coupon/created',
    CouponUpdated: 'coupon/updated',
    CouponDeleted: 'coupon/deleted',
    TemplateIntegrationCreated: 'template-integration/created',
    TemplateIntegrationUpdated: 'template-integration/updated',
    TemplateIntegrationDeleted: 'template-integration/deleted',
    OrderCreated: 'order/created',
    OrderStatusInProgress: 'order/status/in-progress',
    OrderStatusCompleted: 'order/status/completed',
    OrderStatusCanceled: 'order/status/canceled',
    OrderStatusRefunded: 'order/status/refunded',
    OrderInsufficientBalance: 'order/insufficient-balance',
    OrderUpdated: 'order/updated',
    OrderDeleted: 'order/deleted',
    SettingCreated: 'setting/created',
    SettingUpdated: 'setting/updated',
    SettingDeleted: 'setting/deleted',
    IssueCreated: 'issue/created',
    IssueUpdated: 'issue/updated',
    IssueDeleted: 'issue/deleted',
    TaskCreated: 'task/created',
    TaskUpdated: 'task/updated',
    TaskDeleted: 'task/deleted',
    TaskCanceled: 'task/canceled',
    TaskInProgress: 'task/in-progress',
    TaskCompleted: 'task/completed',
    TaskPercentageUpdated: 'task/percentage/updated',
    ProductCreated: 'product/created',
    ProductUpdated: 'product/updated',
    ProductDeleted: 'product/deleted',
    ProductAutoRenewUpdated: 'product/auto-renew/updated',
    ProductEnabled: 'product/enabled',
    ProductDisabled: 'product/disabled',
    ProductVersionCreated: 'product/version-created',
    IpGroupCreated: 'ip-group/created',
    IpGroupUpdated: 'ip-group/updated',
    IpGroupDeleted: 'ip-group/deleted',
    IpCreated: 'ip/created',
    IpUpdated: 'ip/updated',
    IpDeleted: 'ip/deleted',
    DomainNameCreated: 'domain-name/created',
    DomainNameUpdated: 'domain-name/updated',
    DomainNameDeleted: 'domain-name/deleted',
    DomainNameLocked: 'domain-name/locked',
    DomainNameUnlocked: 'domain-name/unlocked',
    DomainNameIdshieldActivated: 'domain-name/idshield-activated',
    DomainNameIdshieldDeactivated: 'domain-name/idshield-deactivated',
    DomainNameBundleAdded: 'domain-name/bundle-added',
    DomainNameBundleRemoved: 'domain-name/bundle-removed',
    DomainNameRegistrantUpdated: 'domain-name/registrant-updated',
    DomainNameAdminUpdated: 'domain-name/admin-updated',
    DomainNameTechUpdated: 'domain-name/tech-updated',
    DomainNameBillingUpdated: 'domain-name/billing-updated',
    DomainNameAdditionalUpdated: 'domain-name/additional-updated',
    ItemCreated: 'item/created',
    ItemUpdated: 'item/updated',
    ItemDeleted: 'item/deleted',
    ItemRenewed: 'item/renewed',
    ItemUpgraded: 'item/upgraded',
    ItemDowngraded: 'item/downgraded',
    ItemIpAttached: 'item/ip-attached',
    ItemIpDetached: 'item/ip-detached',
    ItemDetachedFromOrder: 'item/detached-from-order',
    ItemPostponed: 'item/postponed',
    ItemTransferredIn: 'item/transferred-in',
    ItemCanceled: 'item/canceled',
    ItemSuspended: 'item/suspended',
    ItemUnsuspended: 'item/unsuspended',
    ItemAffiliateAdded: 'item/affiliate/added',
    ItemBundleAttached: 'item/bundle/attached',
    ItemBundleDetached: 'item/bundle/detached',
    ItemActivated: 'item/activated',
    ItemSetInactive: 'item/set-inactive',
    ItemProcessed: 'item/processed',
    OrderPaid: 'order/paid',
    Test: 'test'
} as const;

export type IntegrationDtoListenEventsEnum = typeof IntegrationDtoListenEventsEnum[keyof typeof IntegrationDtoListenEventsEnum];
export const IntegrationDtoProductCategoryEnum = {
    Ssl: 'SSL',
    Vps: 'VPS',
    Dedicated: 'DEDICATED',
    WebHosting: 'WEB HOSTING',
    Other: 'OTHER'
} as const;

export type IntegrationDtoProductCategoryEnum = typeof IntegrationDtoProductCategoryEnum[keyof typeof IntegrationDtoProductCategoryEnum];

/**
 * 
 * @export
 * @interface IntegrationInfoResponseDto
 */
export interface IntegrationInfoResponseDto {
    /**
     * The name of the service integration.
     * @type {string}
     * @memberof IntegrationInfoResponseDto
     */
    'name'?: string;
    /**
     * The string contains the path for the service integration\'s logo.
     * @type {string}
     * @memberof IntegrationInfoResponseDto
     */
    'logo'?: string;
    /**
     * The title of the service integration.
     * @type {string}
     * @memberof IntegrationInfoResponseDto
     */
    'title'?: string;
    /**
     * A string providing a brief overview or description of the integration.
     * @type {string}
     * @memberof IntegrationInfoResponseDto
     */
    'description'?: string;
    /**
     * An array that holds all the action fields.
     * @type {Array<ActionFieldDto>}
     * @memberof IntegrationInfoResponseDto
     */
    'actionFields'?: Array<ActionFieldDto>;
    /**
     * An array that holds all the tabs for the product.
     * @type {Array<TabDto>}
     * @memberof IntegrationInfoResponseDto
     */
    'productTabs'?: Array<TabDto>;
    /**
     * An array that holds all the list actions.
     * @type {Array<ListActionDto>}
     * @memberof IntegrationInfoResponseDto
     */
    'listActions'?: Array<ListActionDto>;
    /**
     * An array that holds tabs about the product settings.
     * @type {Array<TabDto>}
     * @memberof IntegrationInfoResponseDto
     */
    'settings'?: Array<TabDto>;
    /**
     * An array that holds all the menu items.
     * @type {Array<MenuItemDto>}
     * @memberof IntegrationInfoResponseDto
     */
    'menuItems'?: Array<MenuItemDto>;
    /**
     * An array that holds all the required fields for the product.
     * @type {string}
     * @memberof IntegrationInfoResponseDto
     */
    'requiredFields'?: string;
    /**
     * An array that holds all the meta keys need to be returned for the product.
     * @type {string}
     * @memberof IntegrationInfoResponseDto
     */
    'returnMetaKeys'?: string;
}
/**
 * 
 * @export
 * @interface IntendedUseParamsDataDto
 */
export interface IntendedUseParamsDataDto {
    /**
     * The intended use of the requested domain.
     * @type {string}
     * @memberof IntendedUseParamsDataDto
     */
    'intendedUse': string;
    /**
     * A reference URL to an existing public online presence of the authority.
     * @type {string}
     * @memberof IntendedUseParamsDataDto
     */
    'referenceUrl'?: string;
    /**
     * The trademark ID if applicable.
     * @type {string}
     * @memberof IntendedUseParamsDataDto
     */
    'trademarkId'?: string;
    /**
     * The issuer of the trademark, if applicable.
     * @type {string}
     * @memberof IntendedUseParamsDataDto
     */
    'trademarkIssuer'?: string;
}
/**
 * 
 * @export
 * @interface InvoiceContactDto
 */
export interface InvoiceContactDto {
    /**
     * The unique identifier for the contact.
     * @type {string}
     * @memberof InvoiceContactDto
     */
    'id'?: string;
    /**
     * The unique identifier of the company associated with this contact.
     * @type {string}
     * @memberof InvoiceContactDto
     */
    'companyId': string;
    /**
     * The unique identifier of the company associated with this contact.
     * @type {string}
     * @memberof InvoiceContactDto
     */
    'userId': string;
    /**
     * The email address of the contact.
     * @type {string}
     * @memberof InvoiceContactDto
     */
    'email': string;
    /**
     * The first name of the contact.
     * @type {string}
     * @memberof InvoiceContactDto
     */
    'firstName': string;
    /**
     * The last name of the contact.
     * @type {string}
     * @memberof InvoiceContactDto
     */
    'lastName': string;
    /**
     * Indicates if the contact represents a company.
     * @type {boolean}
     * @memberof InvoiceContactDto
     */
    'isCompany': boolean;
    /**
     * The name of the company if the contact represents a company.
     * @type {string}
     * @memberof InvoiceContactDto
     */
    'companyName'?: string;
    /**
     * The telephone number of the contact.
     * @type {string}
     * @memberof InvoiceContactDto
     */
    'telephone': string;
    /**
     * The mobile number of the contact.
     * @type {string}
     * @memberof InvoiceContactDto
     */
    'mobile'?: string;
    /**
     * The first address line.
     * @type {string}
     * @memberof InvoiceContactDto
     */
    'address1': string;
    /**
     * The second address line.
     * @type {string}
     * @memberof InvoiceContactDto
     */
    'address2'?: string;
    /**
     * The third address line.
     * @type {string}
     * @memberof InvoiceContactDto
     */
    'address3'?: string;
    /**
     * The postal code or ZIP code.
     * @type {string}
     * @memberof InvoiceContactDto
     */
    'postcode': string;
    /**
     * The city where the contact is located.
     * @type {string}
     * @memberof InvoiceContactDto
     */
    'city': string;
    /**
     * The country where the contact is located.
     * @type {string}
     * @memberof InvoiceContactDto
     */
    'country': InvoiceContactDtoCountryEnum;
    /**
     * The state or region where the contact is located.
     * @type {string}
     * @memberof InvoiceContactDto
     */
    'state'?: string;
    /**
     * The Value Added Tax (VAT) number of the contact.
     * @type {string}
     * @memberof InvoiceContactDto
     */
    'vat'?: string;
    /**
     * The tax office related to the contact.
     * @type {string}
     * @memberof InvoiceContactDto
     */
    'taxOffice'?: string;
    /**
     * The date and time when the contact was created.
     * @type {string}
     * @memberof InvoiceContactDto
     */
    'createdAt'?: string;
    /**
     * The date and time when the contact was last updated.
     * @type {string}
     * @memberof InvoiceContactDto
     */
    'updatedAt'?: string;
}

export const InvoiceContactDtoCountryEnum = {
    Af: 'AF',
    Al: 'AL',
    Dz: 'DZ',
    As: 'AS',
    Ad: 'AD',
    Ao: 'AO',
    Ai: 'AI',
    Aq: 'AQ',
    Ag: 'AG',
    Ar: 'AR',
    Am: 'AM',
    Aw: 'AW',
    Au: 'AU',
    At: 'AT',
    Az: 'AZ',
    Bs: 'BS',
    Bh: 'BH',
    Bd: 'BD',
    Bb: 'BB',
    By: 'BY',
    Be: 'BE',
    Bz: 'BZ',
    Bj: 'BJ',
    Bm: 'BM',
    Bt: 'BT',
    Bo: 'BO',
    Bq: 'BQ',
    Ba: 'BA',
    Bw: 'BW',
    Bv: 'BV',
    Br: 'BR',
    Io: 'IO',
    Bn: 'BN',
    Bg: 'BG',
    Bf: 'BF',
    Bi: 'BI',
    Kh: 'KH',
    Cm: 'CM',
    Ca: 'CA',
    Cv: 'CV',
    Ky: 'KY',
    Cf: 'CF',
    Td: 'TD',
    Cl: 'CL',
    Cn: 'CN',
    Cx: 'CX',
    Cc: 'CC',
    Co: 'CO',
    Km: 'KM',
    Cg: 'CG',
    Cd: 'CD',
    Ck: 'CK',
    Cr: 'CR',
    Ci: 'CI',
    Hr: 'HR',
    Cu: 'CU',
    Cw: 'CW',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Dj: 'DJ',
    Dm: 'DM',
    Do: 'DO',
    Ec: 'EC',
    Eg: 'EG',
    Sv: 'SV',
    Gq: 'GQ',
    Er: 'ER',
    Ee: 'EE',
    Et: 'ET',
    Fk: 'FK',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Gf: 'GF',
    Pf: 'PF',
    Tf: 'TF',
    Ga: 'GA',
    Gm: 'GM',
    Ge: 'GE',
    De: 'DE',
    Gh: 'GH',
    Gi: 'GI',
    Gr: 'GR',
    Gl: 'GL',
    Gd: 'GD',
    Gp: 'GP',
    Gu: 'GU',
    Gt: 'GT',
    Gg: 'GG',
    Gn: 'GN',
    Gw: 'GW',
    Gy: 'GY',
    Ht: 'HT',
    Hm: 'HM',
    Va: 'VA',
    Hn: 'HN',
    Hk: 'HK',
    Hu: 'HU',
    Is: 'IS',
    In: 'IN',
    Id: 'ID',
    Ir: 'IR',
    Iq: 'IQ',
    Ie: 'IE',
    Im: 'IM',
    Il: 'IL',
    It: 'IT',
    Jm: 'JM',
    Jp: 'JP',
    Je: 'JE',
    Jo: 'JO',
    Kz: 'KZ',
    Ke: 'KE',
    Ki: 'KI',
    Kp: 'KP',
    Kr: 'KR',
    Kw: 'KW',
    Kg: 'KG',
    La: 'LA',
    Lv: 'LV',
    Lb: 'LB',
    Ls: 'LS',
    Lr: 'LR',
    Ly: 'LY',
    Li: 'LI',
    Lt: 'LT',
    Lu: 'LU',
    Mo: 'MO',
    Mk: 'MK',
    Mg: 'MG',
    Mw: 'MW',
    My: 'MY',
    Mv: 'MV',
    Ml: 'ML',
    Mt: 'MT',
    Mh: 'MH',
    Mq: 'MQ',
    Mr: 'MR',
    Mu: 'MU',
    Tn: 'TN',
    Tr: 'TR',
    Tm: 'TM',
    Tc: 'TC',
    Tv: 'TV',
    Ug: 'UG',
    Ua: 'UA',
    Ae: 'AE',
    Gb: 'GB',
    Us: 'US',
    Um: 'UM',
    Uy: 'UY',
    Uz: 'UZ',
    Vu: 'VU',
    Ve: 'VE',
    Vn: 'VN',
    Vg: 'VG',
    Vi: 'VI',
    Wf: 'WF',
    Eh: 'EH',
    Ye: 'YE',
    Zm: 'ZM',
    Zw: 'ZW',
    Yt: 'YT',
    Mx: 'MX',
    Fm: 'FM',
    Md: 'MD',
    Mc: 'MC',
    Mn: 'MN',
    Me: 'ME',
    Ms: 'MS',
    Ma: 'MA',
    Mz: 'MZ',
    Mm: 'MM',
    Na: 'NA',
    Nr: 'NR',
    Np: 'NP',
    Nl: 'NL',
    Nc: 'NC',
    Nz: 'NZ',
    Ni: 'NI',
    Ne: 'NE',
    Ng: 'NG',
    Nu: 'NU',
    Nf: 'NF',
    Mp: 'MP',
    No: 'NO',
    Om: 'OM',
    Pk: 'PK',
    Pw: 'PW',
    Ps: 'PS',
    Pa: 'PA',
    Pg: 'PG',
    Py: 'PY',
    Pe: 'PE',
    Ph: 'PH',
    Pn: 'PN',
    Pl: 'PL',
    Pt: 'PT',
    Pr: 'PR',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Ru: 'RU',
    Rw: 'RW',
    Bl: 'BL',
    Sh: 'SH',
    Kn: 'KN',
    Lc: 'LC',
    Mf: 'MF',
    Pm: 'PM',
    Vc: 'VC',
    Ws: 'WS',
    Sm: 'SM',
    St: 'ST',
    Sa: 'SA',
    Sn: 'SN',
    Rs: 'RS',
    Sc: 'SC',
    Sl: 'SL',
    Sg: 'SG',
    Sx: 'SX',
    Sk: 'SK',
    Si: 'SI',
    Sb: 'SB',
    So: 'SO',
    Za: 'ZA',
    Gs: 'GS',
    Ss: 'SS',
    Es: 'ES',
    Lk: 'LK',
    Sd: 'SD',
    Sr: 'SR',
    Sj: 'SJ',
    Sz: 'SZ',
    Se: 'SE',
    Ch: 'CH',
    Sy: 'SY',
    Tw: 'TW',
    Tj: 'TJ',
    Tz: 'TZ',
    Th: 'TH',
    Tl: 'TL',
    Tg: 'TG',
    Tk: 'TK',
    To: 'TO',
    Tt: 'TT'
} as const;

export type InvoiceContactDtoCountryEnum = typeof InvoiceContactDtoCountryEnum[keyof typeof InvoiceContactDtoCountryEnum];

/**
 * 
 * @export
 * @interface IpDto
 */
export interface IpDto {
    /**
     * The unique identifier of the ip.
     * @type {string}
     * @memberof IpDto
     */
    'id'?: string;
    /**
     * The actual address of the ip.
     * @type {string}
     * @memberof IpDto
     */
    'address': string;
    /**
     * The number of bits in the prefix length in an IP address range.
     * @type {number}
     * @memberof IpDto
     */
    'range': number;
    /**
     * The type of the ip.
     * @type {string}
     * @memberof IpDto
     */
    'type': IpDtoTypeEnum;
    /**
     * The unique identifier for the item the ip is assigned to.
     * @type {string}
     * @memberof IpDto
     */
    'assignedToItemId'?: string;
    /**
     * The goup of the ip.
     * @type {IpGroupDto}
     * @memberof IpDto
     */
    'group': IpGroupDto;
}

export const IpDtoTypeEnum = {
    Ipv4: 'IPv4',
    Ipv6: 'IPv6'
} as const;

export type IpDtoTypeEnum = typeof IpDtoTypeEnum[keyof typeof IpDtoTypeEnum];

/**
 * 
 * @export
 * @interface IpGroupDto
 */
export interface IpGroupDto {
    /**
     * The unique identifier of the ip group.
     * @type {string}
     * @memberof IpGroupDto
     */
    'id'?: string;
    /**
     * The ip group name.
     * @type {string}
     * @memberof IpGroupDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface IpSettingsDto
 */
export interface IpSettingsDto {
    /**
     * Indicates if an ip is required.
     * @type {boolean}
     * @memberof IpSettingsDto
     */
    'requireIp': boolean;
    /**
     * The minimum number of ips.
     * @type {number}
     * @memberof IpSettingsDto
     */
    'minIps': number;
    /**
     * A unique identifier representing an IP group.
     * @type {string}
     * @memberof IpSettingsDto
     */
    'ipGroupId'?: string;
    /**
     * The maximum number of ips.
     * @type {number}
     * @memberof IpSettingsDto
     */
    'maxIps': number;
    /**
     * Indicates the number of free ips.
     * @type {number}
     * @memberof IpSettingsDto
     */
    'freeIps': number;
    /**
     * A custom ip price number per month.
     * @type {number}
     * @memberof IpSettingsDto
     */
    'customIpPrice'?: number;
}
/**
 * 
 * @export
 * @interface IssueDto
 */
export interface IssueDto {
    /**
     * The unique identifier for the issue.
     * @type {string}
     * @memberof IssueDto
     */
    'id'?: string;
    /**
     * The title of the issue.
     * @type {string}
     * @memberof IssueDto
     */
    'title': string;
    /**
     * A brief text that describes the issue.
     * @type {string}
     * @memberof IssueDto
     */
    'description': string;
    /**
     * ParentId / UserId: Must provide at least one of two
     * @type {string}
     * @memberof IssueDto
     */
    'companyId'?: string;
    /**
     * The unique identifier of the user associated with the issue.
     * @type {string}
     * @memberof IssueDto
     */
    'forUserId'?: string;
    /**
     * The unique identifier of the item associated with the issue.
     * @type {string}
     * @memberof IssueDto
     */
    'forItemId'?: string;
    /**
     * The unique identifier of the order associated with the issue.
     * @type {string}
     * @memberof IssueDto
     */
    'forOrderId'?: string;
    /**
     * The unique identifier of the integration associated with the issue.
     * @type {string}
     * @memberof IssueDto
     */
    'integrationId'?: string;
    /**
     * Indicates the category of the issue.
     * @type {string}
     * @memberof IssueDto
     */
    'category': IssueDtoCategoryEnum;
    /**
     * Indicates the priority of the issue.
     * @type {string}
     * @memberof IssueDto
     */
    'priority': IssueDtoPriorityEnum;
    /**
     * Defines if the issue is resolved or not.
     * @type {boolean}
     * @memberof IssueDto
     */
    'resolved'?: boolean;
    /**
     * An array that determines the actions taken.
     * @type {Array<string>}
     * @memberof IssueDto
     */
    'actionsDone'?: Array<string>;
}

export const IssueDtoCategoryEnum = {
    Order: 'order',
    OrderItem: 'order_item',
    Other: 'other'
} as const;

export type IssueDtoCategoryEnum = typeof IssueDtoCategoryEnum[keyof typeof IssueDtoCategoryEnum];
export const IssueDtoPriorityEnum = {
    Low: 'low',
    Normal: 'normal',
    Critical: 'critical'
} as const;

export type IssueDtoPriorityEnum = typeof IssueDtoPriorityEnum[keyof typeof IssueDtoPriorityEnum];

/**
 * 
 * @export
 * @interface ItAdditionalDataDto
 */
export interface ItAdditionalDataDto {
    /**
     * The nationality of the contact
     * @type {string}
     * @memberof ItAdditionalDataDto
     */
    'nationality': string;
    /**
     * - 1. Italian and foreign natural persons     - 2. Companies/one man companies     - 3. Freelance workers/professionals     - 4. Non-profit organisations     - 5. Public organisations     - 6. Other subjects     - 7. Foreigners who match 2-6
     * @type {number}
     * @memberof ItAdditionalDataDto
     */
    'entityType': ItAdditionalDataDtoEntityTypeEnum;
    /**
     * The registration code (e.g. codice fiscal, document number, VAT number or numeric tax code) of the contact
     * @type {string}
     * @memberof ItAdditionalDataDto
     */
    'regCode': string;
}

export const ItAdditionalDataDtoEntityTypeEnum = {
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5,
    NUMBER_6: 6,
    NUMBER_7: 7
} as const;

export type ItAdditionalDataDtoEntityTypeEnum = typeof ItAdditionalDataDtoEntityTypeEnum[keyof typeof ItAdditionalDataDtoEntityTypeEnum];

/**
 * 
 * @export
 * @interface ItemAddonDto
 */
export interface ItemAddonDto {
    /**
     * The unique identifier for the addon.
     * @type {string}
     * @memberof ItemAddonDto
     */
    'addonId': string;
    /**
     * 
     * @type {number}
     * @memberof ItemAddonDto
     */
    'value': number;
}
/**
 * 
 * @export
 * @interface ItemAffiliateDto
 */
export interface ItemAffiliateDto {
    /**
     * The identifier of the user supplies affiliate.
     * @type {string}
     * @memberof ItemAffiliateDto
     */
    'affiliateId': string;
    /**
     * The type of affiliate,
     * @type {string}
     * @memberof ItemAffiliateDto
     */
    'affiliateType': ItemAffiliateDtoAffiliateTypeEnum;
    /**
     * The percent or amount.
     * @type {number}
     * @memberof ItemAffiliateDto
     */
    'percentOrAmount': number;
    /**
     * Indicates if the item has been paid or not.
     * @type {boolean}
     * @memberof ItemAffiliateDto
     */
    'paid': boolean;
    /**
     * The date and time when the payment was made.
     * @type {string}
     * @memberof ItemAffiliateDto
     */
    'paidAt': string;
    /**
     * The monetary value to be paid.
     * @type {number}
     * @memberof ItemAffiliateDto
     */
    'value': number;
    /**
     * 
     * @type {string}
     * @memberof ItemAffiliateDto
     */
    'status': ItemAffiliateDtoStatusEnum;
}

export const ItemAffiliateDtoAffiliateTypeEnum = {
    Fixed: 'fixed',
    Percentage: 'percentage'
} as const;

export type ItemAffiliateDtoAffiliateTypeEnum = typeof ItemAffiliateDtoAffiliateTypeEnum[keyof typeof ItemAffiliateDtoAffiliateTypeEnum];
export const ItemAffiliateDtoStatusEnum = {
    Pending: 'pending',
    Accepted: 'accepted',
    Rejected: 'rejected'
} as const;

export type ItemAffiliateDtoStatusEnum = typeof ItemAffiliateDtoStatusEnum[keyof typeof ItemAffiliateDtoStatusEnum];

/**
 * Currency details of the item
 * @export
 * @interface ItemCurrency
 */
export interface ItemCurrency {
    /**
     * 
     * @type {string}
     * @memberof ItemCurrency
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemCurrency
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemCurrency
     */
    'threeLetterCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemCurrency
     */
    'symbol'?: string;
}
/**
 * 
 * @export
 * @interface ItemDto
 */
export interface ItemDto {
    /**
     * Unique identifier for the item
     * @type {string}
     * @memberof ItemDto
     */
    'id'?: string;
    /**
     * Unique identifier for the company associated with the item
     * @type {string}
     * @memberof ItemDto
     */
    'companyId'?: string;
    /**
     * Name of the item
     * @type {string}
     * @memberof ItemDto
     */
    'name'?: string;
    /**
     * Type of the item (e.g., PRODUCT)
     * @type {string}
     * @memberof ItemDto
     */
    'type'?: ItemDtoTypeEnum;
    /**
     * Unique identifier for the order associated with the item
     * @type {string}
     * @memberof ItemDto
     */
    'orderId'?: string;
    /**
     * Action related to the item
     * @type {string}
     * @memberof ItemDto
     */
    'action'?: ItemDtoActionEnum;
    /**
     * Unique identifier for the parent order associated with the item
     * @type {string}
     * @memberof ItemDto
     */
    'parentOrderId'?: string;
    /**
     * Status of the item
     * @type {string}
     * @memberof ItemDto
     */
    'status'?: ItemDtoStatusEnum;
    /**
     * 
     * @type {ProductCategoryDetails}
     * @memberof ItemDto
     */
    'productCategoryDetails'?: ProductCategoryDetails;
    /**
     * 
     * @type {ProductDetails}
     * @memberof ItemDto
     */
    'productDetails'?: ProductDetails;
    /**
     * Addons associated with the item
     * @type {Array<ItemAddonDto>}
     * @memberof ItemDto
     */
    'itemAddons'?: Array<ItemAddonDto>;
    /**
     * 
     * @type {ItemCurrency}
     * @memberof ItemDto
     */
    'currency'?: ItemCurrency;
    /**
     * Metadata associated with the item
     * @type {{ [key: string]: any; }}
     * @memberof ItemDto
     */
    'itemMeta'?: { [key: string]: any; };
    /**
     * These are all the attributes of the General Product as assigned by the Seller.
     * @type {{ [key: string]: any; }}
     * @memberof ItemDto
     */
    'productAttributes': { [key: string]: any; };
    /**
     * Flag indicating whether the item has been transferred out
     * @type {boolean}
     * @memberof ItemDto
     */
    'autoRenew'?: boolean;
    /**
     * Flag indicating whether the item has been transferred out
     * @type {boolean}
     * @memberof ItemDto
     */
    'transferredOut'?: boolean;
    /**
     * Unique identifier for the user from whom the item was transferred
     * @type {string}
     * @memberof ItemDto
     */
    'transferredFromUserId'?: string;
    /**
     * Flag indicating whether the item has expired
     * @type {boolean}
     * @memberof ItemDto
     */
    'expired'?: boolean;
    /**
     * Comment associated with the parent item
     * @type {string}
     * @memberof ItemDto
     */
    'parentComment'?: string;
    /**
     * Comment associated with the user
     * @type {string}
     * @memberof ItemDto
     */
    'userComment'?: string;
    /**
     * Price details of the item
     * @type {PricesDto}
     * @memberof ItemDto
     */
    'price'?: PricesDto;
    /**
     * Duration of the item\'s subscription in months
     * @type {string}
     * @memberof ItemDto
     */
    'duration'?: ItemDtoDurationEnum;
    /**
     * Unique identifiers for items that are bundled with this item
     * @type {string}
     * @memberof ItemDto
     */
    'bundles'?: string;
    /**
     * Unique identifier for the item with which this item is bundled
     * @type {string}
     * @memberof ItemDto
     */
    'bundledWith'?: string;
    /**
     * Unique identifiers for associated IP addresses
     * @type {Array<string>}
     * @memberof ItemDto
     */
    'ipIds'?: Array<string>;
    /**
     * Email addresses for additional notifications
     * @type {Array<string>}
     * @memberof ItemDto
     */
    'additionalNotificationEmails'?: Array<string>;
    /**
     * Unique identifier for the associated domain name
     * @type {string}
     * @memberof ItemDto
     */
    'domainNameId'?: string;
    /**
     * 
     * @type {AffiliateData}
     * @memberof ItemDto
     */
    'affiliateData'?: AffiliateData;
    /**
     * Start date of the item
     * @type {string}
     * @memberof ItemDto
     */
    'startDate'?: string;
    /**
     * End date of the item
     * @type {string}
     * @memberof ItemDto
     */
    'endDate'?: string;
    /**
     * Dates when the item was postponed
     * @type {Array<string>}
     * @memberof ItemDto
     */
    'timesPostponed'?: Array<string>;
    /**
     * 
     * @type {object}
     * @memberof ItemDto
     */
    'meta'?: object;
    /**
     * Date when the item was created
     * @type {string}
     * @memberof ItemDto
     */
    'createdAt'?: string;
    /**
     * Date when the item was last updated
     * @type {string}
     * @memberof ItemDto
     */
    'updatedAt'?: string;
}

export const ItemDtoTypeEnum = {
    Domain: 'DOMAIN',
    Product: 'PRODUCT'
} as const;

export type ItemDtoTypeEnum = typeof ItemDtoTypeEnum[keyof typeof ItemDtoTypeEnum];
export const ItemDtoActionEnum = {
    ItemCreate: 'item/create',
    ItemSuspend: 'item/suspend',
    ItemUnsuspend: 'item/unsuspend',
    ItemRenew: 'item/renew',
    ItemCancel: 'item/cancel',
    ItemDelete: 'item/delete',
    ItemUpgrade: 'item/upgrade',
    ItemUpdate: 'item/update',
    ItemDowngrade: 'item/downgrade',
    DomainCreate: 'domain/create',
    DomainLock: 'domain/lock',
    DomainUnlock: 'domain/unlock',
    DomainRenew: 'domain/renew',
    DomainBundleAdd: 'domain/bundle/add',
    DomainBundleRemove: 'domain/bundle/remove',
    DomainInfo: 'domain/info',
    DomainRecall: 'domain/recall',
    DomainTransferCheck: 'domain/transfer/check',
    DomainTransferCancel: 'domain/transfer/cancel',
    DomainTransferAccept: 'domain/transfer/accept',
    DomainSendAuthCode: 'domain/send-auth-code',
    DomainCheckAvailability: 'domain/check-availability',
    DomainShieldActivate: 'domain/shield/activate',
    DomainShieldDeactivate: 'domain/shield/deactivate',
    DomainDelete: 'domain/delete',
    DomainContactsInfo: 'domain/contacts/info',
    DomainContactsCreate: 'domain/contacts/create',
    DomainContactsUpdate: 'domain/contacts/update',
    DomainContactsDelete: 'domain/contacts/delete',
    DomainContactsRegistrant: 'domain/contacts/registrant',
    DomainContactsAdmin: 'domain/contacts/admin',
    DomainContactsTech: 'domain/contacts/tech',
    DomainContactsBilling: 'domain/contacts/billing',
    DomainResendVerificationEmail: 'domain/resend-verification-email',
    DomainCheckClaims: 'domain/check-claims',
    DomainModifyHosts: 'domain/modify-hosts',
    DomainModifyAuthcode: 'domain/modify-authcode',
    DomainGetTransferStatus: 'domain/get-transfer-status',
    DomainCancelTransfer: 'domain/cancel-transfer',
    DomainRequestTransferAway: 'domain/request-transfer-away',
    DomainRequestTransfer: 'domain/request-transfer',
    DomainCompleteTransferAway: 'domain/complete-transfer-away',
    DomainRejectTransferAway: 'domain/reject-transfer-away',
    DomainRejectTransferExpired: 'domain/reject-transfer-expired'
} as const;

export type ItemDtoActionEnum = typeof ItemDtoActionEnum[keyof typeof ItemDtoActionEnum];
export const ItemDtoStatusEnum = {
    Idle: 'idle',
    Suspended: 'suspended',
    Unsuspended: 'unsuspended',
    Inprogress: 'inprogress',
    Active: 'active',
    Inactive: 'inactive',
    Error: 'error',
    Cancel: 'cancel'
} as const;

export type ItemDtoStatusEnum = typeof ItemDtoStatusEnum[keyof typeof ItemDtoStatusEnum];
export const ItemDtoDurationEnum = {
    _1: '1',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5',
    _6: '6',
    _7: '7',
    _8: '8',
    _9: '9',
    _10: '10',
    _11: '11',
    _12: '12',
    _24: '24',
    _36: '36',
    _48: '48',
    _60: '60',
    _72: '72',
    _84: '84',
    _96: '96',
    _108: '108',
    _120: '120'
} as const;

export type ItemDtoDurationEnum = typeof ItemDtoDurationEnum[keyof typeof ItemDtoDurationEnum];

/**
 * 
 * @export
 * @interface ItemUpdateDto
 */
export interface ItemUpdateDto {
    /**
     * Price details for updating the item
     * @type {PricesDto}
     * @memberof ItemUpdateDto
     */
    'price'?: PricesDto;
    /**
     * Start date for the updated item
     * @type {string}
     * @memberof ItemUpdateDto
     */
    'startDate'?: string;
    /**
     * End date for the updated item
     * @type {string}
     * @memberof ItemUpdateDto
     */
    'endDate'?: string;
}
/**
 * 
 * @export
 * @interface ListActionDto
 */
export interface ListActionDto {
    /**
     * A string representing an identifier for the icon to be displayed for this list action.
     * @type {string}
     * @memberof ListActionDto
     */
    'icon'?: string;
    /**
     * A label for the certain list action.
     * @type {string}
     * @memberof ListActionDto
     */
    'label'?: string;
    /**
     * Indicates if this action is a popup.
     * @type {boolean}
     * @memberof ListActionDto
     */
    'popup'?: boolean;
    /**
     * The link associated with the list action.
     * @type {string}
     * @memberof ListActionDto
     */
    'link'?: string;
}
/**
 * 
 * @export
 * @interface LoginResponseDto
 */
export interface LoginResponseDto {
    /**
     * 
     * @type {string}
     * @memberof LoginResponseDto
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface LvAdditionalDataDto
 */
export interface LvAdditionalDataDto {
    /**
     * The official registration number of the contact in Latvia.
     * @type {string}
     * @memberof LvAdditionalDataDto
     */
    'registrationNumber': string;
    /**
     * The Value Added Tax (VAT) number of the contact, if applicable.
     * @type {string}
     * @memberof LvAdditionalDataDto
     */
    'vatNumber'?: string;
}
/**
 * 
 * @export
 * @interface MenuItemDto
 */
export interface MenuItemDto {
    /**
     * A label for the certain tab.
     * @type {string}
     * @memberof MenuItemDto
     */
    'label'?: string;
    /**
     * The url associated with the tab.
     * @type {string}
     * @memberof MenuItemDto
     */
    'url'?: string;
    /**
     * A string representing an identifier for the icon to be displayed for this menu item.
     * @type {string}
     * @memberof MenuItemDto
     */
    'icon'?: string;
}
/**
 * 
 * @export
 * @interface MultilangTextDto
 */
export interface MultilangTextDto {
    /**
     * 
     * @type {string}
     * @memberof MultilangTextDto
     */
    'language': MultilangTextDtoLanguageEnum;
    /**
     * 
     * @type {string}
     * @memberof MultilangTextDto
     */
    'text': string;
}

export const MultilangTextDtoLanguageEnum = {
    Aa: 'aa',
    Af: 'af',
    Ak: 'ak',
    Sq: 'sq',
    Am: 'am',
    Ar: 'ar',
    An: 'an',
    Hy: 'hy',
    As: 'as',
    Av: 'av',
    Ae: 'ae',
    Ay: 'ay',
    Az: 'az',
    Bm: 'bm',
    Ba: 'ba',
    Eu: 'eu',
    Be: 'be',
    Bn: 'bn',
    Bh: 'bh',
    Bi: 'bi',
    Bs: 'bs',
    Br: 'br',
    Bg: 'bg',
    My: 'my',
    Ca: 'ca',
    Ch: 'ch',
    Ce: 'ce',
    Ny: 'ny',
    Zh: 'zh',
    Cv: 'cv',
    Kw: 'kw',
    Co: 'co',
    Cr: 'cr',
    Hr: 'hr',
    Cs: 'cs',
    Da: 'da',
    Dv: 'dv',
    Nl: 'nl',
    Dz: 'dz',
    En: 'en',
    Eo: 'eo',
    Et: 'et',
    Ee: 'ee',
    Fo: 'fo',
    Fj: 'fj',
    Fi: 'fi',
    Fr: 'fr',
    Ff: 'ff',
    Gl: 'gl',
    Ka: 'ka',
    De: 'de',
    El: 'el',
    Gn: 'gn',
    Gu: 'gu',
    Ht: 'ht',
    Ha: 'ha',
    He: 'he',
    Hz: 'hz',
    Hi: 'hi',
    Ho: 'ho',
    Hu: 'hu',
    Ia: 'ia',
    Id: 'id',
    Ie: 'ie',
    Ga: 'ga',
    Ig: 'ig',
    Ik: 'ik',
    Io: 'io',
    Is: 'is',
    It: 'it',
    Iu: 'iu',
    Ja: 'ja',
    Jv: 'jv',
    Kl: 'kl',
    Kn: 'kn',
    Kr: 'kr',
    Ks: 'ks',
    Kk: 'kk',
    Km: 'km',
    Ki: 'ki',
    Rw: 'rw',
    Ky: 'ky',
    Kv: 'kv',
    Kg: 'kg',
    Ko: 'ko',
    Ku: 'ku',
    Kj: 'kj',
    La: 'la',
    Lb: 'lb',
    Lg: 'lg',
    Li: 'li',
    Ln: 'ln',
    Lo: 'lo',
    Lt: 'lt',
    Lu: 'lu',
    Lv: 'lv',
    Gv: 'gv',
    Mk: 'mk',
    Mg: 'mg',
    Ms: 'ms',
    Ml: 'ml',
    Mt: 'mt',
    Mi: 'mi',
    Mr: 'mr',
    Mh: 'mh',
    Mn: 'mn',
    Na: 'na',
    Nv: 'nv',
    Nd: 'nd',
    Ne: 'ne',
    Ng: 'ng',
    Nb: 'nb',
    Nn: 'nn',
    No: 'no',
    Ii: 'ii',
    Nr: 'nr',
    Oc: 'oc',
    Oj: 'oj',
    Cu: 'cu',
    Om: 'om',
    Or: 'or',
    Os: 'os',
    Pa: 'pa',
    Pi: 'pi',
    Fa: 'fa',
    Pl: 'pl',
    Ps: 'ps',
    Pt: 'pt',
    Qu: 'qu',
    Rm: 'rm',
    Rn: 'rn',
    Ro: 'ro',
    Rh: 'rh',
    Ru: 'ru',
    Sa: 'sa',
    Sc: 'sc',
    Sd: 'sd',
    Se: 'se',
    Sm: 'sm',
    Sg: 'sg',
    Sr: 'sr',
    Gd: 'gd',
    Sn: 'sn',
    Si: 'si',
    Sk: 'sk',
    Sl: 'sl',
    So: 'so',
    St: 'st',
    Es: 'es',
    Su: 'su',
    Sw: 'sw',
    Ss: 'ss',
    Sv: 'sv',
    Ta: 'ta',
    Te: 'te',
    Tg: 'tg',
    Th: 'th',
    Ti: 'ti',
    Bo: 'bo',
    Tk: 'tk',
    Tl: 'tl',
    Tn: 'tn',
    To: 'to',
    Tr: 'tr',
    Ts: 'ts',
    Tt: 'tt',
    Tw: 'tw',
    Ty: 'ty',
    Ug: 'ug',
    Uk: 'uk',
    Ur: 'ur',
    Uz: 'uz',
    Ve: 've',
    Vi: 'vi',
    Vo: 'vo',
    Wa: 'wa',
    Cy: 'cy',
    Wo: 'wo',
    Fy: 'fy',
    Xh: 'xh',
    Yi: 'yi',
    Yo: 'yo',
    Za: 'za',
    Zu: 'zu'
} as const;

export type MultilangTextDtoLanguageEnum = typeof MultilangTextDtoLanguageEnum[keyof typeof MultilangTextDtoLanguageEnum];

/**
 * 
 * @export
 * @interface NameServerDto
 */
export interface NameServerDto {
    /**
     * The fully qualified domain name (FQDN) of the name server.
     * @type {string}
     * @memberof NameServerDto
     */
    'hostName': string;
    /**
     * An array of IPv4 addresses associated with the name server.
     * @type {Array<string>}
     * @memberof NameServerDto
     */
    'ipV4Addresses'?: Array<string>;
    /**
     * An array of IPv6 addresses associated with the name server.
     * @type {Array<string>}
     * @memberof NameServerDto
     */
    'ipV6Addresses'?: Array<string>;
}
/**
 * 
 * @export
 * @interface NlAdditionalDataDto
 */
export interface NlAdditionalDataDto {
    /**
     * The legal form of the contact, e.g., \'B.V.\' or \'N.V.\'
     * @type {string}
     * @memberof NlAdditionalDataDto
     */
    'legalType': NlAdditionalDataDtoLegalTypeEnum;
    /**
     * The registration number associated with the legal form, if applicable.
     * @type {string}
     * @memberof NlAdditionalDataDto
     */
    'legalTypeRegistrationNumber'?: string;
}

export const NlAdditionalDataDtoLegalTypeEnum = {
    Anders: 'ANDERS',
    Bgg: 'BGG',
    Bro: 'BRO',
    Bvi: 'BVI',
    Coop: 'COOP',
    Cv: 'CV',
    Eenmanszaak: 'EENMANSZAAK',
    Eesv: 'EESV',
    Maatschap: 'MAATSCHAP',
    Nv: 'NV',
    Owm: 'OWM'
} as const;

export type NlAdditionalDataDtoLegalTypeEnum = typeof NlAdditionalDataDtoLegalTypeEnum[keyof typeof NlAdditionalDataDtoLegalTypeEnum];

/**
 * 
 * @export
 * @interface OrderDto
 */
export interface OrderDto {
    /**
     * Unique Identifier of order
     * @type {string}
     * @memberof OrderDto
     */
    'id'?: string;
    /**
     * Auto-incremented order identifier
     * @type {number}
     * @memberof OrderDto
     */
    'orderNumber': number;
    /**
     * Information about the invoice contact for this order.
     * @type {InvoiceContactDto}
     * @memberof OrderDto
     */
    'invoiceContact': InvoiceContactDto;
    /**
     * Identifier of the user associated with this order.
     * @type {string}
     * @memberof OrderDto
     */
    'userId'?: string;
    /**
     * Identifier of the coupon used for this order.
     * @type {string}
     * @memberof OrderDto
     */
    'couponId'?: string;
    /**
     * The current status of the order.
     * @type {string}
     * @memberof OrderDto
     */
    'orderStatus'?: OrderDtoOrderStatusEnum;
    /**
     * Array of payment IDs associated with this order.
     * @type {Array<string>}
     * @memberof OrderDto
     */
    'paymentIds': Array<string>;
    /**
     * Array of items included in this order.
     * @type {Array<ItemDto>}
     * @memberof OrderDto
     */
    'lines': Array<ItemDto>;
    /**
     * The invoice status associated with the specific order
     * @type {string}
     * @memberof OrderDto
     */
    'orderInvoiceStatus'?: OrderDtoOrderInvoiceStatusEnum;
    /**
     * Summary information about the order\'s prices and costs.
     * @type {PricesDto}
     * @memberof OrderDto
     */
    'summary': PricesDto;
    /**
     * Indicates whether credits were used for this order.
     * @type {boolean}
     * @memberof OrderDto
     */
    'useCredits'?: boolean;
    /**
     * Log information related to the order.
     * @type {string}
     * @memberof OrderDto
     */
    'logs'?: string;
    /**
     * Timestamp indicating when the order was created.
     * @type {string}
     * @memberof OrderDto
     */
    'createdAt'?: string;
    /**
     * Timestamp indicating when the order was last updated.
     * @type {string}
     * @memberof OrderDto
     */
    'updatedAt'?: string;
}

export const OrderDtoOrderStatusEnum = {
    Pending: 'PENDING',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED',
    Canceled: 'CANCELED',
    Refunded: 'REFUNDED'
} as const;

export type OrderDtoOrderStatusEnum = typeof OrderDtoOrderStatusEnum[keyof typeof OrderDtoOrderStatusEnum];
export const OrderDtoOrderInvoiceStatusEnum = {
    Pending: 'PENDING',
    Success: 'SUCCESS'
} as const;

export type OrderDtoOrderInvoiceStatusEnum = typeof OrderDtoOrderInvoiceStatusEnum[keyof typeof OrderDtoOrderInvoiceStatusEnum];

/**
 * 
 * @export
 * @interface PaginatedResponse
 */
export interface PaginatedResponse {
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedResponse
     */
    'message': string;
    /**
     * 
     * @type {object}
     * @memberof PaginatedResponse
     */
    'data': object;
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponse
     */
    'currentPage': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponse
     */
    'totalPages': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponse
     */
    'perPage': number;
}
/**
 * 
 * @export
 * @interface PaymentDto
 */
export interface PaymentDto {
    /**
     * The unique identifier of the payment.
     * @type {string}
     * @memberof PaymentDto
     */
    'id'?: string;
    /**
     * The type of payment (e.g., ORDER).
     * @type {string}
     * @memberof PaymentDto
     */
    'paymentType': PaymentDtoPaymentTypeEnum;
    /**
     * The type of transaction.
     * @type {string}
     * @memberof PaymentDto
     */
    'transactionType': PaymentDtoTransactionTypeEnum;
    /**
     * The ID of the user associated with the payment.
     * @type {string}
     * @memberof PaymentDto
     */
    'userId'?: string;
    /**
     * The ID of the company associated with the payment.
     * @type {string}
     * @memberof PaymentDto
     */
    'companyId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentDto
     */
    'fullName'?: string;
    /**
     * The unique identifier of the associated order.
     * @type {string}
     * @memberof PaymentDto
     */
    'orderId'?: string;
    /**
     * The service integration associated with the payment.
     * @type {IntegrationDto}
     * @memberof PaymentDto
     */
    'integration': IntegrationDto;
    /**
     * The status of the payment.
     * @type {string}
     * @memberof PaymentDto
     */
    'status': PaymentDtoStatusEnum;
    /**
     * The value of the payment.
     * @type {number}
     * @memberof PaymentDto
     */
    'value': number;
    /**
     * The fee associated with the payment.
     * @type {number}
     * @memberof PaymentDto
     */
    'fee'?: number;
    /**
     * An array of order IDs that have used this payment.
     * @type {Array<string>}
     * @memberof PaymentDto
     */
    'usedByOrderIds'?: Array<string>;
    /**
     * The available balance after the payment.
     * @type {number}
     * @memberof PaymentDto
     */
    'remainingBalance'?: number;
    /**
     * Additional metadata for the payment.
     * @type {object}
     * @memberof PaymentDto
     */
    'meta'?: object;
    /**
     * The date of the payment.
     * @type {string}
     * @memberof PaymentDto
     */
    'date': string;
    /**
     * The date when the payment was created.
     * @type {string}
     * @memberof PaymentDto
     */
    'createdAt'?: string;
    /**
     * The date when the payment was last updated.
     * @type {string}
     * @memberof PaymentDto
     */
    'updatedAt'?: string;
}

export const PaymentDtoPaymentTypeEnum = {
    Order: 'ORDER',
    Credits: 'CREDITS'
} as const;

export type PaymentDtoPaymentTypeEnum = typeof PaymentDtoPaymentTypeEnum[keyof typeof PaymentDtoPaymentTypeEnum];
export const PaymentDtoTransactionTypeEnum = {
    Withdraw: 'WITHDRAW',
    Deposit: 'DEPOSIT'
} as const;

export type PaymentDtoTransactionTypeEnum = typeof PaymentDtoTransactionTypeEnum[keyof typeof PaymentDtoTransactionTypeEnum];
export const PaymentDtoStatusEnum = {
    Pending: 'PENDING',
    Processing: 'PROCESSING',
    Completed: 'COMPLETED',
    Cancel: 'CANCEL',
    Error: 'ERROR'
} as const;

export type PaymentDtoStatusEnum = typeof PaymentDtoStatusEnum[keyof typeof PaymentDtoStatusEnum];

/**
 * 
 * @export
 * @interface PaymentRedirectUrlResponseDto
 */
export interface PaymentRedirectUrlResponseDto {
    /**
     * The URL to which the payment is redirected.
     * @type {string}
     * @memberof PaymentRedirectUrlResponseDto
     */
    'redirectUrl': string;
    /**
     * The date when the redirect URL was created.
     * @type {string}
     * @memberof PaymentRedirectUrlResponseDto
     */
    'createdAt'?: string;
    /**
     * The date when the redirect URL was last updated.
     * @type {string}
     * @memberof PaymentRedirectUrlResponseDto
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface PaymentSubscriptionDto
 */
export interface PaymentSubscriptionDto {
    /**
     * A unique identifier for the integration.
     * @type {string}
     * @memberof PaymentSubscriptionDto
     */
    'integrationId': string;
    /**
     * Metadata associated with the payment Integration.
     * @type {object}
     * @memberof PaymentSubscriptionDto
     */
    'meta': object;
}
/**
 * The user\'s persistent shopping cart.
 * @export
 * @interface PersistentCart
 */
export interface PersistentCart {
    /**
     * The unique identifier of the user.
     * @type {string}
     * @memberof PersistentCart
     */
    'userId': string;
    /**
     * The user\'s shopping cart data.
     * @type {object}
     * @memberof PersistentCart
     */
    'cart': object;
    /**
     * The date and time when the user\'s basket was last updated.
     * @type {string}
     * @memberof PersistentCart
     */
    'updatedAt'?: string;
}
/**
 * A read-only object of PolicyDto.
 * @export
 * @interface Policy
 */
export interface Policy {
    /**
     * The unique identifier of the policy.
     * @type {string}
     * @memberof Policy
     */
    'id'?: string;
    /**
     * The title of the price policy.
     * @type {string}
     * @memberof Policy
     */
    'title': string;
    /**
     * A description of the price policy.
     * @type {string}
     * @memberof Policy
     */
    'description'?: string;
    /**
     * Indicates whether this is the default price policy.
     * @type {boolean}
     * @memberof Policy
     */
    'default': boolean;
    /**
     * The date when the policy was created.
     * @type {string}
     * @memberof Policy
     */
    'createdAt'?: string;
    /**
     * The date when the policy was last updated.
     * @type {string}
     * @memberof Policy
     */
    'updatedAt'?: string;
}
/**
 * A read-only object of the PolicyDto.
 * @export
 * @interface PolicyData
 */
export interface PolicyData {
    /**
     * The unique identifier of the policy.
     * @type {string}
     * @memberof PolicyData
     */
    'id'?: string;
    /**
     * The title of the price policy.
     * @type {string}
     * @memberof PolicyData
     */
    'title': string;
    /**
     * A description of the price policy.
     * @type {string}
     * @memberof PolicyData
     */
    'description'?: string;
    /**
     * Indicates whether this is the default price policy.
     * @type {boolean}
     * @memberof PolicyData
     */
    'default': boolean;
    /**
     * The date when the policy was created.
     * @type {string}
     * @memberof PolicyData
     */
    'createdAt'?: string;
    /**
     * The date when the policy was last updated.
     * @type {string}
     * @memberof PolicyData
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface PolicyDto
 */
export interface PolicyDto {
    /**
     * The unique identifier of the policy.
     * @type {string}
     * @memberof PolicyDto
     */
    'id'?: string;
    /**
     * The title of the price policy.
     * @type {string}
     * @memberof PolicyDto
     */
    'title': string;
    /**
     * A description of the price policy.
     * @type {string}
     * @memberof PolicyDto
     */
    'description'?: string;
    /**
     * Indicates whether this is the default price policy.
     * @type {boolean}
     * @memberof PolicyDto
     */
    'default': boolean;
    /**
     * The date when the policy was created.
     * @type {string}
     * @memberof PolicyDto
     */
    'createdAt'?: string;
    /**
     * The date when the policy was last updated.
     * @type {string}
     * @memberof PolicyDto
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface PremiumPriceCategoryDataDto
 */
export interface PremiumPriceCategoryDataDto {
    /**
     * Some domains are specified by the registry as having a premium price category and as such are more expensive to register, renew and transfer. This is only required for domains that the registry specify have a premium price category associated with
     * @type {string}
     * @memberof PremiumPriceCategoryDataDto
     */
    'priceCategory': PremiumPriceCategoryDataDtoPriceCategoryEnum;
}

export const PremiumPriceCategoryDataDtoPriceCategoryEnum = {
    _2: 'pricecategory 2',
    _3: 'pricecategory 3',
    _4: 'pricecategory 4',
    _5: 'pricecategory 5',
    _6: 'pricecategory 6',
    _7: 'pricecategory 7',
    _8: 'pricecategory 8',
    _9: 'pricecategory 9',
    _10: 'pricecategory 10',
    _11: 'pricecategory 11',
    _12: 'pricecategory 12',
    _13: 'pricecategory 13',
    _14: 'pricecategory 14',
    _15: 'pricecategory 15',
    _16: 'pricecategory 16'
} as const;

export type PremiumPriceCategoryDataDtoPriceCategoryEnum = typeof PremiumPriceCategoryDataDtoPriceCategoryEnum[keyof typeof PremiumPriceCategoryDataDtoPriceCategoryEnum];

/**
 * 
 * @export
 * @interface PriceDto
 */
export interface PriceDto {
    /**
     * Price acoording to duration.
     * @type {string}
     * @memberof PriceDto
     */
    'duration': PriceDtoDurationEnum;
    /**
     * The created price number.
     * @type {number}
     * @memberof PriceDto
     */
    'createPrice': number;
    /**
     * Indicates the price number for renew.
     * @type {number}
     * @memberof PriceDto
     */
    'renewPrice'?: number;
    /**
     * Indicates the price number for one time payment.
     * @type {number}
     * @memberof PriceDto
     */
    'setupPrice'?: number;
    /**
     * Creates the price number for an offer.
     * @type {number}
     * @memberof PriceDto
     */
    'offerCreatePrice'?: number;
    /**
     * Creates the price number for a renew offer.
     * @type {number}
     * @memberof PriceDto
     */
    'offerRenewPrice'?: number;
    /**
     * Creates the price number for a setup offer.
     * @type {number}
     * @memberof PriceDto
     */
    'offerSetupPrice'?: number;
    /**
     * Text that describes the offer and the languege the text is writen on.
     * @type {Array<MultilangTextDto>}
     * @memberof PriceDto
     */
    'offerText'?: Array<MultilangTextDto>;
    /**
     * An object that describes a free tld.
     * @type {Array<FreeTldDto>}
     * @memberof PriceDto
     */
    'freeTld'?: Array<FreeTldDto>;
}

export const PriceDtoDurationEnum = {
    _1: '1',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5',
    _6: '6',
    _7: '7',
    _8: '8',
    _9: '9',
    _10: '10',
    _11: '11',
    _12: '12',
    _24: '24',
    _36: '36',
    _48: '48',
    _60: '60',
    _72: '72',
    _84: '84',
    _96: '96',
    _108: '108',
    _120: '120'
} as const;

export type PriceDtoDurationEnum = typeof PriceDtoDurationEnum[keyof typeof PriceDtoDurationEnum];

/**
 * 
 * @export
 * @interface PricePolicyDto
 */
export interface PricePolicyDto {
    /**
     * The unique identifier of the user.
     * @type {string}
     * @memberof PricePolicyDto
     */
    'userId'?: string;
    /**
     * The policy associated with this price policy.
     * @type {PolicyDto}
     * @memberof PricePolicyDto
     */
    'policy': PolicyDto;
    /**
     * An array of calculated prices.
     * @type {Array<CalculatedPriceDto>}
     * @memberof PricePolicyDto
     */
    'calculatedPrices'?: Array<CalculatedPriceDto>;
    /**
     * An array of price objects.
     * @type {Array<PriceDto>}
     * @memberof PricePolicyDto
     */
    'prices'?: Array<PriceDto>;
    /**
     * An array of dynamic price objects.
     * @type {Array<DynamicPriceDto>}
     * @memberof PricePolicyDto
     */
    'dynamicPrices'?: Array<DynamicPriceDto>;
}
/**
 * 
 * @export
 * @interface PricesDto
 */
export interface PricesDto {
    /**
     * The value of the price.
     * @type {number}
     * @memberof PricesDto
     */
    'value': number;
    /**
     * The value-added tax (VAT) applied to the price.
     * @type {number}
     * @memberof PricesDto
     */
    'vat': number;
    /**
     * The fee associated with the price.
     * @type {number}
     * @memberof PricesDto
     */
    'fee': number;
}
/**
 * 
 * @export
 * @interface ProAdditionalDataDto
 */
export interface ProAdditionalDataDto {
    /**
     * The profession or occupation of the domain holder.
     * @type {string}
     * @memberof ProAdditionalDataDto
     */
    'profession'?: string;
    /**
     * The name of the government certification body or jurisdictional licensing entity recognized by a governmental body.
     * @type {string}
     * @memberof ProAdditionalDataDto
     */
    'authority'?: string;
    /**
     * The website URL of the government certification body or jurisdictional licensing entity.
     * @type {string}
     * @memberof ProAdditionalDataDto
     */
    'authorityWebsite'?: string;
    /**
     * The licence number of the domain holder, if applicable.
     * @type {string}
     * @memberof ProAdditionalDataDto
     */
    'licenceNumber'?: string;
}
/**
 * 
 * @export
 * @interface ProductAffiliateDto
 */
export interface ProductAffiliateDto {
    /**
     * An array of selected durations for the product affiliate.
     * @type {Array<string>}
     * @memberof ProductAffiliateDto
     */
    'durations': Array<ProductAffiliateDtoDurationsEnum>;
    /**
     * The numeric value for the product affiliate.
     * @type {number}
     * @memberof ProductAffiliateDto
     */
    'percentOrAmount': number;
    /**
     * The type of the product affiliate.
     * @type {string}
     * @memberof ProductAffiliateDto
     */
    'type': ProductAffiliateDtoTypeEnum;
    /**
     * The type of action to be performed.
     * @type {string}
     * @memberof ProductAffiliateDto
     */
    'action': ProductAffiliateDtoActionEnum;
    /**
     * The number of days after which commission should be released to the affiliate.
     * @type {number}
     * @memberof ProductAffiliateDto
     */
    'releaseCommisionAfterDays': number;
}

export const ProductAffiliateDtoDurationsEnum = {
    _1: '1',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5',
    _6: '6',
    _7: '7',
    _8: '8',
    _9: '9',
    _10: '10',
    _11: '11',
    _12: '12',
    _24: '24',
    _36: '36',
    _48: '48',
    _60: '60',
    _72: '72',
    _84: '84',
    _96: '96',
    _108: '108',
    _120: '120'
} as const;

export type ProductAffiliateDtoDurationsEnum = typeof ProductAffiliateDtoDurationsEnum[keyof typeof ProductAffiliateDtoDurationsEnum];
export const ProductAffiliateDtoTypeEnum = {
    Fixed: 'fixed',
    Percentage: 'percentage'
} as const;

export type ProductAffiliateDtoTypeEnum = typeof ProductAffiliateDtoTypeEnum[keyof typeof ProductAffiliateDtoTypeEnum];
export const ProductAffiliateDtoActionEnum = {
    ItemCreate: 'item/create',
    ItemSuspend: 'item/suspend',
    ItemUnsuspend: 'item/unsuspend',
    ItemRenew: 'item/renew',
    ItemCancel: 'item/cancel',
    ItemDelete: 'item/delete',
    ItemUpgrade: 'item/upgrade',
    ItemUpdate: 'item/update',
    ItemDowngrade: 'item/downgrade',
    DomainCreate: 'domain/create',
    DomainLock: 'domain/lock',
    DomainUnlock: 'domain/unlock',
    DomainRenew: 'domain/renew',
    DomainBundleAdd: 'domain/bundle/add',
    DomainBundleRemove: 'domain/bundle/remove',
    DomainInfo: 'domain/info',
    DomainRecall: 'domain/recall',
    DomainTransferCheck: 'domain/transfer/check',
    DomainTransferCancel: 'domain/transfer/cancel',
    DomainTransferAccept: 'domain/transfer/accept',
    DomainSendAuthCode: 'domain/send-auth-code',
    DomainCheckAvailability: 'domain/check-availability',
    DomainShieldActivate: 'domain/shield/activate',
    DomainShieldDeactivate: 'domain/shield/deactivate',
    DomainDelete: 'domain/delete',
    DomainContactsInfo: 'domain/contacts/info',
    DomainContactsCreate: 'domain/contacts/create',
    DomainContactsUpdate: 'domain/contacts/update',
    DomainContactsDelete: 'domain/contacts/delete',
    DomainContactsRegistrant: 'domain/contacts/registrant',
    DomainContactsAdmin: 'domain/contacts/admin',
    DomainContactsTech: 'domain/contacts/tech',
    DomainContactsBilling: 'domain/contacts/billing',
    DomainResendVerificationEmail: 'domain/resend-verification-email',
    DomainCheckClaims: 'domain/check-claims',
    DomainModifyHosts: 'domain/modify-hosts',
    DomainModifyAuthcode: 'domain/modify-authcode',
    DomainGetTransferStatus: 'domain/get-transfer-status',
    DomainCancelTransfer: 'domain/cancel-transfer',
    DomainRequestTransferAway: 'domain/request-transfer-away',
    DomainRequestTransfer: 'domain/request-transfer',
    DomainCompleteTransferAway: 'domain/complete-transfer-away',
    DomainRejectTransferAway: 'domain/reject-transfer-away',
    DomainRejectTransferExpired: 'domain/reject-transfer-expired'
} as const;

export type ProductAffiliateDtoActionEnum = typeof ProductAffiliateDtoActionEnum[keyof typeof ProductAffiliateDtoActionEnum];

/**
 * Details of the product category
 * @export
 * @interface ProductCategoryDetails
 */
export interface ProductCategoryDetails {
    /**
     *  Unique identifier of the category associated with the product
     * @type {string}
     * @memberof ProductCategoryDetails
     */
    'productCategoryId'?: string;
    /**
     * 
     * @type {ProductCategoryTitle}
     * @memberof ProductCategoryDetails
     */
    'productCategoryTitle'?: ProductCategoryTitle;
}
/**
 * 
 * @export
 * @interface ProductCategoryDetailsDto
 */
export interface ProductCategoryDetailsDto {
    /**
     *  Unique identifier of the category associated with the product
     * @type {string}
     * @memberof ProductCategoryDetailsDto
     */
    'productCategoryId'?: string;
    /**
     * 
     * @type {ProductCategoryTitle}
     * @memberof ProductCategoryDetailsDto
     */
    'productCategoryTitle'?: ProductCategoryTitle;
}
/**
 * 
 * @export
 * @interface ProductCategoryDto
 */
export interface ProductCategoryDto {
    /**
     * The unique identifier for the product category.
     * @type {string}
     * @memberof ProductCategoryDto
     */
    'id'?: string;
    /**
     * Multilingual product category names.
     * @type {Array<MultilangTextDto>}
     * @memberof ProductCategoryDto
     */
    'name': Array<MultilangTextDto>;
    /**
     * Multilingual product category descriptions.
     * @type {Array<MultilangTextDto>}
     * @memberof ProductCategoryDto
     */
    'description'?: Array<MultilangTextDto>;
    /**
     * The URL of the product category icon.
     * @type {string}
     * @memberof ProductCategoryDto
     */
    'icon_url'?: string;
}
/**
 * Multilingual title of the product category
 * @export
 * @interface ProductCategoryTitle
 */
export interface ProductCategoryTitle {
    /**
     * 
     * @type {string}
     * @memberof ProductCategoryTitle
     */
    'language': ProductCategoryTitleLanguageEnum;
    /**
     * 
     * @type {string}
     * @memberof ProductCategoryTitle
     */
    'text': string;
}

export const ProductCategoryTitleLanguageEnum = {
    Aa: 'aa',
    Af: 'af',
    Ak: 'ak',
    Sq: 'sq',
    Am: 'am',
    Ar: 'ar',
    An: 'an',
    Hy: 'hy',
    As: 'as',
    Av: 'av',
    Ae: 'ae',
    Ay: 'ay',
    Az: 'az',
    Bm: 'bm',
    Ba: 'ba',
    Eu: 'eu',
    Be: 'be',
    Bn: 'bn',
    Bh: 'bh',
    Bi: 'bi',
    Bs: 'bs',
    Br: 'br',
    Bg: 'bg',
    My: 'my',
    Ca: 'ca',
    Ch: 'ch',
    Ce: 'ce',
    Ny: 'ny',
    Zh: 'zh',
    Cv: 'cv',
    Kw: 'kw',
    Co: 'co',
    Cr: 'cr',
    Hr: 'hr',
    Cs: 'cs',
    Da: 'da',
    Dv: 'dv',
    Nl: 'nl',
    Dz: 'dz',
    En: 'en',
    Eo: 'eo',
    Et: 'et',
    Ee: 'ee',
    Fo: 'fo',
    Fj: 'fj',
    Fi: 'fi',
    Fr: 'fr',
    Ff: 'ff',
    Gl: 'gl',
    Ka: 'ka',
    De: 'de',
    El: 'el',
    Gn: 'gn',
    Gu: 'gu',
    Ht: 'ht',
    Ha: 'ha',
    He: 'he',
    Hz: 'hz',
    Hi: 'hi',
    Ho: 'ho',
    Hu: 'hu',
    Ia: 'ia',
    Id: 'id',
    Ie: 'ie',
    Ga: 'ga',
    Ig: 'ig',
    Ik: 'ik',
    Io: 'io',
    Is: 'is',
    It: 'it',
    Iu: 'iu',
    Ja: 'ja',
    Jv: 'jv',
    Kl: 'kl',
    Kn: 'kn',
    Kr: 'kr',
    Ks: 'ks',
    Kk: 'kk',
    Km: 'km',
    Ki: 'ki',
    Rw: 'rw',
    Ky: 'ky',
    Kv: 'kv',
    Kg: 'kg',
    Ko: 'ko',
    Ku: 'ku',
    Kj: 'kj',
    La: 'la',
    Lb: 'lb',
    Lg: 'lg',
    Li: 'li',
    Ln: 'ln',
    Lo: 'lo',
    Lt: 'lt',
    Lu: 'lu',
    Lv: 'lv',
    Gv: 'gv',
    Mk: 'mk',
    Mg: 'mg',
    Ms: 'ms',
    Ml: 'ml',
    Mt: 'mt',
    Mi: 'mi',
    Mr: 'mr',
    Mh: 'mh',
    Mn: 'mn',
    Na: 'na',
    Nv: 'nv',
    Nd: 'nd',
    Ne: 'ne',
    Ng: 'ng',
    Nb: 'nb',
    Nn: 'nn',
    No: 'no',
    Ii: 'ii',
    Nr: 'nr',
    Oc: 'oc',
    Oj: 'oj',
    Cu: 'cu',
    Om: 'om',
    Or: 'or',
    Os: 'os',
    Pa: 'pa',
    Pi: 'pi',
    Fa: 'fa',
    Pl: 'pl',
    Ps: 'ps',
    Pt: 'pt',
    Qu: 'qu',
    Rm: 'rm',
    Rn: 'rn',
    Ro: 'ro',
    Rh: 'rh',
    Ru: 'ru',
    Sa: 'sa',
    Sc: 'sc',
    Sd: 'sd',
    Se: 'se',
    Sm: 'sm',
    Sg: 'sg',
    Sr: 'sr',
    Gd: 'gd',
    Sn: 'sn',
    Si: 'si',
    Sk: 'sk',
    Sl: 'sl',
    So: 'so',
    St: 'st',
    Es: 'es',
    Su: 'su',
    Sw: 'sw',
    Ss: 'ss',
    Sv: 'sv',
    Ta: 'ta',
    Te: 'te',
    Tg: 'tg',
    Th: 'th',
    Ti: 'ti',
    Bo: 'bo',
    Tk: 'tk',
    Tl: 'tl',
    Tn: 'tn',
    To: 'to',
    Tr: 'tr',
    Ts: 'ts',
    Tt: 'tt',
    Tw: 'tw',
    Ty: 'ty',
    Ug: 'ug',
    Uk: 'uk',
    Ur: 'ur',
    Uz: 'uz',
    Ve: 've',
    Vi: 'vi',
    Vo: 'vo',
    Wa: 'wa',
    Cy: 'cy',
    Wo: 'wo',
    Fy: 'fy',
    Xh: 'xh',
    Yi: 'yi',
    Yo: 'yo',
    Za: 'za',
    Zu: 'zu'
} as const;

export type ProductCategoryTitleLanguageEnum = typeof ProductCategoryTitleLanguageEnum[keyof typeof ProductCategoryTitleLanguageEnum];

/**
 * Details of the product associated with the item
 * @export
 * @interface ProductDetails
 */
export interface ProductDetails {
    /**
     * Unique identifier for the product
     * @type {string}
     * @memberof ProductDetails
     */
    'productId': string;
    /**
     * Multilingual title of the product
     * @type {object}
     * @memberof ProductDetails
     */
    'title'?: object;
    /**
     * 
     * @type {Integration}
     * @memberof ProductDetails
     */
    'integration'?: Integration;
    /**
     * Version of the product
     * @type {number}
     * @memberof ProductDetails
     */
    'version'?: number;
}
/**
 * 
 * @export
 * @interface ProductDetailsDto
 */
export interface ProductDetailsDto {
    /**
     * Unique identifier for the product
     * @type {string}
     * @memberof ProductDetailsDto
     */
    'productId': string;
    /**
     * Multilingual title of the product
     * @type {object}
     * @memberof ProductDetailsDto
     */
    'title'?: object;
    /**
     * 
     * @type {Integration}
     * @memberof ProductDetailsDto
     */
    'integration'?: Integration;
    /**
     * Version of the product
     * @type {number}
     * @memberof ProductDetailsDto
     */
    'version'?: number;
}
/**
 * 
 * @export
 * @interface ProductDto
 */
export interface ProductDto {
    /**
     * A unique identifier for the product
     * @type {string}
     * @memberof ProductDto
     */
    'id'?: string;
    /**
     * The name of the product.
     * @type {string}
     * @memberof ProductDto
     */
    'name': string;
    /**
     * The unique identifier of the company that owns the product.
     * @type {string}
     * @memberof ProductDto
     */
    'companyId'?: string;
    /**
     * A boolean that indicates if a a version of the product is active.
     * @type {boolean}
     * @memberof ProductDto
     */
    'activeVersion'?: boolean;
    /**
     * A number that indicates the version of the product.
     * @type {number}
     * @memberof ProductDto
     */
    'version'?: number;
    /**
     * An array that holds all the versions of a product available.
     * @type {number}
     * @memberof ProductDto
     */
    'versionsIds'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    'integrationId': string;
    /**
     * The product\'s category unique identifier.
     * @type {string}
     * @memberof ProductDto
     */
    'categoryId'?: string;
    /**
     * Indicates if a product is enabled.
     * @type {boolean}
     * @memberof ProductDto
     */
    'enabled'?: boolean;
    /**
     * Indicates if auto renew option is active for this product .
     * @type {boolean}
     * @memberof ProductDto
     */
    'autoRenew'?: boolean;
    /**
     * An array of unique identifiers that represent all possible upgrades that can be applied.
     * @type {Array<string>}
     * @memberof ProductDto
     */
    'upgradeProductIds'?: Array<string>;
    /**
     * An array of unique identifiers that represent all possible downgrades that can be applied.
     * @type {Array<string>}
     * @memberof ProductDto
     */
    'downgradeProductIds'?: Array<string>;
    /**
     * An array that holds the title and the written language of the product title.
     * @type {Array<MultilangTextDto>}
     * @memberof ProductDto
     */
    'title': Array<MultilangTextDto>;
    /**
     * An array that holds the description and the written language of the product description.
     * @type {Array<MultilangTextDto>}
     * @memberof ProductDto
     */
    'description'?: Array<MultilangTextDto>;
    /**
     * Indicates if a product id a domain type product.
     * @type {boolean}
     * @memberof ProductDto
     */
    'isDomain'?: boolean;
    /**
     * Indicates if the product requires a domain name.
     * @type {boolean}
     * @memberof ProductDto
     */
    'requireDomain'?: boolean;
    /**
     * The number of days before the registry\'s expiration date, that a domain can be renewed
     * @type {number}
     * @memberof ProductDto
     */
    'expirationDateOffset'?: number;
    /**
     * A number that indicates the number of days a trial on a product lasts. 0 indicates that there is no trial in this product.
     * @type {number}
     * @memberof ProductDto
     */
    'trialDays'?: number;
    /**
     * A number that indicates in how many days the product will be suspended.
     * @type {number}
     * @memberof ProductDto
     */
    'suspendedAfterDays'?: number;
    /**
     * A number that indicates days until user sees the product as deleted.
     * @type {number}
     * @memberof ProductDto
     */
    'softDeleteDays'?: number;
    /**
     * A number that indicates days until the product is actually deleted.
     * @type {number}
     * @memberof ProductDto
     */
    'hardDeleteDays'?: number;
    /**
     * Restore penalty price
     * @type {number}
     * @memberof ProductDto
     */
    'restorePrice'?: number;
    /**
     * An array that holds the templates used for this product.
     * @type {Array<ProductTemplateDto>}
     * @memberof ProductDto
     */
    'templates'?: Array<ProductTemplateDto>;
    /**
     * Default price policies
     * @type {Array<PricePolicyDto>}
     * @memberof ProductDto
     */
    'defaultPrices': Array<PricePolicyDto>;
    /**
     * Premium price policies
     * @type {Array<PricePolicyDto>}
     * @memberof ProductDto
     */
    'premiumPrices'?: Array<PricePolicyDto>;
    /**
     * An object that contains all the specific prices for a domain name.
     * @type {DomainPricesDto}
     * @memberof ProductDto
     */
    'domainPrices'?: DomainPricesDto;
    /**
     * Indicates the type of the invoice.
     * @type {string}
     * @memberof ProductDto
     */
    'invoiceType'?: ProductDtoInvoiceTypeEnum;
    /**
     * A unique identifier of the tld selected.
     * @type {string}
     * @memberof ProductDto
     */
    'tldId'?: string;
    /**
     * Sets the settings for an ip.
     * @type {IpSettingsDto}
     * @memberof ProductDto
     */
    'ipSettings'?: IpSettingsDto;
    /**
     * This number indicates the number available left for sale.
     * @type {number}
     * @memberof ProductDto
     */
    'stock'?: number;
    /**
     * An array that holds the unique identifier of the addons.
     * @type {Array<string>}
     * @memberof ProductDto
     */
    'addonIds'?: Array<string>;
    /**
     * 
     * @type {Array<object>}
     * @memberof ProductDto
     */
    'options'?: Array<object>;
    /**
     * Informations about an affiliate product.
     * @type {ProductAffiliateDto}
     * @memberof ProductDto
     */
    'affiliate'?: ProductAffiliateDto;
    /**
     * An array that contains informations about the product.
     * @type {Array<ProductInformationDto>}
     * @memberof ProductDto
     */
    'information'?: Array<ProductInformationDto>;
    /**
     * An array that holds keywords for product indentification.
     * @type {Array<string>}
     * @memberof ProductDto
     */
    'tags'?: Array<string>;
    /**
     * The client has the option to activate a service that has been deactivated. Here, we determine the duration for which it will remain open
     * @type {number}
     * @memberof ProductDto
     */
    'postponeDays'?: number;
    /**
     * A number that indicates how many times the user can postpone within the last 365 days.
     * @type {number}
     * @memberof ProductDto
     */
    'postponeTimesPerYear'?: number;
    /**
     * Indicates if you can delete this product
     * @type {boolean}
     * @memberof ProductDto
     */
    'deletable'?: boolean;
    /**
     * The date a product created.
     * @type {string}
     * @memberof ProductDto
     */
    'createdAt'?: string;
    /**
     * The date a product updated.
     * @type {string}
     * @memberof ProductDto
     */
    'updatedAt'?: string;
}

export const ProductDtoInvoiceTypeEnum = {
    Snapshot: 'SNAPSHOT',
    Prorata: 'PRORATA',
    Perhour: 'PERHOUR',
    Permonth: 'PERMONTH'
} as const;

export type ProductDtoInvoiceTypeEnum = typeof ProductDtoInvoiceTypeEnum[keyof typeof ProductDtoInvoiceTypeEnum];

/**
 * 
 * @export
 * @interface ProductInformationDto
 */
export interface ProductInformationDto {
    /**
     * An array with the title of the product in any language supports.
     * @type {string}
     * @memberof ProductInformationDto
     */
    'title': string;
    /**
     * An array with a brief description of the product, highlighting its key features and benefits in any language supports..
     * @type {string}
     * @memberof ProductInformationDto
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface ProductTemplateDto
 */
export interface ProductTemplateDto {
    /**
     * The action associated with the template.
     * @type {string}
     * @memberof ProductTemplateDto
     */
    'action': ProductTemplateDtoActionEnum;
    /**
     * The unique identifier for the template.
     * @type {string}
     * @memberof ProductTemplateDto
     */
    'templateId': string;
}

export const ProductTemplateDtoActionEnum = {
    ItemCreate: 'item/create',
    ItemSuspend: 'item/suspend',
    ItemUnsuspend: 'item/unsuspend',
    ItemRenew: 'item/renew',
    ItemCancel: 'item/cancel',
    ItemDelete: 'item/delete',
    ItemUpgrade: 'item/upgrade',
    ItemUpdate: 'item/update',
    ItemDowngrade: 'item/downgrade',
    DomainCreate: 'domain/create',
    DomainLock: 'domain/lock',
    DomainUnlock: 'domain/unlock',
    DomainRenew: 'domain/renew',
    DomainBundleAdd: 'domain/bundle/add',
    DomainBundleRemove: 'domain/bundle/remove',
    DomainInfo: 'domain/info',
    DomainRecall: 'domain/recall',
    DomainTransferCheck: 'domain/transfer/check',
    DomainTransferCancel: 'domain/transfer/cancel',
    DomainTransferAccept: 'domain/transfer/accept',
    DomainSendAuthCode: 'domain/send-auth-code',
    DomainCheckAvailability: 'domain/check-availability',
    DomainShieldActivate: 'domain/shield/activate',
    DomainShieldDeactivate: 'domain/shield/deactivate',
    DomainDelete: 'domain/delete',
    DomainContactsInfo: 'domain/contacts/info',
    DomainContactsCreate: 'domain/contacts/create',
    DomainContactsUpdate: 'domain/contacts/update',
    DomainContactsDelete: 'domain/contacts/delete',
    DomainContactsRegistrant: 'domain/contacts/registrant',
    DomainContactsAdmin: 'domain/contacts/admin',
    DomainContactsTech: 'domain/contacts/tech',
    DomainContactsBilling: 'domain/contacts/billing',
    DomainResendVerificationEmail: 'domain/resend-verification-email',
    DomainCheckClaims: 'domain/check-claims',
    DomainModifyHosts: 'domain/modify-hosts',
    DomainModifyAuthcode: 'domain/modify-authcode',
    DomainGetTransferStatus: 'domain/get-transfer-status',
    DomainCancelTransfer: 'domain/cancel-transfer',
    DomainRequestTransferAway: 'domain/request-transfer-away',
    DomainRequestTransfer: 'domain/request-transfer',
    DomainCompleteTransferAway: 'domain/complete-transfer-away',
    DomainRejectTransferAway: 'domain/reject-transfer-away',
    DomainRejectTransferExpired: 'domain/reject-transfer-expired'
} as const;

export type ProductTemplateDtoActionEnum = typeof ProductTemplateDtoActionEnum[keyof typeof ProductTemplateDtoActionEnum];

/**
 * 
 * @export
 * @interface ProxyServiceDataDto
 */
export interface ProxyServiceDataDto {
    /**
     * Indicates whether the domain should be registered through a proxy owner.
     * @type {boolean}
     * @memberof ProxyServiceDataDto
     */
    'useProxyService': boolean;
}
/**
 * 
 * @export
 * @interface PushPayloadDto
 */
export interface PushPayloadDto {
    /**
     * The title of the push message
     * @type {string}
     * @memberof PushPayloadDto
     */
    'title': string;
    /**
     * The subtitle of the push message
     * @type {string}
     * @memberof PushPayloadDto
     */
    'subtitle'?: string;
    /**
     * The content of the push message
     * @type {string}
     * @memberof PushPayloadDto
     */
    'body': string;
}
/**
 * 
 * @export
 * @interface RegistryContactsDto
 */
export interface RegistryContactsDto {
    /**
     * Code provided by the registry for the registrant. Takes the value of ContactCode from domain Contact associated with the domain
     * @type {string}
     * @memberof RegistryContactsDto
     */
    'registrantCode'?: string;
    /**
     * Admin code provided by hoster.ai
     * @type {string}
     * @memberof RegistryContactsDto
     */
    'adminCode'?: string;
    /**
     * Tech code provided by hoster.ai
     * @type {string}
     * @memberof RegistryContactsDto
     */
    'techCode'?: string;
    /**
     * Billing code provided by hoster.ai
     * @type {string}
     * @memberof RegistryContactsDto
     */
    'billingCode'?: string;
}
/**
 * 
 * @export
 * @interface SmsPayloadDto
 */
export interface SmsPayloadDto {
    /**
     * The SMS message content
     * @type {string}
     * @memberof SmsPayloadDto
     */
    'body': string;
}
/**
 * 
 * @export
 * @interface SunriseDataDto
 */
export interface SunriseDataDto {
    /**
     * A Signed Mark Data (SMD) file is a token demonstrating that minimum eligibility requirements for Sunrise have been verified by the Clearinghouse. The SMD can be used by the Trademark holder to apply for a Domain Name during the sunrise period.
     * @type {string}
     * @memberof SunriseDataDto
     */
    'smdFile': string;
}
/**
 * 
 * @export
 * @interface TabDto
 */
export interface TabDto {
    /**
     * A label for the certain tab.
     * @type {string}
     * @memberof TabDto
     */
    'label'?: string;
    /**
     * The url associated with the tab.
     * @type {string}
     * @memberof TabDto
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface TaskDto
 */
export interface TaskDto {
    /**
     * The unique identifier of the task.
     * @type {string}
     * @memberof TaskDto
     */
    'id'?: string;
    /**
     * A description of the task.
     * @type {string}
     * @memberof TaskDto
     */
    'description': string;
    /**
     * The unique identifier of the integration the task created from.
     * @type {string}
     * @memberof TaskDto
     */
    'createdFromIntegrationId'?: string;
    /**
     * The action a task contains.
     * @type {string}
     * @memberof TaskDto
     */
    'action'?: TaskDtoActionEnum;
    /**
     * The status of the task.
     * @type {string}
     * @memberof TaskDto
     */
    'status'?: TaskDtoStatusEnum;
    /**
     * The type of event related to a service integration\'s operations.
     * @type {string}
     * @memberof TaskDto
     */
    'integrationHandler'?: TaskDtoIntegrationHandlerEnum;
    /**
     * Date task started.
     * @type {string}
     * @memberof TaskDto
     */
    'startedDate'?: string;
    /**
     * Date the task completed
     * @type {string}
     * @memberof TaskDto
     */
    'completedDate'?: string;
    /**
     * The completion percentage of the task action, represented as a number between 0 and 100.
     * @type {number}
     * @memberof TaskDto
     */
    'completePercentage'?: number;
    /**
     * Any payload returned with the task complition.
     * @type {object}
     * @memberof TaskDto
     */
    'payload'?: object;
}

export const TaskDtoActionEnum = {
    ItemCreate: 'item/create',
    ItemSuspend: 'item/suspend',
    ItemUnsuspend: 'item/unsuspend',
    ItemRenew: 'item/renew',
    ItemCancel: 'item/cancel',
    ItemDelete: 'item/delete',
    ItemUpgrade: 'item/upgrade',
    ItemUpdate: 'item/update',
    ItemDowngrade: 'item/downgrade',
    DomainCreate: 'domain/create',
    DomainLock: 'domain/lock',
    DomainUnlock: 'domain/unlock',
    DomainRenew: 'domain/renew',
    DomainBundleAdd: 'domain/bundle/add',
    DomainBundleRemove: 'domain/bundle/remove',
    DomainInfo: 'domain/info',
    DomainRecall: 'domain/recall',
    DomainTransferCheck: 'domain/transfer/check',
    DomainTransferCancel: 'domain/transfer/cancel',
    DomainTransferAccept: 'domain/transfer/accept',
    DomainSendAuthCode: 'domain/send-auth-code',
    DomainCheckAvailability: 'domain/check-availability',
    DomainShieldActivate: 'domain/shield/activate',
    DomainShieldDeactivate: 'domain/shield/deactivate',
    DomainDelete: 'domain/delete',
    DomainContactsInfo: 'domain/contacts/info',
    DomainContactsCreate: 'domain/contacts/create',
    DomainContactsUpdate: 'domain/contacts/update',
    DomainContactsDelete: 'domain/contacts/delete',
    DomainContactsRegistrant: 'domain/contacts/registrant',
    DomainContactsAdmin: 'domain/contacts/admin',
    DomainContactsTech: 'domain/contacts/tech',
    DomainContactsBilling: 'domain/contacts/billing',
    DomainResendVerificationEmail: 'domain/resend-verification-email',
    DomainCheckClaims: 'domain/check-claims',
    DomainModifyHosts: 'domain/modify-hosts',
    DomainModifyAuthcode: 'domain/modify-authcode',
    DomainGetTransferStatus: 'domain/get-transfer-status',
    DomainCancelTransfer: 'domain/cancel-transfer',
    DomainRequestTransferAway: 'domain/request-transfer-away',
    DomainRequestTransfer: 'domain/request-transfer',
    DomainCompleteTransferAway: 'domain/complete-transfer-away',
    DomainRejectTransferAway: 'domain/reject-transfer-away',
    DomainRejectTransferExpired: 'domain/reject-transfer-expired'
} as const;

export type TaskDtoActionEnum = typeof TaskDtoActionEnum[keyof typeof TaskDtoActionEnum];
export const TaskDtoStatusEnum = {
    Pending: 'PENDING',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED',
    Canceled: 'CANCELED'
} as const;

export type TaskDtoStatusEnum = typeof TaskDtoStatusEnum[keyof typeof TaskDtoStatusEnum];
export const TaskDtoIntegrationHandlerEnum = {
    InvoiceSuccess: 'INVOICE.SUCCESS',
    ItemCreate: 'ITEM.CREATE',
    ItemUpgrade: 'ITEM.UPGRADE',
    ItemDowngrade: 'ITEM.DOWNGRADE',
    ItemRenew: 'ITEM.RENEW',
    ItemSuspend: 'ITEM.SUSPEND',
    ItemUnsuspend: 'ITEM.UNSUSPEND',
    ItemInstall: 'ITEM.INSTALL',
    ItemUninstall: 'ITEM.UNINSTALL',
    ProductCreate: 'PRODUCT.CREATE',
    ProductUpdate: 'PRODUCT.UPDATE',
    ProductDelete: 'PRODUCT.DELETE',
    ProductSuspend: 'PRODUCT.SUSPEND',
    ProductUnsuspend: 'PRODUCT.UNSUSPEND',
    ProductRenew: 'PRODUCT.RENEW',
    ProductUpgrade: 'PRODUCT.UPGRADE',
    ProductDowngrade: 'PRODUCT.DOWNGRADE'
} as const;

export type TaskDtoIntegrationHandlerEnum = typeof TaskDtoIntegrationHandlerEnum[keyof typeof TaskDtoIntegrationHandlerEnum];

/**
 * @type TemplateData
 * An array tha cantains necessary data for the templates.
 * @export
 */
export type TemplateData = EmailPayloadDto | PushPayloadDto | SmsPayloadDto;

/**
 * 
 * @export
 * @interface TemplateDto
 */
export interface TemplateDto {
    /**
     * The unique identifier of the template.
     * @type {string}
     * @memberof TemplateDto
     */
    'id'?: string;
    /**
     * The unique identifier of the company.
     * @type {string}
     * @memberof TemplateDto
     */
    'companyId'?: string;
    /**
     * The title of the template.
     * @type {string}
     * @memberof TemplateDto
     */
    'title'?: string;
    /**
     * The notification type of the template.
     * @type {string}
     * @memberof TemplateDto
     */
    'notificationType': TemplateDtoNotificationTypeEnum;
    /**
     * The integration id of the template
     * @type {string}
     * @memberof TemplateDto
     */
    'integrationId': string;
    /**
     * The product id the template is associated with
     * @type {string}
     * @memberof TemplateDto
     */
    'productId': string;
    /**
     * 
     * @type {TemplateData}
     * @memberof TemplateDto
     */
    'data': TemplateData;
    /**
     * The event associated with the template.
     * @type {string}
     * @memberof TemplateDto
     */
    'event'?: TemplateDtoEventEnum;
    /**
     * Indicates if the template is deletable or not.
     * @type {boolean}
     * @memberof TemplateDto
     */
    'deletable'?: boolean;
    /**
     * The date when the template was created.
     * @type {string}
     * @memberof TemplateDto
     */
    'createdAt'?: string;
    /**
     * The date when the template was updated.
     * @type {string}
     * @memberof TemplateDto
     */
    'updatedAt'?: string;
}

export const TemplateDtoNotificationTypeEnum = {
    Email: 'email',
    Chat: 'chat',
    Push: 'push',
    Sms: 'sms'
} as const;

export type TemplateDtoNotificationTypeEnum = typeof TemplateDtoNotificationTypeEnum[keyof typeof TemplateDtoNotificationTypeEnum];
export const TemplateDtoEventEnum = {
    UserCreated: 'user/created',
    UserUpdated: 'user/updated',
    UserDeleted: 'user/deleted',
    UserBanned: 'user/banned',
    UserUnbanned: 'user/unbanned',
    UserCompanyAccessAdded: 'user/company/access/added',
    UserCompanyAccessRemoved: 'user/company/access/removed',
    UserLocked: 'user/locked',
    UserCreditBalanceUpdated: 'user/credit-balance/updated',
    UserUnlocked: 'user/unlocked',
    UserPasswordUpdated: 'user/password/updated',
    UserEmailUpdated: 'user/email/updated',
    UserCurrencyUpdated: 'user/currency/updated',
    UserInvoiceContactUpdated: 'user/invoice-contact/updated',
    UserPolicyUpdated: 'user/policy/updated',
    UserLanguagesUpdated: 'user/languages/updated',
    UserCustomPricePoliciesUpdated: 'user/custom-price-policies/updated',
    UserCustomAddonPricePoliciesUpdated: 'user/custom-addon-price-policies/updated',
    UserCustomAffiliateAdded: 'user/custom-affiliate/added',
    UserCustomAffiliateRemoved: 'user/custom-affiliate/removed',
    UserInvoiceIntervalUpdated: 'user/invoice-interval/updated',
    UserAdditionalNotificationEmailRemoved: 'user/additional-notification-email/removed',
    UserAdditionalNotificationEmailAdded: 'user/additional-notification-email/added',
    UserCommentAdded: 'user/comment/added',
    UserCommentRemoved: 'user/comment/removed',
    UserCommentUpdated: 'user/comment/updated',
    UserTagsUpdated: 'user/tags/updated',
    UserSettingAdded: 'user/setting/added',
    UserSettingRemoved: 'user/setting/removed',
    UserSettingUpdated: 'user/setting/updated',
    UserStartSelling: 'user/start-selling',
    UserRolesUpdated: 'user/roles/updated',
    MessageCreated: 'message/created',
    MessageUpdated: 'message/updated',
    MessageDeleted: 'message/deleted',
    NotificationSent: 'notification/sent',
    PolicyCreated: 'policy/created',
    PolicyUpdated: 'policy/updated',
    PolicyDeleted: 'policy/deleted',
    ProductCategoryCreated: 'product-category/created',
    ProductCategoryUpdated: 'product-category/updated',
    ProductCategoryDeleted: 'product-category/deleted',
    InvoiceContactCreated: 'invoice-contact/created',
    InvoiceContactUpdated: 'invoice-contact/updated',
    InvoiceContactDeleted: 'invoice-contact/deleted',
    InvoiceCreated: 'invoice/created',
    InvoiceUpdated: 'invoice/updated',
    InvoiceDeleted: 'invoice/deleted',
    CurrencyCreated: 'currency/created',
    CurrencyUpdated: 'currency/updated',
    CurrencyDeleted: 'currency/deleted',
    AffiliateCreated: 'affiliate/created',
    AffiliateUpdated: 'affiliate/updated',
    AffiliateDeleted: 'affiliate/deleted',
    CompanyCreated: 'company/created',
    CompanyUpdated: 'company/updated',
    CompanyDeleted: 'company/deleted',
    OrganizationIntegrationAttached: 'organization/integration/attached',
    OrganizationIntegrationDetached: 'organization/integration/detached',
    TldCreated: 'tld/created',
    TldUpdated: 'tld/updated',
    TldDeleted: 'tld/deleted',
    IntegrationCreated: 'integration/created',
    IntegrationUpdated: 'integration/updated',
    IntegrationDeleted: 'integration/deleted',
    IntegrationInstalled: 'integration/installed',
    IntegrationUninstalled: 'integration/uninstalled',
    DomainContactCreated: 'domain-contact/created',
    DomainContactUpdated: 'domain-contact/updated',
    DomainContactDeleted: 'domain-contact/deleted',
    DomainCategoryCreated: 'domain-category/created',
    DomainCategoryUpdated: 'domain-category/updated',
    DomainCategoryDeleted: 'domain-category/deleted',
    AddonCreated: 'addon/created',
    AddonUpdated: 'addon/updated',
    AddonDeleted: 'addon/deleted',
    PaymentCreated: 'payment/created',
    PaymentCanceled: 'payment/canceled',
    PaymentFailed: 'payment/failed',
    PaymentSubscribed: 'payment/subscribed',
    PaymentUnsubscribed: 'payment/unsubscribed',
    PaymentUpdated: 'payment/updated',
    PaymentDeleted: 'payment/deleted',
    PaymentCompleted: 'payment/completed',
    TemplateCreated: 'template/created',
    TemplateUpdated: 'template/updated',
    TemplateDeleted: 'template/deleted',
    CouponCreated: 'coupon/created',
    CouponUpdated: 'coupon/updated',
    CouponDeleted: 'coupon/deleted',
    TemplateIntegrationCreated: 'template-integration/created',
    TemplateIntegrationUpdated: 'template-integration/updated',
    TemplateIntegrationDeleted: 'template-integration/deleted',
    OrderCreated: 'order/created',
    OrderStatusInProgress: 'order/status/in-progress',
    OrderStatusCompleted: 'order/status/completed',
    OrderStatusCanceled: 'order/status/canceled',
    OrderStatusRefunded: 'order/status/refunded',
    OrderInsufficientBalance: 'order/insufficient-balance',
    OrderUpdated: 'order/updated',
    OrderDeleted: 'order/deleted',
    SettingCreated: 'setting/created',
    SettingUpdated: 'setting/updated',
    SettingDeleted: 'setting/deleted',
    IssueCreated: 'issue/created',
    IssueUpdated: 'issue/updated',
    IssueDeleted: 'issue/deleted',
    TaskCreated: 'task/created',
    TaskUpdated: 'task/updated',
    TaskDeleted: 'task/deleted',
    TaskCanceled: 'task/canceled',
    TaskInProgress: 'task/in-progress',
    TaskCompleted: 'task/completed',
    TaskPercentageUpdated: 'task/percentage/updated',
    ProductCreated: 'product/created',
    ProductUpdated: 'product/updated',
    ProductDeleted: 'product/deleted',
    ProductAutoRenewUpdated: 'product/auto-renew/updated',
    ProductEnabled: 'product/enabled',
    ProductDisabled: 'product/disabled',
    ProductVersionCreated: 'product/version-created',
    IpGroupCreated: 'ip-group/created',
    IpGroupUpdated: 'ip-group/updated',
    IpGroupDeleted: 'ip-group/deleted',
    IpCreated: 'ip/created',
    IpUpdated: 'ip/updated',
    IpDeleted: 'ip/deleted',
    DomainNameCreated: 'domain-name/created',
    DomainNameUpdated: 'domain-name/updated',
    DomainNameDeleted: 'domain-name/deleted',
    DomainNameLocked: 'domain-name/locked',
    DomainNameUnlocked: 'domain-name/unlocked',
    DomainNameIdshieldActivated: 'domain-name/idshield-activated',
    DomainNameIdshieldDeactivated: 'domain-name/idshield-deactivated',
    DomainNameBundleAdded: 'domain-name/bundle-added',
    DomainNameBundleRemoved: 'domain-name/bundle-removed',
    DomainNameRegistrantUpdated: 'domain-name/registrant-updated',
    DomainNameAdminUpdated: 'domain-name/admin-updated',
    DomainNameTechUpdated: 'domain-name/tech-updated',
    DomainNameBillingUpdated: 'domain-name/billing-updated',
    DomainNameAdditionalUpdated: 'domain-name/additional-updated',
    ItemCreated: 'item/created',
    ItemUpdated: 'item/updated',
    ItemDeleted: 'item/deleted',
    ItemRenewed: 'item/renewed',
    ItemUpgraded: 'item/upgraded',
    ItemDowngraded: 'item/downgraded',
    ItemIpAttached: 'item/ip-attached',
    ItemIpDetached: 'item/ip-detached',
    ItemDetachedFromOrder: 'item/detached-from-order',
    ItemPostponed: 'item/postponed',
    ItemTransferredIn: 'item/transferred-in',
    ItemCanceled: 'item/canceled',
    ItemSuspended: 'item/suspended',
    ItemUnsuspended: 'item/unsuspended',
    ItemAffiliateAdded: 'item/affiliate/added',
    ItemBundleAttached: 'item/bundle/attached',
    ItemBundleDetached: 'item/bundle/detached',
    ItemActivated: 'item/activated',
    ItemSetInactive: 'item/set-inactive',
    ItemProcessed: 'item/processed',
    OrderPaid: 'order/paid',
    Test: 'test'
} as const;

export type TemplateDtoEventEnum = typeof TemplateDtoEventEnum[keyof typeof TemplateDtoEventEnum];

/**
 * 
 * @export
 * @interface TldDto
 */
export interface TldDto {
    /**
     * The unique identifier for the tld.
     * @type {string}
     * @memberof TldDto
     */
    'id'?: string;
    /**
     * A string that contains the acual tld.
     * @type {string}
     * @memberof TldDto
     */
    'tld': string;
    /**
     * Tld\'s title.
     * @type {string}
     * @memberof TldDto
     */
    'title': string;
    /**
     * The minimum lenght of character you can have.
     * @type {number}
     * @memberof TldDto
     */
    'minLength'?: number;
    /**
     * The maximum lenght of character you can have.
     * @type {number}
     * @memberof TldDto
     */
    'maxLength'?: number;
    /**
     * A regular expresion used for validation
     * @type {object}
     * @memberof TldDto
     */
    'regex'?: object;
    /**
     * The number of days a tld stays in soft quarantine status.
     * @type {number}
     * @memberof TldDto
     */
    'softQuarantineDays'?: number;
    /**
     * The number of days a tld stays in hard quarantine status.
     * @type {number}
     * @memberof TldDto
     */
    'hardQuarantineDays'?: number;
    /**
     * The number of days before the registry\'s expiration date, that the domain is required to be renewed
     * @type {number}
     * @memberof TldDto
     */
    'renewalDateOffset'?: number;
    /**
     * The number of days before the registry\'s expiration date, that a domain can be renewed
     * @type {number}
     * @memberof TldDto
     */
    'expirationDateOffset'?: number;
    /**
     * Indicates how many hours will the auth code be valid.
     * @type {number}
     * @memberof TldDto
     */
    'authorizationCodeValidityHours'?: number;
    /**
     * Indicates if it can be restored during pending delete or not.
     * @type {boolean}
     * @memberof TldDto
     */
    'restoreDuringPendingDelete'?: boolean;
    /**
     * Indicates if it can be deleted or not.
     * @type {boolean}
     * @memberof TldDto
     */
    'allowsDelete'?: boolean;
    /**
     * Indicates if recall is allowed or not.
     * @type {boolean}
     * @memberof TldDto
     */
    'allowsRecall'?: boolean;
    /**
     * Indicates if it supports DNSSEC or not.
     * @type {boolean}
     * @memberof TldDto
     */
    'supportsDNSSEC'?: boolean;
    /**
     * Indicates if it supports IDN or not.
     * @type {boolean}
     * @memberof TldDto
     */
    'supportsIDN'?: boolean;
    /**
     * Indicates if tld has a fee for status soft quarantine or not.
     * @type {boolean}
     * @memberof TldDto
     */
    'hasSoftQuarantineFee'?: boolean;
    /**
     * Indicates if tld has a fee for status hard quarantine or not.
     * @type {boolean}
     * @memberof TldDto
     */
    'hasHardQuarantineFee'?: boolean;
    /**
     * Indicates if you can transfer a tld while it has expired or not.
     * @type {boolean}
     * @memberof TldDto
     */
    'transferWhileExpired'?: boolean;
    /**
     * An array of strings representing registration information for a tld.
     * @type {Array<string>}
     * @memberof TldDto
     */
    'registerInformation'?: Array<string>;
    /**
     * An array of strings representing transfer information for a tld.
     * @type {Array<string>}
     * @memberof TldDto
     */
    'transferInformation'?: Array<string>;
    /**
     * An array of country codes representing the presence of registrant contacts in specific countries.
     * @type {Array<string>}
     * @memberof TldDto
     */
    'registrantContactCountryPresence'?: Array<TldDtoRegistrantContactCountryPresenceEnum>;
    /**
     * An array of country codes representing the presence of administrative contacts in specific countries.
     * @type {Array<string>}
     * @memberof TldDto
     */
    'adminContactCountryPresence'?: Array<TldDtoAdminContactCountryPresenceEnum>;
    /**
     * An array of country codes representing the presence of technical contacts in specific countries.
     * @type {Array<string>}
     * @memberof TldDto
     */
    'techContactCountryPresence'?: Array<TldDtoTechContactCountryPresenceEnum>;
    /**
     * An array of country codes representing the presence of billing contacts in specific countries.
     * @type {Array<string>}
     * @memberof TldDto
     */
    'billingContactCountryPresence'?: Array<TldDtoBillingContactCountryPresenceEnum>;
    /**
     * Indicates if accept or cancel transfer is allowed or not.
     * @type {boolean}
     * @memberof TldDto
     */
    'allowsAcceptOrCancelTransferOut'?: boolean;
    /**
     * Indicates if an active Dns zones are required or not.
     * @type {boolean}
     * @memberof TldDto
     */
    'activeDNSZonesRequired'?: boolean;
    /**
     * Indicates whether the tld will be deleted when its DNS zones become inactive.
     * @type {boolean}
     * @memberof TldDto
     */
    'deletesIfDnsZonesAreInactive'?: boolean;
    /**
     * Determines whether the EPP code should be sent to the domain owner when they request a transfer to a different registrar.
     * @type {boolean}
     * @memberof TldDto
     */
    'sendEppCodeToOwner'?: boolean;
    /**
     * Determines whether the details of the previous owner should be copied to the new owner when a domain transfer takes place.
     * @type {boolean}
     * @memberof TldDto
     */
    'copyOwnerOnTransfer': boolean;
    /**
     * Controls whether the EPP system should send an email and wait for verification when making changes to the registrant\'s email address.
     * @type {boolean}
     * @memberof TldDto
     */
    'registrantEmailAddressVerification'?: boolean;
    /**
     * Specifies the desired registration period for a domain after it has been transferred to a new registrar.
     * @type {string}
     * @memberof TldDto
     */
    'registrationPeriodAfterTransfer'?: TldDtoRegistrationPeriodAfterTransferEnum;
    /**
     * An array of supported durations for domain registrations.
     * @type {Array<string>}
     * @memberof TldDto
     */
    'supportedDurations'?: Array<TldDtoSupportedDurationsEnum>;
    /**
     * An array with all the tld policies.
     * @type {Array<TldPolicyDto>}
     * @memberof TldDto
     */
    'registryPolicies'?: Array<TldPolicyDto>;
    /**
     * An array of DNS servers used for the domain names within this tld.
     * @type {Array<string>}
     * @memberof TldDto
     */
    'DNS'?: Array<string>;
    /**
     * A number indicates the default price for retail.
     * @type {number}
     * @memberof TldDto
     */
    'defaultRetailPrice'?: number;
    /**
     * Specifies additional data associated with a domain within this tld.
     * @type {string}
     * @memberof TldDto
     */
    'domainAdditionalData'?: TldDtoDomainAdditionalDataEnum;
    /**
     * Specifies additional data associated with a contact of this tld.
     * @type {string}
     * @memberof TldDto
     */
    'contactAdditionalData'?: TldDtoContactAdditionalDataEnum;
    /**
     * The date and time when the tld was created.
     * @type {string}
     * @memberof TldDto
     */
    'createdAt'?: string;
    /**
     * The date and time when the service tld was updated.
     * @type {string}
     * @memberof TldDto
     */
    'updatedAt'?: string;
}

export const TldDtoRegistrantContactCountryPresenceEnum = {
    Af: 'AF',
    Al: 'AL',
    Dz: 'DZ',
    As: 'AS',
    Ad: 'AD',
    Ao: 'AO',
    Ai: 'AI',
    Aq: 'AQ',
    Ag: 'AG',
    Ar: 'AR',
    Am: 'AM',
    Aw: 'AW',
    Au: 'AU',
    At: 'AT',
    Az: 'AZ',
    Bs: 'BS',
    Bh: 'BH',
    Bd: 'BD',
    Bb: 'BB',
    By: 'BY',
    Be: 'BE',
    Bz: 'BZ',
    Bj: 'BJ',
    Bm: 'BM',
    Bt: 'BT',
    Bo: 'BO',
    Bq: 'BQ',
    Ba: 'BA',
    Bw: 'BW',
    Bv: 'BV',
    Br: 'BR',
    Io: 'IO',
    Bn: 'BN',
    Bg: 'BG',
    Bf: 'BF',
    Bi: 'BI',
    Kh: 'KH',
    Cm: 'CM',
    Ca: 'CA',
    Cv: 'CV',
    Ky: 'KY',
    Cf: 'CF',
    Td: 'TD',
    Cl: 'CL',
    Cn: 'CN',
    Cx: 'CX',
    Cc: 'CC',
    Co: 'CO',
    Km: 'KM',
    Cg: 'CG',
    Cd: 'CD',
    Ck: 'CK',
    Cr: 'CR',
    Ci: 'CI',
    Hr: 'HR',
    Cu: 'CU',
    Cw: 'CW',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Dj: 'DJ',
    Dm: 'DM',
    Do: 'DO',
    Ec: 'EC',
    Eg: 'EG',
    Sv: 'SV',
    Gq: 'GQ',
    Er: 'ER',
    Ee: 'EE',
    Et: 'ET',
    Fk: 'FK',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Gf: 'GF',
    Pf: 'PF',
    Tf: 'TF',
    Ga: 'GA',
    Gm: 'GM',
    Ge: 'GE',
    De: 'DE',
    Gh: 'GH',
    Gi: 'GI',
    Gr: 'GR',
    Gl: 'GL',
    Gd: 'GD',
    Gp: 'GP',
    Gu: 'GU',
    Gt: 'GT',
    Gg: 'GG',
    Gn: 'GN',
    Gw: 'GW',
    Gy: 'GY',
    Ht: 'HT',
    Hm: 'HM',
    Va: 'VA',
    Hn: 'HN',
    Hk: 'HK',
    Hu: 'HU',
    Is: 'IS',
    In: 'IN',
    Id: 'ID',
    Ir: 'IR',
    Iq: 'IQ',
    Ie: 'IE',
    Im: 'IM',
    Il: 'IL',
    It: 'IT',
    Jm: 'JM',
    Jp: 'JP',
    Je: 'JE',
    Jo: 'JO',
    Kz: 'KZ',
    Ke: 'KE',
    Ki: 'KI',
    Kp: 'KP',
    Kr: 'KR',
    Kw: 'KW',
    Kg: 'KG',
    La: 'LA',
    Lv: 'LV',
    Lb: 'LB',
    Ls: 'LS',
    Lr: 'LR',
    Ly: 'LY',
    Li: 'LI',
    Lt: 'LT',
    Lu: 'LU',
    Mo: 'MO',
    Mk: 'MK',
    Mg: 'MG',
    Mw: 'MW',
    My: 'MY',
    Mv: 'MV',
    Ml: 'ML',
    Mt: 'MT',
    Mh: 'MH',
    Mq: 'MQ',
    Mr: 'MR',
    Mu: 'MU',
    Tn: 'TN',
    Tr: 'TR',
    Tm: 'TM',
    Tc: 'TC',
    Tv: 'TV',
    Ug: 'UG',
    Ua: 'UA',
    Ae: 'AE',
    Gb: 'GB',
    Us: 'US',
    Um: 'UM',
    Uy: 'UY',
    Uz: 'UZ',
    Vu: 'VU',
    Ve: 'VE',
    Vn: 'VN',
    Vg: 'VG',
    Vi: 'VI',
    Wf: 'WF',
    Eh: 'EH',
    Ye: 'YE',
    Zm: 'ZM',
    Zw: 'ZW',
    Yt: 'YT',
    Mx: 'MX',
    Fm: 'FM',
    Md: 'MD',
    Mc: 'MC',
    Mn: 'MN',
    Me: 'ME',
    Ms: 'MS',
    Ma: 'MA',
    Mz: 'MZ',
    Mm: 'MM',
    Na: 'NA',
    Nr: 'NR',
    Np: 'NP',
    Nl: 'NL',
    Nc: 'NC',
    Nz: 'NZ',
    Ni: 'NI',
    Ne: 'NE',
    Ng: 'NG',
    Nu: 'NU',
    Nf: 'NF',
    Mp: 'MP',
    No: 'NO',
    Om: 'OM',
    Pk: 'PK',
    Pw: 'PW',
    Ps: 'PS',
    Pa: 'PA',
    Pg: 'PG',
    Py: 'PY',
    Pe: 'PE',
    Ph: 'PH',
    Pn: 'PN',
    Pl: 'PL',
    Pt: 'PT',
    Pr: 'PR',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Ru: 'RU',
    Rw: 'RW',
    Bl: 'BL',
    Sh: 'SH',
    Kn: 'KN',
    Lc: 'LC',
    Mf: 'MF',
    Pm: 'PM',
    Vc: 'VC',
    Ws: 'WS',
    Sm: 'SM',
    St: 'ST',
    Sa: 'SA',
    Sn: 'SN',
    Rs: 'RS',
    Sc: 'SC',
    Sl: 'SL',
    Sg: 'SG',
    Sx: 'SX',
    Sk: 'SK',
    Si: 'SI',
    Sb: 'SB',
    So: 'SO',
    Za: 'ZA',
    Gs: 'GS',
    Ss: 'SS',
    Es: 'ES',
    Lk: 'LK',
    Sd: 'SD',
    Sr: 'SR',
    Sj: 'SJ',
    Sz: 'SZ',
    Se: 'SE',
    Ch: 'CH',
    Sy: 'SY',
    Tw: 'TW',
    Tj: 'TJ',
    Tz: 'TZ',
    Th: 'TH',
    Tl: 'TL',
    Tg: 'TG',
    Tk: 'TK',
    To: 'TO',
    Tt: 'TT'
} as const;

export type TldDtoRegistrantContactCountryPresenceEnum = typeof TldDtoRegistrantContactCountryPresenceEnum[keyof typeof TldDtoRegistrantContactCountryPresenceEnum];
export const TldDtoAdminContactCountryPresenceEnum = {
    Af: 'AF',
    Al: 'AL',
    Dz: 'DZ',
    As: 'AS',
    Ad: 'AD',
    Ao: 'AO',
    Ai: 'AI',
    Aq: 'AQ',
    Ag: 'AG',
    Ar: 'AR',
    Am: 'AM',
    Aw: 'AW',
    Au: 'AU',
    At: 'AT',
    Az: 'AZ',
    Bs: 'BS',
    Bh: 'BH',
    Bd: 'BD',
    Bb: 'BB',
    By: 'BY',
    Be: 'BE',
    Bz: 'BZ',
    Bj: 'BJ',
    Bm: 'BM',
    Bt: 'BT',
    Bo: 'BO',
    Bq: 'BQ',
    Ba: 'BA',
    Bw: 'BW',
    Bv: 'BV',
    Br: 'BR',
    Io: 'IO',
    Bn: 'BN',
    Bg: 'BG',
    Bf: 'BF',
    Bi: 'BI',
    Kh: 'KH',
    Cm: 'CM',
    Ca: 'CA',
    Cv: 'CV',
    Ky: 'KY',
    Cf: 'CF',
    Td: 'TD',
    Cl: 'CL',
    Cn: 'CN',
    Cx: 'CX',
    Cc: 'CC',
    Co: 'CO',
    Km: 'KM',
    Cg: 'CG',
    Cd: 'CD',
    Ck: 'CK',
    Cr: 'CR',
    Ci: 'CI',
    Hr: 'HR',
    Cu: 'CU',
    Cw: 'CW',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Dj: 'DJ',
    Dm: 'DM',
    Do: 'DO',
    Ec: 'EC',
    Eg: 'EG',
    Sv: 'SV',
    Gq: 'GQ',
    Er: 'ER',
    Ee: 'EE',
    Et: 'ET',
    Fk: 'FK',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Gf: 'GF',
    Pf: 'PF',
    Tf: 'TF',
    Ga: 'GA',
    Gm: 'GM',
    Ge: 'GE',
    De: 'DE',
    Gh: 'GH',
    Gi: 'GI',
    Gr: 'GR',
    Gl: 'GL',
    Gd: 'GD',
    Gp: 'GP',
    Gu: 'GU',
    Gt: 'GT',
    Gg: 'GG',
    Gn: 'GN',
    Gw: 'GW',
    Gy: 'GY',
    Ht: 'HT',
    Hm: 'HM',
    Va: 'VA',
    Hn: 'HN',
    Hk: 'HK',
    Hu: 'HU',
    Is: 'IS',
    In: 'IN',
    Id: 'ID',
    Ir: 'IR',
    Iq: 'IQ',
    Ie: 'IE',
    Im: 'IM',
    Il: 'IL',
    It: 'IT',
    Jm: 'JM',
    Jp: 'JP',
    Je: 'JE',
    Jo: 'JO',
    Kz: 'KZ',
    Ke: 'KE',
    Ki: 'KI',
    Kp: 'KP',
    Kr: 'KR',
    Kw: 'KW',
    Kg: 'KG',
    La: 'LA',
    Lv: 'LV',
    Lb: 'LB',
    Ls: 'LS',
    Lr: 'LR',
    Ly: 'LY',
    Li: 'LI',
    Lt: 'LT',
    Lu: 'LU',
    Mo: 'MO',
    Mk: 'MK',
    Mg: 'MG',
    Mw: 'MW',
    My: 'MY',
    Mv: 'MV',
    Ml: 'ML',
    Mt: 'MT',
    Mh: 'MH',
    Mq: 'MQ',
    Mr: 'MR',
    Mu: 'MU',
    Tn: 'TN',
    Tr: 'TR',
    Tm: 'TM',
    Tc: 'TC',
    Tv: 'TV',
    Ug: 'UG',
    Ua: 'UA',
    Ae: 'AE',
    Gb: 'GB',
    Us: 'US',
    Um: 'UM',
    Uy: 'UY',
    Uz: 'UZ',
    Vu: 'VU',
    Ve: 'VE',
    Vn: 'VN',
    Vg: 'VG',
    Vi: 'VI',
    Wf: 'WF',
    Eh: 'EH',
    Ye: 'YE',
    Zm: 'ZM',
    Zw: 'ZW',
    Yt: 'YT',
    Mx: 'MX',
    Fm: 'FM',
    Md: 'MD',
    Mc: 'MC',
    Mn: 'MN',
    Me: 'ME',
    Ms: 'MS',
    Ma: 'MA',
    Mz: 'MZ',
    Mm: 'MM',
    Na: 'NA',
    Nr: 'NR',
    Np: 'NP',
    Nl: 'NL',
    Nc: 'NC',
    Nz: 'NZ',
    Ni: 'NI',
    Ne: 'NE',
    Ng: 'NG',
    Nu: 'NU',
    Nf: 'NF',
    Mp: 'MP',
    No: 'NO',
    Om: 'OM',
    Pk: 'PK',
    Pw: 'PW',
    Ps: 'PS',
    Pa: 'PA',
    Pg: 'PG',
    Py: 'PY',
    Pe: 'PE',
    Ph: 'PH',
    Pn: 'PN',
    Pl: 'PL',
    Pt: 'PT',
    Pr: 'PR',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Ru: 'RU',
    Rw: 'RW',
    Bl: 'BL',
    Sh: 'SH',
    Kn: 'KN',
    Lc: 'LC',
    Mf: 'MF',
    Pm: 'PM',
    Vc: 'VC',
    Ws: 'WS',
    Sm: 'SM',
    St: 'ST',
    Sa: 'SA',
    Sn: 'SN',
    Rs: 'RS',
    Sc: 'SC',
    Sl: 'SL',
    Sg: 'SG',
    Sx: 'SX',
    Sk: 'SK',
    Si: 'SI',
    Sb: 'SB',
    So: 'SO',
    Za: 'ZA',
    Gs: 'GS',
    Ss: 'SS',
    Es: 'ES',
    Lk: 'LK',
    Sd: 'SD',
    Sr: 'SR',
    Sj: 'SJ',
    Sz: 'SZ',
    Se: 'SE',
    Ch: 'CH',
    Sy: 'SY',
    Tw: 'TW',
    Tj: 'TJ',
    Tz: 'TZ',
    Th: 'TH',
    Tl: 'TL',
    Tg: 'TG',
    Tk: 'TK',
    To: 'TO',
    Tt: 'TT'
} as const;

export type TldDtoAdminContactCountryPresenceEnum = typeof TldDtoAdminContactCountryPresenceEnum[keyof typeof TldDtoAdminContactCountryPresenceEnum];
export const TldDtoTechContactCountryPresenceEnum = {
    Af: 'AF',
    Al: 'AL',
    Dz: 'DZ',
    As: 'AS',
    Ad: 'AD',
    Ao: 'AO',
    Ai: 'AI',
    Aq: 'AQ',
    Ag: 'AG',
    Ar: 'AR',
    Am: 'AM',
    Aw: 'AW',
    Au: 'AU',
    At: 'AT',
    Az: 'AZ',
    Bs: 'BS',
    Bh: 'BH',
    Bd: 'BD',
    Bb: 'BB',
    By: 'BY',
    Be: 'BE',
    Bz: 'BZ',
    Bj: 'BJ',
    Bm: 'BM',
    Bt: 'BT',
    Bo: 'BO',
    Bq: 'BQ',
    Ba: 'BA',
    Bw: 'BW',
    Bv: 'BV',
    Br: 'BR',
    Io: 'IO',
    Bn: 'BN',
    Bg: 'BG',
    Bf: 'BF',
    Bi: 'BI',
    Kh: 'KH',
    Cm: 'CM',
    Ca: 'CA',
    Cv: 'CV',
    Ky: 'KY',
    Cf: 'CF',
    Td: 'TD',
    Cl: 'CL',
    Cn: 'CN',
    Cx: 'CX',
    Cc: 'CC',
    Co: 'CO',
    Km: 'KM',
    Cg: 'CG',
    Cd: 'CD',
    Ck: 'CK',
    Cr: 'CR',
    Ci: 'CI',
    Hr: 'HR',
    Cu: 'CU',
    Cw: 'CW',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Dj: 'DJ',
    Dm: 'DM',
    Do: 'DO',
    Ec: 'EC',
    Eg: 'EG',
    Sv: 'SV',
    Gq: 'GQ',
    Er: 'ER',
    Ee: 'EE',
    Et: 'ET',
    Fk: 'FK',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Gf: 'GF',
    Pf: 'PF',
    Tf: 'TF',
    Ga: 'GA',
    Gm: 'GM',
    Ge: 'GE',
    De: 'DE',
    Gh: 'GH',
    Gi: 'GI',
    Gr: 'GR',
    Gl: 'GL',
    Gd: 'GD',
    Gp: 'GP',
    Gu: 'GU',
    Gt: 'GT',
    Gg: 'GG',
    Gn: 'GN',
    Gw: 'GW',
    Gy: 'GY',
    Ht: 'HT',
    Hm: 'HM',
    Va: 'VA',
    Hn: 'HN',
    Hk: 'HK',
    Hu: 'HU',
    Is: 'IS',
    In: 'IN',
    Id: 'ID',
    Ir: 'IR',
    Iq: 'IQ',
    Ie: 'IE',
    Im: 'IM',
    Il: 'IL',
    It: 'IT',
    Jm: 'JM',
    Jp: 'JP',
    Je: 'JE',
    Jo: 'JO',
    Kz: 'KZ',
    Ke: 'KE',
    Ki: 'KI',
    Kp: 'KP',
    Kr: 'KR',
    Kw: 'KW',
    Kg: 'KG',
    La: 'LA',
    Lv: 'LV',
    Lb: 'LB',
    Ls: 'LS',
    Lr: 'LR',
    Ly: 'LY',
    Li: 'LI',
    Lt: 'LT',
    Lu: 'LU',
    Mo: 'MO',
    Mk: 'MK',
    Mg: 'MG',
    Mw: 'MW',
    My: 'MY',
    Mv: 'MV',
    Ml: 'ML',
    Mt: 'MT',
    Mh: 'MH',
    Mq: 'MQ',
    Mr: 'MR',
    Mu: 'MU',
    Tn: 'TN',
    Tr: 'TR',
    Tm: 'TM',
    Tc: 'TC',
    Tv: 'TV',
    Ug: 'UG',
    Ua: 'UA',
    Ae: 'AE',
    Gb: 'GB',
    Us: 'US',
    Um: 'UM',
    Uy: 'UY',
    Uz: 'UZ',
    Vu: 'VU',
    Ve: 'VE',
    Vn: 'VN',
    Vg: 'VG',
    Vi: 'VI',
    Wf: 'WF',
    Eh: 'EH',
    Ye: 'YE',
    Zm: 'ZM',
    Zw: 'ZW',
    Yt: 'YT',
    Mx: 'MX',
    Fm: 'FM',
    Md: 'MD',
    Mc: 'MC',
    Mn: 'MN',
    Me: 'ME',
    Ms: 'MS',
    Ma: 'MA',
    Mz: 'MZ',
    Mm: 'MM',
    Na: 'NA',
    Nr: 'NR',
    Np: 'NP',
    Nl: 'NL',
    Nc: 'NC',
    Nz: 'NZ',
    Ni: 'NI',
    Ne: 'NE',
    Ng: 'NG',
    Nu: 'NU',
    Nf: 'NF',
    Mp: 'MP',
    No: 'NO',
    Om: 'OM',
    Pk: 'PK',
    Pw: 'PW',
    Ps: 'PS',
    Pa: 'PA',
    Pg: 'PG',
    Py: 'PY',
    Pe: 'PE',
    Ph: 'PH',
    Pn: 'PN',
    Pl: 'PL',
    Pt: 'PT',
    Pr: 'PR',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Ru: 'RU',
    Rw: 'RW',
    Bl: 'BL',
    Sh: 'SH',
    Kn: 'KN',
    Lc: 'LC',
    Mf: 'MF',
    Pm: 'PM',
    Vc: 'VC',
    Ws: 'WS',
    Sm: 'SM',
    St: 'ST',
    Sa: 'SA',
    Sn: 'SN',
    Rs: 'RS',
    Sc: 'SC',
    Sl: 'SL',
    Sg: 'SG',
    Sx: 'SX',
    Sk: 'SK',
    Si: 'SI',
    Sb: 'SB',
    So: 'SO',
    Za: 'ZA',
    Gs: 'GS',
    Ss: 'SS',
    Es: 'ES',
    Lk: 'LK',
    Sd: 'SD',
    Sr: 'SR',
    Sj: 'SJ',
    Sz: 'SZ',
    Se: 'SE',
    Ch: 'CH',
    Sy: 'SY',
    Tw: 'TW',
    Tj: 'TJ',
    Tz: 'TZ',
    Th: 'TH',
    Tl: 'TL',
    Tg: 'TG',
    Tk: 'TK',
    To: 'TO',
    Tt: 'TT'
} as const;

export type TldDtoTechContactCountryPresenceEnum = typeof TldDtoTechContactCountryPresenceEnum[keyof typeof TldDtoTechContactCountryPresenceEnum];
export const TldDtoBillingContactCountryPresenceEnum = {
    Af: 'AF',
    Al: 'AL',
    Dz: 'DZ',
    As: 'AS',
    Ad: 'AD',
    Ao: 'AO',
    Ai: 'AI',
    Aq: 'AQ',
    Ag: 'AG',
    Ar: 'AR',
    Am: 'AM',
    Aw: 'AW',
    Au: 'AU',
    At: 'AT',
    Az: 'AZ',
    Bs: 'BS',
    Bh: 'BH',
    Bd: 'BD',
    Bb: 'BB',
    By: 'BY',
    Be: 'BE',
    Bz: 'BZ',
    Bj: 'BJ',
    Bm: 'BM',
    Bt: 'BT',
    Bo: 'BO',
    Bq: 'BQ',
    Ba: 'BA',
    Bw: 'BW',
    Bv: 'BV',
    Br: 'BR',
    Io: 'IO',
    Bn: 'BN',
    Bg: 'BG',
    Bf: 'BF',
    Bi: 'BI',
    Kh: 'KH',
    Cm: 'CM',
    Ca: 'CA',
    Cv: 'CV',
    Ky: 'KY',
    Cf: 'CF',
    Td: 'TD',
    Cl: 'CL',
    Cn: 'CN',
    Cx: 'CX',
    Cc: 'CC',
    Co: 'CO',
    Km: 'KM',
    Cg: 'CG',
    Cd: 'CD',
    Ck: 'CK',
    Cr: 'CR',
    Ci: 'CI',
    Hr: 'HR',
    Cu: 'CU',
    Cw: 'CW',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Dj: 'DJ',
    Dm: 'DM',
    Do: 'DO',
    Ec: 'EC',
    Eg: 'EG',
    Sv: 'SV',
    Gq: 'GQ',
    Er: 'ER',
    Ee: 'EE',
    Et: 'ET',
    Fk: 'FK',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Gf: 'GF',
    Pf: 'PF',
    Tf: 'TF',
    Ga: 'GA',
    Gm: 'GM',
    Ge: 'GE',
    De: 'DE',
    Gh: 'GH',
    Gi: 'GI',
    Gr: 'GR',
    Gl: 'GL',
    Gd: 'GD',
    Gp: 'GP',
    Gu: 'GU',
    Gt: 'GT',
    Gg: 'GG',
    Gn: 'GN',
    Gw: 'GW',
    Gy: 'GY',
    Ht: 'HT',
    Hm: 'HM',
    Va: 'VA',
    Hn: 'HN',
    Hk: 'HK',
    Hu: 'HU',
    Is: 'IS',
    In: 'IN',
    Id: 'ID',
    Ir: 'IR',
    Iq: 'IQ',
    Ie: 'IE',
    Im: 'IM',
    Il: 'IL',
    It: 'IT',
    Jm: 'JM',
    Jp: 'JP',
    Je: 'JE',
    Jo: 'JO',
    Kz: 'KZ',
    Ke: 'KE',
    Ki: 'KI',
    Kp: 'KP',
    Kr: 'KR',
    Kw: 'KW',
    Kg: 'KG',
    La: 'LA',
    Lv: 'LV',
    Lb: 'LB',
    Ls: 'LS',
    Lr: 'LR',
    Ly: 'LY',
    Li: 'LI',
    Lt: 'LT',
    Lu: 'LU',
    Mo: 'MO',
    Mk: 'MK',
    Mg: 'MG',
    Mw: 'MW',
    My: 'MY',
    Mv: 'MV',
    Ml: 'ML',
    Mt: 'MT',
    Mh: 'MH',
    Mq: 'MQ',
    Mr: 'MR',
    Mu: 'MU',
    Tn: 'TN',
    Tr: 'TR',
    Tm: 'TM',
    Tc: 'TC',
    Tv: 'TV',
    Ug: 'UG',
    Ua: 'UA',
    Ae: 'AE',
    Gb: 'GB',
    Us: 'US',
    Um: 'UM',
    Uy: 'UY',
    Uz: 'UZ',
    Vu: 'VU',
    Ve: 'VE',
    Vn: 'VN',
    Vg: 'VG',
    Vi: 'VI',
    Wf: 'WF',
    Eh: 'EH',
    Ye: 'YE',
    Zm: 'ZM',
    Zw: 'ZW',
    Yt: 'YT',
    Mx: 'MX',
    Fm: 'FM',
    Md: 'MD',
    Mc: 'MC',
    Mn: 'MN',
    Me: 'ME',
    Ms: 'MS',
    Ma: 'MA',
    Mz: 'MZ',
    Mm: 'MM',
    Na: 'NA',
    Nr: 'NR',
    Np: 'NP',
    Nl: 'NL',
    Nc: 'NC',
    Nz: 'NZ',
    Ni: 'NI',
    Ne: 'NE',
    Ng: 'NG',
    Nu: 'NU',
    Nf: 'NF',
    Mp: 'MP',
    No: 'NO',
    Om: 'OM',
    Pk: 'PK',
    Pw: 'PW',
    Ps: 'PS',
    Pa: 'PA',
    Pg: 'PG',
    Py: 'PY',
    Pe: 'PE',
    Ph: 'PH',
    Pn: 'PN',
    Pl: 'PL',
    Pt: 'PT',
    Pr: 'PR',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Ru: 'RU',
    Rw: 'RW',
    Bl: 'BL',
    Sh: 'SH',
    Kn: 'KN',
    Lc: 'LC',
    Mf: 'MF',
    Pm: 'PM',
    Vc: 'VC',
    Ws: 'WS',
    Sm: 'SM',
    St: 'ST',
    Sa: 'SA',
    Sn: 'SN',
    Rs: 'RS',
    Sc: 'SC',
    Sl: 'SL',
    Sg: 'SG',
    Sx: 'SX',
    Sk: 'SK',
    Si: 'SI',
    Sb: 'SB',
    So: 'SO',
    Za: 'ZA',
    Gs: 'GS',
    Ss: 'SS',
    Es: 'ES',
    Lk: 'LK',
    Sd: 'SD',
    Sr: 'SR',
    Sj: 'SJ',
    Sz: 'SZ',
    Se: 'SE',
    Ch: 'CH',
    Sy: 'SY',
    Tw: 'TW',
    Tj: 'TJ',
    Tz: 'TZ',
    Th: 'TH',
    Tl: 'TL',
    Tg: 'TG',
    Tk: 'TK',
    To: 'TO',
    Tt: 'TT'
} as const;

export type TldDtoBillingContactCountryPresenceEnum = typeof TldDtoBillingContactCountryPresenceEnum[keyof typeof TldDtoBillingContactCountryPresenceEnum];
export const TldDtoRegistrationPeriodAfterTransferEnum = {
    Unchanged: 'UNCHANGED',
    Extends: 'EXTENDS',
    Restarts: 'RESTARTS'
} as const;

export type TldDtoRegistrationPeriodAfterTransferEnum = typeof TldDtoRegistrationPeriodAfterTransferEnum[keyof typeof TldDtoRegistrationPeriodAfterTransferEnum];
export const TldDtoSupportedDurationsEnum = {
    _1: '1',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5',
    _6: '6',
    _7: '7',
    _8: '8',
    _9: '9',
    _10: '10',
    _11: '11',
    _12: '12',
    _24: '24',
    _36: '36',
    _48: '48',
    _60: '60',
    _72: '72',
    _84: '84',
    _96: '96',
    _108: '108',
    _120: '120'
} as const;

export type TldDtoSupportedDurationsEnum = typeof TldDtoSupportedDurationsEnum[keyof typeof TldDtoSupportedDurationsEnum];
export const TldDtoDomainAdditionalDataEnum = {
    CatParameter: 'CAT_PARAMETER',
    ChallengeParameter: 'CHALLENGE_PARAMETER',
    ClaimsToken: 'CLAIMS_TOKEN',
    DonutsPriceCategory: 'DONUTS_PRICE_CATEGORY',
    IntentedUse: 'INTENTED_USE',
    PremiumPriceCategory: 'PREMIUM_PRICE_CATEGORY',
    ProxyService: 'PROXY_SERVICE',
    Sunrise: 'SUNRISE',
    UkDirect: 'UK_DIRECT',
    XxxMember: 'XXX_MEMBER'
} as const;

export type TldDtoDomainAdditionalDataEnum = typeof TldDtoDomainAdditionalDataEnum[keyof typeof TldDtoDomainAdditionalDataEnum];
export const TldDtoContactAdditionalDataEnum = {
    Afnic: 'AFNIC',
    Cat: 'CAT',
    De: 'DE',
    Es: 'ES',
    Eu: 'EU',
    It: 'IT',
    Lv: 'LV',
    Nl: 'NL',
    Pro: 'PRO',
    Uk: 'UK',
    Us: 'US'
} as const;

export type TldDtoContactAdditionalDataEnum = typeof TldDtoContactAdditionalDataEnum[keyof typeof TldDtoContactAdditionalDataEnum];

/**
 * 
 * @export
 * @interface TldPolicyDto
 */
export interface TldPolicyDto {
    /**
     * Title for the policy.
     * @type {string}
     * @memberof TldPolicyDto
     */
    'title': string;
    /**
     * A string contains a url associated with the tlds policy.
     * @type {string}
     * @memberof TldPolicyDto
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface UKDirectDataDto
 */
export interface UKDirectDataDto {
    /**
     * The unique domain ID of the related domain.
     * @type {number}
     * @memberof UKDirectDataDto
     */
    'relatedDomainId': number;
}
/**
 * 
 * @export
 * @interface UkAdditionalDataDto
 */
export interface UkAdditionalDataDto {
    /**
     * The category of the type of organization that the registration is being made for, e.g., LTD, PLC, LLP, SCH, RCHAR.
     * @type {string}
     * @memberof UkAdditionalDataDto
     */
    'registrantType': UkAdditionalDataDtoRegistrantTypeEnum;
    /**
     * For Registration Types LTD, PLC, LLP, IP, you should enter the registrant’s Companies House Registration Number.     For Registrant Type SCH, you should enter the DfES UK School number.     For Registrant Type RCHAR, you should enter the registrant\'s Registered Charity Number.
     * @type {string}
     * @memberof UkAdditionalDataDto
     */
    'companyNumber'?: string;
    /**
     * This is not the registered Name of the company (The registered Name of the company should be entered in the Organization Field). A trade name is also called a DBA (doing business as) name. A good example of this is Walmart. Walmart\'s legal business name is Wal-Mart Inc. but its trade name is just Walmart—that\'s the name it uses on its advertising and website, and what most people refer to it as.
     * @type {string}
     * @memberof UkAdditionalDataDto
     */
    'tradingName'?: string;
    /**
     * Indicates whether WHOis opt-out is enabled (true) or disabled (false).
     * @type {boolean}
     * @memberof UkAdditionalDataDto
     */
    'whoisOptOut'?: boolean;
}

export const UkAdditionalDataDtoRegistrantTypeEnum = {
    Tld: 'TLD',
    Plc: 'PLC',
    Ptnr: 'PTNR',
    Stra: 'STRA',
    Llp: 'LLP',
    Ip: 'IP',
    Ind: 'IND',
    Sch: 'SCH',
    Rchar: 'RCHAR',
    Gov: 'GOV',
    Crc: 'CRC',
    Stat: 'STAT',
    Other: 'OTHER',
    Find: 'FIND',
    Fcorp: 'FCORP',
    Fother: 'FOTHER'
} as const;

export type UkAdditionalDataDtoRegistrantTypeEnum = typeof UkAdditionalDataDtoRegistrantTypeEnum[keyof typeof UkAdditionalDataDtoRegistrantTypeEnum];

/**
 * 
 * @export
 * @interface UpdateProductDto
 */
export interface UpdateProductDto {
    /**
     * A unique identifier for the product
     * @type {string}
     * @memberof UpdateProductDto
     */
    'id'?: string;
    /**
     * The name of the product.
     * @type {string}
     * @memberof UpdateProductDto
     */
    'name'?: string;
    /**
     * The unique identifier of the company that owns the product.
     * @type {string}
     * @memberof UpdateProductDto
     */
    'companyId'?: string;
    /**
     * A boolean that indicates if a a version of the product is active.
     * @type {boolean}
     * @memberof UpdateProductDto
     */
    'activeVersion'?: boolean;
    /**
     * A number that indicates the version of the product.
     * @type {number}
     * @memberof UpdateProductDto
     */
    'version'?: number;
    /**
     * An array that holds all the versions of a product available.
     * @type {number}
     * @memberof UpdateProductDto
     */
    'versionsIds'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateProductDto
     */
    'integrationId'?: string;
    /**
     * The product\'s category unique identifier.
     * @type {string}
     * @memberof UpdateProductDto
     */
    'categoryId'?: string;
    /**
     * Indicates if a product is enabled.
     * @type {boolean}
     * @memberof UpdateProductDto
     */
    'enabled'?: boolean;
    /**
     * Indicates if auto renew option is active for this product .
     * @type {boolean}
     * @memberof UpdateProductDto
     */
    'autoRenew'?: boolean;
    /**
     * An array of unique identifiers that represent all possible upgrades that can be applied.
     * @type {Array<string>}
     * @memberof UpdateProductDto
     */
    'upgradeProductIds'?: Array<string>;
    /**
     * An array of unique identifiers that represent all possible downgrades that can be applied.
     * @type {Array<string>}
     * @memberof UpdateProductDto
     */
    'downgradeProductIds'?: Array<string>;
    /**
     * An array that holds the title and the written language of the product title.
     * @type {Array<MultilangTextDto>}
     * @memberof UpdateProductDto
     */
    'title'?: Array<MultilangTextDto>;
    /**
     * An array that holds the description and the written language of the product description.
     * @type {Array<MultilangTextDto>}
     * @memberof UpdateProductDto
     */
    'description'?: Array<MultilangTextDto>;
    /**
     * Indicates if a product id a domain type product.
     * @type {boolean}
     * @memberof UpdateProductDto
     */
    'isDomain'?: boolean;
    /**
     * Indicates if the product requires a domain name.
     * @type {boolean}
     * @memberof UpdateProductDto
     */
    'requireDomain'?: boolean;
    /**
     * The number of days before the registry\'s expiration date, that a domain can be renewed
     * @type {number}
     * @memberof UpdateProductDto
     */
    'expirationDateOffset'?: number;
    /**
     * A number that indicates the number of days a trial on a product lasts. 0 indicates that there is no trial in this product.
     * @type {number}
     * @memberof UpdateProductDto
     */
    'trialDays'?: number;
    /**
     * A number that indicates in how many days the product will be suspended.
     * @type {number}
     * @memberof UpdateProductDto
     */
    'suspendedAfterDays'?: number;
    /**
     * A number that indicates days until user sees the product as deleted.
     * @type {number}
     * @memberof UpdateProductDto
     */
    'softDeleteDays'?: number;
    /**
     * A number that indicates days until the product is actually deleted.
     * @type {number}
     * @memberof UpdateProductDto
     */
    'hardDeleteDays'?: number;
    /**
     * Restore penalty price
     * @type {number}
     * @memberof UpdateProductDto
     */
    'restorePrice'?: number;
    /**
     * An array that holds the templates used for this product.
     * @type {Array<ProductTemplateDto>}
     * @memberof UpdateProductDto
     */
    'templates'?: Array<ProductTemplateDto>;
    /**
     * Default price policies
     * @type {Array<PricePolicyDto>}
     * @memberof UpdateProductDto
     */
    'defaultPrices'?: Array<PricePolicyDto>;
    /**
     * Premium price policies
     * @type {Array<PricePolicyDto>}
     * @memberof UpdateProductDto
     */
    'premiumPrices'?: Array<PricePolicyDto>;
    /**
     * An object that contains all the specific prices for a domain name.
     * @type {DomainPricesDto}
     * @memberof UpdateProductDto
     */
    'domainPrices'?: DomainPricesDto;
    /**
     * Indicates the type of the invoice.
     * @type {string}
     * @memberof UpdateProductDto
     */
    'invoiceType'?: UpdateProductDtoInvoiceTypeEnum;
    /**
     * A unique identifier of the tld selected.
     * @type {string}
     * @memberof UpdateProductDto
     */
    'tldId'?: string;
    /**
     * Sets the settings for an ip.
     * @type {IpSettingsDto}
     * @memberof UpdateProductDto
     */
    'ipSettings'?: IpSettingsDto;
    /**
     * This number indicates the number available left for sale.
     * @type {number}
     * @memberof UpdateProductDto
     */
    'stock'?: number;
    /**
     * An array that holds the unique identifier of the addons.
     * @type {Array<string>}
     * @memberof UpdateProductDto
     */
    'addonIds'?: Array<string>;
    /**
     * 
     * @type {Array<object>}
     * @memberof UpdateProductDto
     */
    'options'?: Array<object>;
    /**
     * Informations about an affiliate product.
     * @type {ProductAffiliateDto}
     * @memberof UpdateProductDto
     */
    'affiliate'?: ProductAffiliateDto;
    /**
     * An array that contains informations about the product.
     * @type {Array<ProductInformationDto>}
     * @memberof UpdateProductDto
     */
    'information'?: Array<ProductInformationDto>;
    /**
     * An array that holds keywords for product indentification.
     * @type {Array<string>}
     * @memberof UpdateProductDto
     */
    'tags'?: Array<string>;
    /**
     * The client has the option to activate a service that has been deactivated. Here, we determine the duration for which it will remain open
     * @type {number}
     * @memberof UpdateProductDto
     */
    'postponeDays'?: number;
    /**
     * A number that indicates how many times the user can postpone within the last 365 days.
     * @type {number}
     * @memberof UpdateProductDto
     */
    'postponeTimesPerYear'?: number;
    /**
     * Indicates if you can delete this product
     * @type {boolean}
     * @memberof UpdateProductDto
     */
    'deletable'?: boolean;
    /**
     * The date a product created.
     * @type {string}
     * @memberof UpdateProductDto
     */
    'createdAt'?: string;
    /**
     * The date a product updated.
     * @type {string}
     * @memberof UpdateProductDto
     */
    'updatedAt'?: string;
}

export const UpdateProductDtoInvoiceTypeEnum = {
    Snapshot: 'SNAPSHOT',
    Prorata: 'PRORATA',
    Perhour: 'PERHOUR',
    Permonth: 'PERMONTH'
} as const;

export type UpdateProductDtoInvoiceTypeEnum = typeof UpdateProductDtoInvoiceTypeEnum[keyof typeof UpdateProductDtoInvoiceTypeEnum];

/**
 * 
 * @export
 * @interface UsAdditionalDataDto
 */
export interface UsAdditionalDataDto {
    /**
     * The purpose of the domain application. Possible values include:     - P1 (Business use for profit)     - P2 (Non-profit business, club, association, etc.)     - P3 (Personal use)     - P4 (Education purposes)     - P5 (Government purposes)
     * @type {string}
     * @memberof UsAdditionalDataDto
     */
    'appPurpose': UsAdditionalDataDtoAppPurposeEnum;
    /**
     * The category of the registrant. Possible values include:     - C11 (A natural person who is a United States citizen)     - C12 (A natural person who is a permanent resident of the United States of America, or     any of its possessions or territories)     - C21 (A US-based organization or company formed within one of the fifty (50) U.S. states,     the District of Columbia, or any of the United States possessions or territories, or organized     or otherwise constituted under the laws of a state of the United States of America, the     District of Columbia, or any of its possessions or territories or a U.S. federal, state, or local     government entity or a political subdivision thereof.)     - C31 (A foreign entity or organization that has a bona fide presence in the United States     of America or any of its possessions or territories who regularly engages in lawful activities     (sales of goods or services or other business, commercial or non-commercial, including     not-for-profit relations in the United States).)     - C32 (A foreign entity or organization that has an office or other facility in the United     States.)
     * @type {string}
     * @memberof UsAdditionalDataDto
     */
    'category': UsAdditionalDataDtoCategoryEnum;
}

export const UsAdditionalDataDtoAppPurposeEnum = {
    P1: 'P1',
    P2: 'P2',
    P3: 'P3',
    P4: 'P4',
    P5: 'P5'
} as const;

export type UsAdditionalDataDtoAppPurposeEnum = typeof UsAdditionalDataDtoAppPurposeEnum[keyof typeof UsAdditionalDataDtoAppPurposeEnum];
export const UsAdditionalDataDtoCategoryEnum = {
    C11: 'C11',
    C12: 'C12',
    C21: 'C21',
    C31: 'C31',
    C32: 'C32'
} as const;

export type UsAdditionalDataDtoCategoryEnum = typeof UsAdditionalDataDtoCategoryEnum[keyof typeof UsAdditionalDataDtoCategoryEnum];

/**
 * 
 * @export
 * @interface UserAddonPricePolicyDto
 */
export interface UserAddonPricePolicyDto {
    /**
     * The unique identifier of the policy.
     * @type {string}
     * @memberof UserAddonPricePolicyDto
     */
    'policyId': string;
    /**
     * The unique identifier of the addon.
     * @type {string}
     * @memberof UserAddonPricePolicyDto
     */
    'addonId': string;
    /**
     * 
     * @type {PolicyData}
     * @memberof UserAddonPricePolicyDto
     */
    'policy'?: PolicyData;
    /**
     * An array of calculated prices.
     * @type {Array<CalculatedPriceDto>}
     * @memberof UserAddonPricePolicyDto
     */
    'calculatedPrices'?: Array<CalculatedPriceDto>;
    /**
     * An array of PriceDto objects.
     * @type {Array<PriceDto>}
     * @memberof UserAddonPricePolicyDto
     */
    'prices'?: Array<PriceDto>;
}
/**
 * 
 * @export
 * @interface UserBasketDto
 */
export interface UserBasketDto {
    /**
     * The unique identifier of the user.
     * @type {string}
     * @memberof UserBasketDto
     */
    'userId': string;
    /**
     * The user\'s shopping cart data.
     * @type {object}
     * @memberof UserBasketDto
     */
    'cart': object;
    /**
     * The date and time when the user\'s basket was last updated.
     * @type {string}
     * @memberof UserBasketDto
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface UserDto
 */
export interface UserDto {
    /**
     * A unique identifier for the user.
     * @type {string}
     * @memberof UserDto
     */
    'id'?: string;
    /**
     * An email address connected to the user.
     * @type {string}
     * @memberof UserDto
     */
    'email'?: string;
    /**
     * Saves the user\'s default language.
     * @type {string}
     * @memberof UserDto
     */
    'defaultLanguage'?: UserDtoDefaultLanguageEnum;
    /**
     * Indicate if a user has locked payments.
     * @type {boolean}
     * @memberof UserDto
     */
    'lockedPayments'?: boolean;
    /**
     * Indicates if a user is banned.
     * @type {boolean}
     * @memberof UserDto
     */
    'banned'?: boolean;
    /**
     * Three letter code about the currency this user use.
     * @type {string}
     * @memberof UserDto
     */
    'currencyThreeLetterCode'?: string;
    /**
     * A unique identifier that indicates the parent company user belongs.
     * @type {string}
     * @memberof UserDto
     */
    'parentCompanyId'?: string;
    /**
     * 
     * @type {DefaultInvoiceContact}
     * @memberof UserDto
     */
    'ownInvoiceContact'?: DefaultInvoiceContact;
    /**
     * A unique identifier that indicates the policy applied to this user.
     * @type {string}
     * @memberof UserDto
     */
    'policyId'?: string;
    /**
     * 
     * @type {CustomPricePolicies}
     * @memberof UserDto
     */
    'customPricePolicies'?: CustomPricePolicies;
    /**
     * 
     * @type {CustomAddonPricePolicies}
     * @memberof UserDto
     */
    'customAddonPricePolicies'?: CustomAddonPricePolicies;
    /**
     * 
     * @type {CustomAffiliates}
     * @memberof UserDto
     */
    'customAffiliates'?: CustomAffiliates;
    /**
     * An array containing comments related to the user.
     * @type {Array<string>}
     * @memberof UserDto
     */
    'comments'?: Array<string>;
    /**
     * 
     * @type {Currency}
     * @memberof UserDto
     */
    'currency'?: Currency;
    /**
     * Indicates invoice frequency.
     * @type {string}
     * @memberof UserDto
     */
    'invoiceInterval'?: UserDtoInvoiceIntervalEnum;
    /**
     * 
     * @type {AcceptedNotificationMethods}
     * @memberof UserDto
     */
    'acceptedNotificationMethods'?: AcceptedNotificationMethods;
    /**
     * 
     * @type {PersistentCart}
     * @memberof UserDto
     */
    'persistentCart'?: PersistentCart;
    /**
     * User tags - only parent can see this
     * @type {string}
     * @memberof UserDto
     */
    'tags'?: string;
    /**
     * User logs - only parent can see this
     * @type {string}
     * @memberof UserDto
     */
    'logs'?: string;
    /**
     * Additional emails to send notifications
     * @type {string}
     * @memberof UserDto
     */
    'additionalNotificationEmails'?: string;
    /**
     * Indicates the credit balance.
     * @type {number}
     * @memberof UserDto
     */
    'creditBalance'?: number;
    /**
     * Indicates user account balance
     * @type {number}
     * @memberof UserDto
     */
    'balance'?: number;
    /**
     * An array of payment subscriptions associated with the user.
     * @type {Array<PaymentSubscriptionDto>}
     * @memberof UserDto
     */
    'paymentSubscriptions'?: Array<PaymentSubscriptionDto>;
    /**
     * The date the user was created.
     * @type {string}
     * @memberof UserDto
     */
    'createdAt'?: string;
    /**
     * The date the user was last updated.
     * @type {string}
     * @memberof UserDto
     */
    'updatedAt'?: string;
}

export const UserDtoDefaultLanguageEnum = {
    Aa: 'aa',
    Af: 'af',
    Ak: 'ak',
    Sq: 'sq',
    Am: 'am',
    Ar: 'ar',
    An: 'an',
    Hy: 'hy',
    As: 'as',
    Av: 'av',
    Ae: 'ae',
    Ay: 'ay',
    Az: 'az',
    Bm: 'bm',
    Ba: 'ba',
    Eu: 'eu',
    Be: 'be',
    Bn: 'bn',
    Bh: 'bh',
    Bi: 'bi',
    Bs: 'bs',
    Br: 'br',
    Bg: 'bg',
    My: 'my',
    Ca: 'ca',
    Ch: 'ch',
    Ce: 'ce',
    Ny: 'ny',
    Zh: 'zh',
    Cv: 'cv',
    Kw: 'kw',
    Co: 'co',
    Cr: 'cr',
    Hr: 'hr',
    Cs: 'cs',
    Da: 'da',
    Dv: 'dv',
    Nl: 'nl',
    Dz: 'dz',
    En: 'en',
    Eo: 'eo',
    Et: 'et',
    Ee: 'ee',
    Fo: 'fo',
    Fj: 'fj',
    Fi: 'fi',
    Fr: 'fr',
    Ff: 'ff',
    Gl: 'gl',
    Ka: 'ka',
    De: 'de',
    El: 'el',
    Gn: 'gn',
    Gu: 'gu',
    Ht: 'ht',
    Ha: 'ha',
    He: 'he',
    Hz: 'hz',
    Hi: 'hi',
    Ho: 'ho',
    Hu: 'hu',
    Ia: 'ia',
    Id: 'id',
    Ie: 'ie',
    Ga: 'ga',
    Ig: 'ig',
    Ik: 'ik',
    Io: 'io',
    Is: 'is',
    It: 'it',
    Iu: 'iu',
    Ja: 'ja',
    Jv: 'jv',
    Kl: 'kl',
    Kn: 'kn',
    Kr: 'kr',
    Ks: 'ks',
    Kk: 'kk',
    Km: 'km',
    Ki: 'ki',
    Rw: 'rw',
    Ky: 'ky',
    Kv: 'kv',
    Kg: 'kg',
    Ko: 'ko',
    Ku: 'ku',
    Kj: 'kj',
    La: 'la',
    Lb: 'lb',
    Lg: 'lg',
    Li: 'li',
    Ln: 'ln',
    Lo: 'lo',
    Lt: 'lt',
    Lu: 'lu',
    Lv: 'lv',
    Gv: 'gv',
    Mk: 'mk',
    Mg: 'mg',
    Ms: 'ms',
    Ml: 'ml',
    Mt: 'mt',
    Mi: 'mi',
    Mr: 'mr',
    Mh: 'mh',
    Mn: 'mn',
    Na: 'na',
    Nv: 'nv',
    Nd: 'nd',
    Ne: 'ne',
    Ng: 'ng',
    Nb: 'nb',
    Nn: 'nn',
    No: 'no',
    Ii: 'ii',
    Nr: 'nr',
    Oc: 'oc',
    Oj: 'oj',
    Cu: 'cu',
    Om: 'om',
    Or: 'or',
    Os: 'os',
    Pa: 'pa',
    Pi: 'pi',
    Fa: 'fa',
    Pl: 'pl',
    Ps: 'ps',
    Pt: 'pt',
    Qu: 'qu',
    Rm: 'rm',
    Rn: 'rn',
    Ro: 'ro',
    Rh: 'rh',
    Ru: 'ru',
    Sa: 'sa',
    Sc: 'sc',
    Sd: 'sd',
    Se: 'se',
    Sm: 'sm',
    Sg: 'sg',
    Sr: 'sr',
    Gd: 'gd',
    Sn: 'sn',
    Si: 'si',
    Sk: 'sk',
    Sl: 'sl',
    So: 'so',
    St: 'st',
    Es: 'es',
    Su: 'su',
    Sw: 'sw',
    Ss: 'ss',
    Sv: 'sv',
    Ta: 'ta',
    Te: 'te',
    Tg: 'tg',
    Th: 'th',
    Ti: 'ti',
    Bo: 'bo',
    Tk: 'tk',
    Tl: 'tl',
    Tn: 'tn',
    To: 'to',
    Tr: 'tr',
    Ts: 'ts',
    Tt: 'tt',
    Tw: 'tw',
    Ty: 'ty',
    Ug: 'ug',
    Uk: 'uk',
    Ur: 'ur',
    Uz: 'uz',
    Ve: 've',
    Vi: 'vi',
    Vo: 'vo',
    Wa: 'wa',
    Cy: 'cy',
    Wo: 'wo',
    Fy: 'fy',
    Xh: 'xh',
    Yi: 'yi',
    Yo: 'yo',
    Za: 'za',
    Zu: 'zu'
} as const;

export type UserDtoDefaultLanguageEnum = typeof UserDtoDefaultLanguageEnum[keyof typeof UserDtoDefaultLanguageEnum];
export const UserDtoInvoiceIntervalEnum = {
    Instant: 'instant',
    Weekly: 'weekly',
    Monthly: 'monthly',
    PerRequest: 'per request'
} as const;

export type UserDtoInvoiceIntervalEnum = typeof UserDtoInvoiceIntervalEnum[keyof typeof UserDtoInvoiceIntervalEnum];

/**
 * 
 * @export
 * @interface UserPricePolicyDto
 */
export interface UserPricePolicyDto {
    /**
     * The unique identifier of the policy.
     * @type {string}
     * @memberof UserPricePolicyDto
     */
    'policyId': string;
    /**
     * The unique identifier of the product.
     * @type {string}
     * @memberof UserPricePolicyDto
     */
    'productId': string;
    /**
     * 
     * @type {Policy}
     * @memberof UserPricePolicyDto
     */
    'policy'?: Policy;
    /**
     * An array of calculated prices.
     * @type {Array<CalculatedPriceDto>}
     * @memberof UserPricePolicyDto
     */
    'calculatedPrices'?: Array<CalculatedPriceDto>;
    /**
     * An array of price objects.
     * @type {Array<PriceDto>}
     * @memberof UserPricePolicyDto
     */
    'prices'?: Array<PriceDto>;
}
/**
 * @type Value
 * The value choosen by the user. This can be a string or a number, depending on the context.
 * @export
 */
export type Value = number | string;

/**
 * 
 * @export
 * @interface XXXMemberDataDto
 */
export interface XXXMemberDataDto {
    /**
     * Used to associate a member with a domain on registration.
     * @type {string}
     * @memberof XXXMemberDataDto
     */
    'memberId': string;
    /**
     * Used to associate a member with a domain on registration.
     * @type {string}
     * @memberof XXXMemberDataDto
     */
    'memberPassword'?: string;
    /**
     * Set to `true` if the domain is intended as a Non-Resolving domain. If not set, the .xxx registry will send a Membership email to the registrant contact’s email address if the email address is not already associated with a Member.
     * @type {boolean}
     * @memberof XXXMemberDataDto
     */
    'nonResolvin': boolean;
}

/**
 * AddonsApi - axios parameter creator
 * @export
 */
export const AddonsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new addon. Returns an AddonDto.
         * @summary Creates a addon
         * @param {string} companyId companyId
         * @param {AddonDto} addonDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAddon: async (companyId: string, addonDto: AddonDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('createAddon', 'companyId', companyId)
            // verify required parameter 'addonDto' is not null or undefined
            assertParamExists('createAddon', 'addonDto', addonDto)
            const localVarPath = `/addons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addonDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a certain addon. Returns null.
         * @summary Delete a addon
         * @param {string} companyId companyId
         * @param {string} id addon id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAddon: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deleteAddon', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAddon', 'id', id)
            const localVarPath = `/addons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all the addons. Returns an array of AddonDto.
         * @summary Get list of all addons
         * @param {string} companyId companyId
         * @param {string} query searches in title and description
         * @param {number} [currentPage] current page
         * @param {number} [perPage] users to show per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAddons: async (companyId: string, query: string, currentPage?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('findAddons', 'companyId', companyId)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('findAddons', 'query', query)
            const localVarPath = `/addons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a certain addon. Returns an AddonDto.
         * @summary Get a addon
         * @param {string} id ID
         * @param {string} companyId companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddon: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAddon', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getAddon', 'companyId', companyId)
            const localVarPath = `/addons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a certain addon. Returns an AddonDto.
         * @summary Update addon
         * @param {string} id addon id
         * @param {string} companyId companyId
         * @param {AddonDto} addonDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAddon: async (id: string, companyId: string, addonDto: AddonDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAddon', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateAddon', 'companyId', companyId)
            // verify required parameter 'addonDto' is not null or undefined
            assertParamExists('updateAddon', 'addonDto', addonDto)
            const localVarPath = `/addons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addonDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddonsApi - functional programming interface
 * @export
 */
export const AddonsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddonsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new addon. Returns an AddonDto.
         * @summary Creates a addon
         * @param {string} companyId companyId
         * @param {AddonDto} addonDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAddon(companyId: string, addonDto: AddonDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindAddons200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAddon(companyId, addonDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddonsApi.createAddon']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a certain addon. Returns null.
         * @summary Delete a addon
         * @param {string} companyId companyId
         * @param {string} id addon id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAddon(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAddon(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddonsApi.deleteAddon']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all the addons. Returns an array of AddonDto.
         * @summary Get list of all addons
         * @param {string} companyId companyId
         * @param {string} query searches in title and description
         * @param {number} [currentPage] current page
         * @param {number} [perPage] users to show per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAddons(companyId: string, query: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindAddons200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAddons(companyId, query, currentPage, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddonsApi.findAddons']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a certain addon. Returns an AddonDto.
         * @summary Get a addon
         * @param {string} id ID
         * @param {string} companyId companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddon(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindAddons200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddon(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddonsApi.getAddon']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a certain addon. Returns an AddonDto.
         * @summary Update addon
         * @param {string} id addon id
         * @param {string} companyId companyId
         * @param {AddonDto} addonDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAddon(id: string, companyId: string, addonDto: AddonDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindAddons200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAddon(id, companyId, addonDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddonsApi.updateAddon']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AddonsApi - factory interface
 * @export
 */
export const AddonsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddonsApiFp(configuration)
    return {
        /**
         * Creates a new addon. Returns an AddonDto.
         * @summary Creates a addon
         * @param {string} companyId companyId
         * @param {AddonDto} addonDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAddon(companyId: string, addonDto: AddonDto, options?: any): AxiosPromise<FindAddons200Response> {
            return localVarFp.createAddon(companyId, addonDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a certain addon. Returns null.
         * @summary Delete a addon
         * @param {string} companyId companyId
         * @param {string} id addon id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAddon(companyId: string, id: string, options?: any): AxiosPromise<GetInvoice200Response> {
            return localVarFp.deleteAddon(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all the addons. Returns an array of AddonDto.
         * @summary Get list of all addons
         * @param {string} companyId companyId
         * @param {string} query searches in title and description
         * @param {number} [currentPage] current page
         * @param {number} [perPage] users to show per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAddons(companyId: string, query: string, currentPage?: number, perPage?: number, options?: any): AxiosPromise<FindAddons200Response> {
            return localVarFp.findAddons(companyId, query, currentPage, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a certain addon. Returns an AddonDto.
         * @summary Get a addon
         * @param {string} id ID
         * @param {string} companyId companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddon(id: string, companyId: string, options?: any): AxiosPromise<FindAddons200Response> {
            return localVarFp.getAddon(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a certain addon. Returns an AddonDto.
         * @summary Update addon
         * @param {string} id addon id
         * @param {string} companyId companyId
         * @param {AddonDto} addonDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAddon(id: string, companyId: string, addonDto: AddonDto, options?: any): AxiosPromise<FindAddons200Response> {
            return localVarFp.updateAddon(id, companyId, addonDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddonsApi - object-oriented interface
 * @export
 * @class AddonsApi
 * @extends {BaseAPI}
 */
export class AddonsApi extends BaseAPI {
    /**
     * Creates a new addon. Returns an AddonDto.
     * @summary Creates a addon
     * @param {string} companyId companyId
     * @param {AddonDto} addonDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddonsApi
     */
    public createAddon(companyId: string, addonDto: AddonDto, options?: RawAxiosRequestConfig) {
        return AddonsApiFp(this.configuration).createAddon(companyId, addonDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a certain addon. Returns null.
     * @summary Delete a addon
     * @param {string} companyId companyId
     * @param {string} id addon id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddonsApi
     */
    public deleteAddon(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return AddonsApiFp(this.configuration).deleteAddon(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all the addons. Returns an array of AddonDto.
     * @summary Get list of all addons
     * @param {string} companyId companyId
     * @param {string} query searches in title and description
     * @param {number} [currentPage] current page
     * @param {number} [perPage] users to show per Page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddonsApi
     */
    public findAddons(companyId: string, query: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return AddonsApiFp(this.configuration).findAddons(companyId, query, currentPage, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a certain addon. Returns an AddonDto.
     * @summary Get a addon
     * @param {string} id ID
     * @param {string} companyId companyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddonsApi
     */
    public getAddon(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return AddonsApiFp(this.configuration).getAddon(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a certain addon. Returns an AddonDto.
     * @summary Update addon
     * @param {string} id addon id
     * @param {string} companyId companyId
     * @param {AddonDto} addonDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddonsApi
     */
    public updateAddon(id: string, companyId: string, addonDto: AddonDto, options?: RawAxiosRequestConfig) {
        return AddonsApiFp(this.configuration).updateAddon(id, companyId, addonDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AffiliatesApi - axios parameter creator
 * @export
 */
export const AffiliatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new affiliate. Return a AffiliateDto.
         * @summary Creates a new affiliate
         * @param {string} companyId companyId
         * @param {AffiliateDto} affiliateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAffiliate: async (companyId: string, affiliateDto: AffiliateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('createAffiliate', 'companyId', companyId)
            // verify required parameter 'affiliateDto' is not null or undefined
            assertParamExists('createAffiliate', 'affiliateDto', affiliateDto)
            const localVarPath = `/affiliates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(affiliateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a certain affiliate. Returns vull.
         * @summary Delete a affiliate
         * @param {string} companyId companyId
         * @param {string} id Affiliate ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAffiliate: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deleteAffiliate', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAffiliate', 'id', id)
            const localVarPath = `/affiliates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all affiliates. Returns an array of AffiliateDto.
         * @summary Get list of all affiliates
         * @param {string} companyId companyId
         * @param {string} [productId] product id
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAffiliate: async (companyId: string, productId?: string, currentPage?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('findAffiliate', 'companyId', companyId)
            const localVarPath = `/affiliates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a certain affiliate. Returns a AffiliateDto.
         * @summary Get a affiliate
         * @param {string} companyId companyId
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAffiliate: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getAffiliate', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAffiliate', 'id', id)
            const localVarPath = `/affiliates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a certain affiliate. Returns a AffiliateDto.
         * @summary Update a affiliate
         * @param {string} companyId companyId
         * @param {string} id Affiliate ID
         * @param {AffiliateDto} affiliateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAffiliate: async (companyId: string, id: string, affiliateDto: AffiliateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateAffiliate', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAffiliate', 'id', id)
            // verify required parameter 'affiliateDto' is not null or undefined
            assertParamExists('updateAffiliate', 'affiliateDto', affiliateDto)
            const localVarPath = `/affiliates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(affiliateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AffiliatesApi - functional programming interface
 * @export
 */
export const AffiliatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AffiliatesApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new affiliate. Return a AffiliateDto.
         * @summary Creates a new affiliate
         * @param {string} companyId companyId
         * @param {AffiliateDto} affiliateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAffiliate(companyId: string, affiliateDto: AffiliateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAffiliate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAffiliate(companyId, affiliateDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AffiliatesApi.createAffiliate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a certain affiliate. Returns vull.
         * @summary Delete a affiliate
         * @param {string} companyId companyId
         * @param {string} id Affiliate ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAffiliate(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAffiliate(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AffiliatesApi.deleteAffiliate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all affiliates. Returns an array of AffiliateDto.
         * @summary Get list of all affiliates
         * @param {string} companyId companyId
         * @param {string} [productId] product id
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAffiliate(companyId: string, productId?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindAffiliate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAffiliate(companyId, productId, currentPage, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AffiliatesApi.findAffiliate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a certain affiliate. Returns a AffiliateDto.
         * @summary Get a affiliate
         * @param {string} companyId companyId
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAffiliate(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAffiliate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAffiliate(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AffiliatesApi.getAffiliate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a certain affiliate. Returns a AffiliateDto.
         * @summary Update a affiliate
         * @param {string} companyId companyId
         * @param {string} id Affiliate ID
         * @param {AffiliateDto} affiliateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAffiliate(companyId: string, id: string, affiliateDto: AffiliateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAffiliate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAffiliate(companyId, id, affiliateDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AffiliatesApi.updateAffiliate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AffiliatesApi - factory interface
 * @export
 */
export const AffiliatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AffiliatesApiFp(configuration)
    return {
        /**
         * Creates a new affiliate. Return a AffiliateDto.
         * @summary Creates a new affiliate
         * @param {string} companyId companyId
         * @param {AffiliateDto} affiliateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAffiliate(companyId: string, affiliateDto: AffiliateDto, options?: any): AxiosPromise<CreateAffiliate200Response> {
            return localVarFp.createAffiliate(companyId, affiliateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a certain affiliate. Returns vull.
         * @summary Delete a affiliate
         * @param {string} companyId companyId
         * @param {string} id Affiliate ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAffiliate(companyId: string, id: string, options?: any): AxiosPromise<GetInvoice200Response> {
            return localVarFp.deleteAffiliate(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all affiliates. Returns an array of AffiliateDto.
         * @summary Get list of all affiliates
         * @param {string} companyId companyId
         * @param {string} [productId] product id
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAffiliate(companyId: string, productId?: string, currentPage?: number, perPage?: number, options?: any): AxiosPromise<FindAffiliate200Response> {
            return localVarFp.findAffiliate(companyId, productId, currentPage, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a certain affiliate. Returns a AffiliateDto.
         * @summary Get a affiliate
         * @param {string} companyId companyId
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAffiliate(companyId: string, id: string, options?: any): AxiosPromise<CreateAffiliate200Response> {
            return localVarFp.getAffiliate(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a certain affiliate. Returns a AffiliateDto.
         * @summary Update a affiliate
         * @param {string} companyId companyId
         * @param {string} id Affiliate ID
         * @param {AffiliateDto} affiliateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAffiliate(companyId: string, id: string, affiliateDto: AffiliateDto, options?: any): AxiosPromise<CreateAffiliate200Response> {
            return localVarFp.updateAffiliate(companyId, id, affiliateDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AffiliatesApi - object-oriented interface
 * @export
 * @class AffiliatesApi
 * @extends {BaseAPI}
 */
export class AffiliatesApi extends BaseAPI {
    /**
     * Creates a new affiliate. Return a AffiliateDto.
     * @summary Creates a new affiliate
     * @param {string} companyId companyId
     * @param {AffiliateDto} affiliateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AffiliatesApi
     */
    public createAffiliate(companyId: string, affiliateDto: AffiliateDto, options?: RawAxiosRequestConfig) {
        return AffiliatesApiFp(this.configuration).createAffiliate(companyId, affiliateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a certain affiliate. Returns vull.
     * @summary Delete a affiliate
     * @param {string} companyId companyId
     * @param {string} id Affiliate ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AffiliatesApi
     */
    public deleteAffiliate(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return AffiliatesApiFp(this.configuration).deleteAffiliate(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all affiliates. Returns an array of AffiliateDto.
     * @summary Get list of all affiliates
     * @param {string} companyId companyId
     * @param {string} [productId] product id
     * @param {number} [currentPage] current page
     * @param {number} [perPage] per Page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AffiliatesApi
     */
    public findAffiliate(companyId: string, productId?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return AffiliatesApiFp(this.configuration).findAffiliate(companyId, productId, currentPage, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a certain affiliate. Returns a AffiliateDto.
     * @summary Get a affiliate
     * @param {string} companyId companyId
     * @param {string} id ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AffiliatesApi
     */
    public getAffiliate(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return AffiliatesApiFp(this.configuration).getAffiliate(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a certain affiliate. Returns a AffiliateDto.
     * @summary Update a affiliate
     * @param {string} companyId companyId
     * @param {string} id Affiliate ID
     * @param {AffiliateDto} affiliateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AffiliatesApi
     */
    public updateAffiliate(companyId: string, id: string, affiliateDto: AffiliateDto, options?: RawAxiosRequestConfig) {
        return AffiliatesApiFp(this.configuration).updateAffiliate(companyId, id, affiliateDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CompaniesApi - axios parameter creator
 * @export
 */
export const CompaniesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns code 200 and a success message. Adds analytics to a company through params companyId and analyticsId.
         * @summary Add company analytics id
         * @param {string} companyId A unique identifier for the company you wish to add analytics.
         * @param {string} analyticsId A unique identifier for the company\&#39;s analytics.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAnalyticsIdToCompany: async (companyId: string, analyticsId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('addAnalyticsIdToCompany', 'companyId', companyId)
            // verify required parameter 'analyticsId' is not null or undefined
            assertParamExists('addAnalyticsIdToCompany', 'analyticsId', analyticsId)
            const localVarPath = `/companies/{companyId}/analytics/{analyticsId}`
                .replace(`{${"companyId"}}`, encodeURIComponent(String(companyId)))
                .replace(`{${"analyticsId"}}`, encodeURIComponent(String(analyticsId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns code 200 and a success message. Adds roles to a user through query roles.
         * @summary Give user access to company
         * @param {string} email The email that is associated with the user.
         * @param {string} companyId A unique identifier for the company you wish the user to grand access to.
         * @param {Array<AddUserAccessToCompanyRolesEnum>} roles An array that contains enums that indicates the role you wish to grant to the user.
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserAccessToCompany: async (email: string, companyId: string, roles: Array<AddUserAccessToCompanyRolesEnum>, requestBody: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('addUserAccessToCompany', 'email', email)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('addUserAccessToCompany', 'companyId', companyId)
            // verify required parameter 'roles' is not null or undefined
            assertParamExists('addUserAccessToCompany', 'roles', roles)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('addUserAccessToCompany', 'requestBody', requestBody)
            const localVarPath = `/companies/{companyId}/access/{email}`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)))
                .replace(`{${"companyId"}}`, encodeURIComponent(String(companyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (roles) {
                localVarQueryParameter['roles'] = roles;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a company.
         * @summary Create a company
         * @param {CompanyDto} companyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCompany: async (companyDto: CompanyDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyDto' is not null or undefined
            assertParamExists('createCompany', 'companyDto', companyDto)
            const localVarPath = `/companies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(companyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete company
         * @param {string} companyId companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCompany: async (companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deleteCompany', 'companyId', companyId)
            const localVarPath = `/companies/{companyId}`
                .replace(`{${"companyId"}}`, encodeURIComponent(String(companyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Finds and returns an array of all the companies exists. Using the queries given paginates the result per page!
         * @summary Get list of all companies User has permissions on
         * @param {number} [perPage] A number that indicates the companies shown per page
         * @param {number} [currentPage] Number that indicates the current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCompanies: async (perPage?: number, currentPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/companies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single company using as param companyUsername.
         * @summary Get a company
         * @param {string} companyId A unique identifier for the company you wish to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompany: async (companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getCompany', 'companyId', companyId)
            const localVarPath = `/companies/{companyId}`
                .replace(`{${"companyId"}}`, encodeURIComponent(String(companyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single company\'s info using as param companyId.
         * @summary Get a company\'s Public Information
         * @param {string} companyId A unique identifier for the company you wish to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoCompany: async (companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('infoCompany', 'companyId', companyId)
            const localVarPath = `/companies/{companyId}/info`
                .replace(`{${"companyId"}}`, encodeURIComponent(String(companyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns code 200, a success message and data.Installs a service integration to a company using params companyId and integrationId.
         * @summary Attach service integration to company
         * @param {string} companyId A unique identifier for the company you wish to attach the service.
         * @param {string} integrationId A unique identifier for the integration that provides the service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationInstallToCompany: async (companyId: string, integrationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('integrationInstallToCompany', 'companyId', companyId)
            // verify required parameter 'integrationId' is not null or undefined
            assertParamExists('integrationInstallToCompany', 'integrationId', integrationId)
            const localVarPath = `/companies/{companyId}/integration/attach/{integrationId}`
                .replace(`{${"companyId"}}`, encodeURIComponent(String(companyId)))
                .replace(`{${"integrationId"}}`, encodeURIComponent(String(integrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns code 200, a success message and data.Detaches a integration from a company using params companyId and integrationId.
         * @summary Detach service integration from company
         * @param {string} companyId A unique identifier for the company you want to detach the service from.
         * @param {string} integrationId A unique identifier for the integration that provides the service you wish to detach.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationUninstallFromCompany: async (companyId: string, integrationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('integrationUninstallFromCompany', 'companyId', companyId)
            // verify required parameter 'integrationId' is not null or undefined
            assertParamExists('integrationUninstallFromCompany', 'integrationId', integrationId)
            const localVarPath = `/companies/{companyId}/integration/detach/{integrationId}`
                .replace(`{${"companyId"}}`, encodeURIComponent(String(companyId)))
                .replace(`{${"integrationId"}}`, encodeURIComponent(String(integrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns code 200 and a success message. Deletes analytics from a company through params companyId and analyticsId.
         * @summary Remove company analytics
         * @param {string} companyId A unique identifier for the company you wish to remove analytics from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAnalyticsIdFromCompany: async (companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('removeAnalyticsIdFromCompany', 'companyId', companyId)
            const localVarPath = `/companies/{companyId}/analytics`
                .replace(`{${"companyId"}}`, encodeURIComponent(String(companyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns code 200 and a success message. Deletes roles from a user.
         * @summary Remove user access to company
         * @param {string} email The email that is associated the user.
         * @param {string} companyId A unique identifier for the company you wish the user to remove access to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserAccessFromCompany: async (email: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('removeUserAccessFromCompany', 'email', email)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('removeUserAccessFromCompany', 'companyId', companyId)
            const localVarPath = `/companies/{companyId}/access/{email}`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)))
                .replace(`{${"companyId"}}`, encodeURIComponent(String(companyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CompaniesApi - functional programming interface
 * @export
 */
export const CompaniesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CompaniesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns code 200 and a success message. Adds analytics to a company through params companyId and analyticsId.
         * @summary Add company analytics id
         * @param {string} companyId A unique identifier for the company you wish to add analytics.
         * @param {string} analyticsId A unique identifier for the company\&#39;s analytics.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAnalyticsIdToCompany(companyId: string, analyticsId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCompany200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAnalyticsIdToCompany(companyId, analyticsId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompaniesApi.addAnalyticsIdToCompany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns code 200 and a success message. Adds roles to a user through query roles.
         * @summary Give user access to company
         * @param {string} email The email that is associated with the user.
         * @param {string} companyId A unique identifier for the company you wish the user to grand access to.
         * @param {Array<AddUserAccessToCompanyRolesEnum>} roles An array that contains enums that indicates the role you wish to grant to the user.
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserAccessToCompany(email: string, companyId: string, roles: Array<AddUserAccessToCompanyRolesEnum>, requestBody: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUserAccessToCompany(email, companyId, roles, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompaniesApi.addUserAccessToCompany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a company.
         * @summary Create a company
         * @param {CompanyDto} companyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCompany(companyDto: CompanyDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCompany200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCompany(companyDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompaniesApi.createCompany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete company
         * @param {string} companyId companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCompany(companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCompany(companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompaniesApi.deleteCompany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Finds and returns an array of all the companies exists. Using the queries given paginates the result per page!
         * @summary Get list of all companies User has permissions on
         * @param {number} [perPage] A number that indicates the companies shown per page
         * @param {number} [currentPage] Number that indicates the current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findCompanies(perPage?: number, currentPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindCompanies200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findCompanies(perPage, currentPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompaniesApi.findCompanies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a single company using as param companyUsername.
         * @summary Get a company
         * @param {string} companyId A unique identifier for the company you wish to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCompany(companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCompany200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCompany(companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompaniesApi.getCompany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a single company\'s info using as param companyId.
         * @summary Get a company\'s Public Information
         * @param {string} companyId A unique identifier for the company you wish to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async infoCompany(companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCompany200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.infoCompany(companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompaniesApi.infoCompany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns code 200, a success message and data.Installs a service integration to a company using params companyId and integrationId.
         * @summary Attach service integration to company
         * @param {string} companyId A unique identifier for the company you wish to attach the service.
         * @param {string} integrationId A unique identifier for the integration that provides the service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async integrationInstallToCompany(companyId: string, integrationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCompany200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.integrationInstallToCompany(companyId, integrationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompaniesApi.integrationInstallToCompany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns code 200, a success message and data.Detaches a integration from a company using params companyId and integrationId.
         * @summary Detach service integration from company
         * @param {string} companyId A unique identifier for the company you want to detach the service from.
         * @param {string} integrationId A unique identifier for the integration that provides the service you wish to detach.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async integrationUninstallFromCompany(companyId: string, integrationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCompany200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.integrationUninstallFromCompany(companyId, integrationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompaniesApi.integrationUninstallFromCompany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns code 200 and a success message. Deletes analytics from a company through params companyId and analyticsId.
         * @summary Remove company analytics
         * @param {string} companyId A unique identifier for the company you wish to remove analytics from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAnalyticsIdFromCompany(companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCompany200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAnalyticsIdFromCompany(companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompaniesApi.removeAnalyticsIdFromCompany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns code 200 and a success message. Deletes roles from a user.
         * @summary Remove user access to company
         * @param {string} email The email that is associated the user.
         * @param {string} companyId A unique identifier for the company you wish the user to remove access to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUserAccessFromCompany(email: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeUserAccessFromCompany(email, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompaniesApi.removeUserAccessFromCompany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CompaniesApi - factory interface
 * @export
 */
export const CompaniesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CompaniesApiFp(configuration)
    return {
        /**
         * Returns code 200 and a success message. Adds analytics to a company through params companyId and analyticsId.
         * @summary Add company analytics id
         * @param {string} companyId A unique identifier for the company you wish to add analytics.
         * @param {string} analyticsId A unique identifier for the company\&#39;s analytics.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAnalyticsIdToCompany(companyId: string, analyticsId: string, options?: any): AxiosPromise<CreateCompany200Response> {
            return localVarFp.addAnalyticsIdToCompany(companyId, analyticsId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns code 200 and a success message. Adds roles to a user through query roles.
         * @summary Give user access to company
         * @param {string} email The email that is associated with the user.
         * @param {string} companyId A unique identifier for the company you wish the user to grand access to.
         * @param {Array<AddUserAccessToCompanyRolesEnum>} roles An array that contains enums that indicates the role you wish to grant to the user.
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserAccessToCompany(email: string, companyId: string, roles: Array<AddUserAccessToCompanyRolesEnum>, requestBody: Array<string>, options?: any): AxiosPromise<GetInvoice200Response> {
            return localVarFp.addUserAccessToCompany(email, companyId, roles, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a company.
         * @summary Create a company
         * @param {CompanyDto} companyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCompany(companyDto: CompanyDto, options?: any): AxiosPromise<CreateCompany200Response> {
            return localVarFp.createCompany(companyDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete company
         * @param {string} companyId companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCompany(companyId: string, options?: any): AxiosPromise<GetInvoice200Response> {
            return localVarFp.deleteCompany(companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Finds and returns an array of all the companies exists. Using the queries given paginates the result per page!
         * @summary Get list of all companies User has permissions on
         * @param {number} [perPage] A number that indicates the companies shown per page
         * @param {number} [currentPage] Number that indicates the current page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCompanies(perPage?: number, currentPage?: number, options?: any): AxiosPromise<FindCompanies200Response> {
            return localVarFp.findCompanies(perPage, currentPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single company using as param companyUsername.
         * @summary Get a company
         * @param {string} companyId A unique identifier for the company you wish to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompany(companyId: string, options?: any): AxiosPromise<CreateCompany200Response> {
            return localVarFp.getCompany(companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single company\'s info using as param companyId.
         * @summary Get a company\'s Public Information
         * @param {string} companyId A unique identifier for the company you wish to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoCompany(companyId: string, options?: any): AxiosPromise<CreateCompany200Response> {
            return localVarFp.infoCompany(companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns code 200, a success message and data.Installs a service integration to a company using params companyId and integrationId.
         * @summary Attach service integration to company
         * @param {string} companyId A unique identifier for the company you wish to attach the service.
         * @param {string} integrationId A unique identifier for the integration that provides the service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationInstallToCompany(companyId: string, integrationId: string, options?: any): AxiosPromise<CreateCompany200Response> {
            return localVarFp.integrationInstallToCompany(companyId, integrationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns code 200, a success message and data.Detaches a integration from a company using params companyId and integrationId.
         * @summary Detach service integration from company
         * @param {string} companyId A unique identifier for the company you want to detach the service from.
         * @param {string} integrationId A unique identifier for the integration that provides the service you wish to detach.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationUninstallFromCompany(companyId: string, integrationId: string, options?: any): AxiosPromise<CreateCompany200Response> {
            return localVarFp.integrationUninstallFromCompany(companyId, integrationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns code 200 and a success message. Deletes analytics from a company through params companyId and analyticsId.
         * @summary Remove company analytics
         * @param {string} companyId A unique identifier for the company you wish to remove analytics from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAnalyticsIdFromCompany(companyId: string, options?: any): AxiosPromise<CreateCompany200Response> {
            return localVarFp.removeAnalyticsIdFromCompany(companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns code 200 and a success message. Deletes roles from a user.
         * @summary Remove user access to company
         * @param {string} email The email that is associated the user.
         * @param {string} companyId A unique identifier for the company you wish the user to remove access to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserAccessFromCompany(email: string, companyId: string, options?: any): AxiosPromise<GetInvoice200Response> {
            return localVarFp.removeUserAccessFromCompany(email, companyId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CompaniesApi - object-oriented interface
 * @export
 * @class CompaniesApi
 * @extends {BaseAPI}
 */
export class CompaniesApi extends BaseAPI {
    /**
     * Returns code 200 and a success message. Adds analytics to a company through params companyId and analyticsId.
     * @summary Add company analytics id
     * @param {string} companyId A unique identifier for the company you wish to add analytics.
     * @param {string} analyticsId A unique identifier for the company\&#39;s analytics.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompaniesApi
     */
    public addAnalyticsIdToCompany(companyId: string, analyticsId: string, options?: RawAxiosRequestConfig) {
        return CompaniesApiFp(this.configuration).addAnalyticsIdToCompany(companyId, analyticsId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns code 200 and a success message. Adds roles to a user through query roles.
     * @summary Give user access to company
     * @param {string} email The email that is associated with the user.
     * @param {string} companyId A unique identifier for the company you wish the user to grand access to.
     * @param {Array<AddUserAccessToCompanyRolesEnum>} roles An array that contains enums that indicates the role you wish to grant to the user.
     * @param {Array<string>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompaniesApi
     */
    public addUserAccessToCompany(email: string, companyId: string, roles: Array<AddUserAccessToCompanyRolesEnum>, requestBody: Array<string>, options?: RawAxiosRequestConfig) {
        return CompaniesApiFp(this.configuration).addUserAccessToCompany(email, companyId, roles, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a company.
     * @summary Create a company
     * @param {CompanyDto} companyDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompaniesApi
     */
    public createCompany(companyDto: CompanyDto, options?: RawAxiosRequestConfig) {
        return CompaniesApiFp(this.configuration).createCompany(companyDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete company
     * @param {string} companyId companyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompaniesApi
     */
    public deleteCompany(companyId: string, options?: RawAxiosRequestConfig) {
        return CompaniesApiFp(this.configuration).deleteCompany(companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Finds and returns an array of all the companies exists. Using the queries given paginates the result per page!
     * @summary Get list of all companies User has permissions on
     * @param {number} [perPage] A number that indicates the companies shown per page
     * @param {number} [currentPage] Number that indicates the current page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompaniesApi
     */
    public findCompanies(perPage?: number, currentPage?: number, options?: RawAxiosRequestConfig) {
        return CompaniesApiFp(this.configuration).findCompanies(perPage, currentPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single company using as param companyUsername.
     * @summary Get a company
     * @param {string} companyId A unique identifier for the company you wish to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompaniesApi
     */
    public getCompany(companyId: string, options?: RawAxiosRequestConfig) {
        return CompaniesApiFp(this.configuration).getCompany(companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single company\'s info using as param companyId.
     * @summary Get a company\'s Public Information
     * @param {string} companyId A unique identifier for the company you wish to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompaniesApi
     */
    public infoCompany(companyId: string, options?: RawAxiosRequestConfig) {
        return CompaniesApiFp(this.configuration).infoCompany(companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns code 200, a success message and data.Installs a service integration to a company using params companyId and integrationId.
     * @summary Attach service integration to company
     * @param {string} companyId A unique identifier for the company you wish to attach the service.
     * @param {string} integrationId A unique identifier for the integration that provides the service.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompaniesApi
     */
    public integrationInstallToCompany(companyId: string, integrationId: string, options?: RawAxiosRequestConfig) {
        return CompaniesApiFp(this.configuration).integrationInstallToCompany(companyId, integrationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns code 200, a success message and data.Detaches a integration from a company using params companyId and integrationId.
     * @summary Detach service integration from company
     * @param {string} companyId A unique identifier for the company you want to detach the service from.
     * @param {string} integrationId A unique identifier for the integration that provides the service you wish to detach.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompaniesApi
     */
    public integrationUninstallFromCompany(companyId: string, integrationId: string, options?: RawAxiosRequestConfig) {
        return CompaniesApiFp(this.configuration).integrationUninstallFromCompany(companyId, integrationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns code 200 and a success message. Deletes analytics from a company through params companyId and analyticsId.
     * @summary Remove company analytics
     * @param {string} companyId A unique identifier for the company you wish to remove analytics from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompaniesApi
     */
    public removeAnalyticsIdFromCompany(companyId: string, options?: RawAxiosRequestConfig) {
        return CompaniesApiFp(this.configuration).removeAnalyticsIdFromCompany(companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns code 200 and a success message. Deletes roles from a user.
     * @summary Remove user access to company
     * @param {string} email The email that is associated the user.
     * @param {string} companyId A unique identifier for the company you wish the user to remove access to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompaniesApi
     */
    public removeUserAccessFromCompany(email: string, companyId: string, options?: RawAxiosRequestConfig) {
        return CompaniesApiFp(this.configuration).removeUserAccessFromCompany(email, companyId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const AddUserAccessToCompanyRolesEnum = {
    SimpleUser: 'SIMPLE_USER',
    FullAccess: 'FULL_ACCESS',
    SuperAdmin: 'SUPER_ADMIN',
    OrderRead: 'ORDER_READ',
    OrderWrite: 'ORDER_WRITE',
    AddonRead: 'ADDON_READ',
    AddonWrite: 'ADDON_WRITE',
    AffiliateRead: 'AFFILIATE_READ',
    AffiliateWrite: 'AFFILIATE WRITE',
    ComanyRead: 'COMANY_READ',
    ComanyWrite: 'COMANY WRITE',
    TemplateRead: 'TEMPLATE_READ',
    TemplateWrite: 'TEMPLATE_WRITE',
    CouponRead: 'COUPON_READ',
    CouponWrite: 'COUPON_WRITE',
    DomainCategoryRead: 'DOMAIN_CATEGORY_READ',
    DomainCategoryWrite: 'DOMAIN_CATEGORY_WRITE',
    DomainContactRead: 'DOMAIN_CONTACT_READ',
    DomainContactWrite: 'DOMAIN_CONTACT_WRITE',
    DomainNameRead: 'DOMAIN_NAME_READ',
    DomainNameWrite: 'DOMAIN_NAME_WRITE',
    InvoiceContactRead: 'INVOICE_CONTACT_READ',
    InvoiceContactWrite: 'INVOICE_CONTACT_WRITE',
    InvoiceRead: 'INVOICE_READ',
    InvoiceWrite: 'INVOICE_WRITE',
    IpGroupsRead: 'IP_GROUPS_READ',
    IpGroupsWrite: 'IP_GROUPS_WRITE',
    IpsRead: 'IPS_READ',
    IpsWrite: 'IPS_WRITE',
    ItemsRead: 'ITEMS_READ',
    ItemsWrite: 'ITEMS_WRITE',
    OrdersRead: 'ORDERS_READ',
    OrdersWrite: 'ORDERS_WRITE',
    PaymentsRead: 'PAYMENTS_READ',
    PaymentsWrite: 'PAYMENTS_WRITE',
    PoliciesRead: 'POLICIES_READ',
    PoliciesWrite: 'POLICIES_WRITE',
    ProductCategoriesRead: 'PRODUCT_CATEGORIES_READ',
    ProductCategoriesWrite: 'PRODUCT_CATEGORIES_WRITE',
    ProductsRead: 'PRODUCTS_READ',
    ProductsWrite: 'PRODUCTS_WRITE',
    SettingsRead: 'SETTINGS_READ',
    SettingsWrite: 'SETTINGS_WRITE',
    IntegrationsRead: 'INTEGRATIONS_READ',
    IntegrationsWrite: 'INTEGRATIONS_WRITE',
    TldsRead: 'TLDS_READ',
    TldsWrite: 'TLDS_WRITE',
    UsersRead: 'USERS_READ',
    UsersWrite: 'USERS_WRITE',
    IssuesWrite: 'ISSUES_WRITE',
    IssuesRead: 'ISSUES_READ'
} as const;
export type AddUserAccessToCompanyRolesEnum = typeof AddUserAccessToCompanyRolesEnum[keyof typeof AddUserAccessToCompanyRolesEnum];


/**
 * CouponsApi - axios parameter creator
 * @export
 */
export const CouponsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new coupon for a specific company. Returns created coupon as CouponDto object
         * @summary Creates a coupon
         * @param {string} companyId The unique identifier of the company to associate the coupon with.
         * @param {CouponDto} couponDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCoupon: async (companyId: string, couponDto: CouponDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('createCoupon', 'companyId', companyId)
            // verify required parameter 'couponDto' is not null or undefined
            assertParamExists('createCoupon', 'couponDto', couponDto)
            const localVarPath = `/coupons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(couponDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific coupon associated with a company. Checks if the coupon is in active use before deletion.
         * @summary Delete a coupon
         * @param {string} id The unique identifier of the coupon to delete.
         * @param {string} companyId The unique identifier of the company associated with the coupon.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoupon: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCoupon', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deleteCoupon', 'companyId', companyId)
            const localVarPath = `/coupons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of coupons based on various criteria including product IDs, date ranges, and pagination. Returns an array of CouponDto objects
         * @summary Get list of all coupons
         * @param {string} companyId The company ID.
         * @param {Array<any>} productIds An array of product IDs to filter coupons by.
         * @param {string} [fromStartDate] Start date to filter coupons created on or after this date.
         * @param {string} [toStartDate] End date to filter coupons created on or before this date.
         * @param {string} [fromEndDate] Start date to filter coupons valid on or after this date.
         * @param {string} [toEndDate] End date to filter coupons valid on or before this date.
         * @param {number} [currentPage] The current page number for pagination.
         * @param {number} [perPage] The number of coupons to display per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCoupons: async (companyId: string, productIds: Array<any>, fromStartDate?: string, toStartDate?: string, fromEndDate?: string, toEndDate?: string, currentPage?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('findCoupons', 'companyId', companyId)
            // verify required parameter 'productIds' is not null or undefined
            assertParamExists('findCoupons', 'productIds', productIds)
            const localVarPath = `/coupons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (productIds) {
                localVarQueryParameter['productIds'] = productIds;
            }

            if (fromStartDate !== undefined) {
                localVarQueryParameter['fromStartDate'] = (fromStartDate as any instanceof Date) ?
                    (fromStartDate as any).toISOString() :
                    fromStartDate;
            }

            if (toStartDate !== undefined) {
                localVarQueryParameter['toStartDate'] = (toStartDate as any instanceof Date) ?
                    (toStartDate as any).toISOString() :
                    toStartDate;
            }

            if (fromEndDate !== undefined) {
                localVarQueryParameter['fromEndDate'] = (fromEndDate as any instanceof Date) ?
                    (fromEndDate as any).toISOString() :
                    fromEndDate;
            }

            if (toEndDate !== undefined) {
                localVarQueryParameter['toEndDate'] = (toEndDate as any instanceof Date) ?
                    (toEndDate as any).toISOString() :
                    toEndDate;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a coupon\'s details based on its unique ID and company. Returns CouponDto object
         * @summary Get a coupon
         * @param {string} id The unique identifier of the coupon.
         * @param {string} companyId The company\&#39;s unique identifier associated with the coupon.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoupon: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCoupon', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getCoupon', 'companyId', companyId)
            const localVarPath = `/coupons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the details of an existing coupon associated with a specific company. Returns updated CouponDto object
         * @summary Update coupon
         * @param {string} companyId The unique identifier of the company associated with the coupon.
         * @param {string} id The unique identifier of the coupon to update.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCoupon: async (companyId: string, id: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateCoupon', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCoupon', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateCoupon', 'body', body)
            const localVarPath = `/coupons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CouponsApi - functional programming interface
 * @export
 */
export const CouponsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CouponsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new coupon for a specific company. Returns created coupon as CouponDto object
         * @summary Creates a coupon
         * @param {string} companyId The unique identifier of the company to associate the coupon with.
         * @param {CouponDto} couponDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCoupon(companyId: string, couponDto: CouponDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindCoupons200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCoupon(companyId, couponDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CouponsApi.createCoupon']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a specific coupon associated with a company. Checks if the coupon is in active use before deletion.
         * @summary Delete a coupon
         * @param {string} id The unique identifier of the coupon to delete.
         * @param {string} companyId The unique identifier of the company associated with the coupon.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCoupon(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCoupon(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CouponsApi.deleteCoupon']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of coupons based on various criteria including product IDs, date ranges, and pagination. Returns an array of CouponDto objects
         * @summary Get list of all coupons
         * @param {string} companyId The company ID.
         * @param {Array<any>} productIds An array of product IDs to filter coupons by.
         * @param {string} [fromStartDate] Start date to filter coupons created on or after this date.
         * @param {string} [toStartDate] End date to filter coupons created on or before this date.
         * @param {string} [fromEndDate] Start date to filter coupons valid on or after this date.
         * @param {string} [toEndDate] End date to filter coupons valid on or before this date.
         * @param {number} [currentPage] The current page number for pagination.
         * @param {number} [perPage] The number of coupons to display per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findCoupons(companyId: string, productIds: Array<any>, fromStartDate?: string, toStartDate?: string, fromEndDate?: string, toEndDate?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindCoupons200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findCoupons(companyId, productIds, fromStartDate, toStartDate, fromEndDate, toEndDate, currentPage, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CouponsApi.findCoupons']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a coupon\'s details based on its unique ID and company. Returns CouponDto object
         * @summary Get a coupon
         * @param {string} id The unique identifier of the coupon.
         * @param {string} companyId The company\&#39;s unique identifier associated with the coupon.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCoupon(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindCoupons200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCoupon(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CouponsApi.getCoupon']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the details of an existing coupon associated with a specific company. Returns updated CouponDto object
         * @summary Update coupon
         * @param {string} companyId The unique identifier of the company associated with the coupon.
         * @param {string} id The unique identifier of the coupon to update.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCoupon(companyId: string, id: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindCoupons200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCoupon(companyId, id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CouponsApi.updateCoupon']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CouponsApi - factory interface
 * @export
 */
export const CouponsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CouponsApiFp(configuration)
    return {
        /**
         * Create a new coupon for a specific company. Returns created coupon as CouponDto object
         * @summary Creates a coupon
         * @param {string} companyId The unique identifier of the company to associate the coupon with.
         * @param {CouponDto} couponDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCoupon(companyId: string, couponDto: CouponDto, options?: any): AxiosPromise<FindCoupons200Response> {
            return localVarFp.createCoupon(companyId, couponDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific coupon associated with a company. Checks if the coupon is in active use before deletion.
         * @summary Delete a coupon
         * @param {string} id The unique identifier of the coupon to delete.
         * @param {string} companyId The unique identifier of the company associated with the coupon.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoupon(id: string, companyId: string, options?: any): AxiosPromise<GetInvoice200Response> {
            return localVarFp.deleteCoupon(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of coupons based on various criteria including product IDs, date ranges, and pagination. Returns an array of CouponDto objects
         * @summary Get list of all coupons
         * @param {string} companyId The company ID.
         * @param {Array<any>} productIds An array of product IDs to filter coupons by.
         * @param {string} [fromStartDate] Start date to filter coupons created on or after this date.
         * @param {string} [toStartDate] End date to filter coupons created on or before this date.
         * @param {string} [fromEndDate] Start date to filter coupons valid on or after this date.
         * @param {string} [toEndDate] End date to filter coupons valid on or before this date.
         * @param {number} [currentPage] The current page number for pagination.
         * @param {number} [perPage] The number of coupons to display per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCoupons(companyId: string, productIds: Array<any>, fromStartDate?: string, toStartDate?: string, fromEndDate?: string, toEndDate?: string, currentPage?: number, perPage?: number, options?: any): AxiosPromise<FindCoupons200Response> {
            return localVarFp.findCoupons(companyId, productIds, fromStartDate, toStartDate, fromEndDate, toEndDate, currentPage, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a coupon\'s details based on its unique ID and company. Returns CouponDto object
         * @summary Get a coupon
         * @param {string} id The unique identifier of the coupon.
         * @param {string} companyId The company\&#39;s unique identifier associated with the coupon.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoupon(id: string, companyId: string, options?: any): AxiosPromise<FindCoupons200Response> {
            return localVarFp.getCoupon(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the details of an existing coupon associated with a specific company. Returns updated CouponDto object
         * @summary Update coupon
         * @param {string} companyId The unique identifier of the company associated with the coupon.
         * @param {string} id The unique identifier of the coupon to update.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCoupon(companyId: string, id: string, body: object, options?: any): AxiosPromise<FindCoupons200Response> {
            return localVarFp.updateCoupon(companyId, id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CouponsApi - object-oriented interface
 * @export
 * @class CouponsApi
 * @extends {BaseAPI}
 */
export class CouponsApi extends BaseAPI {
    /**
     * Create a new coupon for a specific company. Returns created coupon as CouponDto object
     * @summary Creates a coupon
     * @param {string} companyId The unique identifier of the company to associate the coupon with.
     * @param {CouponDto} couponDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApi
     */
    public createCoupon(companyId: string, couponDto: CouponDto, options?: RawAxiosRequestConfig) {
        return CouponsApiFp(this.configuration).createCoupon(companyId, couponDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific coupon associated with a company. Checks if the coupon is in active use before deletion.
     * @summary Delete a coupon
     * @param {string} id The unique identifier of the coupon to delete.
     * @param {string} companyId The unique identifier of the company associated with the coupon.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApi
     */
    public deleteCoupon(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return CouponsApiFp(this.configuration).deleteCoupon(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of coupons based on various criteria including product IDs, date ranges, and pagination. Returns an array of CouponDto objects
     * @summary Get list of all coupons
     * @param {string} companyId The company ID.
     * @param {Array<any>} productIds An array of product IDs to filter coupons by.
     * @param {string} [fromStartDate] Start date to filter coupons created on or after this date.
     * @param {string} [toStartDate] End date to filter coupons created on or before this date.
     * @param {string} [fromEndDate] Start date to filter coupons valid on or after this date.
     * @param {string} [toEndDate] End date to filter coupons valid on or before this date.
     * @param {number} [currentPage] The current page number for pagination.
     * @param {number} [perPage] The number of coupons to display per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApi
     */
    public findCoupons(companyId: string, productIds: Array<any>, fromStartDate?: string, toStartDate?: string, fromEndDate?: string, toEndDate?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return CouponsApiFp(this.configuration).findCoupons(companyId, productIds, fromStartDate, toStartDate, fromEndDate, toEndDate, currentPage, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a coupon\'s details based on its unique ID and company. Returns CouponDto object
     * @summary Get a coupon
     * @param {string} id The unique identifier of the coupon.
     * @param {string} companyId The company\&#39;s unique identifier associated with the coupon.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApi
     */
    public getCoupon(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return CouponsApiFp(this.configuration).getCoupon(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the details of an existing coupon associated with a specific company. Returns updated CouponDto object
     * @summary Update coupon
     * @param {string} companyId The unique identifier of the company associated with the coupon.
     * @param {string} id The unique identifier of the coupon to update.
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApi
     */
    public updateCoupon(companyId: string, id: string, body: object, options?: RawAxiosRequestConfig) {
        return CouponsApiFp(this.configuration).updateCoupon(companyId, id, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateItemsControllerActivateItem: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events/order/status/in-progress/activate-items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateTrialProductsControllerActivateTrialProducts: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events/order/created/activate-trial-items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completedPaymentListenerPaymentCompleted: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events/payment/created/process-payment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyIntegrationsNotifyIntegrations: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events/user/created/notify-integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pubSubResponseControllerFailureResponse: async (body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('pubSubResponseControllerFailureResponse', 'body', body)
            const localVarPath = `/pubsub-response/failure`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pubSubResponseControllerSuccessResponse: async (body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('pubSubResponseControllerSuccessResponse', 'body', body)
            const localVarPath = `/pubsub-response/success`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pubSubResponseControllerTaskResponse: async (body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('pubSubResponseControllerTaskResponse', 'body', body)
            const localVarPath = `/pubsub-response/task`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailControllerSendEmail: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events/order/status/completed/send-email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateItemsControllerActivateItem(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateItemsControllerActivateItem(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.activateItemsControllerActivateItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateTrialProductsControllerActivateTrialProducts(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateTrialProductsControllerActivateTrialProducts(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.activateTrialProductsControllerActivateTrialProducts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completedPaymentListenerPaymentCompleted(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completedPaymentListenerPaymentCompleted(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.completedPaymentListenerPaymentCompleted']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notifyIntegrationsNotifyIntegrations(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notifyIntegrationsNotifyIntegrations(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.notifyIntegrationsNotifyIntegrations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pubSubResponseControllerFailureResponse(body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pubSubResponseControllerFailureResponse(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.pubSubResponseControllerFailureResponse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pubSubResponseControllerSuccessResponse(body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pubSubResponseControllerSuccessResponse(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.pubSubResponseControllerSuccessResponse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pubSubResponseControllerTaskResponse(body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pubSubResponseControllerTaskResponse(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.pubSubResponseControllerTaskResponse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendEmailControllerSendEmail(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendEmailControllerSendEmail(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.sendEmailControllerSendEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateItemsControllerActivateItem(options?: any): AxiosPromise<void> {
            return localVarFp.activateItemsControllerActivateItem(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateTrialProductsControllerActivateTrialProducts(options?: any): AxiosPromise<void> {
            return localVarFp.activateTrialProductsControllerActivateTrialProducts(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completedPaymentListenerPaymentCompleted(options?: any): AxiosPromise<void> {
            return localVarFp.completedPaymentListenerPaymentCompleted(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyIntegrationsNotifyIntegrations(options?: any): AxiosPromise<void> {
            return localVarFp.notifyIntegrationsNotifyIntegrations(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pubSubResponseControllerFailureResponse(body: object, options?: any): AxiosPromise<void> {
            return localVarFp.pubSubResponseControllerFailureResponse(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pubSubResponseControllerSuccessResponse(body: object, options?: any): AxiosPromise<void> {
            return localVarFp.pubSubResponseControllerSuccessResponse(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pubSubResponseControllerTaskResponse(body: object, options?: any): AxiosPromise<void> {
            return localVarFp.pubSubResponseControllerTaskResponse(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailControllerSendEmail(options?: any): AxiosPromise<void> {
            return localVarFp.sendEmailControllerSendEmail(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public activateItemsControllerActivateItem(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).activateItemsControllerActivateItem(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public activateTrialProductsControllerActivateTrialProducts(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).activateTrialProductsControllerActivateTrialProducts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public completedPaymentListenerPaymentCompleted(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).completedPaymentListenerPaymentCompleted(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public notifyIntegrationsNotifyIntegrations(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).notifyIntegrationsNotifyIntegrations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public pubSubResponseControllerFailureResponse(body: object, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).pubSubResponseControllerFailureResponse(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public pubSubResponseControllerSuccessResponse(body: object, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).pubSubResponseControllerSuccessResponse(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public pubSubResponseControllerTaskResponse(body: object, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).pubSubResponseControllerTaskResponse(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public sendEmailControllerSendEmail(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).sendEmailControllerSendEmail(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DomainCategoriesApi - axios parameter creator
 * @export
 */
export const DomainCategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new domain category. Returns a DomainCategoryDto.
         * @summary Creates a new domainCategory
         * @param {string} companyId companyId
         * @param {DomainCategoryDto} domainCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomainCategory: async (companyId: string, domainCategoryDto: DomainCategoryDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('createDomainCategory', 'companyId', companyId)
            // verify required parameter 'domainCategoryDto' is not null or undefined
            assertParamExists('createDomainCategory', 'domainCategoryDto', domainCategoryDto)
            const localVarPath = `/domain-categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainCategoryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a certain domain category. Returns a DomainCategoryDto.
         * @summary Delete a domainCategory
         * @param {string} companyId companyId
         * @param {string} id DomainCategory ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomainCategory: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deleteDomainCategory', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDomainCategory', 'id', id)
            const localVarPath = `/domain-categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all domain categories. Returns an array of DomainCategoryDto.
         * @summary Get list of all domainCategories
         * @param {string} companyId companyId
         * @param {string} [description] 
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDomainCategories: async (companyId: string, description?: string, currentPage?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('findDomainCategories', 'companyId', companyId)
            const localVarPath = `/domain-categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a certain domain category. Returns a DomainCategoryDto.
         * @summary Get a domainCategory
         * @param {string} companyId companyId
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainCategory: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getDomainCategory', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDomainCategory', 'id', id)
            const localVarPath = `/domain-categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a certain domain category. Returns a DomainCategoryDto.
         * @summary Update a domainCategory
         * @param {string} companyId companyId
         * @param {string} id DomainCategory ID
         * @param {DomainCategoryDto} domainCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainCategory: async (companyId: string, id: string, domainCategoryDto: DomainCategoryDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainCategory', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainCategory', 'id', id)
            // verify required parameter 'domainCategoryDto' is not null or undefined
            assertParamExists('updateDomainCategory', 'domainCategoryDto', domainCategoryDto)
            const localVarPath = `/domain-categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainCategoryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DomainCategoriesApi - functional programming interface
 * @export
 */
export const DomainCategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DomainCategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new domain category. Returns a DomainCategoryDto.
         * @summary Creates a new domainCategory
         * @param {string} companyId companyId
         * @param {DomainCategoryDto} domainCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDomainCategory(companyId: string, domainCategoryDto: DomainCategoryDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDomainCategory201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDomainCategory(companyId, domainCategoryDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainCategoriesApi.createDomainCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a certain domain category. Returns a DomainCategoryDto.
         * @summary Delete a domainCategory
         * @param {string} companyId companyId
         * @param {string} id DomainCategory ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDomainCategory(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDomainCategory(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainCategoriesApi.deleteDomainCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all domain categories. Returns an array of DomainCategoryDto.
         * @summary Get list of all domainCategories
         * @param {string} companyId companyId
         * @param {string} [description] 
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findDomainCategories(companyId: string, description?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindDomainCategories200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findDomainCategories(companyId, description, currentPage, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainCategoriesApi.findDomainCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a certain domain category. Returns a DomainCategoryDto.
         * @summary Get a domainCategory
         * @param {string} companyId companyId
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDomainCategory(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDomainCategory201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDomainCategory(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainCategoriesApi.getDomainCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a certain domain category. Returns a DomainCategoryDto.
         * @summary Update a domainCategory
         * @param {string} companyId companyId
         * @param {string} id DomainCategory ID
         * @param {DomainCategoryDto} domainCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainCategory(companyId: string, id: string, domainCategoryDto: DomainCategoryDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDomainCategory201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainCategory(companyId, id, domainCategoryDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainCategoriesApi.updateDomainCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DomainCategoriesApi - factory interface
 * @export
 */
export const DomainCategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DomainCategoriesApiFp(configuration)
    return {
        /**
         * Creates a new domain category. Returns a DomainCategoryDto.
         * @summary Creates a new domainCategory
         * @param {string} companyId companyId
         * @param {DomainCategoryDto} domainCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomainCategory(companyId: string, domainCategoryDto: DomainCategoryDto, options?: any): AxiosPromise<CreateDomainCategory201Response> {
            return localVarFp.createDomainCategory(companyId, domainCategoryDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a certain domain category. Returns a DomainCategoryDto.
         * @summary Delete a domainCategory
         * @param {string} companyId companyId
         * @param {string} id DomainCategory ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomainCategory(companyId: string, id: string, options?: any): AxiosPromise<GetInvoice200Response> {
            return localVarFp.deleteDomainCategory(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all domain categories. Returns an array of DomainCategoryDto.
         * @summary Get list of all domainCategories
         * @param {string} companyId companyId
         * @param {string} [description] 
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDomainCategories(companyId: string, description?: string, currentPage?: number, perPage?: number, options?: any): AxiosPromise<FindDomainCategories200Response> {
            return localVarFp.findDomainCategories(companyId, description, currentPage, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a certain domain category. Returns a DomainCategoryDto.
         * @summary Get a domainCategory
         * @param {string} companyId companyId
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainCategory(companyId: string, id: string, options?: any): AxiosPromise<CreateDomainCategory201Response> {
            return localVarFp.getDomainCategory(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a certain domain category. Returns a DomainCategoryDto.
         * @summary Update a domainCategory
         * @param {string} companyId companyId
         * @param {string} id DomainCategory ID
         * @param {DomainCategoryDto} domainCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainCategory(companyId: string, id: string, domainCategoryDto: DomainCategoryDto, options?: any): AxiosPromise<CreateDomainCategory201Response> {
            return localVarFp.updateDomainCategory(companyId, id, domainCategoryDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DomainCategoriesApi - object-oriented interface
 * @export
 * @class DomainCategoriesApi
 * @extends {BaseAPI}
 */
export class DomainCategoriesApi extends BaseAPI {
    /**
     * Creates a new domain category. Returns a DomainCategoryDto.
     * @summary Creates a new domainCategory
     * @param {string} companyId companyId
     * @param {DomainCategoryDto} domainCategoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainCategoriesApi
     */
    public createDomainCategory(companyId: string, domainCategoryDto: DomainCategoryDto, options?: RawAxiosRequestConfig) {
        return DomainCategoriesApiFp(this.configuration).createDomainCategory(companyId, domainCategoryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a certain domain category. Returns a DomainCategoryDto.
     * @summary Delete a domainCategory
     * @param {string} companyId companyId
     * @param {string} id DomainCategory ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainCategoriesApi
     */
    public deleteDomainCategory(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return DomainCategoriesApiFp(this.configuration).deleteDomainCategory(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all domain categories. Returns an array of DomainCategoryDto.
     * @summary Get list of all domainCategories
     * @param {string} companyId companyId
     * @param {string} [description] 
     * @param {number} [currentPage] current page
     * @param {number} [perPage] per Page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainCategoriesApi
     */
    public findDomainCategories(companyId: string, description?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return DomainCategoriesApiFp(this.configuration).findDomainCategories(companyId, description, currentPage, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a certain domain category. Returns a DomainCategoryDto.
     * @summary Get a domainCategory
     * @param {string} companyId companyId
     * @param {string} id ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainCategoriesApi
     */
    public getDomainCategory(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return DomainCategoriesApiFp(this.configuration).getDomainCategory(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a certain domain category. Returns a DomainCategoryDto.
     * @summary Update a domainCategory
     * @param {string} companyId companyId
     * @param {string} id DomainCategory ID
     * @param {DomainCategoryDto} domainCategoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainCategoriesApi
     */
    public updateDomainCategory(companyId: string, id: string, domainCategoryDto: DomainCategoryDto, options?: RawAxiosRequestConfig) {
        return DomainCategoriesApiFp(this.configuration).updateDomainCategory(companyId, id, domainCategoryDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DomainContactsApi - axios parameter creator
 * @export
 */
export const DomainContactsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new domain contact associated with a specific company based on the provided \'companyId\' path parameter. You should provide the details of the new domain contact in the request body using the \'DomainContactDto\'. This endpoint returns the domain contact data(\'DomainContactDto\') with a 201 status code upon success.
         * @summary Creates a new domain contact
         * @param {string} companyId companyId
         * @param {DomainContactDto} domainContactDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomainContact: async (companyId: string, domainContactDto: DomainContactDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('createDomainContact', 'companyId', companyId)
            // verify required parameter 'domainContactDto' is not null or undefined
            assertParamExists('createDomainContact', 'domainContactDto', domainContactDto)
            const localVarPath = `/domain-contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainContactDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a domain contact associated with a specific company. Provide the \'id\' of the domain contact you want to delete and the \'companyId\' it belongs to as path parameters. This endpoint returns a success response with a 200 status code upon successful deletion.
         * @summary Delete an domain contact
         * @param {string} id The ID of the domain contact to delete.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomainContact: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDomainContact', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deleteDomainContact', 'companyId', companyId)
            const localVarPath = `/domain-contacts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of domain contacts associated with a specific company based on the provided parameters. You can filter the results by name, street, postcode, organization, city, state, telephone, fax, or email using the \'query\' parameter. If you want to filter by the country code, you can use the \'country\' parameter. You can also paginate the results by specifying the \'currentPage\' and \'perPage\' parameters. This endpoint returns a list of domain contacts (type: DomainContactDto) associated with the specified company.
         * @summary Get list of all domain contacts
         * @param {string} companyId The ID of the company for which you want to retrieve domain contacts.
         * @param {string} [query] A query string for searching domain contacts by name, street, postcode, organization, city, state, telephone, fax, or email. (Optional)
         * @param {FindDomainContactsCountryEnum} [country] Filter domain contacts by the ISO 3166-1-alpha-2 country code. (Optional)
         * @param {string} [userId] Filter by the ID of the parent domain contact. (Optional)
         * @param {number} [currentPage] The current page number for pagination. (Optional)
         * @param {number} [perPage] The number of items to display per page. (Optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDomainContacts: async (companyId: string, query?: string, country?: FindDomainContactsCountryEnum, userId?: string, currentPage?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('findDomainContacts', 'companyId', companyId)
            const localVarPath = `/domain-contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a specific domain contact associated with a company based on the provided parameters. This endpoint allows you to retrieve a specific domain contact by specifying its \'id\' and the \'companyId\' it belongs to. It returns detailed information about the domain contact.
         * @summary Get a domain contacts
         * @param {string} id The ID of the domain contact.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainContact: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDomainContact', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getDomainContact', 'companyId', companyId)
            const localVarPath = `/domain-contacts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact you want to update and the \'companyId\' it belongs to as path parameters. You should include the updated domain contact details in the request body using \'DomainContactDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update domain contact
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {string} id The ID of the domain contact to update.
         * @param {DomainContactDto} domainContactDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContact: async (companyId: string, id: string, domainContactDto: DomainContactDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainContact', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainContact', 'id', id)
            // verify required parameter 'domainContactDto' is not null or undefined
            assertParamExists('updateDomainContact', 'domainContactDto', domainContactDto)
            const localVarPath = `/domain-contacts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainContactDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'AfnicAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update afnic additional data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {AfnicAdditionalDataDto} afnicAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactAfnicAdditionalData: async (id: string, companyId: string, afnicAdditionalDataDto: AfnicAdditionalDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainContactAfnicAdditionalData', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainContactAfnicAdditionalData', 'companyId', companyId)
            // verify required parameter 'afnicAdditionalDataDto' is not null or undefined
            assertParamExists('updateDomainContactAfnicAdditionalData', 'afnicAdditionalDataDto', afnicAdditionalDataDto)
            const localVarPath = `/domain-contacts/{id}/additional/afnic`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(afnicAdditionalDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'CatAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update Cat additional data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {CatAdditionalDataDto} catAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactCatAdditionalData: async (id: string, companyId: string, catAdditionalDataDto: CatAdditionalDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainContactCatAdditionalData', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainContactCatAdditionalData', 'companyId', companyId)
            // verify required parameter 'catAdditionalDataDto' is not null or undefined
            assertParamExists('updateDomainContactCatAdditionalData', 'catAdditionalDataDto', catAdditionalDataDto)
            const localVarPath = `/domain-contacts/{id}/additional/cat`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(catAdditionalDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'DeAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update de additional data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {DeAdditionalDataDto} deAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactDeAdditionalData: async (id: string, companyId: string, deAdditionalDataDto: DeAdditionalDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainContactDeAdditionalData', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainContactDeAdditionalData', 'companyId', companyId)
            // verify required parameter 'deAdditionalDataDto' is not null or undefined
            assertParamExists('updateDomainContactDeAdditionalData', 'deAdditionalDataDto', deAdditionalDataDto)
            const localVarPath = `/domain-contacts/{id}/additional/de`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deAdditionalDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'EsAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update es additional data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {EsAdditionalDataDto} esAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactEsAdditionalData: async (id: string, companyId: string, esAdditionalDataDto: EsAdditionalDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainContactEsAdditionalData', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainContactEsAdditionalData', 'companyId', companyId)
            // verify required parameter 'esAdditionalDataDto' is not null or undefined
            assertParamExists('updateDomainContactEsAdditionalData', 'esAdditionalDataDto', esAdditionalDataDto)
            const localVarPath = `/domain-contacts/{id}/additional/es`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(esAdditionalDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'EuBeAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update eu-be additional data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {EuBeAdditionalDataDto} euBeAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactEuBeAdditionalData: async (id: string, companyId: string, euBeAdditionalDataDto: EuBeAdditionalDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainContactEuBeAdditionalData', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainContactEuBeAdditionalData', 'companyId', companyId)
            // verify required parameter 'euBeAdditionalDataDto' is not null or undefined
            assertParamExists('updateDomainContactEuBeAdditionalData', 'euBeAdditionalDataDto', euBeAdditionalDataDto)
            const localVarPath = `/domain-contacts/{id}/additional/eu-be`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(euBeAdditionalDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'ItAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update IT additional data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {ItAdditionalDataDto} itAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactItAdditionalData: async (id: string, companyId: string, itAdditionalDataDto: ItAdditionalDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainContactItAdditionalData', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainContactItAdditionalData', 'companyId', companyId)
            // verify required parameter 'itAdditionalDataDto' is not null or undefined
            assertParamExists('updateDomainContactItAdditionalData', 'itAdditionalDataDto', itAdditionalDataDto)
            const localVarPath = `/domain-contacts/{id}/additional/it`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itAdditionalDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'ItAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update IT additional data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {LvAdditionalDataDto} lvAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactLvAdditionalData: async (id: string, companyId: string, lvAdditionalDataDto: LvAdditionalDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainContactLvAdditionalData', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainContactLvAdditionalData', 'companyId', companyId)
            // verify required parameter 'lvAdditionalDataDto' is not null or undefined
            assertParamExists('updateDomainContactLvAdditionalData', 'lvAdditionalDataDto', lvAdditionalDataDto)
            const localVarPath = `/domain-contacts/{id}/additional/lv`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lvAdditionalDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'NlAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update NL additional data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {NlAdditionalDataDto} nlAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactNlAdditionalData: async (id: string, companyId: string, nlAdditionalDataDto: NlAdditionalDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainContactNlAdditionalData', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainContactNlAdditionalData', 'companyId', companyId)
            // verify required parameter 'nlAdditionalDataDto' is not null or undefined
            assertParamExists('updateDomainContactNlAdditionalData', 'nlAdditionalDataDto', nlAdditionalDataDto)
            const localVarPath = `/domain-contacts/{id}/additional/nl`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nlAdditionalDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update additional data for a domain contact in the \'Pro\' category associated with a specific company. Specify the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. Include the updated additional data details in the request body using \'ProAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update Pro additional data
         * @param {string} id The ID of the domain contact to update.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {ProAdditionalDataDto} proAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactProAdditionalData: async (id: string, companyId: string, proAdditionalDataDto: ProAdditionalDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainContactProAdditionalData', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainContactProAdditionalData', 'companyId', companyId)
            // verify required parameter 'proAdditionalDataDto' is not null or undefined
            assertParamExists('updateDomainContactProAdditionalData', 'proAdditionalDataDto', proAdditionalDataDto)
            const localVarPath = `/domain-contacts/{id}/additional/pro`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(proAdditionalDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update additional data for a domain contact in the \'UK\' category associated with a specific company. Specify the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. Include the updated additional data details in the request body using \'UkAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update UK additional data
         * @param {string} id The ID of the domain contact to update.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {UkAdditionalDataDto} ukAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactUkAdditionalData: async (id: string, companyId: string, ukAdditionalDataDto: UkAdditionalDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainContactUkAdditionalData', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainContactUkAdditionalData', 'companyId', companyId)
            // verify required parameter 'ukAdditionalDataDto' is not null or undefined
            assertParamExists('updateDomainContactUkAdditionalData', 'ukAdditionalDataDto', ukAdditionalDataDto)
            const localVarPath = `/domain-contacts/{id}/additional/uk`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ukAdditionalDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update additional data for a domain contact in the \'US\' category associated with a specific company. Specify the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. Include the updated additional data details in the request body using \'UsAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update US additional data
         * @param {string} id The ID of the domain contact to update.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {UsAdditionalDataDto} usAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactUsAdditionalData: async (id: string, companyId: string, usAdditionalDataDto: UsAdditionalDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainContactUsAdditionalData', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainContactUsAdditionalData', 'companyId', companyId)
            // verify required parameter 'usAdditionalDataDto' is not null or undefined
            assertParamExists('updateDomainContactUsAdditionalData', 'usAdditionalDataDto', usAdditionalDataDto)
            const localVarPath = `/domain-contacts/{id}/additional/us`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usAdditionalDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DomainContactsApi - functional programming interface
 * @export
 */
export const DomainContactsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DomainContactsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new domain contact associated with a specific company based on the provided \'companyId\' path parameter. You should provide the details of the new domain contact in the request body using the \'DomainContactDto\'. This endpoint returns the domain contact data(\'DomainContactDto\') with a 201 status code upon success.
         * @summary Creates a new domain contact
         * @param {string} companyId companyId
         * @param {DomainContactDto} domainContactDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDomainContact(companyId: string, domainContactDto: DomainContactDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDomainContact200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDomainContact(companyId, domainContactDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainContactsApi.createDomainContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a domain contact associated with a specific company. Provide the \'id\' of the domain contact you want to delete and the \'companyId\' it belongs to as path parameters. This endpoint returns a success response with a 200 status code upon successful deletion.
         * @summary Delete an domain contact
         * @param {string} id The ID of the domain contact to delete.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDomainContact(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDomainContact(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainContactsApi.deleteDomainContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of domain contacts associated with a specific company based on the provided parameters. You can filter the results by name, street, postcode, organization, city, state, telephone, fax, or email using the \'query\' parameter. If you want to filter by the country code, you can use the \'country\' parameter. You can also paginate the results by specifying the \'currentPage\' and \'perPage\' parameters. This endpoint returns a list of domain contacts (type: DomainContactDto) associated with the specified company.
         * @summary Get list of all domain contacts
         * @param {string} companyId The ID of the company for which you want to retrieve domain contacts.
         * @param {string} [query] A query string for searching domain contacts by name, street, postcode, organization, city, state, telephone, fax, or email. (Optional)
         * @param {FindDomainContactsCountryEnum} [country] Filter domain contacts by the ISO 3166-1-alpha-2 country code. (Optional)
         * @param {string} [userId] Filter by the ID of the parent domain contact. (Optional)
         * @param {number} [currentPage] The current page number for pagination. (Optional)
         * @param {number} [perPage] The number of items to display per page. (Optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findDomainContacts(companyId: string, query?: string, country?: FindDomainContactsCountryEnum, userId?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindDomainContacts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findDomainContacts(companyId, query, country, userId, currentPage, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainContactsApi.findDomainContacts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a specific domain contact associated with a company based on the provided parameters. This endpoint allows you to retrieve a specific domain contact by specifying its \'id\' and the \'companyId\' it belongs to. It returns detailed information about the domain contact.
         * @summary Get a domain contacts
         * @param {string} id The ID of the domain contact.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDomainContact(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDomainContact200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDomainContact(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainContactsApi.getDomainContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact you want to update and the \'companyId\' it belongs to as path parameters. You should include the updated domain contact details in the request body using \'DomainContactDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update domain contact
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {string} id The ID of the domain contact to update.
         * @param {DomainContactDto} domainContactDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainContact(companyId: string, id: string, domainContactDto: DomainContactDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDomainContact200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainContact(companyId, id, domainContactDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainContactsApi.updateDomainContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'AfnicAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update afnic additional data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {AfnicAdditionalDataDto} afnicAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainContactAfnicAdditionalData(id: string, companyId: string, afnicAdditionalDataDto: AfnicAdditionalDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDomainContact200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainContactAfnicAdditionalData(id, companyId, afnicAdditionalDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainContactsApi.updateDomainContactAfnicAdditionalData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'CatAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update Cat additional data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {CatAdditionalDataDto} catAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainContactCatAdditionalData(id: string, companyId: string, catAdditionalDataDto: CatAdditionalDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDomainContact200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainContactCatAdditionalData(id, companyId, catAdditionalDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainContactsApi.updateDomainContactCatAdditionalData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'DeAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update de additional data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {DeAdditionalDataDto} deAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainContactDeAdditionalData(id: string, companyId: string, deAdditionalDataDto: DeAdditionalDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDomainContact200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainContactDeAdditionalData(id, companyId, deAdditionalDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainContactsApi.updateDomainContactDeAdditionalData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'EsAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update es additional data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {EsAdditionalDataDto} esAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainContactEsAdditionalData(id: string, companyId: string, esAdditionalDataDto: EsAdditionalDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDomainContact200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainContactEsAdditionalData(id, companyId, esAdditionalDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainContactsApi.updateDomainContactEsAdditionalData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'EuBeAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update eu-be additional data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {EuBeAdditionalDataDto} euBeAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainContactEuBeAdditionalData(id: string, companyId: string, euBeAdditionalDataDto: EuBeAdditionalDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDomainContact200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainContactEuBeAdditionalData(id, companyId, euBeAdditionalDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainContactsApi.updateDomainContactEuBeAdditionalData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'ItAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update IT additional data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {ItAdditionalDataDto} itAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainContactItAdditionalData(id: string, companyId: string, itAdditionalDataDto: ItAdditionalDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDomainContact200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainContactItAdditionalData(id, companyId, itAdditionalDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainContactsApi.updateDomainContactItAdditionalData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'ItAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update IT additional data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {LvAdditionalDataDto} lvAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainContactLvAdditionalData(id: string, companyId: string, lvAdditionalDataDto: LvAdditionalDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDomainContact200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainContactLvAdditionalData(id, companyId, lvAdditionalDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainContactsApi.updateDomainContactLvAdditionalData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'NlAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update NL additional data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {NlAdditionalDataDto} nlAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainContactNlAdditionalData(id: string, companyId: string, nlAdditionalDataDto: NlAdditionalDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDomainContact200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainContactNlAdditionalData(id, companyId, nlAdditionalDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainContactsApi.updateDomainContactNlAdditionalData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update additional data for a domain contact in the \'Pro\' category associated with a specific company. Specify the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. Include the updated additional data details in the request body using \'ProAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update Pro additional data
         * @param {string} id The ID of the domain contact to update.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {ProAdditionalDataDto} proAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainContactProAdditionalData(id: string, companyId: string, proAdditionalDataDto: ProAdditionalDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDomainContact200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainContactProAdditionalData(id, companyId, proAdditionalDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainContactsApi.updateDomainContactProAdditionalData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update additional data for a domain contact in the \'UK\' category associated with a specific company. Specify the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. Include the updated additional data details in the request body using \'UkAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update UK additional data
         * @param {string} id The ID of the domain contact to update.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {UkAdditionalDataDto} ukAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainContactUkAdditionalData(id: string, companyId: string, ukAdditionalDataDto: UkAdditionalDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDomainContact200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainContactUkAdditionalData(id, companyId, ukAdditionalDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainContactsApi.updateDomainContactUkAdditionalData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update additional data for a domain contact in the \'US\' category associated with a specific company. Specify the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. Include the updated additional data details in the request body using \'UsAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update US additional data
         * @param {string} id The ID of the domain contact to update.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {UsAdditionalDataDto} usAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainContactUsAdditionalData(id: string, companyId: string, usAdditionalDataDto: UsAdditionalDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDomainContact200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainContactUsAdditionalData(id, companyId, usAdditionalDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainContactsApi.updateDomainContactUsAdditionalData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DomainContactsApi - factory interface
 * @export
 */
export const DomainContactsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DomainContactsApiFp(configuration)
    return {
        /**
         * Creates a new domain contact associated with a specific company based on the provided \'companyId\' path parameter. You should provide the details of the new domain contact in the request body using the \'DomainContactDto\'. This endpoint returns the domain contact data(\'DomainContactDto\') with a 201 status code upon success.
         * @summary Creates a new domain contact
         * @param {string} companyId companyId
         * @param {DomainContactDto} domainContactDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomainContact(companyId: string, domainContactDto: DomainContactDto, options?: any): AxiosPromise<CreateDomainContact200Response> {
            return localVarFp.createDomainContact(companyId, domainContactDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a domain contact associated with a specific company. Provide the \'id\' of the domain contact you want to delete and the \'companyId\' it belongs to as path parameters. This endpoint returns a success response with a 200 status code upon successful deletion.
         * @summary Delete an domain contact
         * @param {string} id The ID of the domain contact to delete.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomainContact(id: string, companyId: string, options?: any): AxiosPromise<GetInvoice200Response> {
            return localVarFp.deleteDomainContact(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of domain contacts associated with a specific company based on the provided parameters. You can filter the results by name, street, postcode, organization, city, state, telephone, fax, or email using the \'query\' parameter. If you want to filter by the country code, you can use the \'country\' parameter. You can also paginate the results by specifying the \'currentPage\' and \'perPage\' parameters. This endpoint returns a list of domain contacts (type: DomainContactDto) associated with the specified company.
         * @summary Get list of all domain contacts
         * @param {string} companyId The ID of the company for which you want to retrieve domain contacts.
         * @param {string} [query] A query string for searching domain contacts by name, street, postcode, organization, city, state, telephone, fax, or email. (Optional)
         * @param {FindDomainContactsCountryEnum} [country] Filter domain contacts by the ISO 3166-1-alpha-2 country code. (Optional)
         * @param {string} [userId] Filter by the ID of the parent domain contact. (Optional)
         * @param {number} [currentPage] The current page number for pagination. (Optional)
         * @param {number} [perPage] The number of items to display per page. (Optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDomainContacts(companyId: string, query?: string, country?: FindDomainContactsCountryEnum, userId?: string, currentPage?: number, perPage?: number, options?: any): AxiosPromise<FindDomainContacts200Response> {
            return localVarFp.findDomainContacts(companyId, query, country, userId, currentPage, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a specific domain contact associated with a company based on the provided parameters. This endpoint allows you to retrieve a specific domain contact by specifying its \'id\' and the \'companyId\' it belongs to. It returns detailed information about the domain contact.
         * @summary Get a domain contacts
         * @param {string} id The ID of the domain contact.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainContact(id: string, companyId: string, options?: any): AxiosPromise<CreateDomainContact200Response> {
            return localVarFp.getDomainContact(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact you want to update and the \'companyId\' it belongs to as path parameters. You should include the updated domain contact details in the request body using \'DomainContactDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update domain contact
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {string} id The ID of the domain contact to update.
         * @param {DomainContactDto} domainContactDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContact(companyId: string, id: string, domainContactDto: DomainContactDto, options?: any): AxiosPromise<CreateDomainContact200Response> {
            return localVarFp.updateDomainContact(companyId, id, domainContactDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'AfnicAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update afnic additional data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {AfnicAdditionalDataDto} afnicAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactAfnicAdditionalData(id: string, companyId: string, afnicAdditionalDataDto: AfnicAdditionalDataDto, options?: any): AxiosPromise<CreateDomainContact200Response> {
            return localVarFp.updateDomainContactAfnicAdditionalData(id, companyId, afnicAdditionalDataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'CatAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update Cat additional data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {CatAdditionalDataDto} catAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactCatAdditionalData(id: string, companyId: string, catAdditionalDataDto: CatAdditionalDataDto, options?: any): AxiosPromise<CreateDomainContact200Response> {
            return localVarFp.updateDomainContactCatAdditionalData(id, companyId, catAdditionalDataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'DeAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update de additional data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {DeAdditionalDataDto} deAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactDeAdditionalData(id: string, companyId: string, deAdditionalDataDto: DeAdditionalDataDto, options?: any): AxiosPromise<CreateDomainContact200Response> {
            return localVarFp.updateDomainContactDeAdditionalData(id, companyId, deAdditionalDataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'EsAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update es additional data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {EsAdditionalDataDto} esAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactEsAdditionalData(id: string, companyId: string, esAdditionalDataDto: EsAdditionalDataDto, options?: any): AxiosPromise<CreateDomainContact200Response> {
            return localVarFp.updateDomainContactEsAdditionalData(id, companyId, esAdditionalDataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'EuBeAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update eu-be additional data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {EuBeAdditionalDataDto} euBeAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactEuBeAdditionalData(id: string, companyId: string, euBeAdditionalDataDto: EuBeAdditionalDataDto, options?: any): AxiosPromise<CreateDomainContact200Response> {
            return localVarFp.updateDomainContactEuBeAdditionalData(id, companyId, euBeAdditionalDataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'ItAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update IT additional data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {ItAdditionalDataDto} itAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactItAdditionalData(id: string, companyId: string, itAdditionalDataDto: ItAdditionalDataDto, options?: any): AxiosPromise<CreateDomainContact200Response> {
            return localVarFp.updateDomainContactItAdditionalData(id, companyId, itAdditionalDataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'ItAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update IT additional data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {LvAdditionalDataDto} lvAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactLvAdditionalData(id: string, companyId: string, lvAdditionalDataDto: LvAdditionalDataDto, options?: any): AxiosPromise<CreateDomainContact200Response> {
            return localVarFp.updateDomainContactLvAdditionalData(id, companyId, lvAdditionalDataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'NlAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update NL additional data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {NlAdditionalDataDto} nlAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactNlAdditionalData(id: string, companyId: string, nlAdditionalDataDto: NlAdditionalDataDto, options?: any): AxiosPromise<CreateDomainContact200Response> {
            return localVarFp.updateDomainContactNlAdditionalData(id, companyId, nlAdditionalDataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Update additional data for a domain contact in the \'Pro\' category associated with a specific company. Specify the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. Include the updated additional data details in the request body using \'ProAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update Pro additional data
         * @param {string} id The ID of the domain contact to update.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {ProAdditionalDataDto} proAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactProAdditionalData(id: string, companyId: string, proAdditionalDataDto: ProAdditionalDataDto, options?: any): AxiosPromise<CreateDomainContact200Response> {
            return localVarFp.updateDomainContactProAdditionalData(id, companyId, proAdditionalDataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Update additional data for a domain contact in the \'UK\' category associated with a specific company. Specify the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. Include the updated additional data details in the request body using \'UkAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update UK additional data
         * @param {string} id The ID of the domain contact to update.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {UkAdditionalDataDto} ukAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactUkAdditionalData(id: string, companyId: string, ukAdditionalDataDto: UkAdditionalDataDto, options?: any): AxiosPromise<CreateDomainContact200Response> {
            return localVarFp.updateDomainContactUkAdditionalData(id, companyId, ukAdditionalDataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Update additional data for a domain contact in the \'US\' category associated with a specific company. Specify the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. Include the updated additional data details in the request body using \'UsAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update US additional data
         * @param {string} id The ID of the domain contact to update.
         * @param {string} companyId The ID of the company associated with the domain contact.
         * @param {UsAdditionalDataDto} usAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactUsAdditionalData(id: string, companyId: string, usAdditionalDataDto: UsAdditionalDataDto, options?: any): AxiosPromise<CreateDomainContact200Response> {
            return localVarFp.updateDomainContactUsAdditionalData(id, companyId, usAdditionalDataDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DomainContactsApi - object-oriented interface
 * @export
 * @class DomainContactsApi
 * @extends {BaseAPI}
 */
export class DomainContactsApi extends BaseAPI {
    /**
     * Creates a new domain contact associated with a specific company based on the provided \'companyId\' path parameter. You should provide the details of the new domain contact in the request body using the \'DomainContactDto\'. This endpoint returns the domain contact data(\'DomainContactDto\') with a 201 status code upon success.
     * @summary Creates a new domain contact
     * @param {string} companyId companyId
     * @param {DomainContactDto} domainContactDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainContactsApi
     */
    public createDomainContact(companyId: string, domainContactDto: DomainContactDto, options?: RawAxiosRequestConfig) {
        return DomainContactsApiFp(this.configuration).createDomainContact(companyId, domainContactDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a domain contact associated with a specific company. Provide the \'id\' of the domain contact you want to delete and the \'companyId\' it belongs to as path parameters. This endpoint returns a success response with a 200 status code upon successful deletion.
     * @summary Delete an domain contact
     * @param {string} id The ID of the domain contact to delete.
     * @param {string} companyId The ID of the company associated with the domain contact.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainContactsApi
     */
    public deleteDomainContact(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return DomainContactsApiFp(this.configuration).deleteDomainContact(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of domain contacts associated with a specific company based on the provided parameters. You can filter the results by name, street, postcode, organization, city, state, telephone, fax, or email using the \'query\' parameter. If you want to filter by the country code, you can use the \'country\' parameter. You can also paginate the results by specifying the \'currentPage\' and \'perPage\' parameters. This endpoint returns a list of domain contacts (type: DomainContactDto) associated with the specified company.
     * @summary Get list of all domain contacts
     * @param {string} companyId The ID of the company for which you want to retrieve domain contacts.
     * @param {string} [query] A query string for searching domain contacts by name, street, postcode, organization, city, state, telephone, fax, or email. (Optional)
     * @param {FindDomainContactsCountryEnum} [country] Filter domain contacts by the ISO 3166-1-alpha-2 country code. (Optional)
     * @param {string} [userId] Filter by the ID of the parent domain contact. (Optional)
     * @param {number} [currentPage] The current page number for pagination. (Optional)
     * @param {number} [perPage] The number of items to display per page. (Optional)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainContactsApi
     */
    public findDomainContacts(companyId: string, query?: string, country?: FindDomainContactsCountryEnum, userId?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return DomainContactsApiFp(this.configuration).findDomainContacts(companyId, query, country, userId, currentPage, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a specific domain contact associated with a company based on the provided parameters. This endpoint allows you to retrieve a specific domain contact by specifying its \'id\' and the \'companyId\' it belongs to. It returns detailed information about the domain contact.
     * @summary Get a domain contacts
     * @param {string} id The ID of the domain contact.
     * @param {string} companyId The ID of the company associated with the domain contact.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainContactsApi
     */
    public getDomainContact(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return DomainContactsApiFp(this.configuration).getDomainContact(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact you want to update and the \'companyId\' it belongs to as path parameters. You should include the updated domain contact details in the request body using \'DomainContactDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
     * @summary Update domain contact
     * @param {string} companyId The ID of the company associated with the domain contact.
     * @param {string} id The ID of the domain contact to update.
     * @param {DomainContactDto} domainContactDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainContactsApi
     */
    public updateDomainContact(companyId: string, id: string, domainContactDto: DomainContactDto, options?: RawAxiosRequestConfig) {
        return DomainContactsApiFp(this.configuration).updateDomainContact(companyId, id, domainContactDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'AfnicAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
     * @summary Update afnic additional data
     * @param {string} id The ID of the domain contact to update additional data for.
     * @param {string} companyId The ID of the company associated with the domain contact.
     * @param {AfnicAdditionalDataDto} afnicAdditionalDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainContactsApi
     */
    public updateDomainContactAfnicAdditionalData(id: string, companyId: string, afnicAdditionalDataDto: AfnicAdditionalDataDto, options?: RawAxiosRequestConfig) {
        return DomainContactsApiFp(this.configuration).updateDomainContactAfnicAdditionalData(id, companyId, afnicAdditionalDataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'CatAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
     * @summary Update Cat additional data
     * @param {string} id The ID of the domain contact to update additional data for.
     * @param {string} companyId The ID of the company associated with the domain contact.
     * @param {CatAdditionalDataDto} catAdditionalDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainContactsApi
     */
    public updateDomainContactCatAdditionalData(id: string, companyId: string, catAdditionalDataDto: CatAdditionalDataDto, options?: RawAxiosRequestConfig) {
        return DomainContactsApiFp(this.configuration).updateDomainContactCatAdditionalData(id, companyId, catAdditionalDataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'DeAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
     * @summary Update de additional data
     * @param {string} id The ID of the domain contact to update additional data for.
     * @param {string} companyId The ID of the company associated with the domain contact.
     * @param {DeAdditionalDataDto} deAdditionalDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainContactsApi
     */
    public updateDomainContactDeAdditionalData(id: string, companyId: string, deAdditionalDataDto: DeAdditionalDataDto, options?: RawAxiosRequestConfig) {
        return DomainContactsApiFp(this.configuration).updateDomainContactDeAdditionalData(id, companyId, deAdditionalDataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'EsAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
     * @summary Update es additional data
     * @param {string} id The ID of the domain contact to update additional data for.
     * @param {string} companyId The ID of the company associated with the domain contact.
     * @param {EsAdditionalDataDto} esAdditionalDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainContactsApi
     */
    public updateDomainContactEsAdditionalData(id: string, companyId: string, esAdditionalDataDto: EsAdditionalDataDto, options?: RawAxiosRequestConfig) {
        return DomainContactsApiFp(this.configuration).updateDomainContactEsAdditionalData(id, companyId, esAdditionalDataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'EuBeAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
     * @summary Update eu-be additional data
     * @param {string} id The ID of the domain contact to update additional data for.
     * @param {string} companyId The ID of the company associated with the domain contact.
     * @param {EuBeAdditionalDataDto} euBeAdditionalDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainContactsApi
     */
    public updateDomainContactEuBeAdditionalData(id: string, companyId: string, euBeAdditionalDataDto: EuBeAdditionalDataDto, options?: RawAxiosRequestConfig) {
        return DomainContactsApiFp(this.configuration).updateDomainContactEuBeAdditionalData(id, companyId, euBeAdditionalDataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'ItAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
     * @summary Update IT additional data
     * @param {string} id The ID of the domain contact to update additional data for.
     * @param {string} companyId The ID of the company associated with the domain contact.
     * @param {ItAdditionalDataDto} itAdditionalDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainContactsApi
     */
    public updateDomainContactItAdditionalData(id: string, companyId: string, itAdditionalDataDto: ItAdditionalDataDto, options?: RawAxiosRequestConfig) {
        return DomainContactsApiFp(this.configuration).updateDomainContactItAdditionalData(id, companyId, itAdditionalDataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'ItAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
     * @summary Update IT additional data
     * @param {string} id The ID of the domain contact to update additional data for.
     * @param {string} companyId The ID of the company associated with the domain contact.
     * @param {LvAdditionalDataDto} lvAdditionalDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainContactsApi
     */
    public updateDomainContactLvAdditionalData(id: string, companyId: string, lvAdditionalDataDto: LvAdditionalDataDto, options?: RawAxiosRequestConfig) {
        return DomainContactsApiFp(this.configuration).updateDomainContactLvAdditionalData(id, companyId, lvAdditionalDataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'NlAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
     * @summary Update NL additional data
     * @param {string} id The ID of the domain contact to update additional data for.
     * @param {string} companyId The ID of the company associated with the domain contact.
     * @param {NlAdditionalDataDto} nlAdditionalDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainContactsApi
     */
    public updateDomainContactNlAdditionalData(id: string, companyId: string, nlAdditionalDataDto: NlAdditionalDataDto, options?: RawAxiosRequestConfig) {
        return DomainContactsApiFp(this.configuration).updateDomainContactNlAdditionalData(id, companyId, nlAdditionalDataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update additional data for a domain contact in the \'Pro\' category associated with a specific company. Specify the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. Include the updated additional data details in the request body using \'ProAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
     * @summary Update Pro additional data
     * @param {string} id The ID of the domain contact to update.
     * @param {string} companyId The ID of the company associated with the domain contact.
     * @param {ProAdditionalDataDto} proAdditionalDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainContactsApi
     */
    public updateDomainContactProAdditionalData(id: string, companyId: string, proAdditionalDataDto: ProAdditionalDataDto, options?: RawAxiosRequestConfig) {
        return DomainContactsApiFp(this.configuration).updateDomainContactProAdditionalData(id, companyId, proAdditionalDataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update additional data for a domain contact in the \'UK\' category associated with a specific company. Specify the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. Include the updated additional data details in the request body using \'UkAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
     * @summary Update UK additional data
     * @param {string} id The ID of the domain contact to update.
     * @param {string} companyId The ID of the company associated with the domain contact.
     * @param {UkAdditionalDataDto} ukAdditionalDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainContactsApi
     */
    public updateDomainContactUkAdditionalData(id: string, companyId: string, ukAdditionalDataDto: UkAdditionalDataDto, options?: RawAxiosRequestConfig) {
        return DomainContactsApiFp(this.configuration).updateDomainContactUkAdditionalData(id, companyId, ukAdditionalDataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update additional data for a domain contact in the \'US\' category associated with a specific company. Specify the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. Include the updated additional data details in the request body using \'UsAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
     * @summary Update US additional data
     * @param {string} id The ID of the domain contact to update.
     * @param {string} companyId The ID of the company associated with the domain contact.
     * @param {UsAdditionalDataDto} usAdditionalDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainContactsApi
     */
    public updateDomainContactUsAdditionalData(id: string, companyId: string, usAdditionalDataDto: UsAdditionalDataDto, options?: RawAxiosRequestConfig) {
        return DomainContactsApiFp(this.configuration).updateDomainContactUsAdditionalData(id, companyId, usAdditionalDataDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const FindDomainContactsCountryEnum = {
    Af: 'AF',
    Al: 'AL',
    Dz: 'DZ',
    As: 'AS',
    Ad: 'AD',
    Ao: 'AO',
    Ai: 'AI',
    Aq: 'AQ',
    Ag: 'AG',
    Ar: 'AR',
    Am: 'AM',
    Aw: 'AW',
    Au: 'AU',
    At: 'AT',
    Az: 'AZ',
    Bs: 'BS',
    Bh: 'BH',
    Bd: 'BD',
    Bb: 'BB',
    By: 'BY',
    Be: 'BE',
    Bz: 'BZ',
    Bj: 'BJ',
    Bm: 'BM',
    Bt: 'BT',
    Bo: 'BO',
    Bq: 'BQ',
    Ba: 'BA',
    Bw: 'BW',
    Bv: 'BV',
    Br: 'BR',
    Io: 'IO',
    Bn: 'BN',
    Bg: 'BG',
    Bf: 'BF',
    Bi: 'BI',
    Kh: 'KH',
    Cm: 'CM',
    Ca: 'CA',
    Cv: 'CV',
    Ky: 'KY',
    Cf: 'CF',
    Td: 'TD',
    Cl: 'CL',
    Cn: 'CN',
    Cx: 'CX',
    Cc: 'CC',
    Co: 'CO',
    Km: 'KM',
    Cg: 'CG',
    Cd: 'CD',
    Ck: 'CK',
    Cr: 'CR',
    Ci: 'CI',
    Hr: 'HR',
    Cu: 'CU',
    Cw: 'CW',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Dj: 'DJ',
    Dm: 'DM',
    Do: 'DO',
    Ec: 'EC',
    Eg: 'EG',
    Sv: 'SV',
    Gq: 'GQ',
    Er: 'ER',
    Ee: 'EE',
    Et: 'ET',
    Fk: 'FK',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Gf: 'GF',
    Pf: 'PF',
    Tf: 'TF',
    Ga: 'GA',
    Gm: 'GM',
    Ge: 'GE',
    De: 'DE',
    Gh: 'GH',
    Gi: 'GI',
    Gr: 'GR',
    Gl: 'GL',
    Gd: 'GD',
    Gp: 'GP',
    Gu: 'GU',
    Gt: 'GT',
    Gg: 'GG',
    Gn: 'GN',
    Gw: 'GW',
    Gy: 'GY',
    Ht: 'HT',
    Hm: 'HM',
    Va: 'VA',
    Hn: 'HN',
    Hk: 'HK',
    Hu: 'HU',
    Is: 'IS',
    In: 'IN',
    Id: 'ID',
    Ir: 'IR',
    Iq: 'IQ',
    Ie: 'IE',
    Im: 'IM',
    Il: 'IL',
    It: 'IT',
    Jm: 'JM',
    Jp: 'JP',
    Je: 'JE',
    Jo: 'JO',
    Kz: 'KZ',
    Ke: 'KE',
    Ki: 'KI',
    Kp: 'KP',
    Kr: 'KR',
    Kw: 'KW',
    Kg: 'KG',
    La: 'LA',
    Lv: 'LV',
    Lb: 'LB',
    Ls: 'LS',
    Lr: 'LR',
    Ly: 'LY',
    Li: 'LI',
    Lt: 'LT',
    Lu: 'LU',
    Mo: 'MO',
    Mk: 'MK',
    Mg: 'MG',
    Mw: 'MW',
    My: 'MY',
    Mv: 'MV',
    Ml: 'ML',
    Mt: 'MT',
    Mh: 'MH',
    Mq: 'MQ',
    Mr: 'MR',
    Mu: 'MU',
    Tn: 'TN',
    Tr: 'TR',
    Tm: 'TM',
    Tc: 'TC',
    Tv: 'TV',
    Ug: 'UG',
    Ua: 'UA',
    Ae: 'AE',
    Gb: 'GB',
    Us: 'US',
    Um: 'UM',
    Uy: 'UY',
    Uz: 'UZ',
    Vu: 'VU',
    Ve: 'VE',
    Vn: 'VN',
    Vg: 'VG',
    Vi: 'VI',
    Wf: 'WF',
    Eh: 'EH',
    Ye: 'YE',
    Zm: 'ZM',
    Zw: 'ZW',
    Yt: 'YT',
    Mx: 'MX',
    Fm: 'FM',
    Md: 'MD',
    Mc: 'MC',
    Mn: 'MN',
    Me: 'ME',
    Ms: 'MS',
    Ma: 'MA',
    Mz: 'MZ',
    Mm: 'MM',
    Na: 'NA',
    Nr: 'NR',
    Np: 'NP',
    Nl: 'NL',
    Nc: 'NC',
    Nz: 'NZ',
    Ni: 'NI',
    Ne: 'NE',
    Ng: 'NG',
    Nu: 'NU',
    Nf: 'NF',
    Mp: 'MP',
    No: 'NO',
    Om: 'OM',
    Pk: 'PK',
    Pw: 'PW',
    Ps: 'PS',
    Pa: 'PA',
    Pg: 'PG',
    Py: 'PY',
    Pe: 'PE',
    Ph: 'PH',
    Pn: 'PN',
    Pl: 'PL',
    Pt: 'PT',
    Pr: 'PR',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Ru: 'RU',
    Rw: 'RW',
    Bl: 'BL',
    Sh: 'SH',
    Kn: 'KN',
    Lc: 'LC',
    Mf: 'MF',
    Pm: 'PM',
    Vc: 'VC',
    Ws: 'WS',
    Sm: 'SM',
    St: 'ST',
    Sa: 'SA',
    Sn: 'SN',
    Rs: 'RS',
    Sc: 'SC',
    Sl: 'SL',
    Sg: 'SG',
    Sx: 'SX',
    Sk: 'SK',
    Si: 'SI',
    Sb: 'SB',
    So: 'SO',
    Za: 'ZA',
    Gs: 'GS',
    Ss: 'SS',
    Es: 'ES',
    Lk: 'LK',
    Sd: 'SD',
    Sr: 'SR',
    Sj: 'SJ',
    Sz: 'SZ',
    Se: 'SE',
    Ch: 'CH',
    Sy: 'SY',
    Tw: 'TW',
    Tj: 'TJ',
    Tz: 'TZ',
    Th: 'TH',
    Tl: 'TL',
    Tg: 'TG',
    Tk: 'TK',
    To: 'TO',
    Tt: 'TT'
} as const;
export type FindDomainContactsCountryEnum = typeof FindDomainContactsCountryEnum[keyof typeof FindDomainContactsCountryEnum];


/**
 * DomainNamesApi - axios parameter creator
 * @export
 */
export const DomainNamesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Receives the unique identifiers of a company(companyId) and the domain name(id) that is in the process of being transferred and then accepts it. It then returns success or not
         * @summary Accept domain name transfer
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain will be transferred to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptDomainNameTransfer: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('acceptDomainNameTransfer', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('acceptDomainNameTransfer', 'companyId', companyId)
            const localVarPath = `/domain-names/{id}/transfer/accept`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a domain name(id). It then activates domain id shield and returns the updated domain information  
         * @summary Activate domain id shield
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateDomainNameShield: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('activateDomainNameShield', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('activateDomainNameShield', 'companyId', companyId)
            const localVarPath = `/domain-names/{id}/shield/activate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a domain name(id) that belongs to it and adds the bundle name to the domain. It then returns the updated information of that domain
         * @summary Add a bundle to a domain name
         * @param {string} id The unique identifier of the domain name to add a bundle to.
         * @param {string} companyId The unique identifier of the company the domain belongs to.
         * @param {DomainBundleDto} domainBundleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDomainNameBundle: async (id: string, companyId: string, domainBundleDto: DomainBundleDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addDomainNameBundle', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('addDomainNameBundle', 'companyId', companyId)
            // verify required parameter 'domainBundleDto' is not null or undefined
            assertParamExists('addDomainNameBundle', 'domainBundleDto', domainBundleDto)
            const localVarPath = `/domain-names/{id}/bundle/add`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainBundleDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receives the unique identifiers of a company(companyId) and the domain name(id) that is in the process of being transferred and then cancels it. It then returns success or not
         * @summary Cancel domain name transfer
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelDomainNameTransfer: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancelDomainNameTransfer', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('cancelDomainNameTransfer', 'companyId', companyId)
            const localVarPath = `/domain-names/{id}/transfer/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a nuamber ofdomain names(id) to check availability for. It then returns an array whose each member shows whether or not a single domain name from the ones given is available or not
         * @summary Check domain name availability
         * @param {string} companyId Unique identifier of the company requesting the check.
         * @param {DomainCheckAvailabilityRequestDto} domainCheckAvailabilityRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDomainNameAvailability: async (companyId: string, domainCheckAvailabilityRequestDto: DomainCheckAvailabilityRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('checkDomainNameAvailability', 'companyId', companyId)
            // verify required parameter 'domainCheckAvailabilityRequestDto' is not null or undefined
            assertParamExists('checkDomainNameAvailability', 'domainCheckAvailabilityRequestDto', domainCheckAvailabilityRequestDto)
            const localVarPath = `/domain-names/check-availability`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainCheckAvailabilityRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a nuamber of domain names(id) to check availability for. 
         * @summary Check domain name availability and response with web sockets
         * @param {string} companyId Unique identifier of the company requesting the check
         * @param {DomainCheckAvailabilityRequestDto} domainCheckAvailabilityRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDomainNameAvailabilitySockets: async (companyId: string, domainCheckAvailabilityRequestDto: DomainCheckAvailabilityRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('checkDomainNameAvailabilitySockets', 'companyId', companyId)
            // verify required parameter 'domainCheckAvailabilityRequestDto' is not null or undefined
            assertParamExists('checkDomainNameAvailabilitySockets', 'domainCheckAvailabilityRequestDto', domainCheckAvailabilityRequestDto)
            const localVarPath = `/domain-names/check-availability/web-sockets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainCheckAvailabilityRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a domain name(id) that belongs to it and checks whether the domain is transferable. It then returns success or not
         * @summary Check if domain is transferrable
         * @param {string} id The unique identifier of the domain name to check for transfer eligibility.
         * @param {string} companyId The unique identifier of the company the domain belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDomainNameTransfer: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('checkDomainNameTransfer', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('checkDomainNameTransfer', 'companyId', companyId)
            const localVarPath = `/domain-names/{id}/transfer/check`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receives the unique identifiers of a company(companyId) and the domain name(id) to be claimed. It then returns success or not
         * @summary Claim Domain name
         * @param {string} domain The domain name to be claimed.
         * @param {string} companyId The unique identifier of the company to claim the domain.
         * @param {string} document Proof of ownership document.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimDomainName: async (domain: string, companyId: string, document: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('claimDomainName', 'domain', domain)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('claimDomainName', 'companyId', companyId)
            // verify required parameter 'document' is not null or undefined
            assertParamExists('claimDomainName', 'document', document)
            const localVarPath = `/domain-names/{domain}/claim/upload`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (document !== undefined) {
                localVarQueryParameter['document'] = document;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a domain name(id). It then deactivates the domain Id shield and returns the updated domain information.  
         * @summary Deactivate domain id shield
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateDomainNameShield: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deactivateDomainNameShield', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deactivateDomainNameShield', 'companyId', companyId)
            const localVarPath = `/domain-names/{id}/shield/deactivate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a domain name(id) and then deletes it. It then returns success or not
         * @summary Delete a domain name
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomainName: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDomainName', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deleteDomainName', 'companyId', companyId)
            const localVarPath = `/domain-names/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receives the unique identifiers of a company(companyId) and exports all the domain names that belong to it. It then returns a csv file conataining the domain names.
         * @summary Export domain names to csv file
         * @param {string} companyId The unique identifier of the company to export domains for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportDomainNames: async (companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('exportDomainNames', 'companyId', companyId)
            const localVarPath = `/domain-names/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Recieves the unique identifier of a company(comapnyId) and returns all the domain names that belong to it. In the case of a domain name given as a query, The results will be sorted by the query
         * @summary Get list of all domain names
         * @param {string} companyId The unique identifier of the company you wish to get domains for.
         * @param {string} [domainName] Filter the results by domain name.
         * @param {number} [currentPage] Specify the current page number for pagination.
         * @param {number} [perPage] Specify the number of items per page for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDomainNames: async (companyId: string, domainName?: string, currentPage?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('findDomainNames', 'companyId', companyId)
            const localVarPath = `/domain-names`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (domainName !== undefined) {
                localVarQueryParameter['domainName'] = domainName;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a domain name(id) that belongs to it and returns all the information of that domain
         * @summary Get a domain name
         * @param {string} id The unique identifier of the domain name you wish to get.
         * @param {string} companyId The unique identifier of the company the domain belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainName: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDomainName', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getDomainName', 'companyId', companyId)
            const localVarPath = `/domain-names/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a domain name(id) that belongs to it and locks the domain. It then returns the updated information of that domain
         * @summary Lock domain name
         * @param {string} id The unique identifier of the domain name to lock.
         * @param {string} companyId The unique identifier of the company the domain name belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockDomainName: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('lockDomainName', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('lockDomainName', 'companyId', companyId)
            const localVarPath = `/domain-names/{id}/lock`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a domain name(id) that belongs to it and recalls the domain. It then returns the information of that domain
         * @summary Recall a domain name
         * @param {string} id The unique identifier of the domain name to recall.
         * @param {string} companyId The unique identifier of the company the domain belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recallDomainName: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('recallDomainName', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('recallDomainName', 'companyId', companyId)
            const localVarPath = `/domain-names/{id}/recall`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a domain name(id) that belongs to it and removes the bundle name from the domain. It then returns the information of the updated domain
         * @summary Remove a bundle from a domain name
         * @param {string} id The unique identifier of the domain name to remove a bundle from.
         * @param {string} companyId The unique identifier of the company the domainn belongs to.
         * @param {string} bundleName The name of the bundle to remove from the domain name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDomainNameBundle: async (id: string, companyId: string, bundleName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeDomainNameBundle', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('removeDomainNameBundle', 'companyId', companyId)
            // verify required parameter 'bundleName' is not null or undefined
            assertParamExists('removeDomainNameBundle', 'bundleName', bundleName)
            const localVarPath = `/domain-names/{id}/bundle/remove`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (bundleName !== undefined) {
                localVarQueryParameter['bundleName'] = bundleName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a domain name(id) and then sends the auth code in an email. It then returns success or not
         * @summary Send email with EPP (auth) code
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendDomainNameAuthCode: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('sendDomainNameAuthCode', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('sendDomainNameAuthCode', 'companyId', companyId)
            const localVarPath = `/domain-names/{id}/send-auth-code`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a domain name(id) that belongs to it and syncs the domain. It then returns the information of that domain
         * @summary Sync a domain name
         * @param {string} id The unique identifier of the domain name to sync.
         * @param {string} companyId The unique identifier of the company the domain belons to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncDomainName: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('syncDomainName', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('syncDomainName', 'companyId', companyId)
            const localVarPath = `/domain-names/{id}/sync`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a domain name(id) that belongs to it and unlocks the domain. It then returns the updated information of that domain
         * @summary Unlock domain name
         * @param {string} id The unique identifier of the domain name to unlock.
         * @param {string} companyId The unique identifier of the company the domain name belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockDomainName: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unlockDomainName', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('unlockDomainName', 'companyId', companyId)
            const localVarPath = `/domain-names/{id}/unlock`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the additional parameters necessary for .cat domains. It then updates them and finally returns the updated domain information.
         * @summary Update additional .cat information
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {CatParameterDataDto} catParameterDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainNameAdditionalCat: async (id: string, companyId: string, catParameterDataDto: CatParameterDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainNameAdditionalCat', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainNameAdditionalCat', 'companyId', companyId)
            // verify required parameter 'catParameterDataDto' is not null or undefined
            assertParamExists('updateDomainNameAdditionalCat', 'catParameterDataDto', catParameterDataDto)
            const localVarPath = `/domain-names/{id}/additional/cat-parameter`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(catParameterDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the domain\'s challenges parameters. It then updates them and returns the updates domain information
         * @summary Update additional domain challenge information
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {ChallengeParametersDataDto} challengeParametersDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainNameAdditionalChallenge: async (id: string, companyId: string, challengeParametersDataDto: ChallengeParametersDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainNameAdditionalChallenge', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainNameAdditionalChallenge', 'companyId', companyId)
            // verify required parameter 'challengeParametersDataDto' is not null or undefined
            assertParamExists('updateDomainNameAdditionalChallenge', 'challengeParametersDataDto', challengeParametersDataDto)
            const localVarPath = `/domain-names/{id}/additional/challenge-parameter`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(challengeParametersDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and te domain claims token. It then updates it and returns the updated domain data
         * @summary Update additional claims token data
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {ClaimsTokenDataDto} claimsTokenDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainNameAdditionalClaimTokenData: async (id: string, companyId: string, claimsTokenDataDto: ClaimsTokenDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainNameAdditionalClaimTokenData', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainNameAdditionalClaimTokenData', 'companyId', companyId)
            // verify required parameter 'claimsTokenDataDto' is not null or undefined
            assertParamExists('updateDomainNameAdditionalClaimTokenData', 'claimsTokenDataDto', claimsTokenDataDto)
            const localVarPath = `/domain-names/{id}/additional/claims-token`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(claimsTokenDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the Donuts Price Category the domain belongs to. It then updates it and then returns the updated domain information
         * @summary Update additional donuts price category data
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {DonutsPriceCategoryDataDto} donutsPriceCategoryDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainNameAdditionalDonutsPriceCategoryData: async (id: string, companyId: string, donutsPriceCategoryDataDto: DonutsPriceCategoryDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainNameAdditionalDonutsPriceCategoryData', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainNameAdditionalDonutsPriceCategoryData', 'companyId', companyId)
            // verify required parameter 'donutsPriceCategoryDataDto' is not null or undefined
            assertParamExists('updateDomainNameAdditionalDonutsPriceCategoryData', 'donutsPriceCategoryDataDto', donutsPriceCategoryDataDto)
            const localVarPath = `/domain-names/{id}/additional/donuts-price-category`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(donutsPriceCategoryDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the intended use information for the domain. It then updates them and returns the updated domain information.
         * @summary Update additional intended use params data
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {IntendedUseParamsDataDto} intendedUseParamsDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainNameAdditionalIntendedUseParamsDataDto: async (id: string, companyId: string, intendedUseParamsDataDto: IntendedUseParamsDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainNameAdditionalIntendedUseParamsDataDto', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainNameAdditionalIntendedUseParamsDataDto', 'companyId', companyId)
            // verify required parameter 'intendedUseParamsDataDto' is not null or undefined
            assertParamExists('updateDomainNameAdditionalIntendedUseParamsDataDto', 'intendedUseParamsDataDto', intendedUseParamsDataDto)
            const localVarPath = `/domain-names/{id}/additional/intended-use-params`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(intendedUseParamsDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the premium price category the domain belongs to. It then updates them and returns the updated domain information.
         * @summary Update additional premium price category data
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {PremiumPriceCategoryDataDto} premiumPriceCategoryDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainNameAdditionalPremiumPriceCategoryData: async (id: string, companyId: string, premiumPriceCategoryDataDto: PremiumPriceCategoryDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainNameAdditionalPremiumPriceCategoryData', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainNameAdditionalPremiumPriceCategoryData', 'companyId', companyId)
            // verify required parameter 'premiumPriceCategoryDataDto' is not null or undefined
            assertParamExists('updateDomainNameAdditionalPremiumPriceCategoryData', 'premiumPriceCategoryDataDto', premiumPriceCategoryDataDto)
            const localVarPath = `/domain-names/{id}/additional/premium-price-category`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(premiumPriceCategoryDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the proxy service information associated with the domain. It then updates them and returns the updated domain information.
         * @summary Update additional proxy service data
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {ProxyServiceDataDto} proxyServiceDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainNameAdditionalProxyServiceDataDto: async (id: string, companyId: string, proxyServiceDataDto: ProxyServiceDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainNameAdditionalProxyServiceDataDto', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainNameAdditionalProxyServiceDataDto', 'companyId', companyId)
            // verify required parameter 'proxyServiceDataDto' is not null or undefined
            assertParamExists('updateDomainNameAdditionalProxyServiceDataDto', 'proxyServiceDataDto', proxyServiceDataDto)
            const localVarPath = `/domain-names/{id}/additional/proxy-service`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(proxyServiceDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the smd file associated with the domain. It then updates it and returns the updated domain information.
         * @summary Update additional sunrise data
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {SunriseDataDto} sunriseDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainNameAdditionalSunriseData: async (id: string, companyId: string, sunriseDataDto: SunriseDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainNameAdditionalSunriseData', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainNameAdditionalSunriseData', 'companyId', companyId)
            // verify required parameter 'sunriseDataDto' is not null or undefined
            assertParamExists('updateDomainNameAdditionalSunriseData', 'sunriseDataDto', sunriseDataDto)
            const localVarPath = `/domain-names/{id}/additional/sunrise`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sunriseDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the .uk direct information of the domain. It then updates them and returns the updated domain information.
         * @summary Update additional uk direct data
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {UKDirectDataDto} uKDirectDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainNameAdditionalUkDirectData: async (id: string, companyId: string, uKDirectDataDto: UKDirectDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainNameAdditionalUkDirectData', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainNameAdditionalUkDirectData', 'companyId', companyId)
            // verify required parameter 'uKDirectDataDto' is not null or undefined
            assertParamExists('updateDomainNameAdditionalUkDirectData', 'uKDirectDataDto', uKDirectDataDto)
            const localVarPath = `/domain-names/{id}/additional/uk-direct`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uKDirectDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the .xxx member info of the domain. It then updates them and returns the updated domain information.
         * @summary Update additional xxx member data
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {XXXMemberDataDto} xXXMemberDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainNameAdditionalxxxMemberData: async (id: string, companyId: string, xXXMemberDataDto: XXXMemberDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainNameAdditionalxxxMemberData', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainNameAdditionalxxxMemberData', 'companyId', companyId)
            // verify required parameter 'xXXMemberDataDto' is not null or undefined
            assertParamExists('updateDomainNameAdditionalxxxMemberData', 'xXXMemberDataDto', xXXMemberDataDto)
            const localVarPath = `/domain-names/{id}/additional/xxx-member`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(xXXMemberDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the new Admin Code. It then updates the domain admin code by replacing the old one with the new one. Finally it returns the updated domain information.
         * @summary Update admin code
         * @param {string} id Unique identifier of the domain name
         * @param {string} newAdminCode New admin code
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainNameAdminCode: async (id: string, newAdminCode: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainNameAdminCode', 'id', id)
            // verify required parameter 'newAdminCode' is not null or undefined
            assertParamExists('updateDomainNameAdminCode', 'newAdminCode', newAdminCode)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainNameAdminCode', 'companyId', companyId)
            const localVarPath = `/domain-names/{id}/contacts/admin/{newAdminCode}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"newAdminCode"}}`, encodeURIComponent(String(newAdminCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the new Billing Code. It then updates the domain billing code by replacing the old one with the new one. Finally it returns the updated domain information.
         * @summary Update billing code
         * @param {string} id Unique identifier of the domain name
         * @param {string} newBillingCode New billing code
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainNameBillingCode: async (id: string, newBillingCode: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainNameBillingCode', 'id', id)
            // verify required parameter 'newBillingCode' is not null or undefined
            assertParamExists('updateDomainNameBillingCode', 'newBillingCode', newBillingCode)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainNameBillingCode', 'companyId', companyId)
            const localVarPath = `/domain-names/{id}/contacts/billing/{newBillingCode}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"newBillingCode"}}`, encodeURIComponent(String(newBillingCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the new Registrant Code. It then updates the domain registrant code by replacing the old one with the new one. Finally it returns the updated domain information.
         * @summary Update registrant code
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {string} newRegistrantCode New registrant code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainNameRegistrantCode: async (id: string, companyId: string, newRegistrantCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainNameRegistrantCode', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainNameRegistrantCode', 'companyId', companyId)
            // verify required parameter 'newRegistrantCode' is not null or undefined
            assertParamExists('updateDomainNameRegistrantCode', 'newRegistrantCode', newRegistrantCode)
            const localVarPath = `/domain-names/{id}/contacts/registrant/{newRegistrantCode}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"newRegistrantCode"}}`, encodeURIComponent(String(newRegistrantCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the new Technical Code. It then updates the domain technical code by replacing the old one with the new one. Finally it returns the updated domain information.
         * @summary Update tech code
         * @param {string} id Unique identifier of the domain name
         * @param {string} newTechCode New tech code
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainNameTechCode: async (id: string, newTechCode: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainNameTechCode', 'id', id)
            // verify required parameter 'newTechCode' is not null or undefined
            assertParamExists('updateDomainNameTechCode', 'newTechCode', newTechCode)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainNameTechCode', 'companyId', companyId)
            const localVarPath = `/domain-names/{id}/contacts/tech/{newTechCode}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"newTechCode"}}`, encodeURIComponent(String(newTechCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DomainNamesApi - functional programming interface
 * @export
 */
export const DomainNamesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DomainNamesApiAxiosParamCreator(configuration)
    return {
        /**
         * Receives the unique identifiers of a company(companyId) and the domain name(id) that is in the process of being transferred and then accepts it. It then returns success or not
         * @summary Accept domain name transfer
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain will be transferred to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptDomainNameTransfer(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptDomainNameTransfer(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainNamesApi.acceptDomainNameTransfer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a domain name(id). It then activates domain id shield and returns the updated domain information  
         * @summary Activate domain id shield
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateDomainNameShield(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateDomainNameShield(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainNamesApi.activateDomainNameShield']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a domain name(id) that belongs to it and adds the bundle name to the domain. It then returns the updated information of that domain
         * @summary Add a bundle to a domain name
         * @param {string} id The unique identifier of the domain name to add a bundle to.
         * @param {string} companyId The unique identifier of the company the domain belongs to.
         * @param {DomainBundleDto} domainBundleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addDomainNameBundle(id: string, companyId: string, domainBundleDto: DomainBundleDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDomainName200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addDomainNameBundle(id, companyId, domainBundleDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainNamesApi.addDomainNameBundle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Receives the unique identifiers of a company(companyId) and the domain name(id) that is in the process of being transferred and then cancels it. It then returns success or not
         * @summary Cancel domain name transfer
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelDomainNameTransfer(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelDomainNameTransfer(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainNamesApi.cancelDomainNameTransfer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a nuamber ofdomain names(id) to check availability for. It then returns an array whose each member shows whether or not a single domain name from the ones given is available or not
         * @summary Check domain name availability
         * @param {string} companyId Unique identifier of the company requesting the check.
         * @param {DomainCheckAvailabilityRequestDto} domainCheckAvailabilityRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkDomainNameAvailability(companyId: string, domainCheckAvailabilityRequestDto: DomainCheckAvailabilityRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckDomainNameAvailability200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkDomainNameAvailability(companyId, domainCheckAvailabilityRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainNamesApi.checkDomainNameAvailability']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a nuamber of domain names(id) to check availability for. 
         * @summary Check domain name availability and response with web sockets
         * @param {string} companyId Unique identifier of the company requesting the check
         * @param {DomainCheckAvailabilityRequestDto} domainCheckAvailabilityRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkDomainNameAvailabilitySockets(companyId: string, domainCheckAvailabilityRequestDto: DomainCheckAvailabilityRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckDomainNameAvailabilitySockets200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkDomainNameAvailabilitySockets(companyId, domainCheckAvailabilityRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainNamesApi.checkDomainNameAvailabilitySockets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a domain name(id) that belongs to it and checks whether the domain is transferable. It then returns success or not
         * @summary Check if domain is transferrable
         * @param {string} id The unique identifier of the domain name to check for transfer eligibility.
         * @param {string} companyId The unique identifier of the company the domain belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkDomainNameTransfer(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkDomainNameTransfer(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainNamesApi.checkDomainNameTransfer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Receives the unique identifiers of a company(companyId) and the domain name(id) to be claimed. It then returns success or not
         * @summary Claim Domain name
         * @param {string} domain The domain name to be claimed.
         * @param {string} companyId The unique identifier of the company to claim the domain.
         * @param {string} document Proof of ownership document.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async claimDomainName(domain: string, companyId: string, document: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.claimDomainName(domain, companyId, document, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainNamesApi.claimDomainName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a domain name(id). It then deactivates the domain Id shield and returns the updated domain information.  
         * @summary Deactivate domain id shield
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateDomainNameShield(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateDomainNameShield(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainNamesApi.deactivateDomainNameShield']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a domain name(id) and then deletes it. It then returns success or not
         * @summary Delete a domain name
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDomainName(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDomainName(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainNamesApi.deleteDomainName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Receives the unique identifiers of a company(companyId) and exports all the domain names that belong to it. It then returns a csv file conataining the domain names.
         * @summary Export domain names to csv file
         * @param {string} companyId The unique identifier of the company to export domains for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportDomainNames(companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportDomainNames(companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainNamesApi.exportDomainNames']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Recieves the unique identifier of a company(comapnyId) and returns all the domain names that belong to it. In the case of a domain name given as a query, The results will be sorted by the query
         * @summary Get list of all domain names
         * @param {string} companyId The unique identifier of the company you wish to get domains for.
         * @param {string} [domainName] Filter the results by domain name.
         * @param {number} [currentPage] Specify the current page number for pagination.
         * @param {number} [perPage] Specify the number of items per page for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findDomainNames(companyId: string, domainName?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindDomainNames200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findDomainNames(companyId, domainName, currentPage, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainNamesApi.findDomainNames']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a domain name(id) that belongs to it and returns all the information of that domain
         * @summary Get a domain name
         * @param {string} id The unique identifier of the domain name you wish to get.
         * @param {string} companyId The unique identifier of the company the domain belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDomainName(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDomainName200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDomainName(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainNamesApi.getDomainName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a domain name(id) that belongs to it and locks the domain. It then returns the updated information of that domain
         * @summary Lock domain name
         * @param {string} id The unique identifier of the domain name to lock.
         * @param {string} companyId The unique identifier of the company the domain name belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lockDomainName(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lockDomainName(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainNamesApi.lockDomainName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a domain name(id) that belongs to it and recalls the domain. It then returns the information of that domain
         * @summary Recall a domain name
         * @param {string} id The unique identifier of the domain name to recall.
         * @param {string} companyId The unique identifier of the company the domain belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recallDomainName(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recallDomainName(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainNamesApi.recallDomainName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a domain name(id) that belongs to it and removes the bundle name from the domain. It then returns the information of the updated domain
         * @summary Remove a bundle from a domain name
         * @param {string} id The unique identifier of the domain name to remove a bundle from.
         * @param {string} companyId The unique identifier of the company the domainn belongs to.
         * @param {string} bundleName The name of the bundle to remove from the domain name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeDomainNameBundle(id: string, companyId: string, bundleName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeDomainNameBundle(id, companyId, bundleName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainNamesApi.removeDomainNameBundle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a domain name(id) and then sends the auth code in an email. It then returns success or not
         * @summary Send email with EPP (auth) code
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendDomainNameAuthCode(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendDomainNameAuthCode(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainNamesApi.sendDomainNameAuthCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a domain name(id) that belongs to it and syncs the domain. It then returns the information of that domain
         * @summary Sync a domain name
         * @param {string} id The unique identifier of the domain name to sync.
         * @param {string} companyId The unique identifier of the company the domain belons to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncDomainName(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncDomainName(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainNamesApi.syncDomainName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a domain name(id) that belongs to it and unlocks the domain. It then returns the updated information of that domain
         * @summary Unlock domain name
         * @param {string} id The unique identifier of the domain name to unlock.
         * @param {string} companyId The unique identifier of the company the domain name belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlockDomainName(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlockDomainName(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainNamesApi.unlockDomainName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the additional parameters necessary for .cat domains. It then updates them and finally returns the updated domain information.
         * @summary Update additional .cat information
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {CatParameterDataDto} catParameterDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainNameAdditionalCat(id: string, companyId: string, catParameterDataDto: CatParameterDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainNameAdditionalCat(id, companyId, catParameterDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainNamesApi.updateDomainNameAdditionalCat']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the domain\'s challenges parameters. It then updates them and returns the updates domain information
         * @summary Update additional domain challenge information
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {ChallengeParametersDataDto} challengeParametersDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainNameAdditionalChallenge(id: string, companyId: string, challengeParametersDataDto: ChallengeParametersDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainNameAdditionalChallenge(id, companyId, challengeParametersDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainNamesApi.updateDomainNameAdditionalChallenge']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and te domain claims token. It then updates it and returns the updated domain data
         * @summary Update additional claims token data
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {ClaimsTokenDataDto} claimsTokenDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainNameAdditionalClaimTokenData(id: string, companyId: string, claimsTokenDataDto: ClaimsTokenDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainNameAdditionalClaimTokenData(id, companyId, claimsTokenDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainNamesApi.updateDomainNameAdditionalClaimTokenData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the Donuts Price Category the domain belongs to. It then updates it and then returns the updated domain information
         * @summary Update additional donuts price category data
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {DonutsPriceCategoryDataDto} donutsPriceCategoryDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainNameAdditionalDonutsPriceCategoryData(id: string, companyId: string, donutsPriceCategoryDataDto: DonutsPriceCategoryDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainNameAdditionalDonutsPriceCategoryData(id, companyId, donutsPriceCategoryDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainNamesApi.updateDomainNameAdditionalDonutsPriceCategoryData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the intended use information for the domain. It then updates them and returns the updated domain information.
         * @summary Update additional intended use params data
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {IntendedUseParamsDataDto} intendedUseParamsDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainNameAdditionalIntendedUseParamsDataDto(id: string, companyId: string, intendedUseParamsDataDto: IntendedUseParamsDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainNameAdditionalIntendedUseParamsDataDto(id, companyId, intendedUseParamsDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainNamesApi.updateDomainNameAdditionalIntendedUseParamsDataDto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the premium price category the domain belongs to. It then updates them and returns the updated domain information.
         * @summary Update additional premium price category data
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {PremiumPriceCategoryDataDto} premiumPriceCategoryDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainNameAdditionalPremiumPriceCategoryData(id: string, companyId: string, premiumPriceCategoryDataDto: PremiumPriceCategoryDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainNameAdditionalPremiumPriceCategoryData(id, companyId, premiumPriceCategoryDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainNamesApi.updateDomainNameAdditionalPremiumPriceCategoryData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the proxy service information associated with the domain. It then updates them and returns the updated domain information.
         * @summary Update additional proxy service data
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {ProxyServiceDataDto} proxyServiceDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainNameAdditionalProxyServiceDataDto(id: string, companyId: string, proxyServiceDataDto: ProxyServiceDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainNameAdditionalProxyServiceDataDto(id, companyId, proxyServiceDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainNamesApi.updateDomainNameAdditionalProxyServiceDataDto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the smd file associated with the domain. It then updates it and returns the updated domain information.
         * @summary Update additional sunrise data
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {SunriseDataDto} sunriseDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainNameAdditionalSunriseData(id: string, companyId: string, sunriseDataDto: SunriseDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainNameAdditionalSunriseData(id, companyId, sunriseDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainNamesApi.updateDomainNameAdditionalSunriseData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the .uk direct information of the domain. It then updates them and returns the updated domain information.
         * @summary Update additional uk direct data
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {UKDirectDataDto} uKDirectDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainNameAdditionalUkDirectData(id: string, companyId: string, uKDirectDataDto: UKDirectDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainNameAdditionalUkDirectData(id, companyId, uKDirectDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainNamesApi.updateDomainNameAdditionalUkDirectData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the .xxx member info of the domain. It then updates them and returns the updated domain information.
         * @summary Update additional xxx member data
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {XXXMemberDataDto} xXXMemberDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainNameAdditionalxxxMemberData(id: string, companyId: string, xXXMemberDataDto: XXXMemberDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainNameAdditionalxxxMemberData(id, companyId, xXXMemberDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainNamesApi.updateDomainNameAdditionalxxxMemberData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the new Admin Code. It then updates the domain admin code by replacing the old one with the new one. Finally it returns the updated domain information.
         * @summary Update admin code
         * @param {string} id Unique identifier of the domain name
         * @param {string} newAdminCode New admin code
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainNameAdminCode(id: string, newAdminCode: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainNameAdminCode(id, newAdminCode, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainNamesApi.updateDomainNameAdminCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the new Billing Code. It then updates the domain billing code by replacing the old one with the new one. Finally it returns the updated domain information.
         * @summary Update billing code
         * @param {string} id Unique identifier of the domain name
         * @param {string} newBillingCode New billing code
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainNameBillingCode(id: string, newBillingCode: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainNameBillingCode(id, newBillingCode, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainNamesApi.updateDomainNameBillingCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the new Registrant Code. It then updates the domain registrant code by replacing the old one with the new one. Finally it returns the updated domain information.
         * @summary Update registrant code
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {string} newRegistrantCode New registrant code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainNameRegistrantCode(id: string, companyId: string, newRegistrantCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDomainName200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainNameRegistrantCode(id, companyId, newRegistrantCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainNamesApi.updateDomainNameRegistrantCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the new Technical Code. It then updates the domain technical code by replacing the old one with the new one. Finally it returns the updated domain information.
         * @summary Update tech code
         * @param {string} id Unique identifier of the domain name
         * @param {string} newTechCode New tech code
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainNameTechCode(id: string, newTechCode: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainNameTechCode(id, newTechCode, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainNamesApi.updateDomainNameTechCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DomainNamesApi - factory interface
 * @export
 */
export const DomainNamesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DomainNamesApiFp(configuration)
    return {
        /**
         * Receives the unique identifiers of a company(companyId) and the domain name(id) that is in the process of being transferred and then accepts it. It then returns success or not
         * @summary Accept domain name transfer
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain will be transferred to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptDomainNameTransfer(id: string, companyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.acceptDomainNameTransfer(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a domain name(id). It then activates domain id shield and returns the updated domain information  
         * @summary Activate domain id shield
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateDomainNameShield(id: string, companyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.activateDomainNameShield(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a domain name(id) that belongs to it and adds the bundle name to the domain. It then returns the updated information of that domain
         * @summary Add a bundle to a domain name
         * @param {string} id The unique identifier of the domain name to add a bundle to.
         * @param {string} companyId The unique identifier of the company the domain belongs to.
         * @param {DomainBundleDto} domainBundleDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDomainNameBundle(id: string, companyId: string, domainBundleDto: DomainBundleDto, options?: any): AxiosPromise<GetDomainName200Response> {
            return localVarFp.addDomainNameBundle(id, companyId, domainBundleDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Receives the unique identifiers of a company(companyId) and the domain name(id) that is in the process of being transferred and then cancels it. It then returns success or not
         * @summary Cancel domain name transfer
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelDomainNameTransfer(id: string, companyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.cancelDomainNameTransfer(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a nuamber ofdomain names(id) to check availability for. It then returns an array whose each member shows whether or not a single domain name from the ones given is available or not
         * @summary Check domain name availability
         * @param {string} companyId Unique identifier of the company requesting the check.
         * @param {DomainCheckAvailabilityRequestDto} domainCheckAvailabilityRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDomainNameAvailability(companyId: string, domainCheckAvailabilityRequestDto: DomainCheckAvailabilityRequestDto, options?: any): AxiosPromise<CheckDomainNameAvailability200Response> {
            return localVarFp.checkDomainNameAvailability(companyId, domainCheckAvailabilityRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a nuamber of domain names(id) to check availability for. 
         * @summary Check domain name availability and response with web sockets
         * @param {string} companyId Unique identifier of the company requesting the check
         * @param {DomainCheckAvailabilityRequestDto} domainCheckAvailabilityRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDomainNameAvailabilitySockets(companyId: string, domainCheckAvailabilityRequestDto: DomainCheckAvailabilityRequestDto, options?: any): AxiosPromise<CheckDomainNameAvailabilitySockets200Response> {
            return localVarFp.checkDomainNameAvailabilitySockets(companyId, domainCheckAvailabilityRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a domain name(id) that belongs to it and checks whether the domain is transferable. It then returns success or not
         * @summary Check if domain is transferrable
         * @param {string} id The unique identifier of the domain name to check for transfer eligibility.
         * @param {string} companyId The unique identifier of the company the domain belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDomainNameTransfer(id: string, companyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.checkDomainNameTransfer(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Receives the unique identifiers of a company(companyId) and the domain name(id) to be claimed. It then returns success or not
         * @summary Claim Domain name
         * @param {string} domain The domain name to be claimed.
         * @param {string} companyId The unique identifier of the company to claim the domain.
         * @param {string} document Proof of ownership document.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimDomainName(domain: string, companyId: string, document: string, options?: any): AxiosPromise<void> {
            return localVarFp.claimDomainName(domain, companyId, document, options).then((request) => request(axios, basePath));
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a domain name(id). It then deactivates the domain Id shield and returns the updated domain information.  
         * @summary Deactivate domain id shield
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateDomainNameShield(id: string, companyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deactivateDomainNameShield(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a domain name(id) and then deletes it. It then returns success or not
         * @summary Delete a domain name
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomainName(id: string, companyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDomainName(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Receives the unique identifiers of a company(companyId) and exports all the domain names that belong to it. It then returns a csv file conataining the domain names.
         * @summary Export domain names to csv file
         * @param {string} companyId The unique identifier of the company to export domains for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportDomainNames(companyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.exportDomainNames(companyId, options).then((request) => request(axios, basePath));
        },
        /**
         *  Recieves the unique identifier of a company(comapnyId) and returns all the domain names that belong to it. In the case of a domain name given as a query, The results will be sorted by the query
         * @summary Get list of all domain names
         * @param {string} companyId The unique identifier of the company you wish to get domains for.
         * @param {string} [domainName] Filter the results by domain name.
         * @param {number} [currentPage] Specify the current page number for pagination.
         * @param {number} [perPage] Specify the number of items per page for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDomainNames(companyId: string, domainName?: string, currentPage?: number, perPage?: number, options?: any): AxiosPromise<FindDomainNames200Response> {
            return localVarFp.findDomainNames(companyId, domainName, currentPage, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a domain name(id) that belongs to it and returns all the information of that domain
         * @summary Get a domain name
         * @param {string} id The unique identifier of the domain name you wish to get.
         * @param {string} companyId The unique identifier of the company the domain belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainName(id: string, companyId: string, options?: any): AxiosPromise<GetDomainName200Response> {
            return localVarFp.getDomainName(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a domain name(id) that belongs to it and locks the domain. It then returns the updated information of that domain
         * @summary Lock domain name
         * @param {string} id The unique identifier of the domain name to lock.
         * @param {string} companyId The unique identifier of the company the domain name belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockDomainName(id: string, companyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.lockDomainName(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a domain name(id) that belongs to it and recalls the domain. It then returns the information of that domain
         * @summary Recall a domain name
         * @param {string} id The unique identifier of the domain name to recall.
         * @param {string} companyId The unique identifier of the company the domain belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recallDomainName(id: string, companyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.recallDomainName(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a domain name(id) that belongs to it and removes the bundle name from the domain. It then returns the information of the updated domain
         * @summary Remove a bundle from a domain name
         * @param {string} id The unique identifier of the domain name to remove a bundle from.
         * @param {string} companyId The unique identifier of the company the domainn belongs to.
         * @param {string} bundleName The name of the bundle to remove from the domain name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDomainNameBundle(id: string, companyId: string, bundleName: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeDomainNameBundle(id, companyId, bundleName, options).then((request) => request(axios, basePath));
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a domain name(id) and then sends the auth code in an email. It then returns success or not
         * @summary Send email with EPP (auth) code
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendDomainNameAuthCode(id: string, companyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.sendDomainNameAuthCode(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a domain name(id) that belongs to it and syncs the domain. It then returns the information of that domain
         * @summary Sync a domain name
         * @param {string} id The unique identifier of the domain name to sync.
         * @param {string} companyId The unique identifier of the company the domain belons to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncDomainName(id: string, companyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.syncDomainName(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Receives the unique identifiers of a company(companyId) and a domain name(id) that belongs to it and unlocks the domain. It then returns the updated information of that domain
         * @summary Unlock domain name
         * @param {string} id The unique identifier of the domain name to unlock.
         * @param {string} companyId The unique identifier of the company the domain name belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockDomainName(id: string, companyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.unlockDomainName(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the additional parameters necessary for .cat domains. It then updates them and finally returns the updated domain information.
         * @summary Update additional .cat information
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {CatParameterDataDto} catParameterDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainNameAdditionalCat(id: string, companyId: string, catParameterDataDto: CatParameterDataDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateDomainNameAdditionalCat(id, companyId, catParameterDataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the domain\'s challenges parameters. It then updates them and returns the updates domain information
         * @summary Update additional domain challenge information
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {ChallengeParametersDataDto} challengeParametersDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainNameAdditionalChallenge(id: string, companyId: string, challengeParametersDataDto: ChallengeParametersDataDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateDomainNameAdditionalChallenge(id, companyId, challengeParametersDataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and te domain claims token. It then updates it and returns the updated domain data
         * @summary Update additional claims token data
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {ClaimsTokenDataDto} claimsTokenDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainNameAdditionalClaimTokenData(id: string, companyId: string, claimsTokenDataDto: ClaimsTokenDataDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateDomainNameAdditionalClaimTokenData(id, companyId, claimsTokenDataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the Donuts Price Category the domain belongs to. It then updates it and then returns the updated domain information
         * @summary Update additional donuts price category data
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {DonutsPriceCategoryDataDto} donutsPriceCategoryDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainNameAdditionalDonutsPriceCategoryData(id: string, companyId: string, donutsPriceCategoryDataDto: DonutsPriceCategoryDataDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateDomainNameAdditionalDonutsPriceCategoryData(id, companyId, donutsPriceCategoryDataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the intended use information for the domain. It then updates them and returns the updated domain information.
         * @summary Update additional intended use params data
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {IntendedUseParamsDataDto} intendedUseParamsDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainNameAdditionalIntendedUseParamsDataDto(id: string, companyId: string, intendedUseParamsDataDto: IntendedUseParamsDataDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateDomainNameAdditionalIntendedUseParamsDataDto(id, companyId, intendedUseParamsDataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the premium price category the domain belongs to. It then updates them and returns the updated domain information.
         * @summary Update additional premium price category data
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {PremiumPriceCategoryDataDto} premiumPriceCategoryDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainNameAdditionalPremiumPriceCategoryData(id: string, companyId: string, premiumPriceCategoryDataDto: PremiumPriceCategoryDataDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateDomainNameAdditionalPremiumPriceCategoryData(id, companyId, premiumPriceCategoryDataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the proxy service information associated with the domain. It then updates them and returns the updated domain information.
         * @summary Update additional proxy service data
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {ProxyServiceDataDto} proxyServiceDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainNameAdditionalProxyServiceDataDto(id: string, companyId: string, proxyServiceDataDto: ProxyServiceDataDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateDomainNameAdditionalProxyServiceDataDto(id, companyId, proxyServiceDataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the smd file associated with the domain. It then updates it and returns the updated domain information.
         * @summary Update additional sunrise data
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {SunriseDataDto} sunriseDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainNameAdditionalSunriseData(id: string, companyId: string, sunriseDataDto: SunriseDataDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateDomainNameAdditionalSunriseData(id, companyId, sunriseDataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the .uk direct information of the domain. It then updates them and returns the updated domain information.
         * @summary Update additional uk direct data
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {UKDirectDataDto} uKDirectDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainNameAdditionalUkDirectData(id: string, companyId: string, uKDirectDataDto: UKDirectDataDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateDomainNameAdditionalUkDirectData(id, companyId, uKDirectDataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the .xxx member info of the domain. It then updates them and returns the updated domain information.
         * @summary Update additional xxx member data
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {XXXMemberDataDto} xXXMemberDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainNameAdditionalxxxMemberData(id: string, companyId: string, xXXMemberDataDto: XXXMemberDataDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateDomainNameAdditionalxxxMemberData(id, companyId, xXXMemberDataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the new Admin Code. It then updates the domain admin code by replacing the old one with the new one. Finally it returns the updated domain information.
         * @summary Update admin code
         * @param {string} id Unique identifier of the domain name
         * @param {string} newAdminCode New admin code
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainNameAdminCode(id: string, newAdminCode: string, companyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.updateDomainNameAdminCode(id, newAdminCode, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the new Billing Code. It then updates the domain billing code by replacing the old one with the new one. Finally it returns the updated domain information.
         * @summary Update billing code
         * @param {string} id Unique identifier of the domain name
         * @param {string} newBillingCode New billing code
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainNameBillingCode(id: string, newBillingCode: string, companyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.updateDomainNameBillingCode(id, newBillingCode, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the new Registrant Code. It then updates the domain registrant code by replacing the old one with the new one. Finally it returns the updated domain information.
         * @summary Update registrant code
         * @param {string} id Unique identifier of the domain name
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {string} newRegistrantCode New registrant code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainNameRegistrantCode(id: string, companyId: string, newRegistrantCode: string, options?: any): AxiosPromise<GetDomainName200Response> {
            return localVarFp.updateDomainNameRegistrantCode(id, companyId, newRegistrantCode, options).then((request) => request(axios, basePath));
        },
        /**
         * Receives the unique identifiers of a company(companyId) a domain name(id) and the new Technical Code. It then updates the domain technical code by replacing the old one with the new one. Finally it returns the updated domain information.
         * @summary Update tech code
         * @param {string} id Unique identifier of the domain name
         * @param {string} newTechCode New tech code
         * @param {string} companyId Unique identifier of the company the domain belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainNameTechCode(id: string, newTechCode: string, companyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.updateDomainNameTechCode(id, newTechCode, companyId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DomainNamesApi - object-oriented interface
 * @export
 * @class DomainNamesApi
 * @extends {BaseAPI}
 */
export class DomainNamesApi extends BaseAPI {
    /**
     * Receives the unique identifiers of a company(companyId) and the domain name(id) that is in the process of being transferred and then accepts it. It then returns success or not
     * @summary Accept domain name transfer
     * @param {string} id Unique identifier of the domain name
     * @param {string} companyId Unique identifier of the company the domain will be transferred to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainNamesApi
     */
    public acceptDomainNameTransfer(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return DomainNamesApiFp(this.configuration).acceptDomainNameTransfer(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Receives the unique identifiers of a company(companyId) and a domain name(id). It then activates domain id shield and returns the updated domain information  
     * @summary Activate domain id shield
     * @param {string} id Unique identifier of the domain name
     * @param {string} companyId Unique identifier of the company the domain belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainNamesApi
     */
    public activateDomainNameShield(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return DomainNamesApiFp(this.configuration).activateDomainNameShield(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Receives the unique identifiers of a company(companyId) and a domain name(id) that belongs to it and adds the bundle name to the domain. It then returns the updated information of that domain
     * @summary Add a bundle to a domain name
     * @param {string} id The unique identifier of the domain name to add a bundle to.
     * @param {string} companyId The unique identifier of the company the domain belongs to.
     * @param {DomainBundleDto} domainBundleDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainNamesApi
     */
    public addDomainNameBundle(id: string, companyId: string, domainBundleDto: DomainBundleDto, options?: RawAxiosRequestConfig) {
        return DomainNamesApiFp(this.configuration).addDomainNameBundle(id, companyId, domainBundleDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Receives the unique identifiers of a company(companyId) and the domain name(id) that is in the process of being transferred and then cancels it. It then returns success or not
     * @summary Cancel domain name transfer
     * @param {string} id Unique identifier of the domain name
     * @param {string} companyId Unique identifier of the company the domain belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainNamesApi
     */
    public cancelDomainNameTransfer(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return DomainNamesApiFp(this.configuration).cancelDomainNameTransfer(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Receives the unique identifiers of a company(companyId) and a nuamber ofdomain names(id) to check availability for. It then returns an array whose each member shows whether or not a single domain name from the ones given is available or not
     * @summary Check domain name availability
     * @param {string} companyId Unique identifier of the company requesting the check.
     * @param {DomainCheckAvailabilityRequestDto} domainCheckAvailabilityRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainNamesApi
     */
    public checkDomainNameAvailability(companyId: string, domainCheckAvailabilityRequestDto: DomainCheckAvailabilityRequestDto, options?: RawAxiosRequestConfig) {
        return DomainNamesApiFp(this.configuration).checkDomainNameAvailability(companyId, domainCheckAvailabilityRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Receives the unique identifiers of a company(companyId) and a nuamber of domain names(id) to check availability for. 
     * @summary Check domain name availability and response with web sockets
     * @param {string} companyId Unique identifier of the company requesting the check
     * @param {DomainCheckAvailabilityRequestDto} domainCheckAvailabilityRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainNamesApi
     */
    public checkDomainNameAvailabilitySockets(companyId: string, domainCheckAvailabilityRequestDto: DomainCheckAvailabilityRequestDto, options?: RawAxiosRequestConfig) {
        return DomainNamesApiFp(this.configuration).checkDomainNameAvailabilitySockets(companyId, domainCheckAvailabilityRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Receives the unique identifiers of a company(companyId) and a domain name(id) that belongs to it and checks whether the domain is transferable. It then returns success or not
     * @summary Check if domain is transferrable
     * @param {string} id The unique identifier of the domain name to check for transfer eligibility.
     * @param {string} companyId The unique identifier of the company the domain belongs to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainNamesApi
     */
    public checkDomainNameTransfer(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return DomainNamesApiFp(this.configuration).checkDomainNameTransfer(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Receives the unique identifiers of a company(companyId) and the domain name(id) to be claimed. It then returns success or not
     * @summary Claim Domain name
     * @param {string} domain The domain name to be claimed.
     * @param {string} companyId The unique identifier of the company to claim the domain.
     * @param {string} document Proof of ownership document.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainNamesApi
     */
    public claimDomainName(domain: string, companyId: string, document: string, options?: RawAxiosRequestConfig) {
        return DomainNamesApiFp(this.configuration).claimDomainName(domain, companyId, document, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Receives the unique identifiers of a company(companyId) and a domain name(id). It then deactivates the domain Id shield and returns the updated domain information.  
     * @summary Deactivate domain id shield
     * @param {string} id Unique identifier of the domain name
     * @param {string} companyId Unique identifier of the company the domain belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainNamesApi
     */
    public deactivateDomainNameShield(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return DomainNamesApiFp(this.configuration).deactivateDomainNameShield(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Receives the unique identifiers of a company(companyId) and a domain name(id) and then deletes it. It then returns success or not
     * @summary Delete a domain name
     * @param {string} id Unique identifier of the domain name
     * @param {string} companyId Unique identifier of the company the domain belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainNamesApi
     */
    public deleteDomainName(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return DomainNamesApiFp(this.configuration).deleteDomainName(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Receives the unique identifiers of a company(companyId) and exports all the domain names that belong to it. It then returns a csv file conataining the domain names.
     * @summary Export domain names to csv file
     * @param {string} companyId The unique identifier of the company to export domains for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainNamesApi
     */
    public exportDomainNames(companyId: string, options?: RawAxiosRequestConfig) {
        return DomainNamesApiFp(this.configuration).exportDomainNames(companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Recieves the unique identifier of a company(comapnyId) and returns all the domain names that belong to it. In the case of a domain name given as a query, The results will be sorted by the query
     * @summary Get list of all domain names
     * @param {string} companyId The unique identifier of the company you wish to get domains for.
     * @param {string} [domainName] Filter the results by domain name.
     * @param {number} [currentPage] Specify the current page number for pagination.
     * @param {number} [perPage] Specify the number of items per page for pagination.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainNamesApi
     */
    public findDomainNames(companyId: string, domainName?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return DomainNamesApiFp(this.configuration).findDomainNames(companyId, domainName, currentPage, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Receives the unique identifiers of a company(companyId) and a domain name(id) that belongs to it and returns all the information of that domain
     * @summary Get a domain name
     * @param {string} id The unique identifier of the domain name you wish to get.
     * @param {string} companyId The unique identifier of the company the domain belongs to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainNamesApi
     */
    public getDomainName(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return DomainNamesApiFp(this.configuration).getDomainName(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Receives the unique identifiers of a company(companyId) and a domain name(id) that belongs to it and locks the domain. It then returns the updated information of that domain
     * @summary Lock domain name
     * @param {string} id The unique identifier of the domain name to lock.
     * @param {string} companyId The unique identifier of the company the domain name belongs to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainNamesApi
     */
    public lockDomainName(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return DomainNamesApiFp(this.configuration).lockDomainName(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Receives the unique identifiers of a company(companyId) and a domain name(id) that belongs to it and recalls the domain. It then returns the information of that domain
     * @summary Recall a domain name
     * @param {string} id The unique identifier of the domain name to recall.
     * @param {string} companyId The unique identifier of the company the domain belongs to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainNamesApi
     */
    public recallDomainName(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return DomainNamesApiFp(this.configuration).recallDomainName(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Receives the unique identifiers of a company(companyId) and a domain name(id) that belongs to it and removes the bundle name from the domain. It then returns the information of the updated domain
     * @summary Remove a bundle from a domain name
     * @param {string} id The unique identifier of the domain name to remove a bundle from.
     * @param {string} companyId The unique identifier of the company the domainn belongs to.
     * @param {string} bundleName The name of the bundle to remove from the domain name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainNamesApi
     */
    public removeDomainNameBundle(id: string, companyId: string, bundleName: string, options?: RawAxiosRequestConfig) {
        return DomainNamesApiFp(this.configuration).removeDomainNameBundle(id, companyId, bundleName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Receives the unique identifiers of a company(companyId) and a domain name(id) and then sends the auth code in an email. It then returns success or not
     * @summary Send email with EPP (auth) code
     * @param {string} id Unique identifier of the domain name
     * @param {string} companyId Unique identifier of the company the domain belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainNamesApi
     */
    public sendDomainNameAuthCode(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return DomainNamesApiFp(this.configuration).sendDomainNameAuthCode(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Receives the unique identifiers of a company(companyId) and a domain name(id) that belongs to it and syncs the domain. It then returns the information of that domain
     * @summary Sync a domain name
     * @param {string} id The unique identifier of the domain name to sync.
     * @param {string} companyId The unique identifier of the company the domain belons to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainNamesApi
     */
    public syncDomainName(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return DomainNamesApiFp(this.configuration).syncDomainName(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Receives the unique identifiers of a company(companyId) and a domain name(id) that belongs to it and unlocks the domain. It then returns the updated information of that domain
     * @summary Unlock domain name
     * @param {string} id The unique identifier of the domain name to unlock.
     * @param {string} companyId The unique identifier of the company the domain name belongs to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainNamesApi
     */
    public unlockDomainName(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return DomainNamesApiFp(this.configuration).unlockDomainName(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Receives the unique identifiers of a company(companyId) a domain name(id) and the additional parameters necessary for .cat domains. It then updates them and finally returns the updated domain information.
     * @summary Update additional .cat information
     * @param {string} id Unique identifier of the domain name
     * @param {string} companyId Unique identifier of the company the domain belongs to
     * @param {CatParameterDataDto} catParameterDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainNamesApi
     */
    public updateDomainNameAdditionalCat(id: string, companyId: string, catParameterDataDto: CatParameterDataDto, options?: RawAxiosRequestConfig) {
        return DomainNamesApiFp(this.configuration).updateDomainNameAdditionalCat(id, companyId, catParameterDataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Receives the unique identifiers of a company(companyId) a domain name(id) and the domain\'s challenges parameters. It then updates them and returns the updates domain information
     * @summary Update additional domain challenge information
     * @param {string} id Unique identifier of the domain name
     * @param {string} companyId Unique identifier of the company the domain belongs to
     * @param {ChallengeParametersDataDto} challengeParametersDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainNamesApi
     */
    public updateDomainNameAdditionalChallenge(id: string, companyId: string, challengeParametersDataDto: ChallengeParametersDataDto, options?: RawAxiosRequestConfig) {
        return DomainNamesApiFp(this.configuration).updateDomainNameAdditionalChallenge(id, companyId, challengeParametersDataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Receives the unique identifiers of a company(companyId) a domain name(id) and te domain claims token. It then updates it and returns the updated domain data
     * @summary Update additional claims token data
     * @param {string} id Unique identifier of the domain name
     * @param {string} companyId Unique identifier of the company the domain belongs to
     * @param {ClaimsTokenDataDto} claimsTokenDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainNamesApi
     */
    public updateDomainNameAdditionalClaimTokenData(id: string, companyId: string, claimsTokenDataDto: ClaimsTokenDataDto, options?: RawAxiosRequestConfig) {
        return DomainNamesApiFp(this.configuration).updateDomainNameAdditionalClaimTokenData(id, companyId, claimsTokenDataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Receives the unique identifiers of a company(companyId) a domain name(id) and the Donuts Price Category the domain belongs to. It then updates it and then returns the updated domain information
     * @summary Update additional donuts price category data
     * @param {string} id Unique identifier of the domain name
     * @param {string} companyId Unique identifier of the company the domain belongs to
     * @param {DonutsPriceCategoryDataDto} donutsPriceCategoryDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainNamesApi
     */
    public updateDomainNameAdditionalDonutsPriceCategoryData(id: string, companyId: string, donutsPriceCategoryDataDto: DonutsPriceCategoryDataDto, options?: RawAxiosRequestConfig) {
        return DomainNamesApiFp(this.configuration).updateDomainNameAdditionalDonutsPriceCategoryData(id, companyId, donutsPriceCategoryDataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Receives the unique identifiers of a company(companyId) a domain name(id) and the intended use information for the domain. It then updates them and returns the updated domain information.
     * @summary Update additional intended use params data
     * @param {string} id Unique identifier of the domain name
     * @param {string} companyId Unique identifier of the company the domain belongs to
     * @param {IntendedUseParamsDataDto} intendedUseParamsDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainNamesApi
     */
    public updateDomainNameAdditionalIntendedUseParamsDataDto(id: string, companyId: string, intendedUseParamsDataDto: IntendedUseParamsDataDto, options?: RawAxiosRequestConfig) {
        return DomainNamesApiFp(this.configuration).updateDomainNameAdditionalIntendedUseParamsDataDto(id, companyId, intendedUseParamsDataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Receives the unique identifiers of a company(companyId) a domain name(id) and the premium price category the domain belongs to. It then updates them and returns the updated domain information.
     * @summary Update additional premium price category data
     * @param {string} id Unique identifier of the domain name
     * @param {string} companyId Unique identifier of the company the domain belongs to
     * @param {PremiumPriceCategoryDataDto} premiumPriceCategoryDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainNamesApi
     */
    public updateDomainNameAdditionalPremiumPriceCategoryData(id: string, companyId: string, premiumPriceCategoryDataDto: PremiumPriceCategoryDataDto, options?: RawAxiosRequestConfig) {
        return DomainNamesApiFp(this.configuration).updateDomainNameAdditionalPremiumPriceCategoryData(id, companyId, premiumPriceCategoryDataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Receives the unique identifiers of a company(companyId) a domain name(id) and the proxy service information associated with the domain. It then updates them and returns the updated domain information.
     * @summary Update additional proxy service data
     * @param {string} id Unique identifier of the domain name
     * @param {string} companyId Unique identifier of the company the domain belongs to
     * @param {ProxyServiceDataDto} proxyServiceDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainNamesApi
     */
    public updateDomainNameAdditionalProxyServiceDataDto(id: string, companyId: string, proxyServiceDataDto: ProxyServiceDataDto, options?: RawAxiosRequestConfig) {
        return DomainNamesApiFp(this.configuration).updateDomainNameAdditionalProxyServiceDataDto(id, companyId, proxyServiceDataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Receives the unique identifiers of a company(companyId) a domain name(id) and the smd file associated with the domain. It then updates it and returns the updated domain information.
     * @summary Update additional sunrise data
     * @param {string} id Unique identifier of the domain name
     * @param {string} companyId Unique identifier of the company the domain belongs to
     * @param {SunriseDataDto} sunriseDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainNamesApi
     */
    public updateDomainNameAdditionalSunriseData(id: string, companyId: string, sunriseDataDto: SunriseDataDto, options?: RawAxiosRequestConfig) {
        return DomainNamesApiFp(this.configuration).updateDomainNameAdditionalSunriseData(id, companyId, sunriseDataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Receives the unique identifiers of a company(companyId) a domain name(id) and the .uk direct information of the domain. It then updates them and returns the updated domain information.
     * @summary Update additional uk direct data
     * @param {string} id Unique identifier of the domain name
     * @param {string} companyId Unique identifier of the company the domain belongs to
     * @param {UKDirectDataDto} uKDirectDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainNamesApi
     */
    public updateDomainNameAdditionalUkDirectData(id: string, companyId: string, uKDirectDataDto: UKDirectDataDto, options?: RawAxiosRequestConfig) {
        return DomainNamesApiFp(this.configuration).updateDomainNameAdditionalUkDirectData(id, companyId, uKDirectDataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Receives the unique identifiers of a company(companyId) a domain name(id) and the .xxx member info of the domain. It then updates them and returns the updated domain information.
     * @summary Update additional xxx member data
     * @param {string} id Unique identifier of the domain name
     * @param {string} companyId Unique identifier of the company the domain belongs to
     * @param {XXXMemberDataDto} xXXMemberDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainNamesApi
     */
    public updateDomainNameAdditionalxxxMemberData(id: string, companyId: string, xXXMemberDataDto: XXXMemberDataDto, options?: RawAxiosRequestConfig) {
        return DomainNamesApiFp(this.configuration).updateDomainNameAdditionalxxxMemberData(id, companyId, xXXMemberDataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Receives the unique identifiers of a company(companyId) a domain name(id) and the new Admin Code. It then updates the domain admin code by replacing the old one with the new one. Finally it returns the updated domain information.
     * @summary Update admin code
     * @param {string} id Unique identifier of the domain name
     * @param {string} newAdminCode New admin code
     * @param {string} companyId Unique identifier of the company the domain belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainNamesApi
     */
    public updateDomainNameAdminCode(id: string, newAdminCode: string, companyId: string, options?: RawAxiosRequestConfig) {
        return DomainNamesApiFp(this.configuration).updateDomainNameAdminCode(id, newAdminCode, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Receives the unique identifiers of a company(companyId) a domain name(id) and the new Billing Code. It then updates the domain billing code by replacing the old one with the new one. Finally it returns the updated domain information.
     * @summary Update billing code
     * @param {string} id Unique identifier of the domain name
     * @param {string} newBillingCode New billing code
     * @param {string} companyId Unique identifier of the company the domain belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainNamesApi
     */
    public updateDomainNameBillingCode(id: string, newBillingCode: string, companyId: string, options?: RawAxiosRequestConfig) {
        return DomainNamesApiFp(this.configuration).updateDomainNameBillingCode(id, newBillingCode, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Receives the unique identifiers of a company(companyId) a domain name(id) and the new Registrant Code. It then updates the domain registrant code by replacing the old one with the new one. Finally it returns the updated domain information.
     * @summary Update registrant code
     * @param {string} id Unique identifier of the domain name
     * @param {string} companyId Unique identifier of the company the domain belongs to
     * @param {string} newRegistrantCode New registrant code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainNamesApi
     */
    public updateDomainNameRegistrantCode(id: string, companyId: string, newRegistrantCode: string, options?: RawAxiosRequestConfig) {
        return DomainNamesApiFp(this.configuration).updateDomainNameRegistrantCode(id, companyId, newRegistrantCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Receives the unique identifiers of a company(companyId) a domain name(id) and the new Technical Code. It then updates the domain technical code by replacing the old one with the new one. Finally it returns the updated domain information.
     * @summary Update tech code
     * @param {string} id Unique identifier of the domain name
     * @param {string} newTechCode New tech code
     * @param {string} companyId Unique identifier of the company the domain belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainNamesApi
     */
    public updateDomainNameTechCode(id: string, newTechCode: string, companyId: string, options?: RawAxiosRequestConfig) {
        return DomainNamesApiFp(this.configuration).updateDomainNameTechCode(id, newTechCode, companyId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * IPGroupsApi - axios parameter creator
 * @export
 */
export const IPGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new ip group. Returns a IpGroupDto.
         * @summary Creates a new IP group
         * @param {string} companyId companyId
         * @param {IpGroupDto} ipGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIpGroup: async (companyId: string, ipGroupDto: IpGroupDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('createIpGroup', 'companyId', companyId)
            // verify required parameter 'ipGroupDto' is not null or undefined
            assertParamExists('createIpGroup', 'ipGroupDto', ipGroupDto)
            const localVarPath = `/ip-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ipGroupDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a certain ip group. Returns a IpGroupDto.
         * @summary Delete a ipGroups
         * @param {string} id IpGroups ID
         * @param {string} companyId companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIpGroup: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteIpGroup', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deleteIpGroup', 'companyId', companyId)
            const localVarPath = `/ip-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all ip groups. Returns an array of IpGroupDto.
         * @summary Get list of all ipGroups
         * @param {string} companyId companyId
         * @param {string} name 
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findIpGroups: async (companyId: string, name: string, currentPage?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('findIpGroups', 'companyId', companyId)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('findIpGroups', 'name', name)
            const localVarPath = `/ip-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a certain ip group. Returns a IpGroupDto.
         * @summary Get a ipGroups
         * @param {string} id ID
         * @param {string} companyId companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIpGroup: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIpGroup', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getIpGroup', 'companyId', companyId)
            const localVarPath = `/ip-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a certain ip group. Returns a IpGroupDto.
         * @summary Update a ipGroups
         * @param {string} id IpGroups ID
         * @param {string} companyId companyId
         * @param {IpGroupDto} ipGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIpGroup: async (id: string, companyId: string, ipGroupDto: IpGroupDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateIpGroup', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateIpGroup', 'companyId', companyId)
            // verify required parameter 'ipGroupDto' is not null or undefined
            assertParamExists('updateIpGroup', 'ipGroupDto', ipGroupDto)
            const localVarPath = `/ip-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ipGroupDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IPGroupsApi - functional programming interface
 * @export
 */
export const IPGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IPGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new ip group. Returns a IpGroupDto.
         * @summary Creates a new IP group
         * @param {string} companyId companyId
         * @param {IpGroupDto} ipGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createIpGroup(companyId: string, ipGroupDto: IpGroupDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateIpGroup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createIpGroup(companyId, ipGroupDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IPGroupsApi.createIpGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a certain ip group. Returns a IpGroupDto.
         * @summary Delete a ipGroups
         * @param {string} id IpGroups ID
         * @param {string} companyId companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteIpGroup(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteIpGroup(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IPGroupsApi.deleteIpGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all ip groups. Returns an array of IpGroupDto.
         * @summary Get list of all ipGroups
         * @param {string} companyId companyId
         * @param {string} name 
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findIpGroups(companyId: string, name: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindIpGroups200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findIpGroups(companyId, name, currentPage, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IPGroupsApi.findIpGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a certain ip group. Returns a IpGroupDto.
         * @summary Get a ipGroups
         * @param {string} id ID
         * @param {string} companyId companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIpGroup(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateIpGroup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIpGroup(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IPGroupsApi.getIpGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a certain ip group. Returns a IpGroupDto.
         * @summary Update a ipGroups
         * @param {string} id IpGroups ID
         * @param {string} companyId companyId
         * @param {IpGroupDto} ipGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateIpGroup(id: string, companyId: string, ipGroupDto: IpGroupDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateIpGroup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateIpGroup(id, companyId, ipGroupDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IPGroupsApi.updateIpGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IPGroupsApi - factory interface
 * @export
 */
export const IPGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IPGroupsApiFp(configuration)
    return {
        /**
         * Creates a new ip group. Returns a IpGroupDto.
         * @summary Creates a new IP group
         * @param {string} companyId companyId
         * @param {IpGroupDto} ipGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIpGroup(companyId: string, ipGroupDto: IpGroupDto, options?: any): AxiosPromise<CreateIpGroup200Response> {
            return localVarFp.createIpGroup(companyId, ipGroupDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a certain ip group. Returns a IpGroupDto.
         * @summary Delete a ipGroups
         * @param {string} id IpGroups ID
         * @param {string} companyId companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIpGroup(id: string, companyId: string, options?: any): AxiosPromise<GetInvoice200Response> {
            return localVarFp.deleteIpGroup(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all ip groups. Returns an array of IpGroupDto.
         * @summary Get list of all ipGroups
         * @param {string} companyId companyId
         * @param {string} name 
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findIpGroups(companyId: string, name: string, currentPage?: number, perPage?: number, options?: any): AxiosPromise<FindIpGroups200Response> {
            return localVarFp.findIpGroups(companyId, name, currentPage, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a certain ip group. Returns a IpGroupDto.
         * @summary Get a ipGroups
         * @param {string} id ID
         * @param {string} companyId companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIpGroup(id: string, companyId: string, options?: any): AxiosPromise<CreateIpGroup200Response> {
            return localVarFp.getIpGroup(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a certain ip group. Returns a IpGroupDto.
         * @summary Update a ipGroups
         * @param {string} id IpGroups ID
         * @param {string} companyId companyId
         * @param {IpGroupDto} ipGroupDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIpGroup(id: string, companyId: string, ipGroupDto: IpGroupDto, options?: any): AxiosPromise<CreateIpGroup200Response> {
            return localVarFp.updateIpGroup(id, companyId, ipGroupDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IPGroupsApi - object-oriented interface
 * @export
 * @class IPGroupsApi
 * @extends {BaseAPI}
 */
export class IPGroupsApi extends BaseAPI {
    /**
     * Creates a new ip group. Returns a IpGroupDto.
     * @summary Creates a new IP group
     * @param {string} companyId companyId
     * @param {IpGroupDto} ipGroupDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IPGroupsApi
     */
    public createIpGroup(companyId: string, ipGroupDto: IpGroupDto, options?: RawAxiosRequestConfig) {
        return IPGroupsApiFp(this.configuration).createIpGroup(companyId, ipGroupDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a certain ip group. Returns a IpGroupDto.
     * @summary Delete a ipGroups
     * @param {string} id IpGroups ID
     * @param {string} companyId companyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IPGroupsApi
     */
    public deleteIpGroup(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return IPGroupsApiFp(this.configuration).deleteIpGroup(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all ip groups. Returns an array of IpGroupDto.
     * @summary Get list of all ipGroups
     * @param {string} companyId companyId
     * @param {string} name 
     * @param {number} [currentPage] current page
     * @param {number} [perPage] per Page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IPGroupsApi
     */
    public findIpGroups(companyId: string, name: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return IPGroupsApiFp(this.configuration).findIpGroups(companyId, name, currentPage, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a certain ip group. Returns a IpGroupDto.
     * @summary Get a ipGroups
     * @param {string} id ID
     * @param {string} companyId companyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IPGroupsApi
     */
    public getIpGroup(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return IPGroupsApiFp(this.configuration).getIpGroup(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a certain ip group. Returns a IpGroupDto.
     * @summary Update a ipGroups
     * @param {string} id IpGroups ID
     * @param {string} companyId companyId
     * @param {IpGroupDto} ipGroupDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IPGroupsApi
     */
    public updateIpGroup(id: string, companyId: string, ipGroupDto: IpGroupDto, options?: RawAxiosRequestConfig) {
        return IPGroupsApiFp(this.configuration).updateIpGroup(id, companyId, ipGroupDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * IPsApi - axios parameter creator
 * @export
 */
export const IPsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new ip. Returns a IpDto.
         * @summary Creates a new IP group
         * @param {string} companyId companyId
         * @param {IpDto} ipDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIP: async (companyId: string, ipDto: IpDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('createIP', 'companyId', companyId)
            // verify required parameter 'ipDto' is not null or undefined
            assertParamExists('createIP', 'ipDto', ipDto)
            const localVarPath = `/ips`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ipDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a certain ip. Returns null.
         * @summary Delete a ips
         * @param {string} companyId companyId
         * @param {string} id Ips ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIP: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deleteIP', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteIP', 'id', id)
            const localVarPath = `/ips/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all ips. Returns an array of IpDto.
         * @summary Get list of all ips
         * @param {string} companyId companyId
         * @param {FindIPsAddressEnum} [address] ip address
         * @param {number} [range] 
         * @param {FindIPsTypeEnum} [type] 
         * @param {string} [groupId] 
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findIPs: async (companyId: string, address?: FindIPsAddressEnum, range?: number, type?: FindIPsTypeEnum, groupId?: string, currentPage?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('findIPs', 'companyId', companyId)
            const localVarPath = `/ips`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (range !== undefined) {
                localVarQueryParameter['range'] = range;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['groupId'] = groupId;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a certain ip. Returns an IpDto.
         * @summary Get an ip
         * @param {string} id ID
         * @param {string} companyId companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIP: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIP', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getIP', 'companyId', companyId)
            const localVarPath = `/ips/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a certain ip. Returns a IpDto.
         * @summary Update a ips
         * @param {string} companyId companyId
         * @param {string} id Ips ID
         * @param {IpDto} ipDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIP: async (companyId: string, id: string, ipDto: IpDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateIP', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateIP', 'id', id)
            // verify required parameter 'ipDto' is not null or undefined
            assertParamExists('updateIP', 'ipDto', ipDto)
            const localVarPath = `/ips/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ipDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IPsApi - functional programming interface
 * @export
 */
export const IPsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IPsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new ip. Returns a IpDto.
         * @summary Creates a new IP group
         * @param {string} companyId companyId
         * @param {IpDto} ipDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createIP(companyId: string, ipDto: IpDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindIPs200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createIP(companyId, ipDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IPsApi.createIP']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a certain ip. Returns null.
         * @summary Delete a ips
         * @param {string} companyId companyId
         * @param {string} id Ips ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteIP(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteIP(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IPsApi.deleteIP']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all ips. Returns an array of IpDto.
         * @summary Get list of all ips
         * @param {string} companyId companyId
         * @param {FindIPsAddressEnum} [address] ip address
         * @param {number} [range] 
         * @param {FindIPsTypeEnum} [type] 
         * @param {string} [groupId] 
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findIPs(companyId: string, address?: FindIPsAddressEnum, range?: number, type?: FindIPsTypeEnum, groupId?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindIPs200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findIPs(companyId, address, range, type, groupId, currentPage, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IPsApi.findIPs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a certain ip. Returns an IpDto.
         * @summary Get an ip
         * @param {string} id ID
         * @param {string} companyId companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIP(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindIPs200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIP(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IPsApi.getIP']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a certain ip. Returns a IpDto.
         * @summary Update a ips
         * @param {string} companyId companyId
         * @param {string} id Ips ID
         * @param {IpDto} ipDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateIP(companyId: string, id: string, ipDto: IpDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindIPs200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateIP(companyId, id, ipDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IPsApi.updateIP']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IPsApi - factory interface
 * @export
 */
export const IPsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IPsApiFp(configuration)
    return {
        /**
         * Creates a new ip. Returns a IpDto.
         * @summary Creates a new IP group
         * @param {string} companyId companyId
         * @param {IpDto} ipDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIP(companyId: string, ipDto: IpDto, options?: any): AxiosPromise<FindIPs200Response> {
            return localVarFp.createIP(companyId, ipDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a certain ip. Returns null.
         * @summary Delete a ips
         * @param {string} companyId companyId
         * @param {string} id Ips ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIP(companyId: string, id: string, options?: any): AxiosPromise<GetInvoice200Response> {
            return localVarFp.deleteIP(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all ips. Returns an array of IpDto.
         * @summary Get list of all ips
         * @param {string} companyId companyId
         * @param {FindIPsAddressEnum} [address] ip address
         * @param {number} [range] 
         * @param {FindIPsTypeEnum} [type] 
         * @param {string} [groupId] 
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findIPs(companyId: string, address?: FindIPsAddressEnum, range?: number, type?: FindIPsTypeEnum, groupId?: string, currentPage?: number, perPage?: number, options?: any): AxiosPromise<FindIPs200Response> {
            return localVarFp.findIPs(companyId, address, range, type, groupId, currentPage, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a certain ip. Returns an IpDto.
         * @summary Get an ip
         * @param {string} id ID
         * @param {string} companyId companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIP(id: string, companyId: string, options?: any): AxiosPromise<FindIPs200Response> {
            return localVarFp.getIP(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a certain ip. Returns a IpDto.
         * @summary Update a ips
         * @param {string} companyId companyId
         * @param {string} id Ips ID
         * @param {IpDto} ipDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIP(companyId: string, id: string, ipDto: IpDto, options?: any): AxiosPromise<FindIPs200Response> {
            return localVarFp.updateIP(companyId, id, ipDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IPsApi - object-oriented interface
 * @export
 * @class IPsApi
 * @extends {BaseAPI}
 */
export class IPsApi extends BaseAPI {
    /**
     * Creates a new ip. Returns a IpDto.
     * @summary Creates a new IP group
     * @param {string} companyId companyId
     * @param {IpDto} ipDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IPsApi
     */
    public createIP(companyId: string, ipDto: IpDto, options?: RawAxiosRequestConfig) {
        return IPsApiFp(this.configuration).createIP(companyId, ipDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a certain ip. Returns null.
     * @summary Delete a ips
     * @param {string} companyId companyId
     * @param {string} id Ips ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IPsApi
     */
    public deleteIP(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return IPsApiFp(this.configuration).deleteIP(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all ips. Returns an array of IpDto.
     * @summary Get list of all ips
     * @param {string} companyId companyId
     * @param {FindIPsAddressEnum} [address] ip address
     * @param {number} [range] 
     * @param {FindIPsTypeEnum} [type] 
     * @param {string} [groupId] 
     * @param {number} [currentPage] current page
     * @param {number} [perPage] per Page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IPsApi
     */
    public findIPs(companyId: string, address?: FindIPsAddressEnum, range?: number, type?: FindIPsTypeEnum, groupId?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return IPsApiFp(this.configuration).findIPs(companyId, address, range, type, groupId, currentPage, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a certain ip. Returns an IpDto.
     * @summary Get an ip
     * @param {string} id ID
     * @param {string} companyId companyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IPsApi
     */
    public getIP(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return IPsApiFp(this.configuration).getIP(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a certain ip. Returns a IpDto.
     * @summary Update a ips
     * @param {string} companyId companyId
     * @param {string} id Ips ID
     * @param {IpDto} ipDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IPsApi
     */
    public updateIP(companyId: string, id: string, ipDto: IpDto, options?: RawAxiosRequestConfig) {
        return IPsApiFp(this.configuration).updateIP(companyId, id, ipDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const FindIPsAddressEnum = {
    Ipv4: 'ipv4',
    Ipv6: 'ipv6'
} as const;
export type FindIPsAddressEnum = typeof FindIPsAddressEnum[keyof typeof FindIPsAddressEnum];
/**
 * @export
 */
export const FindIPsTypeEnum = {
    Ipv4: 'IPv4',
    Ipv6: 'IPv6'
} as const;
export type FindIPsTypeEnum = typeof FindIPsTypeEnum[keyof typeof FindIPsTypeEnum];


/**
 * IntegrationsApi - axios parameter creator
 * @export
 */
export const IntegrationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a token. Returns a IntegrationDto.
         * @summary Check an integration
         * @param {string} companyId The company ID
         * @param {string} token The integration token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkIntegration: async (companyId: string, token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('checkIntegration', 'companyId', companyId)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('checkIntegration', 'token', token)
            const localVarPath = `/integrations/token/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new service integration. Returns a IntegrationDto.
         * @summary Creates a integration
         * @param {string} companyId 
         * @param {IntegrationDto} integrationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIntegration: async (companyId: string, integrationDto: IntegrationDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('createIntegration', 'companyId', companyId)
            // verify required parameter 'integrationDto' is not null or undefined
            assertParamExists('createIntegration', 'integrationDto', integrationDto)
            const localVarPath = `/integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(integrationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a integration. Returns a boolean that indicates the success of the delete action.
         * @summary Delete an integration
         * @param {string} companyId 
         * @param {string} id integration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIntegration: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deleteIntegration', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteIntegration', 'id', id)
            const localVarPath = `/integrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all the service integrations.
         * @summary Get list of all service integrations. Returns an array of IntegrationDto.
         * @param {string} [title] 
         * @param {FindIntegrationsTypeEnum} [type] 
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findIntegrations: async (title?: string, type?: FindIntegrationsTypeEnum, currentPage?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a certain integration. Returns a IntegrationDto.
         * @summary Get a integration
         * @param {string} companyId 
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegration: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getIntegration', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIntegration', 'id', id)
            const localVarPath = `/integrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a certains service integration info based on specific product. Returns a SingleResponseDto.
         * @summary integration info
         * @param {string} companyId 
         * @param {string} productId integration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductInfoIntegration: async (companyId: string, productId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getProductInfoIntegration', 'companyId', companyId)
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getProductInfoIntegration', 'productId', productId)
            const localVarPath = `/integrations/info/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends an event hook to the service integration. Returns null.
         * @summary integration event hook
         * @param {string} companyId 
         * @param {string} id integration ID
         * @param {string} event 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hookIntegration: async (companyId: string, id: string, event: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('hookIntegration', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('hookIntegration', 'id', id)
            // verify required parameter 'event' is not null or undefined
            assertParamExists('hookIntegration', 'event', event)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('hookIntegration', 'body', body)
            const localVarPath = `/integrations/{id}/hooks`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (event !== undefined) {
                localVarQueryParameter['event'] = event;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves info about a service integration.Returns a SingleResponseDto.
         * @summary integration info
         * @param {string} companyId 
         * @param {string} id integration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoIntegration: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('infoIntegration', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('infoIntegration', 'id', id)
            const localVarPath = `/integrations/{id}/info`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Installs a service integration.
         * @summary integration install
         * @param {string} id integration ID
         * @param {string} companyId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installIntegration: async (id: string, companyId: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('installIntegration', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('installIntegration', 'companyId', companyId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('installIntegration', 'body', body)
            const localVarPath = `/integrations/{id}/install`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a scheduled maintenance. Returns IntegrationDto.
         * @summary ScheduleMaintenance
         * @param {string} companyId 
         * @param {string} id Integration ID
         * @param {string} maintenanceStartDate Maintenance start date
         * @param {string} maintenanceEndDate Maintenance end date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleIntegrationMaintenance: async (companyId: string, id: string, maintenanceStartDate: string, maintenanceEndDate: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('scheduleIntegrationMaintenance', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('scheduleIntegrationMaintenance', 'id', id)
            // verify required parameter 'maintenanceStartDate' is not null or undefined
            assertParamExists('scheduleIntegrationMaintenance', 'maintenanceStartDate', maintenanceStartDate)
            // verify required parameter 'maintenanceEndDate' is not null or undefined
            assertParamExists('scheduleIntegrationMaintenance', 'maintenanceEndDate', maintenanceEndDate)
            const localVarPath = `/integrations/{id}/maintenance/schedule`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (maintenanceStartDate !== undefined) {
                localVarQueryParameter['maintenanceStartDate'] = (maintenanceStartDate as any instanceof Date) ?
                    (maintenanceStartDate as any).toISOString().substring(0,10) :
                    maintenanceStartDate;
            }

            if (maintenanceEndDate !== undefined) {
                localVarQueryParameter['maintenanceEndDate'] = (maintenanceEndDate as any instanceof Date) ?
                    (maintenanceEndDate as any).toISOString().substring(0,10) :
                    maintenanceEndDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts a scheduled maintenance. Returns a success message and a IntegrationDto.
         * @summary integration start maintenance
         * @param {string} companyId 
         * @param {string} id integration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startIntegrationMaintenance: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('startIntegrationMaintenance', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('startIntegrationMaintenance', 'id', id)
            const localVarPath = `/integrations/{id}/maintenance/start`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stops a scheduled maintenance. Returns a success message and a IntegrationDto.
         * @summary integration stop maintenance
         * @param {string} companyId 
         * @param {string} id integration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopIntegrationMaintenance: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('stopIntegrationMaintenance', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stopIntegrationMaintenance', 'id', id)
            const localVarPath = `/integrations/{id}/maintenance/stop`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refreshes the authentication token of a certain integration. Returns a string with the new token.
         * @summary Refresh integration token
         * @param {string} companyId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenRefreshIntegration: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('tokenRefreshIntegration', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tokenRefreshIntegration', 'id', id)
            const localVarPath = `/integrations/{id}/refresh-token`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uninstalls a service integration.
         * @summary integration uninstall
         * @param {string} companyId 
         * @param {string} id integration ID
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallIntegration: async (companyId: string, id: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('uninstallIntegration', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uninstallIntegration', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('uninstallIntegration', 'body', body)
            const localVarPath = `/integrations/{id}/uninstall`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a certain integration. Returns a IntegrationDto.
         * @summary Update integration
         * @param {string} companyId 
         * @param {string} id integration ID
         * @param {IntegrationDto} integrationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIntegration: async (companyId: string, id: string, integrationDto: IntegrationDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateIntegration', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateIntegration', 'id', id)
            // verify required parameter 'integrationDto' is not null or undefined
            assertParamExists('updateIntegration', 'integrationDto', integrationDto)
            const localVarPath = `/integrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(integrationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends an action field to be validated to the service integration.
         * @summary Validate integration
         * @param {string} companyId 
         * @param {string} productId integration ID
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateIntegration: async (companyId: string, productId: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('validateIntegration', 'companyId', companyId)
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('validateIntegration', 'productId', productId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('validateIntegration', 'body', body)
            const localVarPath = `/integrations/validate/action-fields/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IntegrationsApi - functional programming interface
 * @export
 */
export const IntegrationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IntegrationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a token. Returns a IntegrationDto.
         * @summary Check an integration
         * @param {string} companyId The company ID
         * @param {string} token The integration token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkIntegration(companyId: string, token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateIntegration201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkIntegration(companyId, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.checkIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new service integration. Returns a IntegrationDto.
         * @summary Creates a integration
         * @param {string} companyId 
         * @param {IntegrationDto} integrationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createIntegration(companyId: string, integrationDto: IntegrationDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateIntegration201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createIntegration(companyId, integrationDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.createIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a integration. Returns a boolean that indicates the success of the delete action.
         * @summary Delete an integration
         * @param {string} companyId 
         * @param {string} id integration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteIntegration(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteIntegration(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.deleteIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all the service integrations.
         * @summary Get list of all service integrations. Returns an array of IntegrationDto.
         * @param {string} [title] 
         * @param {FindIntegrationsTypeEnum} [type] 
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findIntegrations(title?: string, type?: FindIntegrationsTypeEnum, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindIntegrations200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findIntegrations(title, type, currentPage, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.findIntegrations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a certain integration. Returns a IntegrationDto.
         * @summary Get a integration
         * @param {string} companyId 
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIntegration(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateIntegration201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIntegration(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.getIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a certains service integration info based on specific product. Returns a SingleResponseDto.
         * @summary integration info
         * @param {string} companyId 
         * @param {string} productId integration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductInfoIntegration(companyId: string, productId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductInfoIntegration(companyId, productId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.getProductInfoIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sends an event hook to the service integration. Returns null.
         * @summary integration event hook
         * @param {string} companyId 
         * @param {string} id integration ID
         * @param {string} event 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hookIntegration(companyId: string, id: string, event: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hookIntegration(companyId, id, event, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.hookIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves info about a service integration.Returns a SingleResponseDto.
         * @summary integration info
         * @param {string} companyId 
         * @param {string} id integration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async infoIntegration(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.infoIntegration(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.infoIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Installs a service integration.
         * @summary integration install
         * @param {string} id integration ID
         * @param {string} companyId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async installIntegration(id: string, companyId: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.installIntegration(id, companyId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.installIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a scheduled maintenance. Returns IntegrationDto.
         * @summary ScheduleMaintenance
         * @param {string} companyId 
         * @param {string} id Integration ID
         * @param {string} maintenanceStartDate Maintenance start date
         * @param {string} maintenanceEndDate Maintenance end date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scheduleIntegrationMaintenance(companyId: string, id: string, maintenanceStartDate: string, maintenanceEndDate: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateIntegration201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleIntegrationMaintenance(companyId, id, maintenanceStartDate, maintenanceEndDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.scheduleIntegrationMaintenance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Starts a scheduled maintenance. Returns a success message and a IntegrationDto.
         * @summary integration start maintenance
         * @param {string} companyId 
         * @param {string} id integration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startIntegrationMaintenance(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateIntegration201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startIntegrationMaintenance(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.startIntegrationMaintenance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Stops a scheduled maintenance. Returns a success message and a IntegrationDto.
         * @summary integration stop maintenance
         * @param {string} companyId 
         * @param {string} id integration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopIntegrationMaintenance(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateIntegration201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopIntegrationMaintenance(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.stopIntegrationMaintenance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Refreshes the authentication token of a certain integration. Returns a string with the new token.
         * @summary Refresh integration token
         * @param {string} companyId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenRefreshIntegration(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateIntegration201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenRefreshIntegration(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.tokenRefreshIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Uninstalls a service integration.
         * @summary integration uninstall
         * @param {string} companyId 
         * @param {string} id integration ID
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uninstallIntegration(companyId: string, id: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uninstallIntegration(companyId, id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.uninstallIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a certain integration. Returns a IntegrationDto.
         * @summary Update integration
         * @param {string} companyId 
         * @param {string} id integration ID
         * @param {IntegrationDto} integrationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateIntegration(companyId: string, id: string, integrationDto: IntegrationDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateIntegration201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateIntegration(companyId, id, integrationDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.updateIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sends an action field to be validated to the service integration.
         * @summary Validate integration
         * @param {string} companyId 
         * @param {string} productId integration ID
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateIntegration(companyId: string, productId: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateIntegration(companyId, productId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.validateIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IntegrationsApi - factory interface
 * @export
 */
export const IntegrationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IntegrationsApiFp(configuration)
    return {
        /**
         * Retrieves a token. Returns a IntegrationDto.
         * @summary Check an integration
         * @param {string} companyId The company ID
         * @param {string} token The integration token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkIntegration(companyId: string, token: string, options?: any): AxiosPromise<CreateIntegration201Response> {
            return localVarFp.checkIntegration(companyId, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new service integration. Returns a IntegrationDto.
         * @summary Creates a integration
         * @param {string} companyId 
         * @param {IntegrationDto} integrationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIntegration(companyId: string, integrationDto: IntegrationDto, options?: any): AxiosPromise<CreateIntegration201Response> {
            return localVarFp.createIntegration(companyId, integrationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a integration. Returns a boolean that indicates the success of the delete action.
         * @summary Delete an integration
         * @param {string} companyId 
         * @param {string} id integration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIntegration(companyId: string, id: string, options?: any): AxiosPromise<GetInvoice200Response> {
            return localVarFp.deleteIntegration(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all the service integrations.
         * @summary Get list of all service integrations. Returns an array of IntegrationDto.
         * @param {string} [title] 
         * @param {FindIntegrationsTypeEnum} [type] 
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findIntegrations(title?: string, type?: FindIntegrationsTypeEnum, currentPage?: number, perPage?: number, options?: any): AxiosPromise<FindIntegrations200Response> {
            return localVarFp.findIntegrations(title, type, currentPage, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a certain integration. Returns a IntegrationDto.
         * @summary Get a integration
         * @param {string} companyId 
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegration(companyId: string, id: string, options?: any): AxiosPromise<CreateIntegration201Response> {
            return localVarFp.getIntegration(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a certains service integration info based on specific product. Returns a SingleResponseDto.
         * @summary integration info
         * @param {string} companyId 
         * @param {string} productId integration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductInfoIntegration(companyId: string, productId: string, options?: any): AxiosPromise<GetInvoice200Response> {
            return localVarFp.getProductInfoIntegration(companyId, productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends an event hook to the service integration. Returns null.
         * @summary integration event hook
         * @param {string} companyId 
         * @param {string} id integration ID
         * @param {string} event 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hookIntegration(companyId: string, id: string, event: string, body: object, options?: any): AxiosPromise<GetInvoice200Response> {
            return localVarFp.hookIntegration(companyId, id, event, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves info about a service integration.Returns a SingleResponseDto.
         * @summary integration info
         * @param {string} companyId 
         * @param {string} id integration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        infoIntegration(companyId: string, id: string, options?: any): AxiosPromise<GetInvoice200Response> {
            return localVarFp.infoIntegration(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Installs a service integration.
         * @summary integration install
         * @param {string} id integration ID
         * @param {string} companyId 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installIntegration(id: string, companyId: string, body: object, options?: any): AxiosPromise<GetInvoice200Response> {
            return localVarFp.installIntegration(id, companyId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a scheduled maintenance. Returns IntegrationDto.
         * @summary ScheduleMaintenance
         * @param {string} companyId 
         * @param {string} id Integration ID
         * @param {string} maintenanceStartDate Maintenance start date
         * @param {string} maintenanceEndDate Maintenance end date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleIntegrationMaintenance(companyId: string, id: string, maintenanceStartDate: string, maintenanceEndDate: string, options?: any): AxiosPromise<CreateIntegration201Response> {
            return localVarFp.scheduleIntegrationMaintenance(companyId, id, maintenanceStartDate, maintenanceEndDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Starts a scheduled maintenance. Returns a success message and a IntegrationDto.
         * @summary integration start maintenance
         * @param {string} companyId 
         * @param {string} id integration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startIntegrationMaintenance(companyId: string, id: string, options?: any): AxiosPromise<CreateIntegration201Response> {
            return localVarFp.startIntegrationMaintenance(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Stops a scheduled maintenance. Returns a success message and a IntegrationDto.
         * @summary integration stop maintenance
         * @param {string} companyId 
         * @param {string} id integration ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopIntegrationMaintenance(companyId: string, id: string, options?: any): AxiosPromise<CreateIntegration201Response> {
            return localVarFp.stopIntegrationMaintenance(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Refreshes the authentication token of a certain integration. Returns a string with the new token.
         * @summary Refresh integration token
         * @param {string} companyId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenRefreshIntegration(companyId: string, id: string, options?: any): AxiosPromise<CreateIntegration201Response> {
            return localVarFp.tokenRefreshIntegration(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Uninstalls a service integration.
         * @summary integration uninstall
         * @param {string} companyId 
         * @param {string} id integration ID
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallIntegration(companyId: string, id: string, body: object, options?: any): AxiosPromise<GetInvoice200Response> {
            return localVarFp.uninstallIntegration(companyId, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a certain integration. Returns a IntegrationDto.
         * @summary Update integration
         * @param {string} companyId 
         * @param {string} id integration ID
         * @param {IntegrationDto} integrationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIntegration(companyId: string, id: string, integrationDto: IntegrationDto, options?: any): AxiosPromise<CreateIntegration201Response> {
            return localVarFp.updateIntegration(companyId, id, integrationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends an action field to be validated to the service integration.
         * @summary Validate integration
         * @param {string} companyId 
         * @param {string} productId integration ID
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateIntegration(companyId: string, productId: string, body: object, options?: any): AxiosPromise<GetInvoice200Response> {
            return localVarFp.validateIntegration(companyId, productId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IntegrationsApi - object-oriented interface
 * @export
 * @class IntegrationsApi
 * @extends {BaseAPI}
 */
export class IntegrationsApi extends BaseAPI {
    /**
     * Retrieves a token. Returns a IntegrationDto.
     * @summary Check an integration
     * @param {string} companyId The company ID
     * @param {string} token The integration token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public checkIntegration(companyId: string, token: string, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).checkIntegration(companyId, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new service integration. Returns a IntegrationDto.
     * @summary Creates a integration
     * @param {string} companyId 
     * @param {IntegrationDto} integrationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public createIntegration(companyId: string, integrationDto: IntegrationDto, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).createIntegration(companyId, integrationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a integration. Returns a boolean that indicates the success of the delete action.
     * @summary Delete an integration
     * @param {string} companyId 
     * @param {string} id integration ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public deleteIntegration(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).deleteIntegration(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all the service integrations.
     * @summary Get list of all service integrations. Returns an array of IntegrationDto.
     * @param {string} [title] 
     * @param {FindIntegrationsTypeEnum} [type] 
     * @param {number} [currentPage] current page
     * @param {number} [perPage] per Page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public findIntegrations(title?: string, type?: FindIntegrationsTypeEnum, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).findIntegrations(title, type, currentPage, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a certain integration. Returns a IntegrationDto.
     * @summary Get a integration
     * @param {string} companyId 
     * @param {string} id ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getIntegration(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).getIntegration(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a certains service integration info based on specific product. Returns a SingleResponseDto.
     * @summary integration info
     * @param {string} companyId 
     * @param {string} productId integration ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getProductInfoIntegration(companyId: string, productId: string, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).getProductInfoIntegration(companyId, productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends an event hook to the service integration. Returns null.
     * @summary integration event hook
     * @param {string} companyId 
     * @param {string} id integration ID
     * @param {string} event 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public hookIntegration(companyId: string, id: string, event: string, body: object, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).hookIntegration(companyId, id, event, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves info about a service integration.Returns a SingleResponseDto.
     * @summary integration info
     * @param {string} companyId 
     * @param {string} id integration ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public infoIntegration(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).infoIntegration(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Installs a service integration.
     * @summary integration install
     * @param {string} id integration ID
     * @param {string} companyId 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public installIntegration(id: string, companyId: string, body: object, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).installIntegration(id, companyId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a scheduled maintenance. Returns IntegrationDto.
     * @summary ScheduleMaintenance
     * @param {string} companyId 
     * @param {string} id Integration ID
     * @param {string} maintenanceStartDate Maintenance start date
     * @param {string} maintenanceEndDate Maintenance end date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public scheduleIntegrationMaintenance(companyId: string, id: string, maintenanceStartDate: string, maintenanceEndDate: string, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).scheduleIntegrationMaintenance(companyId, id, maintenanceStartDate, maintenanceEndDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starts a scheduled maintenance. Returns a success message and a IntegrationDto.
     * @summary integration start maintenance
     * @param {string} companyId 
     * @param {string} id integration ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public startIntegrationMaintenance(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).startIntegrationMaintenance(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stops a scheduled maintenance. Returns a success message and a IntegrationDto.
     * @summary integration stop maintenance
     * @param {string} companyId 
     * @param {string} id integration ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public stopIntegrationMaintenance(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).stopIntegrationMaintenance(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refreshes the authentication token of a certain integration. Returns a string with the new token.
     * @summary Refresh integration token
     * @param {string} companyId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public tokenRefreshIntegration(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).tokenRefreshIntegration(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uninstalls a service integration.
     * @summary integration uninstall
     * @param {string} companyId 
     * @param {string} id integration ID
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public uninstallIntegration(companyId: string, id: string, body: object, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).uninstallIntegration(companyId, id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a certain integration. Returns a IntegrationDto.
     * @summary Update integration
     * @param {string} companyId 
     * @param {string} id integration ID
     * @param {IntegrationDto} integrationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public updateIntegration(companyId: string, id: string, integrationDto: IntegrationDto, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).updateIntegration(companyId, id, integrationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends an action field to be validated to the service integration.
     * @summary Validate integration
     * @param {string} companyId 
     * @param {string} productId integration ID
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public validateIntegration(companyId: string, productId: string, body: object, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).validateIntegration(companyId, productId, body, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const FindIntegrationsTypeEnum = {
    Product: 'product',
    Registry: 'registry',
    Application: 'application',
    Dns: 'dns',
    Payment: 'payment',
    Notification: 'notification',
    Invoice: 'invoice'
} as const;
export type FindIntegrationsTypeEnum = typeof FindIntegrationsTypeEnum[keyof typeof FindIntegrationsTypeEnum];


/**
 * InvoiceContactsApi - axios parameter creator
 * @export
 */
export const InvoiceContactsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint allows you to create a new invoice contact for a specific company. It returns a response containing the created invoice contact or an error response.
         * @summary Creates a new invoice contact
         * @param {string} companyId companyId
         * @param {InvoiceContactDto} invoiceContactDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceContact: async (companyId: string, invoiceContactDto: InvoiceContactDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('createInvoiceContact', 'companyId', companyId)
            // verify required parameter 'invoiceContactDto' is not null or undefined
            assertParamExists('createInvoiceContact', 'invoiceContactDto', invoiceContactDto)
            const localVarPath = `/invoice-contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(invoiceContactDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to delete an existing invoice contact for a specific company. It retrieves the invoice contact by ID and deletes it. It returns a response indicating the success of the deletion or an error response if the invoice contact is not found.
         * @summary Delete an invoice contact
         * @param {string} id Invoice contact ID
         * @param {string} companyId companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceContact: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteInvoiceContact', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deleteInvoiceContact', 'companyId', companyId)
            const localVarPath = `/invoice-contacts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves a list of invoice contacts based on the provided parameters. It allows filtering by company ID, query string, country, and pagination parameters.
         * @summary Get list of all invoice contacts
         * @param {string} companyId companyId
         * @param {string} [query] Query search for Name, Street, Postcode, Org, City, State, telephone, fax, email
         * @param {FindInvoiceContactsCountryEnum} [country] 
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findInvoiceContacts: async (companyId: string, query?: string, country?: FindInvoiceContactsCountryEnum, currentPage?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('findInvoiceContacts', 'companyId', companyId)
            const localVarPath = `/invoice-contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an invoice contacts
         * @param {string} id ID
         * @param {string} companyId companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceContact: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getInvoiceContact', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getInvoiceContact', 'companyId', companyId)
            const localVarPath = `/invoice-contacts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to update an existing invoice contact for a specific company. It retrieves the invoice contact by ID and updates its details based on the provided data. It returns a response containing the updated invoice contact or an error response.
         * @summary Update an invoice contact
         * @param {string} id Invoice contact ID
         * @param {string} companyId companyId
         * @param {InvoiceContactDto} invoiceContactDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvoiceContact: async (id: string, companyId: string, invoiceContactDto: InvoiceContactDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateInvoiceContact', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateInvoiceContact', 'companyId', companyId)
            // verify required parameter 'invoiceContactDto' is not null or undefined
            assertParamExists('updateInvoiceContact', 'invoiceContactDto', invoiceContactDto)
            const localVarPath = `/invoice-contacts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(invoiceContactDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoiceContactsApi - functional programming interface
 * @export
 */
export const InvoiceContactsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvoiceContactsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint allows you to create a new invoice contact for a specific company. It returns a response containing the created invoice contact or an error response.
         * @summary Creates a new invoice contact
         * @param {string} companyId companyId
         * @param {InvoiceContactDto} invoiceContactDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInvoiceContact(companyId: string, invoiceContactDto: InvoiceContactDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateInvoiceContact200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInvoiceContact(companyId, invoiceContactDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoiceContactsApi.createInvoiceContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint allows you to delete an existing invoice contact for a specific company. It retrieves the invoice contact by ID and deletes it. It returns a response indicating the success of the deletion or an error response if the invoice contact is not found.
         * @summary Delete an invoice contact
         * @param {string} id Invoice contact ID
         * @param {string} companyId companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInvoiceContact(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInvoiceContact(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoiceContactsApi.deleteInvoiceContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint retrieves a list of invoice contacts based on the provided parameters. It allows filtering by company ID, query string, country, and pagination parameters.
         * @summary Get list of all invoice contacts
         * @param {string} companyId companyId
         * @param {string} [query] Query search for Name, Street, Postcode, Org, City, State, telephone, fax, email
         * @param {FindInvoiceContactsCountryEnum} [country] 
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findInvoiceContacts(companyId: string, query?: string, country?: FindInvoiceContactsCountryEnum, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindInvoiceContacts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findInvoiceContacts(companyId, query, country, currentPage, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoiceContactsApi.findInvoiceContacts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get an invoice contacts
         * @param {string} id ID
         * @param {string} companyId companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoiceContact(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateInvoiceContact200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoiceContact(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoiceContactsApi.getInvoiceContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint allows you to update an existing invoice contact for a specific company. It retrieves the invoice contact by ID and updates its details based on the provided data. It returns a response containing the updated invoice contact or an error response.
         * @summary Update an invoice contact
         * @param {string} id Invoice contact ID
         * @param {string} companyId companyId
         * @param {InvoiceContactDto} invoiceContactDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateInvoiceContact(id: string, companyId: string, invoiceContactDto: InvoiceContactDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateInvoiceContact200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateInvoiceContact(id, companyId, invoiceContactDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoiceContactsApi.updateInvoiceContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InvoiceContactsApi - factory interface
 * @export
 */
export const InvoiceContactsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvoiceContactsApiFp(configuration)
    return {
        /**
         * This endpoint allows you to create a new invoice contact for a specific company. It returns a response containing the created invoice contact or an error response.
         * @summary Creates a new invoice contact
         * @param {string} companyId companyId
         * @param {InvoiceContactDto} invoiceContactDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceContact(companyId: string, invoiceContactDto: InvoiceContactDto, options?: any): AxiosPromise<CreateInvoiceContact200Response> {
            return localVarFp.createInvoiceContact(companyId, invoiceContactDto, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to delete an existing invoice contact for a specific company. It retrieves the invoice contact by ID and deletes it. It returns a response indicating the success of the deletion or an error response if the invoice contact is not found.
         * @summary Delete an invoice contact
         * @param {string} id Invoice contact ID
         * @param {string} companyId companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceContact(id: string, companyId: string, options?: any): AxiosPromise<GetInvoice200Response> {
            return localVarFp.deleteInvoiceContact(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves a list of invoice contacts based on the provided parameters. It allows filtering by company ID, query string, country, and pagination parameters.
         * @summary Get list of all invoice contacts
         * @param {string} companyId companyId
         * @param {string} [query] Query search for Name, Street, Postcode, Org, City, State, telephone, fax, email
         * @param {FindInvoiceContactsCountryEnum} [country] 
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findInvoiceContacts(companyId: string, query?: string, country?: FindInvoiceContactsCountryEnum, currentPage?: number, perPage?: number, options?: any): AxiosPromise<FindInvoiceContacts200Response> {
            return localVarFp.findInvoiceContacts(companyId, query, country, currentPage, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an invoice contacts
         * @param {string} id ID
         * @param {string} companyId companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceContact(id: string, companyId: string, options?: any): AxiosPromise<CreateInvoiceContact200Response> {
            return localVarFp.getInvoiceContact(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to update an existing invoice contact for a specific company. It retrieves the invoice contact by ID and updates its details based on the provided data. It returns a response containing the updated invoice contact or an error response.
         * @summary Update an invoice contact
         * @param {string} id Invoice contact ID
         * @param {string} companyId companyId
         * @param {InvoiceContactDto} invoiceContactDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvoiceContact(id: string, companyId: string, invoiceContactDto: InvoiceContactDto, options?: any): AxiosPromise<CreateInvoiceContact200Response> {
            return localVarFp.updateInvoiceContact(id, companyId, invoiceContactDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvoiceContactsApi - object-oriented interface
 * @export
 * @class InvoiceContactsApi
 * @extends {BaseAPI}
 */
export class InvoiceContactsApi extends BaseAPI {
    /**
     * This endpoint allows you to create a new invoice contact for a specific company. It returns a response containing the created invoice contact or an error response.
     * @summary Creates a new invoice contact
     * @param {string} companyId companyId
     * @param {InvoiceContactDto} invoiceContactDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceContactsApi
     */
    public createInvoiceContact(companyId: string, invoiceContactDto: InvoiceContactDto, options?: RawAxiosRequestConfig) {
        return InvoiceContactsApiFp(this.configuration).createInvoiceContact(companyId, invoiceContactDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to delete an existing invoice contact for a specific company. It retrieves the invoice contact by ID and deletes it. It returns a response indicating the success of the deletion or an error response if the invoice contact is not found.
     * @summary Delete an invoice contact
     * @param {string} id Invoice contact ID
     * @param {string} companyId companyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceContactsApi
     */
    public deleteInvoiceContact(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return InvoiceContactsApiFp(this.configuration).deleteInvoiceContact(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves a list of invoice contacts based on the provided parameters. It allows filtering by company ID, query string, country, and pagination parameters.
     * @summary Get list of all invoice contacts
     * @param {string} companyId companyId
     * @param {string} [query] Query search for Name, Street, Postcode, Org, City, State, telephone, fax, email
     * @param {FindInvoiceContactsCountryEnum} [country] 
     * @param {number} [currentPage] current page
     * @param {number} [perPage] per Page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceContactsApi
     */
    public findInvoiceContacts(companyId: string, query?: string, country?: FindInvoiceContactsCountryEnum, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return InvoiceContactsApiFp(this.configuration).findInvoiceContacts(companyId, query, country, currentPage, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an invoice contacts
     * @param {string} id ID
     * @param {string} companyId companyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceContactsApi
     */
    public getInvoiceContact(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return InvoiceContactsApiFp(this.configuration).getInvoiceContact(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to update an existing invoice contact for a specific company. It retrieves the invoice contact by ID and updates its details based on the provided data. It returns a response containing the updated invoice contact or an error response.
     * @summary Update an invoice contact
     * @param {string} id Invoice contact ID
     * @param {string} companyId companyId
     * @param {InvoiceContactDto} invoiceContactDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceContactsApi
     */
    public updateInvoiceContact(id: string, companyId: string, invoiceContactDto: InvoiceContactDto, options?: RawAxiosRequestConfig) {
        return InvoiceContactsApiFp(this.configuration).updateInvoiceContact(id, companyId, invoiceContactDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const FindInvoiceContactsCountryEnum = {
    Af: 'AF',
    Al: 'AL',
    Dz: 'DZ',
    As: 'AS',
    Ad: 'AD',
    Ao: 'AO',
    Ai: 'AI',
    Aq: 'AQ',
    Ag: 'AG',
    Ar: 'AR',
    Am: 'AM',
    Aw: 'AW',
    Au: 'AU',
    At: 'AT',
    Az: 'AZ',
    Bs: 'BS',
    Bh: 'BH',
    Bd: 'BD',
    Bb: 'BB',
    By: 'BY',
    Be: 'BE',
    Bz: 'BZ',
    Bj: 'BJ',
    Bm: 'BM',
    Bt: 'BT',
    Bo: 'BO',
    Bq: 'BQ',
    Ba: 'BA',
    Bw: 'BW',
    Bv: 'BV',
    Br: 'BR',
    Io: 'IO',
    Bn: 'BN',
    Bg: 'BG',
    Bf: 'BF',
    Bi: 'BI',
    Kh: 'KH',
    Cm: 'CM',
    Ca: 'CA',
    Cv: 'CV',
    Ky: 'KY',
    Cf: 'CF',
    Td: 'TD',
    Cl: 'CL',
    Cn: 'CN',
    Cx: 'CX',
    Cc: 'CC',
    Co: 'CO',
    Km: 'KM',
    Cg: 'CG',
    Cd: 'CD',
    Ck: 'CK',
    Cr: 'CR',
    Ci: 'CI',
    Hr: 'HR',
    Cu: 'CU',
    Cw: 'CW',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Dj: 'DJ',
    Dm: 'DM',
    Do: 'DO',
    Ec: 'EC',
    Eg: 'EG',
    Sv: 'SV',
    Gq: 'GQ',
    Er: 'ER',
    Ee: 'EE',
    Et: 'ET',
    Fk: 'FK',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Gf: 'GF',
    Pf: 'PF',
    Tf: 'TF',
    Ga: 'GA',
    Gm: 'GM',
    Ge: 'GE',
    De: 'DE',
    Gh: 'GH',
    Gi: 'GI',
    Gr: 'GR',
    Gl: 'GL',
    Gd: 'GD',
    Gp: 'GP',
    Gu: 'GU',
    Gt: 'GT',
    Gg: 'GG',
    Gn: 'GN',
    Gw: 'GW',
    Gy: 'GY',
    Ht: 'HT',
    Hm: 'HM',
    Va: 'VA',
    Hn: 'HN',
    Hk: 'HK',
    Hu: 'HU',
    Is: 'IS',
    In: 'IN',
    Id: 'ID',
    Ir: 'IR',
    Iq: 'IQ',
    Ie: 'IE',
    Im: 'IM',
    Il: 'IL',
    It: 'IT',
    Jm: 'JM',
    Jp: 'JP',
    Je: 'JE',
    Jo: 'JO',
    Kz: 'KZ',
    Ke: 'KE',
    Ki: 'KI',
    Kp: 'KP',
    Kr: 'KR',
    Kw: 'KW',
    Kg: 'KG',
    La: 'LA',
    Lv: 'LV',
    Lb: 'LB',
    Ls: 'LS',
    Lr: 'LR',
    Ly: 'LY',
    Li: 'LI',
    Lt: 'LT',
    Lu: 'LU',
    Mo: 'MO',
    Mk: 'MK',
    Mg: 'MG',
    Mw: 'MW',
    My: 'MY',
    Mv: 'MV',
    Ml: 'ML',
    Mt: 'MT',
    Mh: 'MH',
    Mq: 'MQ',
    Mr: 'MR',
    Mu: 'MU',
    Tn: 'TN',
    Tr: 'TR',
    Tm: 'TM',
    Tc: 'TC',
    Tv: 'TV',
    Ug: 'UG',
    Ua: 'UA',
    Ae: 'AE',
    Gb: 'GB',
    Us: 'US',
    Um: 'UM',
    Uy: 'UY',
    Uz: 'UZ',
    Vu: 'VU',
    Ve: 'VE',
    Vn: 'VN',
    Vg: 'VG',
    Vi: 'VI',
    Wf: 'WF',
    Eh: 'EH',
    Ye: 'YE',
    Zm: 'ZM',
    Zw: 'ZW',
    Yt: 'YT',
    Mx: 'MX',
    Fm: 'FM',
    Md: 'MD',
    Mc: 'MC',
    Mn: 'MN',
    Me: 'ME',
    Ms: 'MS',
    Ma: 'MA',
    Mz: 'MZ',
    Mm: 'MM',
    Na: 'NA',
    Nr: 'NR',
    Np: 'NP',
    Nl: 'NL',
    Nc: 'NC',
    Nz: 'NZ',
    Ni: 'NI',
    Ne: 'NE',
    Ng: 'NG',
    Nu: 'NU',
    Nf: 'NF',
    Mp: 'MP',
    No: 'NO',
    Om: 'OM',
    Pk: 'PK',
    Pw: 'PW',
    Ps: 'PS',
    Pa: 'PA',
    Pg: 'PG',
    Py: 'PY',
    Pe: 'PE',
    Ph: 'PH',
    Pn: 'PN',
    Pl: 'PL',
    Pt: 'PT',
    Pr: 'PR',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Ru: 'RU',
    Rw: 'RW',
    Bl: 'BL',
    Sh: 'SH',
    Kn: 'KN',
    Lc: 'LC',
    Mf: 'MF',
    Pm: 'PM',
    Vc: 'VC',
    Ws: 'WS',
    Sm: 'SM',
    St: 'ST',
    Sa: 'SA',
    Sn: 'SN',
    Rs: 'RS',
    Sc: 'SC',
    Sl: 'SL',
    Sg: 'SG',
    Sx: 'SX',
    Sk: 'SK',
    Si: 'SI',
    Sb: 'SB',
    So: 'SO',
    Za: 'ZA',
    Gs: 'GS',
    Ss: 'SS',
    Es: 'ES',
    Lk: 'LK',
    Sd: 'SD',
    Sr: 'SR',
    Sj: 'SJ',
    Sz: 'SZ',
    Se: 'SE',
    Ch: 'CH',
    Sy: 'SY',
    Tw: 'TW',
    Tj: 'TJ',
    Tz: 'TZ',
    Th: 'TH',
    Tl: 'TL',
    Tg: 'TG',
    Tk: 'TK',
    To: 'TO',
    Tt: 'TT'
} as const;
export type FindInvoiceContactsCountryEnum = typeof FindInvoiceContactsCountryEnum[keyof typeof FindInvoiceContactsCountryEnum];


/**
 * InvoicesApi - axios parameter creator
 * @export
 */
export const InvoicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancel Invoice
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelInvoice: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancelInvoice', 'id', id)
            const localVarPath = `/invoices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Export invoices
         * @param {string} companyId The unique identifier of the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportInvoice: async (companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('exportInvoice', 'companyId', companyId)
            const localVarPath = `/invoices/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all invoices for a specific company based on various filter options and pagination.
         * @summary Get list of all invoices
         * @param {string} companyId The unique identifier of the company.
         * @param {FindInvoicesStatusEnum} [status] Filter invoices by status (optional).
         * @param {number} [currentPage] Current page number (optional).
         * @param {number} [perPage] Number of invoices to display per page (optional).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findInvoices: async (companyId: string, status?: FindInvoicesStatusEnum, currentPage?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('findInvoices', 'companyId', companyId)
            const localVarPath = `/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific invoice for a company based on its unique identifier.
         * @summary Get an invoice
         * @param {string} id The unique identifier of the invoice to retrieve.
         * @param {string} companyId The unique identifier of the company to which the invoice belongs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoice: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getInvoice', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getInvoice', 'companyId', companyId)
            const localVarPath = `/invoices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoicesApi - functional programming interface
 * @export
 */
export const InvoicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvoicesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Cancel Invoice
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelInvoice(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelInvoice(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.cancelInvoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Export invoices
         * @param {string} companyId The unique identifier of the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportInvoice(companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportInvoice(companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.exportInvoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all invoices for a specific company based on various filter options and pagination.
         * @summary Get list of all invoices
         * @param {string} companyId The unique identifier of the company.
         * @param {FindInvoicesStatusEnum} [status] Filter invoices by status (optional).
         * @param {number} [currentPage] Current page number (optional).
         * @param {number} [perPage] Number of invoices to display per page (optional).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findInvoices(companyId: string, status?: FindInvoicesStatusEnum, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindInvoices200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findInvoices(companyId, status, currentPage, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.findInvoices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific invoice for a company based on its unique identifier.
         * @summary Get an invoice
         * @param {string} id The unique identifier of the invoice to retrieve.
         * @param {string} companyId The unique identifier of the company to which the invoice belongs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoice(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoice(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.getInvoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InvoicesApi - factory interface
 * @export
 */
export const InvoicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvoicesApiFp(configuration)
    return {
        /**
         * 
         * @summary Cancel Invoice
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelInvoice(id: string, options?: any): AxiosPromise<GetInvoice200Response> {
            return localVarFp.cancelInvoice(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Export invoices
         * @param {string} companyId The unique identifier of the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportInvoice(companyId: string, options?: any): AxiosPromise<GetInvoice200Response> {
            return localVarFp.exportInvoice(companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all invoices for a specific company based on various filter options and pagination.
         * @summary Get list of all invoices
         * @param {string} companyId The unique identifier of the company.
         * @param {FindInvoicesStatusEnum} [status] Filter invoices by status (optional).
         * @param {number} [currentPage] Current page number (optional).
         * @param {number} [perPage] Number of invoices to display per page (optional).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findInvoices(companyId: string, status?: FindInvoicesStatusEnum, currentPage?: number, perPage?: number, options?: any): AxiosPromise<FindInvoices200Response> {
            return localVarFp.findInvoices(companyId, status, currentPage, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific invoice for a company based on its unique identifier.
         * @summary Get an invoice
         * @param {string} id The unique identifier of the invoice to retrieve.
         * @param {string} companyId The unique identifier of the company to which the invoice belongs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoice(id: string, companyId: string, options?: any): AxiosPromise<GetInvoice200Response> {
            return localVarFp.getInvoice(id, companyId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvoicesApi - object-oriented interface
 * @export
 * @class InvoicesApi
 * @extends {BaseAPI}
 */
export class InvoicesApi extends BaseAPI {
    /**
     * 
     * @summary Cancel Invoice
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public cancelInvoice(id: string, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).cancelInvoice(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Export invoices
     * @param {string} companyId The unique identifier of the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public exportInvoice(companyId: string, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).exportInvoice(companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all invoices for a specific company based on various filter options and pagination.
     * @summary Get list of all invoices
     * @param {string} companyId The unique identifier of the company.
     * @param {FindInvoicesStatusEnum} [status] Filter invoices by status (optional).
     * @param {number} [currentPage] Current page number (optional).
     * @param {number} [perPage] Number of invoices to display per page (optional).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public findInvoices(companyId: string, status?: FindInvoicesStatusEnum, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).findInvoices(companyId, status, currentPage, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific invoice for a company based on its unique identifier.
     * @summary Get an invoice
     * @param {string} id The unique identifier of the invoice to retrieve.
     * @param {string} companyId The unique identifier of the company to which the invoice belongs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public getInvoice(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).getInvoice(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const FindInvoicesStatusEnum = {
    Pending: 'PENDING',
    Success: 'SUCCESS'
} as const;
export type FindInvoicesStatusEnum = typeof FindInvoicesStatusEnum[keyof typeof FindInvoicesStatusEnum];


/**
 * IssuesApi - axios parameter creator
 * @export
 */
export const IssuesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new issue. Returns an IssueDto.
         * @summary Creates a new issue
         * @param {string} companyId companyId
         * @param {IssueDto} issueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIssue: async (companyId: string, issueDto: IssueDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('createIssue', 'companyId', companyId)
            // verify required parameter 'issueDto' is not null or undefined
            assertParamExists('createIssue', 'issueDto', issueDto)
            const localVarPath = `/issues`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(issueDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a certain issue. Returns null.
         * @summary Delete an issue
         * @param {string} companyId companyId
         * @param {string} id Issue ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIssue: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deleteIssue', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteIssue', 'id', id)
            const localVarPath = `/issues/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all issues. Returns an array of IssueDto.
         * @summary Get list of all issues
         * @param {string} companyId companyId
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {boolean} [resolved] 
         * @param {FindIssuesIssueCategoryEnum} [issueCategory] 
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findIssues: async (companyId: string, title?: string, description?: string, resolved?: boolean, issueCategory?: FindIssuesIssueCategoryEnum, currentPage?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('findIssues', 'companyId', companyId)
            const localVarPath = `/issues`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (resolved !== undefined) {
                localVarQueryParameter['resolved'] = resolved;
            }

            if (issueCategory !== undefined) {
                localVarQueryParameter['issueCategory'] = issueCategory;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a certain issue. Returns an IssueDto.
         * @summary Get an issue
         * @param {string} companyId companyId
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIssue: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getIssue', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIssue', 'id', id)
            const localVarPath = `/issues/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} companyId 
         * @param {string} fromDate 
         * @param {string} toDate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuesControllerExportIssuesToCsv: async (companyId: string, fromDate: string, toDate: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('issuesControllerExportIssuesToCsv', 'companyId', companyId)
            // verify required parameter 'fromDate' is not null or undefined
            assertParamExists('issuesControllerExportIssuesToCsv', 'fromDate', fromDate)
            // verify required parameter 'toDate' is not null or undefined
            assertParamExists('issuesControllerExportIssuesToCsv', 'toDate', toDate)
            const localVarPath = `/issues/export-to-csv`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a certain issue. Returns an IssueDto.
         * @summary Update issue
         * @param {string} companyId companyId
         * @param {string} id Product Category ID
         * @param {IssueDto} issueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIssue: async (companyId: string, id: string, issueDto: IssueDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateIssue', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateIssue', 'id', id)
            // verify required parameter 'issueDto' is not null or undefined
            assertParamExists('updateIssue', 'issueDto', issueDto)
            const localVarPath = `/issues/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(issueDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IssuesApi - functional programming interface
 * @export
 */
export const IssuesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IssuesApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new issue. Returns an IssueDto.
         * @summary Creates a new issue
         * @param {string} companyId companyId
         * @param {IssueDto} issueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createIssue(companyId: string, issueDto: IssueDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateIssue201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createIssue(companyId, issueDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssuesApi.createIssue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a certain issue. Returns null.
         * @summary Delete an issue
         * @param {string} companyId companyId
         * @param {string} id Issue ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteIssue(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteIssue(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssuesApi.deleteIssue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all issues. Returns an array of IssueDto.
         * @summary Get list of all issues
         * @param {string} companyId companyId
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {boolean} [resolved] 
         * @param {FindIssuesIssueCategoryEnum} [issueCategory] 
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findIssues(companyId: string, title?: string, description?: string, resolved?: boolean, issueCategory?: FindIssuesIssueCategoryEnum, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindIssues200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findIssues(companyId, title, description, resolved, issueCategory, currentPage, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssuesApi.findIssues']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a certain issue. Returns an IssueDto.
         * @summary Get an issue
         * @param {string} companyId companyId
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIssue(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateIssue201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIssue(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssuesApi.getIssue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} companyId 
         * @param {string} fromDate 
         * @param {string} toDate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issuesControllerExportIssuesToCsv(companyId: string, fromDate: string, toDate: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issuesControllerExportIssuesToCsv(companyId, fromDate, toDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssuesApi.issuesControllerExportIssuesToCsv']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a certain issue. Returns an IssueDto.
         * @summary Update issue
         * @param {string} companyId companyId
         * @param {string} id Product Category ID
         * @param {IssueDto} issueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateIssue(companyId: string, id: string, issueDto: IssueDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateIssue201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateIssue(companyId, id, issueDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssuesApi.updateIssue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IssuesApi - factory interface
 * @export
 */
export const IssuesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IssuesApiFp(configuration)
    return {
        /**
         * Creates a new issue. Returns an IssueDto.
         * @summary Creates a new issue
         * @param {string} companyId companyId
         * @param {IssueDto} issueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIssue(companyId: string, issueDto: IssueDto, options?: any): AxiosPromise<CreateIssue201Response> {
            return localVarFp.createIssue(companyId, issueDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a certain issue. Returns null.
         * @summary Delete an issue
         * @param {string} companyId companyId
         * @param {string} id Issue ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIssue(companyId: string, id: string, options?: any): AxiosPromise<GetInvoice200Response> {
            return localVarFp.deleteIssue(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all issues. Returns an array of IssueDto.
         * @summary Get list of all issues
         * @param {string} companyId companyId
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {boolean} [resolved] 
         * @param {FindIssuesIssueCategoryEnum} [issueCategory] 
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findIssues(companyId: string, title?: string, description?: string, resolved?: boolean, issueCategory?: FindIssuesIssueCategoryEnum, currentPage?: number, perPage?: number, options?: any): AxiosPromise<FindIssues200Response> {
            return localVarFp.findIssues(companyId, title, description, resolved, issueCategory, currentPage, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a certain issue. Returns an IssueDto.
         * @summary Get an issue
         * @param {string} companyId companyId
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIssue(companyId: string, id: string, options?: any): AxiosPromise<CreateIssue201Response> {
            return localVarFp.getIssue(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} companyId 
         * @param {string} fromDate 
         * @param {string} toDate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuesControllerExportIssuesToCsv(companyId: string, fromDate: string, toDate: string, options?: any): AxiosPromise<void> {
            return localVarFp.issuesControllerExportIssuesToCsv(companyId, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a certain issue. Returns an IssueDto.
         * @summary Update issue
         * @param {string} companyId companyId
         * @param {string} id Product Category ID
         * @param {IssueDto} issueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIssue(companyId: string, id: string, issueDto: IssueDto, options?: any): AxiosPromise<CreateIssue201Response> {
            return localVarFp.updateIssue(companyId, id, issueDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IssuesApi - object-oriented interface
 * @export
 * @class IssuesApi
 * @extends {BaseAPI}
 */
export class IssuesApi extends BaseAPI {
    /**
     * Creates a new issue. Returns an IssueDto.
     * @summary Creates a new issue
     * @param {string} companyId companyId
     * @param {IssueDto} issueDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesApi
     */
    public createIssue(companyId: string, issueDto: IssueDto, options?: RawAxiosRequestConfig) {
        return IssuesApiFp(this.configuration).createIssue(companyId, issueDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a certain issue. Returns null.
     * @summary Delete an issue
     * @param {string} companyId companyId
     * @param {string} id Issue ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesApi
     */
    public deleteIssue(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return IssuesApiFp(this.configuration).deleteIssue(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all issues. Returns an array of IssueDto.
     * @summary Get list of all issues
     * @param {string} companyId companyId
     * @param {string} [title] 
     * @param {string} [description] 
     * @param {boolean} [resolved] 
     * @param {FindIssuesIssueCategoryEnum} [issueCategory] 
     * @param {number} [currentPage] current page
     * @param {number} [perPage] per Page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesApi
     */
    public findIssues(companyId: string, title?: string, description?: string, resolved?: boolean, issueCategory?: FindIssuesIssueCategoryEnum, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return IssuesApiFp(this.configuration).findIssues(companyId, title, description, resolved, issueCategory, currentPage, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a certain issue. Returns an IssueDto.
     * @summary Get an issue
     * @param {string} companyId companyId
     * @param {string} id ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesApi
     */
    public getIssue(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return IssuesApiFp(this.configuration).getIssue(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} companyId 
     * @param {string} fromDate 
     * @param {string} toDate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesApi
     */
    public issuesControllerExportIssuesToCsv(companyId: string, fromDate: string, toDate: string, options?: RawAxiosRequestConfig) {
        return IssuesApiFp(this.configuration).issuesControllerExportIssuesToCsv(companyId, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a certain issue. Returns an IssueDto.
     * @summary Update issue
     * @param {string} companyId companyId
     * @param {string} id Product Category ID
     * @param {IssueDto} issueDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesApi
     */
    public updateIssue(companyId: string, id: string, issueDto: IssueDto, options?: RawAxiosRequestConfig) {
        return IssuesApiFp(this.configuration).updateIssue(companyId, id, issueDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const FindIssuesIssueCategoryEnum = {
    Order: 'order',
    OrderItem: 'order_item',
    Other: 'other'
} as const;
export type FindIssuesIssueCategoryEnum = typeof FindIssuesIssueCategoryEnum[keyof typeof FindIssuesIssueCategoryEnum];


/**
 * ItemsApi - axios parameter creator
 * @export
 */
export const ItemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add an affiliate user to an item. This operation associates an affiliate user with a specific item. Returns the updated ItemDto
         * @summary add affiliate user to items
         * @param {string} id The unique identifier of the item to which the affiliate user will be added.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {ItemAffiliateDto} itemAffiliateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        affiliateItemAdd: async (id: string, companyId: string, itemAffiliateDto: ItemAffiliateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('affiliateItemAdd', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('affiliateItemAdd', 'companyId', companyId)
            // verify required parameter 'itemAffiliateDto' is not null or undefined
            assertParamExists('affiliateItemAdd', 'itemAffiliateDto', itemAffiliateDto)
            const localVarPath = `/items/{id}/affiliate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemAffiliateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove the affiliate user association from an item. This operation disassociates an affiliate user from a specific item. Returns the updated ItemDto
         * @summary remove affiliate from items
         * @param {string} id The unique identifier of the item from which the affiliate user will be removed.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        affiliateItemRemove: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('affiliateItemRemove', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('affiliateItemRemove', 'companyId', companyId)
            const localVarPath = `/items/{id}/affiliate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attach a list of IPs to an item based on its unique identifier. Returns an updated ItemDto object 
         * @summary Update items
         * @param {string} id The unique identifier of the item to which IPs will be attached.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {Array<any>} ips An array of IP addresses to attach to the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachItemIps: async (id: string, companyId: string, ips: Array<any>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('attachItemIps', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('attachItemIps', 'companyId', companyId)
            // verify required parameter 'ips' is not null or undefined
            assertParamExists('attachItemIps', 'ips', ips)
            const localVarPath = `/items/{id}/ips/attach`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (ips) {
                localVarQueryParameter['ips'] = ips;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary detach an items bundle
         * @param {string} id The unique identifier of the item to which the bundle will be attached.
         * @param {string} companyId The unique identifier of the company associated with the item and the bundle.
         * @param {string} bundleId The unique identifier of the bundle to be deattached from the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundleItemDetach: async (id: string, companyId: string, bundleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('bundleItemDetach', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('bundleItemDetach', 'companyId', companyId)
            // verify required parameter 'bundleId' is not null or undefined
            assertParamExists('bundleItemDetach', 'bundleId', bundleId)
            const localVarPath = `/items/{id}/bundles/detach/{bundleId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel an item, optionally providing a refund. This operation cancels an item and can also trigger a refund, depending on the specified refund options.
         * @summary cancel an items
         * @param {string} id The unique identifier of the item to be canceled.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {CancelItemRefundTypeEnum} [refundType] Type of refund to be initiated if \&quot;refund\&quot; is set to true.
         * @param {boolean} [refund] Specify whether a refund should be initiated for the canceled item. Defaults to false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelItem: async (id: string, companyId: string, refundType?: CancelItemRefundTypeEnum, refund?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancelItem', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('cancelItem', 'companyId', companyId)
            const localVarPath = `/items/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (refundType !== undefined) {
                localVarQueryParameter['refundType'] = refundType;
            }

            if (refund !== undefined) {
                localVarQueryParameter['refund'] = refund;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently delete an item. This operation removes an item from the system. Use with caution as this action is irreversible. Returns true on success
         * @summary delete an items
         * @param {string} id The unique identifier of the item to be deleted.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteItem', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deleteItem', 'companyId', companyId)
            const localVarPath = `/items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete parent comment on items
         * @param {string} id The unique identifier of the item for which the parent comment will be removed. Returns true on success
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemParentComment: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteItemParentComment', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deleteItemParentComment', 'companyId', companyId)
            const localVarPath = `/items/{id}/comment/parent`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the user comment associated with an item based on its unique identifier. This operation is only available to the user who created the item. The user is authenticated through the use of a JWT token that has a JwtUserPayload. Returns true on success
         * @summary Delete user comment on items
         * @param {string} id The unique identifier of the item for which the user comment will be deleted.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemUserComment: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteItemUserComment', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deleteItemUserComment', 'companyId', companyId)
            const localVarPath = `/items/{id}/comment/user`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Detach an item based on its unique identifier. This operation removes the item from its parent container. Returns the updated ItemDto object.
         * @summary Detach item from order
         * @param {string} id The unique identifier of the item to detach.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachItem: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('detachItem', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('detachItem', 'companyId', companyId)
            const localVarPath = `/items/{id}/detach`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Detach a list of IPs from an item based on its unique identifier. Returns the updated ItemDto object
         * @summary Update items
         * @param {string} id The unique identifier of the item from which IPs will be detached.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {Array<string>} ips An array of IP addresses to detach from the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachItemIps: async (id: string, companyId: string, ips: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('detachItemIps', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('detachItemIps', 'companyId', companyId)
            // verify required parameter 'ips' is not null or undefined
            assertParamExists('detachItemIps', 'ips', ips)
            const localVarPath = `/items/{id}/ips/detach`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (ips) {
                localVarQueryParameter['ips'] = ips;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all items based on specified filters. Returns an array of ItemDto objects
         * @summary Get list of all items
         * @param {string} companyId The unique identifier of the company associated with the items.
         * @param {string} userId The unique identifier of the user associated with the items.
         * @param {string} [name] Filter items by name. Provide a partial or full name of the item to search for.
         * @param {Array<string>} [addons] Filter items by addons. Provide an array of addon names to filter items that have these addons.
         * @param {string} [categoryTitle] Filter items by category title. Provide the title of the category to search for items within that category.
         * @param {string} [productTitle] Filter items by product title. Provide the title of the product to search for items within that product.
         * @param {string} [fromEndDate] Filter items with a start date equal to or later than the specified date.
         * @param {string} [toEndDate] Filter items with an end date equal to or earlier than the specified date.
         * @param {string} [fromStartDate] Filter items with a start date equal to or later than the specified date.
         * @param {string} [toStartDate] Filter items with an end date equal to or earlier than the specified date.
         * @param {number} [fromPrice] Filter items with a price equal to or higher than the specified value.
         * @param {number} [toPrice] Filter items with a price equal to or lower than the specified value.
         * @param {number} [currentPage] Specify the current page number for paginated results.
         * @param {number} [perPage] Specify the number of items to display per page in the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findItems: async (companyId: string, userId: string, name?: string, addons?: Array<string>, categoryTitle?: string, productTitle?: string, fromEndDate?: string, toEndDate?: string, fromStartDate?: string, toStartDate?: string, fromPrice?: number, toPrice?: number, currentPage?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('findItems', 'companyId', companyId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('findItems', 'userId', userId)
            const localVarPath = `/items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (addons) {
                localVarQueryParameter['addons'] = addons;
            }

            if (categoryTitle !== undefined) {
                localVarQueryParameter['categoryTitle'] = categoryTitle;
            }

            if (productTitle !== undefined) {
                localVarQueryParameter['productTitle'] = productTitle;
            }

            if (fromEndDate !== undefined) {
                localVarQueryParameter['fromEndDate'] = (fromEndDate as any instanceof Date) ?
                    (fromEndDate as any).toISOString() :
                    fromEndDate;
            }

            if (toEndDate !== undefined) {
                localVarQueryParameter['toEndDate'] = (toEndDate as any instanceof Date) ?
                    (toEndDate as any).toISOString() :
                    toEndDate;
            }

            if (fromStartDate !== undefined) {
                localVarQueryParameter['fromStartDate'] = (fromStartDate as any instanceof Date) ?
                    (fromStartDate as any).toISOString() :
                    fromStartDate;
            }

            if (toStartDate !== undefined) {
                localVarQueryParameter['toStartDate'] = (toStartDate as any instanceof Date) ?
                    (toStartDate as any).toISOString() :
                    toStartDate;
            }

            if (fromPrice !== undefined) {
                localVarQueryParameter['fromPrice'] = fromPrice;
            }

            if (toPrice !== undefined) {
                localVarQueryParameter['toPrice'] = toPrice;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an item based on its unique identifier. Returns an ItemDto object
         * @summary Get an item
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {string} id The unique identifier of the item to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getItem', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItem', 'id', id)
            const localVarPath = `/items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the parent comment associated with an item based on its unique identifier. Returns the parent comment as a string
         * @summary Get parent comment on items
         * @param {string} id The unique identifier of the item for which the parent comment will be retrieved.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemParentComment: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItemParentComment', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getItemParentComment', 'companyId', companyId)
            const localVarPath = `/items/{id}/comment/parent`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the user comment associated with an item based on its unique identifier. This operation is only available to the user who created the item. The user is authenticated witha JWT token that has a JetUserPayload. Returns user comment as a string
         * @summary Get user comment on items
         * @param {string} id The unique identifier of the item for which the user comment will be retrieved.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemUserComment: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItemUserComment', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getItemUserComment', 'companyId', companyId)
            const localVarPath = `/items/{id}/comment/user`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Postpone the expiration date of an item based on its unique identifier. Returns the updated ItemDto object
         * @summary Postpone an Item\'s expiration
         * @param {string} id The unique identifier of the item for which the expiration will be postponed.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postponeItem: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postponeItem', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('postponeItem', 'companyId', companyId)
            const localVarPath = `/items/{id}/postpone`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retry a failed operation on an item. This is used to retry an action on an item that previously failed. Returns updated ItemDto
         * @summary items retry
         * @param {string} id The unique identifier of the item to retry the operation on.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryItem: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retryItem', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('retryItem', 'companyId', companyId)
            const localVarPath = `/items/{id}/retry`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate or retrieve an ownership certificate for an item based on its unique identifier and optional certificate parameters.
         * @summary ownership certificate
         * @param {string} id The unique identifier of the item for which the ownership certificate is requested.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {string} certificate items ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendItemOwnershipCertificate: async (id: string, companyId: string, certificate: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('sendItemOwnershipCertificate', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('sendItemOwnershipCertificate', 'companyId', companyId)
            // verify required parameter 'certificate' is not null or undefined
            assertParamExists('sendItemOwnershipCertificate', 'certificate', certificate)
            const localVarPath = `/items/{id}/ownershipCertificate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (certificate !== undefined) {
                localVarQueryParameter['certificate'] = certificate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Suspend an item, temporarily marking it as suspended. Suspended items are not available for certain operations until they are reactivated. Returns updated ItemDto
         * @summary suspend an items
         * @param {string} id The unique identifier of the item to be suspended.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suspendItem: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('suspendItem', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('suspendItem', 'companyId', companyId)
            const localVarPath = `/items/{id}/suspend`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Transfer an item to another user or organization within the same company. Returns updated ItemDto object
         * @summary Transfer items to another organization
         * @param {string} id The unique identifier of the item to transfer.
         * @param {string} companyId The unique identifier of the company associated with the item and the target user or organization.
         * @param {string} userId The unique identifier of the user or organization to which the item will be transferred.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferItem: async (id: string, companyId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('transferItem', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('transferItem', 'companyId', companyId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('transferItem', 'userId', userId)
            const localVarPath = `/items/{id}/transfer/{userId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unsuspend a previously suspended item, marking it as active and available for operations. Returns updated ItemDto
         * @summary unsuspend an items
         * @param {string} id The unique identifier of the item to be unsuspended.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsuspendItem: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unsuspendItem', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('unsuspendItem', 'companyId', companyId)
            const localVarPath = `/items/{id}/unsuspend`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an item\'s details based on its unique identifier. Returns the updated ItemDto object
         * @summary Update items
         * @param {string} id The unique identifier of the item to update.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {ItemUpdateDto} itemUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem: async (id: string, companyId: string, itemUpdateDto: ItemUpdateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateItem', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateItem', 'companyId', companyId)
            // verify required parameter 'itemUpdateDto' is not null or undefined
            assertParamExists('updateItem', 'itemUpdateDto', itemUpdateDto)
            const localVarPath = `/items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemUpdateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the parent comment associated with an item based on its unique identifier.
         * @summary Get parent comment on items
         * @param {string} id The unique identifier of the item for which the parent comment will be updated.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {string} comment The new parent comment to update for the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemParentComment: async (id: string, companyId: string, comment: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateItemParentComment', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateItemParentComment', 'companyId', companyId)
            // verify required parameter 'comment' is not null or undefined
            assertParamExists('updateItemParentComment', 'comment', comment)
            const localVarPath = `/items/{id}/comment/parent/{comment}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"comment"}}`, encodeURIComponent(String(comment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the user comment associated with an item based on its unique identifier. This operation is only available to the user who created the item. The user is authenticated witha JWT token that has a JetUserPayload. Returns the updated comment as a string
         * @summary Get user comment on items
         * @param {string} id The unique identifier of the item for which the user comment will be updated.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {string} comment The new user comment to update for the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemUserComment: async (id: string, companyId: string, comment: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateItemUserComment', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateItemUserComment', 'companyId', companyId)
            // verify required parameter 'comment' is not null or undefined
            assertParamExists('updateItemUserComment', 'comment', comment)
            const localVarPath = `/items/{id}/comment/user/{comment}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"comment"}}`, encodeURIComponent(String(comment)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsApi - functional programming interface
 * @export
 */
export const ItemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsApiAxiosParamCreator(configuration)
    return {
        /**
         * Add an affiliate user to an item. This operation associates an affiliate user with a specific item. Returns the updated ItemDto
         * @summary add affiliate user to items
         * @param {string} id The unique identifier of the item to which the affiliate user will be added.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {ItemAffiliateDto} itemAffiliateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async affiliateItemAdd(id: string, companyId: string, itemAffiliateDto: ItemAffiliateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetItem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.affiliateItemAdd(id, companyId, itemAffiliateDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.affiliateItemAdd']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove the affiliate user association from an item. This operation disassociates an affiliate user from a specific item. Returns the updated ItemDto
         * @summary remove affiliate from items
         * @param {string} id The unique identifier of the item from which the affiliate user will be removed.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async affiliateItemRemove(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetItem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.affiliateItemRemove(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.affiliateItemRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Attach a list of IPs to an item based on its unique identifier. Returns an updated ItemDto object 
         * @summary Update items
         * @param {string} id The unique identifier of the item to which IPs will be attached.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {Array<any>} ips An array of IP addresses to attach to the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attachItemIps(id: string, companyId: string, ips: Array<any>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetItem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attachItemIps(id, companyId, ips, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.attachItemIps']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary detach an items bundle
         * @param {string} id The unique identifier of the item to which the bundle will be attached.
         * @param {string} companyId The unique identifier of the company associated with the item and the bundle.
         * @param {string} bundleId The unique identifier of the bundle to be deattached from the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bundleItemDetach(id: string, companyId: string, bundleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetItem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bundleItemDetach(id, companyId, bundleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.bundleItemDetach']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel an item, optionally providing a refund. This operation cancels an item and can also trigger a refund, depending on the specified refund options.
         * @summary cancel an items
         * @param {string} id The unique identifier of the item to be canceled.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {CancelItemRefundTypeEnum} [refundType] Type of refund to be initiated if \&quot;refund\&quot; is set to true.
         * @param {boolean} [refund] Specify whether a refund should be initiated for the canceled item. Defaults to false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelItem(id: string, companyId: string, refundType?: CancelItemRefundTypeEnum, refund?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetItem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelItem(id, companyId, refundType, refund, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.cancelItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permanently delete an item. This operation removes an item from the system. Use with caution as this action is irreversible. Returns true on success
         * @summary delete an items
         * @param {string} id The unique identifier of the item to be deleted.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItem(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItem(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.deleteItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete parent comment on items
         * @param {string} id The unique identifier of the item for which the parent comment will be removed. Returns true on success
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemParentComment(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetItem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemParentComment(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.deleteItemParentComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete the user comment associated with an item based on its unique identifier. This operation is only available to the user who created the item. The user is authenticated through the use of a JWT token that has a JwtUserPayload. Returns true on success
         * @summary Delete user comment on items
         * @param {string} id The unique identifier of the item for which the user comment will be deleted.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItemUserComment(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetItem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItemUserComment(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.deleteItemUserComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Detach an item based on its unique identifier. This operation removes the item from its parent container. Returns the updated ItemDto object.
         * @summary Detach item from order
         * @param {string} id The unique identifier of the item to detach.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detachItem(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetItem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detachItem(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.detachItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Detach a list of IPs from an item based on its unique identifier. Returns the updated ItemDto object
         * @summary Update items
         * @param {string} id The unique identifier of the item from which IPs will be detached.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {Array<string>} ips An array of IP addresses to detach from the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detachItemIps(id: string, companyId: string, ips: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetItem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detachItemIps(id, companyId, ips, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.detachItemIps']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all items based on specified filters. Returns an array of ItemDto objects
         * @summary Get list of all items
         * @param {string} companyId The unique identifier of the company associated with the items.
         * @param {string} userId The unique identifier of the user associated with the items.
         * @param {string} [name] Filter items by name. Provide a partial or full name of the item to search for.
         * @param {Array<string>} [addons] Filter items by addons. Provide an array of addon names to filter items that have these addons.
         * @param {string} [categoryTitle] Filter items by category title. Provide the title of the category to search for items within that category.
         * @param {string} [productTitle] Filter items by product title. Provide the title of the product to search for items within that product.
         * @param {string} [fromEndDate] Filter items with a start date equal to or later than the specified date.
         * @param {string} [toEndDate] Filter items with an end date equal to or earlier than the specified date.
         * @param {string} [fromStartDate] Filter items with a start date equal to or later than the specified date.
         * @param {string} [toStartDate] Filter items with an end date equal to or earlier than the specified date.
         * @param {number} [fromPrice] Filter items with a price equal to or higher than the specified value.
         * @param {number} [toPrice] Filter items with a price equal to or lower than the specified value.
         * @param {number} [currentPage] Specify the current page number for paginated results.
         * @param {number} [perPage] Specify the number of items to display per page in the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findItems(companyId: string, userId: string, name?: string, addons?: Array<string>, categoryTitle?: string, productTitle?: string, fromEndDate?: string, toEndDate?: string, fromStartDate?: string, toStartDate?: string, fromPrice?: number, toPrice?: number, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindItems200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findItems(companyId, userId, name, addons, categoryTitle, productTitle, fromEndDate, toEndDate, fromStartDate, toStartDate, fromPrice, toPrice, currentPage, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.findItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an item based on its unique identifier. Returns an ItemDto object
         * @summary Get an item
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {string} id The unique identifier of the item to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItem(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetItem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItem(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.getItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the parent comment associated with an item based on its unique identifier. Returns the parent comment as a string
         * @summary Get parent comment on items
         * @param {string} id The unique identifier of the item for which the parent comment will be retrieved.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemParentComment(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetItem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemParentComment(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.getItemParentComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the user comment associated with an item based on its unique identifier. This operation is only available to the user who created the item. The user is authenticated witha JWT token that has a JetUserPayload. Returns user comment as a string
         * @summary Get user comment on items
         * @param {string} id The unique identifier of the item for which the user comment will be retrieved.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemUserComment(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetItem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemUserComment(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.getItemUserComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Postpone the expiration date of an item based on its unique identifier. Returns the updated ItemDto object
         * @summary Postpone an Item\'s expiration
         * @param {string} id The unique identifier of the item for which the expiration will be postponed.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postponeItem(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetItem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postponeItem(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.postponeItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retry a failed operation on an item. This is used to retry an action on an item that previously failed. Returns updated ItemDto
         * @summary items retry
         * @param {string} id The unique identifier of the item to retry the operation on.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retryItem(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetItem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retryItem(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.retryItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generate or retrieve an ownership certificate for an item based on its unique identifier and optional certificate parameters.
         * @summary ownership certificate
         * @param {string} id The unique identifier of the item for which the ownership certificate is requested.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {string} certificate items ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendItemOwnershipCertificate(id: string, companyId: string, certificate: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetItem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendItemOwnershipCertificate(id, companyId, certificate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.sendItemOwnershipCertificate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Suspend an item, temporarily marking it as suspended. Suspended items are not available for certain operations until they are reactivated. Returns updated ItemDto
         * @summary suspend an items
         * @param {string} id The unique identifier of the item to be suspended.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async suspendItem(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetItem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.suspendItem(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.suspendItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Transfer an item to another user or organization within the same company. Returns updated ItemDto object
         * @summary Transfer items to another organization
         * @param {string} id The unique identifier of the item to transfer.
         * @param {string} companyId The unique identifier of the company associated with the item and the target user or organization.
         * @param {string} userId The unique identifier of the user or organization to which the item will be transferred.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transferItem(id: string, companyId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetItem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transferItem(id, companyId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.transferItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unsuspend a previously suspended item, marking it as active and available for operations. Returns updated ItemDto
         * @summary unsuspend an items
         * @param {string} id The unique identifier of the item to be unsuspended.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unsuspendItem(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetItem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unsuspendItem(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.unsuspendItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an item\'s details based on its unique identifier. Returns the updated ItemDto object
         * @summary Update items
         * @param {string} id The unique identifier of the item to update.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {ItemUpdateDto} itemUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItem(id: string, companyId: string, itemUpdateDto: ItemUpdateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetItem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateItem(id, companyId, itemUpdateDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.updateItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the parent comment associated with an item based on its unique identifier.
         * @summary Get parent comment on items
         * @param {string} id The unique identifier of the item for which the parent comment will be updated.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {string} comment The new parent comment to update for the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItemParentComment(id: string, companyId: string, comment: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetItem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateItemParentComment(id, companyId, comment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.updateItemParentComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the user comment associated with an item based on its unique identifier. This operation is only available to the user who created the item. The user is authenticated witha JWT token that has a JetUserPayload. Returns the updated comment as a string
         * @summary Get user comment on items
         * @param {string} id The unique identifier of the item for which the user comment will be updated.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {string} comment The new user comment to update for the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItemUserComment(id: string, companyId: string, comment: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetItem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateItemUserComment(id, companyId, comment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.updateItemUserComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ItemsApi - factory interface
 * @export
 */
export const ItemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsApiFp(configuration)
    return {
        /**
         * Add an affiliate user to an item. This operation associates an affiliate user with a specific item. Returns the updated ItemDto
         * @summary add affiliate user to items
         * @param {string} id The unique identifier of the item to which the affiliate user will be added.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {ItemAffiliateDto} itemAffiliateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        affiliateItemAdd(id: string, companyId: string, itemAffiliateDto: ItemAffiliateDto, options?: any): AxiosPromise<GetItem200Response> {
            return localVarFp.affiliateItemAdd(id, companyId, itemAffiliateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove the affiliate user association from an item. This operation disassociates an affiliate user from a specific item. Returns the updated ItemDto
         * @summary remove affiliate from items
         * @param {string} id The unique identifier of the item from which the affiliate user will be removed.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        affiliateItemRemove(id: string, companyId: string, options?: any): AxiosPromise<GetItem200Response> {
            return localVarFp.affiliateItemRemove(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Attach a list of IPs to an item based on its unique identifier. Returns an updated ItemDto object 
         * @summary Update items
         * @param {string} id The unique identifier of the item to which IPs will be attached.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {Array<any>} ips An array of IP addresses to attach to the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachItemIps(id: string, companyId: string, ips: Array<any>, options?: any): AxiosPromise<GetItem200Response> {
            return localVarFp.attachItemIps(id, companyId, ips, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary detach an items bundle
         * @param {string} id The unique identifier of the item to which the bundle will be attached.
         * @param {string} companyId The unique identifier of the company associated with the item and the bundle.
         * @param {string} bundleId The unique identifier of the bundle to be deattached from the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bundleItemDetach(id: string, companyId: string, bundleId: string, options?: any): AxiosPromise<GetItem200Response> {
            return localVarFp.bundleItemDetach(id, companyId, bundleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel an item, optionally providing a refund. This operation cancels an item and can also trigger a refund, depending on the specified refund options.
         * @summary cancel an items
         * @param {string} id The unique identifier of the item to be canceled.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {CancelItemRefundTypeEnum} [refundType] Type of refund to be initiated if \&quot;refund\&quot; is set to true.
         * @param {boolean} [refund] Specify whether a refund should be initiated for the canceled item. Defaults to false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelItem(id: string, companyId: string, refundType?: CancelItemRefundTypeEnum, refund?: boolean, options?: any): AxiosPromise<GetItem200Response> {
            return localVarFp.cancelItem(id, companyId, refundType, refund, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently delete an item. This operation removes an item from the system. Use with caution as this action is irreversible. Returns true on success
         * @summary delete an items
         * @param {string} id The unique identifier of the item to be deleted.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem(id: string, companyId: string, options?: any): AxiosPromise<GetInvoice200Response> {
            return localVarFp.deleteItem(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete parent comment on items
         * @param {string} id The unique identifier of the item for which the parent comment will be removed. Returns true on success
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemParentComment(id: string, companyId: string, options?: any): AxiosPromise<GetItem200Response> {
            return localVarFp.deleteItemParentComment(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the user comment associated with an item based on its unique identifier. This operation is only available to the user who created the item. The user is authenticated through the use of a JWT token that has a JwtUserPayload. Returns true on success
         * @summary Delete user comment on items
         * @param {string} id The unique identifier of the item for which the user comment will be deleted.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItemUserComment(id: string, companyId: string, options?: any): AxiosPromise<GetItem200Response> {
            return localVarFp.deleteItemUserComment(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Detach an item based on its unique identifier. This operation removes the item from its parent container. Returns the updated ItemDto object.
         * @summary Detach item from order
         * @param {string} id The unique identifier of the item to detach.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachItem(id: string, companyId: string, options?: any): AxiosPromise<GetItem200Response> {
            return localVarFp.detachItem(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Detach a list of IPs from an item based on its unique identifier. Returns the updated ItemDto object
         * @summary Update items
         * @param {string} id The unique identifier of the item from which IPs will be detached.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {Array<string>} ips An array of IP addresses to detach from the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachItemIps(id: string, companyId: string, ips: Array<string>, options?: any): AxiosPromise<GetItem200Response> {
            return localVarFp.detachItemIps(id, companyId, ips, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all items based on specified filters. Returns an array of ItemDto objects
         * @summary Get list of all items
         * @param {string} companyId The unique identifier of the company associated with the items.
         * @param {string} userId The unique identifier of the user associated with the items.
         * @param {string} [name] Filter items by name. Provide a partial or full name of the item to search for.
         * @param {Array<string>} [addons] Filter items by addons. Provide an array of addon names to filter items that have these addons.
         * @param {string} [categoryTitle] Filter items by category title. Provide the title of the category to search for items within that category.
         * @param {string} [productTitle] Filter items by product title. Provide the title of the product to search for items within that product.
         * @param {string} [fromEndDate] Filter items with a start date equal to or later than the specified date.
         * @param {string} [toEndDate] Filter items with an end date equal to or earlier than the specified date.
         * @param {string} [fromStartDate] Filter items with a start date equal to or later than the specified date.
         * @param {string} [toStartDate] Filter items with an end date equal to or earlier than the specified date.
         * @param {number} [fromPrice] Filter items with a price equal to or higher than the specified value.
         * @param {number} [toPrice] Filter items with a price equal to or lower than the specified value.
         * @param {number} [currentPage] Specify the current page number for paginated results.
         * @param {number} [perPage] Specify the number of items to display per page in the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findItems(companyId: string, userId: string, name?: string, addons?: Array<string>, categoryTitle?: string, productTitle?: string, fromEndDate?: string, toEndDate?: string, fromStartDate?: string, toStartDate?: string, fromPrice?: number, toPrice?: number, currentPage?: number, perPage?: number, options?: any): AxiosPromise<FindItems200Response> {
            return localVarFp.findItems(companyId, userId, name, addons, categoryTitle, productTitle, fromEndDate, toEndDate, fromStartDate, toStartDate, fromPrice, toPrice, currentPage, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an item based on its unique identifier. Returns an ItemDto object
         * @summary Get an item
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {string} id The unique identifier of the item to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem(companyId: string, id: string, options?: any): AxiosPromise<GetItem200Response> {
            return localVarFp.getItem(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the parent comment associated with an item based on its unique identifier. Returns the parent comment as a string
         * @summary Get parent comment on items
         * @param {string} id The unique identifier of the item for which the parent comment will be retrieved.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemParentComment(id: string, companyId: string, options?: any): AxiosPromise<GetItem200Response> {
            return localVarFp.getItemParentComment(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the user comment associated with an item based on its unique identifier. This operation is only available to the user who created the item. The user is authenticated witha JWT token that has a JetUserPayload. Returns user comment as a string
         * @summary Get user comment on items
         * @param {string} id The unique identifier of the item for which the user comment will be retrieved.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemUserComment(id: string, companyId: string, options?: any): AxiosPromise<GetItem200Response> {
            return localVarFp.getItemUserComment(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Postpone the expiration date of an item based on its unique identifier. Returns the updated ItemDto object
         * @summary Postpone an Item\'s expiration
         * @param {string} id The unique identifier of the item for which the expiration will be postponed.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postponeItem(id: string, companyId: string, options?: any): AxiosPromise<GetItem200Response> {
            return localVarFp.postponeItem(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retry a failed operation on an item. This is used to retry an action on an item that previously failed. Returns updated ItemDto
         * @summary items retry
         * @param {string} id The unique identifier of the item to retry the operation on.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryItem(id: string, companyId: string, options?: any): AxiosPromise<GetItem200Response> {
            return localVarFp.retryItem(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate or retrieve an ownership certificate for an item based on its unique identifier and optional certificate parameters.
         * @summary ownership certificate
         * @param {string} id The unique identifier of the item for which the ownership certificate is requested.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {string} certificate items ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendItemOwnershipCertificate(id: string, companyId: string, certificate: string, options?: any): AxiosPromise<GetItem200Response> {
            return localVarFp.sendItemOwnershipCertificate(id, companyId, certificate, options).then((request) => request(axios, basePath));
        },
        /**
         * Suspend an item, temporarily marking it as suspended. Suspended items are not available for certain operations until they are reactivated. Returns updated ItemDto
         * @summary suspend an items
         * @param {string} id The unique identifier of the item to be suspended.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        suspendItem(id: string, companyId: string, options?: any): AxiosPromise<GetItem200Response> {
            return localVarFp.suspendItem(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Transfer an item to another user or organization within the same company. Returns updated ItemDto object
         * @summary Transfer items to another organization
         * @param {string} id The unique identifier of the item to transfer.
         * @param {string} companyId The unique identifier of the company associated with the item and the target user or organization.
         * @param {string} userId The unique identifier of the user or organization to which the item will be transferred.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferItem(id: string, companyId: string, userId: string, options?: any): AxiosPromise<GetItem200Response> {
            return localVarFp.transferItem(id, companyId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Unsuspend a previously suspended item, marking it as active and available for operations. Returns updated ItemDto
         * @summary unsuspend an items
         * @param {string} id The unique identifier of the item to be unsuspended.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsuspendItem(id: string, companyId: string, options?: any): AxiosPromise<GetItem200Response> {
            return localVarFp.unsuspendItem(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an item\'s details based on its unique identifier. Returns the updated ItemDto object
         * @summary Update items
         * @param {string} id The unique identifier of the item to update.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {ItemUpdateDto} itemUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem(id: string, companyId: string, itemUpdateDto: ItemUpdateDto, options?: any): AxiosPromise<GetItem200Response> {
            return localVarFp.updateItem(id, companyId, itemUpdateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the parent comment associated with an item based on its unique identifier.
         * @summary Get parent comment on items
         * @param {string} id The unique identifier of the item for which the parent comment will be updated.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {string} comment The new parent comment to update for the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemParentComment(id: string, companyId: string, comment: string, options?: any): AxiosPromise<GetItem200Response> {
            return localVarFp.updateItemParentComment(id, companyId, comment, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the user comment associated with an item based on its unique identifier. This operation is only available to the user who created the item. The user is authenticated witha JWT token that has a JetUserPayload. Returns the updated comment as a string
         * @summary Get user comment on items
         * @param {string} id The unique identifier of the item for which the user comment will be updated.
         * @param {string} companyId The unique identifier of the company associated with the item.
         * @param {string} comment The new user comment to update for the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemUserComment(id: string, companyId: string, comment: string, options?: any): AxiosPromise<GetItem200Response> {
            return localVarFp.updateItemUserComment(id, companyId, comment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsApi - object-oriented interface
 * @export
 * @class ItemsApi
 * @extends {BaseAPI}
 */
export class ItemsApi extends BaseAPI {
    /**
     * Add an affiliate user to an item. This operation associates an affiliate user with a specific item. Returns the updated ItemDto
     * @summary add affiliate user to items
     * @param {string} id The unique identifier of the item to which the affiliate user will be added.
     * @param {string} companyId The unique identifier of the company associated with the item.
     * @param {ItemAffiliateDto} itemAffiliateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public affiliateItemAdd(id: string, companyId: string, itemAffiliateDto: ItemAffiliateDto, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).affiliateItemAdd(id, companyId, itemAffiliateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove the affiliate user association from an item. This operation disassociates an affiliate user from a specific item. Returns the updated ItemDto
     * @summary remove affiliate from items
     * @param {string} id The unique identifier of the item from which the affiliate user will be removed.
     * @param {string} companyId The unique identifier of the company associated with the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public affiliateItemRemove(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).affiliateItemRemove(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Attach a list of IPs to an item based on its unique identifier. Returns an updated ItemDto object 
     * @summary Update items
     * @param {string} id The unique identifier of the item to which IPs will be attached.
     * @param {string} companyId The unique identifier of the company associated with the item.
     * @param {Array<any>} ips An array of IP addresses to attach to the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public attachItemIps(id: string, companyId: string, ips: Array<any>, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).attachItemIps(id, companyId, ips, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary detach an items bundle
     * @param {string} id The unique identifier of the item to which the bundle will be attached.
     * @param {string} companyId The unique identifier of the company associated with the item and the bundle.
     * @param {string} bundleId The unique identifier of the bundle to be deattached from the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public bundleItemDetach(id: string, companyId: string, bundleId: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).bundleItemDetach(id, companyId, bundleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel an item, optionally providing a refund. This operation cancels an item and can also trigger a refund, depending on the specified refund options.
     * @summary cancel an items
     * @param {string} id The unique identifier of the item to be canceled.
     * @param {string} companyId The unique identifier of the company associated with the item.
     * @param {CancelItemRefundTypeEnum} [refundType] Type of refund to be initiated if \&quot;refund\&quot; is set to true.
     * @param {boolean} [refund] Specify whether a refund should be initiated for the canceled item. Defaults to false.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public cancelItem(id: string, companyId: string, refundType?: CancelItemRefundTypeEnum, refund?: boolean, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).cancelItem(id, companyId, refundType, refund, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently delete an item. This operation removes an item from the system. Use with caution as this action is irreversible. Returns true on success
     * @summary delete an items
     * @param {string} id The unique identifier of the item to be deleted.
     * @param {string} companyId The unique identifier of the company associated with the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public deleteItem(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).deleteItem(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete parent comment on items
     * @param {string} id The unique identifier of the item for which the parent comment will be removed. Returns true on success
     * @param {string} companyId The unique identifier of the company associated with the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public deleteItemParentComment(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).deleteItemParentComment(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the user comment associated with an item based on its unique identifier. This operation is only available to the user who created the item. The user is authenticated through the use of a JWT token that has a JwtUserPayload. Returns true on success
     * @summary Delete user comment on items
     * @param {string} id The unique identifier of the item for which the user comment will be deleted.
     * @param {string} companyId The unique identifier of the company associated with the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public deleteItemUserComment(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).deleteItemUserComment(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Detach an item based on its unique identifier. This operation removes the item from its parent container. Returns the updated ItemDto object.
     * @summary Detach item from order
     * @param {string} id The unique identifier of the item to detach.
     * @param {string} companyId The unique identifier of the company associated with the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public detachItem(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).detachItem(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Detach a list of IPs from an item based on its unique identifier. Returns the updated ItemDto object
     * @summary Update items
     * @param {string} id The unique identifier of the item from which IPs will be detached.
     * @param {string} companyId The unique identifier of the company associated with the item.
     * @param {Array<string>} ips An array of IP addresses to detach from the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public detachItemIps(id: string, companyId: string, ips: Array<string>, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).detachItemIps(id, companyId, ips, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all items based on specified filters. Returns an array of ItemDto objects
     * @summary Get list of all items
     * @param {string} companyId The unique identifier of the company associated with the items.
     * @param {string} userId The unique identifier of the user associated with the items.
     * @param {string} [name] Filter items by name. Provide a partial or full name of the item to search for.
     * @param {Array<string>} [addons] Filter items by addons. Provide an array of addon names to filter items that have these addons.
     * @param {string} [categoryTitle] Filter items by category title. Provide the title of the category to search for items within that category.
     * @param {string} [productTitle] Filter items by product title. Provide the title of the product to search for items within that product.
     * @param {string} [fromEndDate] Filter items with a start date equal to or later than the specified date.
     * @param {string} [toEndDate] Filter items with an end date equal to or earlier than the specified date.
     * @param {string} [fromStartDate] Filter items with a start date equal to or later than the specified date.
     * @param {string} [toStartDate] Filter items with an end date equal to or earlier than the specified date.
     * @param {number} [fromPrice] Filter items with a price equal to or higher than the specified value.
     * @param {number} [toPrice] Filter items with a price equal to or lower than the specified value.
     * @param {number} [currentPage] Specify the current page number for paginated results.
     * @param {number} [perPage] Specify the number of items to display per page in the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public findItems(companyId: string, userId: string, name?: string, addons?: Array<string>, categoryTitle?: string, productTitle?: string, fromEndDate?: string, toEndDate?: string, fromStartDate?: string, toStartDate?: string, fromPrice?: number, toPrice?: number, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).findItems(companyId, userId, name, addons, categoryTitle, productTitle, fromEndDate, toEndDate, fromStartDate, toStartDate, fromPrice, toPrice, currentPage, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an item based on its unique identifier. Returns an ItemDto object
     * @summary Get an item
     * @param {string} companyId The unique identifier of the company associated with the item.
     * @param {string} id The unique identifier of the item to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public getItem(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).getItem(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the parent comment associated with an item based on its unique identifier. Returns the parent comment as a string
     * @summary Get parent comment on items
     * @param {string} id The unique identifier of the item for which the parent comment will be retrieved.
     * @param {string} companyId The unique identifier of the company associated with the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public getItemParentComment(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).getItemParentComment(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the user comment associated with an item based on its unique identifier. This operation is only available to the user who created the item. The user is authenticated witha JWT token that has a JetUserPayload. Returns user comment as a string
     * @summary Get user comment on items
     * @param {string} id The unique identifier of the item for which the user comment will be retrieved.
     * @param {string} companyId The unique identifier of the company associated with the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public getItemUserComment(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).getItemUserComment(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Postpone the expiration date of an item based on its unique identifier. Returns the updated ItemDto object
     * @summary Postpone an Item\'s expiration
     * @param {string} id The unique identifier of the item for which the expiration will be postponed.
     * @param {string} companyId The unique identifier of the company associated with the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public postponeItem(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).postponeItem(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retry a failed operation on an item. This is used to retry an action on an item that previously failed. Returns updated ItemDto
     * @summary items retry
     * @param {string} id The unique identifier of the item to retry the operation on.
     * @param {string} companyId The unique identifier of the company associated with the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public retryItem(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).retryItem(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate or retrieve an ownership certificate for an item based on its unique identifier and optional certificate parameters.
     * @summary ownership certificate
     * @param {string} id The unique identifier of the item for which the ownership certificate is requested.
     * @param {string} companyId The unique identifier of the company associated with the item.
     * @param {string} certificate items ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public sendItemOwnershipCertificate(id: string, companyId: string, certificate: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).sendItemOwnershipCertificate(id, companyId, certificate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Suspend an item, temporarily marking it as suspended. Suspended items are not available for certain operations until they are reactivated. Returns updated ItemDto
     * @summary suspend an items
     * @param {string} id The unique identifier of the item to be suspended.
     * @param {string} companyId The unique identifier of the company associated with the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public suspendItem(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).suspendItem(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Transfer an item to another user or organization within the same company. Returns updated ItemDto object
     * @summary Transfer items to another organization
     * @param {string} id The unique identifier of the item to transfer.
     * @param {string} companyId The unique identifier of the company associated with the item and the target user or organization.
     * @param {string} userId The unique identifier of the user or organization to which the item will be transferred.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public transferItem(id: string, companyId: string, userId: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).transferItem(id, companyId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unsuspend a previously suspended item, marking it as active and available for operations. Returns updated ItemDto
     * @summary unsuspend an items
     * @param {string} id The unique identifier of the item to be unsuspended.
     * @param {string} companyId The unique identifier of the company associated with the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public unsuspendItem(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).unsuspendItem(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an item\'s details based on its unique identifier. Returns the updated ItemDto object
     * @summary Update items
     * @param {string} id The unique identifier of the item to update.
     * @param {string} companyId The unique identifier of the company associated with the item.
     * @param {ItemUpdateDto} itemUpdateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public updateItem(id: string, companyId: string, itemUpdateDto: ItemUpdateDto, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).updateItem(id, companyId, itemUpdateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the parent comment associated with an item based on its unique identifier.
     * @summary Get parent comment on items
     * @param {string} id The unique identifier of the item for which the parent comment will be updated.
     * @param {string} companyId The unique identifier of the company associated with the item.
     * @param {string} comment The new parent comment to update for the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public updateItemParentComment(id: string, companyId: string, comment: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).updateItemParentComment(id, companyId, comment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the user comment associated with an item based on its unique identifier. This operation is only available to the user who created the item. The user is authenticated witha JWT token that has a JetUserPayload. Returns the updated comment as a string
     * @summary Get user comment on items
     * @param {string} id The unique identifier of the item for which the user comment will be updated.
     * @param {string} companyId The unique identifier of the company associated with the item.
     * @param {string} comment The new user comment to update for the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public updateItemUserComment(id: string, companyId: string, comment: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).updateItemUserComment(id, companyId, comment, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const CancelItemRefundTypeEnum = {
    Credit: 'credit',
    PaymentMethod: 'payment_method'
} as const;
export type CancelItemRefundTypeEnum = typeof CancelItemRefundTypeEnum[keyof typeof CancelItemRefundTypeEnum];


/**
 * OrdersApi - axios parameter creator
 * @export
 */
export const OrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This operation adds a new order line to an existing order. Returns the updated OrderDto object.
         * @summary add line
         * @param {string} id The unique identifier of the order.
         * @param {string} companyId The unique identifier of the company for which the order belongs.
         * @param {ItemDto} itemDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrderLine: async (id: string, companyId: string, itemDto: ItemDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addOrderLine', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('addOrderLine', 'companyId', companyId)
            // verify required parameter 'itemDto' is not null or undefined
            assertParamExists('addOrderLine', 'itemDto', itemDto)
            const localVarPath = `/orders/{id}/add-line`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation changes the invoice contact for a specific order. Returns the updated OrderDto object.
         * @summary change invoice contact id
         * @param {string} id The unique identifier of the order.
         * @param {string} companyId The unique identifier of the company for which the order belongs.
         * @param {string} newInvoiceContactId The unique identifier of the new invoice contact.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeOrderInvoiceContact: async (id: string, companyId: string, newInvoiceContactId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('changeOrderInvoiceContact', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('changeOrderInvoiceContact', 'companyId', companyId)
            // verify required parameter 'newInvoiceContactId' is not null or undefined
            assertParamExists('changeOrderInvoiceContact', 'newInvoiceContactId', newInvoiceContactId)
            const localVarPath = `/orders/{id}/invoice-contact/{newInvoiceContactId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"newInvoiceContactId"}}`, encodeURIComponent(String(newInvoiceContactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation creates a new order for a specific company. Returns an OrderDto object.
         * @summary Creates an order
         * @param {string} companyId The unique identifier of the company where the order will be created.
         * @param {OrderDto} orderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder: async (companyId: string, orderDto: OrderDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('createOrder', 'companyId', companyId)
            // verify required parameter 'orderDto' is not null or undefined
            assertParamExists('createOrder', 'orderDto', orderDto)
            const localVarPath = `/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation allows you to invoice an order.
         * @summary Invoice order
         * @param {string} id The unique identifier of the order to be invoiced.
         * @param {string} companyId The unique identifier of the company for which the order belongs.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderInvoice: async (id: string, companyId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createOrderInvoice', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('createOrderInvoice', 'companyId', companyId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createOrderInvoice', 'userId', userId)
            const localVarPath = `/orders/{id}/invoice`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation allows you to delete an order. Returns true on success.
         * @summary Delete an order
         * @param {string} id The unique identifier of the order to be deleted.
         * @param {string} companyId The unique identifier of the company for which the order belongs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrder: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteOrder', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deleteOrder', 'companyId', companyId)
            const localVarPath = `/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation allows you to export orders for a specific company.
         * @summary Export orders
         * @param {string} companyId The unique identifier of the company for which orders will be exported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportOrders: async (companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('exportOrders', 'companyId', companyId)
            const localVarPath = `/orders/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation retrieves a list of all orders for a specific company. You can search for orders based on various criteria such as order ID or invoice contact details. Pagination is supported, allowing you to specify the page number and the number of items to display per page. Returns orders in the  form of OrderDto[] array of objects 
         * @summary Get list of all orders
         * @param {string} companyId The unique identifier of the company.
         * @param {string} userId The unique identifier of the user.
         * @param {string} [query] A search query to filter orders based on order ID or invoice contact details.
         * @param {number} [currentPage] The page number for paginated results.
         * @param {number} [perPage] The number of items to display per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOrders: async (companyId: string, userId: string, query?: string, currentPage?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('findOrders', 'companyId', companyId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('findOrders', 'userId', userId)
            const localVarPath = `/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation retrieves a single order for a specific company. Returns an OrderDto object.
         * @summary Get an order
         * @param {string} companyId The unique identifier of the company.
         * @param {string} id The unique identifier of the order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getOrder', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOrder', 'id', id)
            const localVarPath = `/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation removes an order line from an existing order. Returns updated OrderDto object.
         * @summary Remove order line
         * @param {string} id The unique identifier of the order.
         * @param {string} lineId The unique identifier of the order line to be removed.
         * @param {string} companyId The unique identifier of the company for which the order belongs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOrderLine: async (id: string, lineId: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeOrderLine', 'id', id)
            // verify required parameter 'lineId' is not null or undefined
            assertParamExists('removeOrderLine', 'lineId', lineId)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('removeOrderLine', 'companyId', companyId)
            const localVarPath = `/orders/{id}/remove-line/{lineId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"lineId"}}`, encodeURIComponent(String(lineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation allows you to resend an order email for a specific order and company. On Success returns true
         * @summary resend order email
         * @param {string} companyId companyId
         * @param {string} id ID
         * @param {Array<string>} [emails] Additional ermail addresses to receive order link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendOrderEmail: async (companyId: string, id: string, emails?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('resendOrderEmail', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('resendOrderEmail', 'id', id)
            const localVarPath = `/orders/{id}/resend-order-email`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (emails) {
                localVarQueryParameter['emails'] = emails;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation allows you to resend a payment email for a specific order and company. On Success returns true
         * @summary resend payment email
         * @param {string} companyId The unique identifier of the company for which the order email will be resent.
         * @param {string} id The unique identifier of the order.
         * @param {Array<string>} [emails] Additional email addresses to receive the order link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendOrderEmailPayment: async (companyId: string, id: string, emails?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('resendOrderEmailPayment', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('resendOrderEmailPayment', 'id', id)
            const localVarPath = `/orders/{id}/resend-payment-email`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (emails) {
                localVarQueryParameter['emails'] = emails;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrdersApi - functional programming interface
 * @export
 */
export const OrdersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * This operation adds a new order line to an existing order. Returns the updated OrderDto object.
         * @summary add line
         * @param {string} id The unique identifier of the order.
         * @param {string} companyId The unique identifier of the company for which the order belongs.
         * @param {ItemDto} itemDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrderLine(id: string, companyId: string, itemDto: ItemDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrder201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrderLine(id, companyId, itemDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.addOrderLine']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This operation changes the invoice contact for a specific order. Returns the updated OrderDto object.
         * @summary change invoice contact id
         * @param {string} id The unique identifier of the order.
         * @param {string} companyId The unique identifier of the company for which the order belongs.
         * @param {string} newInvoiceContactId The unique identifier of the new invoice contact.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeOrderInvoiceContact(id: string, companyId: string, newInvoiceContactId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetItem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeOrderInvoiceContact(id, companyId, newInvoiceContactId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.changeOrderInvoiceContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This operation creates a new order for a specific company. Returns an OrderDto object.
         * @summary Creates an order
         * @param {string} companyId The unique identifier of the company where the order will be created.
         * @param {OrderDto} orderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrder(companyId: string, orderDto: OrderDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrder201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrder(companyId, orderDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.createOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This operation allows you to invoice an order.
         * @summary Invoice order
         * @param {string} id The unique identifier of the order to be invoiced.
         * @param {string} companyId The unique identifier of the company for which the order belongs.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrderInvoice(id: string, companyId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrderInvoice(id, companyId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.createOrderInvoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This operation allows you to delete an order. Returns true on success.
         * @summary Delete an order
         * @param {string} id The unique identifier of the order to be deleted.
         * @param {string} companyId The unique identifier of the company for which the order belongs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrder(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrder(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.deleteOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This operation allows you to export orders for a specific company.
         * @summary Export orders
         * @param {string} companyId The unique identifier of the company for which orders will be exported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportOrders(companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrder201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportOrders(companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.exportOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This operation retrieves a list of all orders for a specific company. You can search for orders based on various criteria such as order ID or invoice contact details. Pagination is supported, allowing you to specify the page number and the number of items to display per page. Returns orders in the  form of OrderDto[] array of objects 
         * @summary Get list of all orders
         * @param {string} companyId The unique identifier of the company.
         * @param {string} userId The unique identifier of the user.
         * @param {string} [query] A search query to filter orders based on order ID or invoice contact details.
         * @param {number} [currentPage] The page number for paginated results.
         * @param {number} [perPage] The number of items to display per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOrders(companyId: string, userId: string, query?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindOrders200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOrders(companyId, userId, query, currentPage, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.findOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This operation retrieves a single order for a specific company. Returns an OrderDto object.
         * @summary Get an order
         * @param {string} companyId The unique identifier of the company.
         * @param {string} id The unique identifier of the order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrder(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrder201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrder(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.getOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This operation removes an order line from an existing order. Returns updated OrderDto object.
         * @summary Remove order line
         * @param {string} id The unique identifier of the order.
         * @param {string} lineId The unique identifier of the order line to be removed.
         * @param {string} companyId The unique identifier of the company for which the order belongs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeOrderLine(id: string, lineId: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeOrderLine(id, lineId, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.removeOrderLine']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This operation allows you to resend an order email for a specific order and company. On Success returns true
         * @summary resend order email
         * @param {string} companyId companyId
         * @param {string} id ID
         * @param {Array<string>} [emails] Additional ermail addresses to receive order link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendOrderEmail(companyId: string, id: string, emails?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrder201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendOrderEmail(companyId, id, emails, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.resendOrderEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This operation allows you to resend a payment email for a specific order and company. On Success returns true
         * @summary resend payment email
         * @param {string} companyId The unique identifier of the company for which the order email will be resent.
         * @param {string} id The unique identifier of the order.
         * @param {Array<string>} [emails] Additional email addresses to receive the order link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendOrderEmailPayment(companyId: string, id: string, emails?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrder201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendOrderEmailPayment(companyId, id, emails, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.resendOrderEmailPayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrdersApi - factory interface
 * @export
 */
export const OrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrdersApiFp(configuration)
    return {
        /**
         * This operation adds a new order line to an existing order. Returns the updated OrderDto object.
         * @summary add line
         * @param {string} id The unique identifier of the order.
         * @param {string} companyId The unique identifier of the company for which the order belongs.
         * @param {ItemDto} itemDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrderLine(id: string, companyId: string, itemDto: ItemDto, options?: any): AxiosPromise<CreateOrder201Response> {
            return localVarFp.addOrderLine(id, companyId, itemDto, options).then((request) => request(axios, basePath));
        },
        /**
         * This operation changes the invoice contact for a specific order. Returns the updated OrderDto object.
         * @summary change invoice contact id
         * @param {string} id The unique identifier of the order.
         * @param {string} companyId The unique identifier of the company for which the order belongs.
         * @param {string} newInvoiceContactId The unique identifier of the new invoice contact.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeOrderInvoiceContact(id: string, companyId: string, newInvoiceContactId: string, options?: any): AxiosPromise<GetItem200Response> {
            return localVarFp.changeOrderInvoiceContact(id, companyId, newInvoiceContactId, options).then((request) => request(axios, basePath));
        },
        /**
         * This operation creates a new order for a specific company. Returns an OrderDto object.
         * @summary Creates an order
         * @param {string} companyId The unique identifier of the company where the order will be created.
         * @param {OrderDto} orderDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder(companyId: string, orderDto: OrderDto, options?: any): AxiosPromise<CreateOrder201Response> {
            return localVarFp.createOrder(companyId, orderDto, options).then((request) => request(axios, basePath));
        },
        /**
         * This operation allows you to invoice an order.
         * @summary Invoice order
         * @param {string} id The unique identifier of the order to be invoiced.
         * @param {string} companyId The unique identifier of the company for which the order belongs.
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderInvoice(id: string, companyId: string, userId: string, options?: any): AxiosPromise<GetInvoice200Response> {
            return localVarFp.createOrderInvoice(id, companyId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * This operation allows you to delete an order. Returns true on success.
         * @summary Delete an order
         * @param {string} id The unique identifier of the order to be deleted.
         * @param {string} companyId The unique identifier of the company for which the order belongs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrder(id: string, companyId: string, options?: any): AxiosPromise<GetInvoice200Response> {
            return localVarFp.deleteOrder(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * This operation allows you to export orders for a specific company.
         * @summary Export orders
         * @param {string} companyId The unique identifier of the company for which orders will be exported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportOrders(companyId: string, options?: any): AxiosPromise<CreateOrder201Response> {
            return localVarFp.exportOrders(companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * This operation retrieves a list of all orders for a specific company. You can search for orders based on various criteria such as order ID or invoice contact details. Pagination is supported, allowing you to specify the page number and the number of items to display per page. Returns orders in the  form of OrderDto[] array of objects 
         * @summary Get list of all orders
         * @param {string} companyId The unique identifier of the company.
         * @param {string} userId The unique identifier of the user.
         * @param {string} [query] A search query to filter orders based on order ID or invoice contact details.
         * @param {number} [currentPage] The page number for paginated results.
         * @param {number} [perPage] The number of items to display per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOrders(companyId: string, userId: string, query?: string, currentPage?: number, perPage?: number, options?: any): AxiosPromise<FindOrders200Response> {
            return localVarFp.findOrders(companyId, userId, query, currentPage, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * This operation retrieves a single order for a specific company. Returns an OrderDto object.
         * @summary Get an order
         * @param {string} companyId The unique identifier of the company.
         * @param {string} id The unique identifier of the order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder(companyId: string, id: string, options?: any): AxiosPromise<CreateOrder201Response> {
            return localVarFp.getOrder(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * This operation removes an order line from an existing order. Returns updated OrderDto object.
         * @summary Remove order line
         * @param {string} id The unique identifier of the order.
         * @param {string} lineId The unique identifier of the order line to be removed.
         * @param {string} companyId The unique identifier of the company for which the order belongs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOrderLine(id: string, lineId: string, companyId: string, options?: any): AxiosPromise<GetInvoice200Response> {
            return localVarFp.removeOrderLine(id, lineId, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * This operation allows you to resend an order email for a specific order and company. On Success returns true
         * @summary resend order email
         * @param {string} companyId companyId
         * @param {string} id ID
         * @param {Array<string>} [emails] Additional ermail addresses to receive order link
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendOrderEmail(companyId: string, id: string, emails?: Array<string>, options?: any): AxiosPromise<CreateOrder201Response> {
            return localVarFp.resendOrderEmail(companyId, id, emails, options).then((request) => request(axios, basePath));
        },
        /**
         * This operation allows you to resend a payment email for a specific order and company. On Success returns true
         * @summary resend payment email
         * @param {string} companyId The unique identifier of the company for which the order email will be resent.
         * @param {string} id The unique identifier of the order.
         * @param {Array<string>} [emails] Additional email addresses to receive the order link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendOrderEmailPayment(companyId: string, id: string, emails?: Array<string>, options?: any): AxiosPromise<CreateOrder201Response> {
            return localVarFp.resendOrderEmailPayment(companyId, id, emails, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
export class OrdersApi extends BaseAPI {
    /**
     * This operation adds a new order line to an existing order. Returns the updated OrderDto object.
     * @summary add line
     * @param {string} id The unique identifier of the order.
     * @param {string} companyId The unique identifier of the company for which the order belongs.
     * @param {ItemDto} itemDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public addOrderLine(id: string, companyId: string, itemDto: ItemDto, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).addOrderLine(id, companyId, itemDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This operation changes the invoice contact for a specific order. Returns the updated OrderDto object.
     * @summary change invoice contact id
     * @param {string} id The unique identifier of the order.
     * @param {string} companyId The unique identifier of the company for which the order belongs.
     * @param {string} newInvoiceContactId The unique identifier of the new invoice contact.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public changeOrderInvoiceContact(id: string, companyId: string, newInvoiceContactId: string, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).changeOrderInvoiceContact(id, companyId, newInvoiceContactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This operation creates a new order for a specific company. Returns an OrderDto object.
     * @summary Creates an order
     * @param {string} companyId The unique identifier of the company where the order will be created.
     * @param {OrderDto} orderDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public createOrder(companyId: string, orderDto: OrderDto, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).createOrder(companyId, orderDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This operation allows you to invoice an order.
     * @summary Invoice order
     * @param {string} id The unique identifier of the order to be invoiced.
     * @param {string} companyId The unique identifier of the company for which the order belongs.
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public createOrderInvoice(id: string, companyId: string, userId: string, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).createOrderInvoice(id, companyId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This operation allows you to delete an order. Returns true on success.
     * @summary Delete an order
     * @param {string} id The unique identifier of the order to be deleted.
     * @param {string} companyId The unique identifier of the company for which the order belongs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public deleteOrder(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).deleteOrder(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This operation allows you to export orders for a specific company.
     * @summary Export orders
     * @param {string} companyId The unique identifier of the company for which orders will be exported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public exportOrders(companyId: string, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).exportOrders(companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This operation retrieves a list of all orders for a specific company. You can search for orders based on various criteria such as order ID or invoice contact details. Pagination is supported, allowing you to specify the page number and the number of items to display per page. Returns orders in the  form of OrderDto[] array of objects 
     * @summary Get list of all orders
     * @param {string} companyId The unique identifier of the company.
     * @param {string} userId The unique identifier of the user.
     * @param {string} [query] A search query to filter orders based on order ID or invoice contact details.
     * @param {number} [currentPage] The page number for paginated results.
     * @param {number} [perPage] The number of items to display per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public findOrders(companyId: string, userId: string, query?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).findOrders(companyId, userId, query, currentPage, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This operation retrieves a single order for a specific company. Returns an OrderDto object.
     * @summary Get an order
     * @param {string} companyId The unique identifier of the company.
     * @param {string} id The unique identifier of the order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getOrder(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).getOrder(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This operation removes an order line from an existing order. Returns updated OrderDto object.
     * @summary Remove order line
     * @param {string} id The unique identifier of the order.
     * @param {string} lineId The unique identifier of the order line to be removed.
     * @param {string} companyId The unique identifier of the company for which the order belongs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public removeOrderLine(id: string, lineId: string, companyId: string, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).removeOrderLine(id, lineId, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This operation allows you to resend an order email for a specific order and company. On Success returns true
     * @summary resend order email
     * @param {string} companyId companyId
     * @param {string} id ID
     * @param {Array<string>} [emails] Additional ermail addresses to receive order link
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public resendOrderEmail(companyId: string, id: string, emails?: Array<string>, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).resendOrderEmail(companyId, id, emails, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This operation allows you to resend a payment email for a specific order and company. On Success returns true
     * @summary resend payment email
     * @param {string} companyId The unique identifier of the company for which the order email will be resent.
     * @param {string} id The unique identifier of the order.
     * @param {Array<string>} [emails] Additional email addresses to receive the order link.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public resendOrderEmailPayment(companyId: string, id: string, emails?: Array<string>, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).resendOrderEmailPayment(companyId, id, emails, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentsApi - axios parameter creator
 * @export
 */
export const PaymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Initiate a payment with the provided payment details and obtain a redirect URL for payment processing. Returns PaymentRedirectUrlDto object
         * @summary Create a payment 
         * @param {string} companyId The unique identifier of the company where the payment will be made.
         * @param {PaymentDto} paymentDto Payment details for the payment request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayment: async (companyId: string, paymentDto: PaymentDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('createPayment', 'companyId', companyId)
            // verify required parameter 'paymentDto' is not null or undefined
            assertParamExists('createPayment', 'paymentDto', paymentDto)
            const localVarPath = `/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a payment record in the specified company.
         * @summary Delete a payment
         * @param {string} id The unique identifier of the payment to be deleted.
         * @param {string} companyId The unique identifier of the company where the payment exists.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePayment: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePayment', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deletePayment', 'companyId', companyId)
            const localVarPath = `/payments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export a list of payments for the specified company.
         * @summary export payments
         * @param {string} companyId The unique identifier of the company where the payments will be exported from.
         * @param {string} [userId] The unique identifier of the specific user of which the payments will be exporeted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportPayment: async (companyId: string, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('exportPayment', 'companyId', companyId)
            const localVarPath = `/payments/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of payments based on various filtering parameters. Returns an array of PaymentDto objects
         * @summary Get list of all payments
         * @param {string} companyId The unique identifier of the company for which payments will be retrieved.
         * @param {string} userId 
         * @param {FindPaymentsTypeEnum} [type] Filter payments by type.
         * @param {string} [integration] Filter payments by service integration ID or title.
         * @param {FindPaymentsStatusEnum} [status] Filter payments by status.
         * @param {number} [fromValue] Filter payments with values greater than or equal to this value.
         * @param {number} [toValue] Filter payments with values less than or equal to this value.
         * @param {string} [fromDate] Filter payments with dates on or after this date (in ISO 8601 format).
         * @param {string} [toDate] Filter payments with dates on or before this date (in ISO 8601 format).
         * @param {number} [currentPage] Specify the current page for paginated results.
         * @param {number} [perPage] Specify the number of items per page in the paginated results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPayments: async (companyId: string, userId: string, type?: FindPaymentsTypeEnum, integration?: string, status?: FindPaymentsStatusEnum, fromValue?: number, toValue?: number, fromDate?: string, toDate?: string, currentPage?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('findPayments', 'companyId', companyId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('findPayments', 'userId', userId)
            const localVarPath = `/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (integration !== undefined) {
                localVarQueryParameter['integration'] = integration;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (fromValue !== undefined) {
                localVarQueryParameter['fromValue'] = fromValue;
            }

            if (toValue !== undefined) {
                localVarQueryParameter['toValue'] = toValue;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve detailed information about a payment by its unique identifier. Returns PaymentDto object
         * @summary Get a payment
         * @param {string} id The unique identifier of the payment.
         * @param {string} companyId The unique identifier of the company for which the payment belongs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayment: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPayment', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getPayment', 'companyId', companyId)
            const localVarPath = `/payments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing payment record in the specified company. Returns updated PaymentDto
         * @summary Update payment
         * @param {string} companyId The unique identifier of the company where the payment will be updated.
         * @param {string} id The unique identifier of the payment to be updated.
         * @param {PaymentDto} paymentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePayment: async (companyId: string, id: string, paymentDto: PaymentDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updatePayment', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePayment', 'id', id)
            // verify required parameter 'paymentDto' is not null or undefined
            assertParamExists('updatePayment', 'paymentDto', paymentDto)
            const localVarPath = `/payments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentsApi - functional programming interface
 * @export
 */
export const PaymentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Initiate a payment with the provided payment details and obtain a redirect URL for payment processing. Returns PaymentRedirectUrlDto object
         * @summary Create a payment 
         * @param {string} companyId The unique identifier of the company where the payment will be made.
         * @param {PaymentDto} paymentDto Payment details for the payment request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPayment(companyId: string, paymentDto: PaymentDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePayment200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPayment(companyId, paymentDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.createPayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a payment record in the specified company.
         * @summary Delete a payment
         * @param {string} id The unique identifier of the payment to be deleted.
         * @param {string} companyId The unique identifier of the company where the payment exists.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePayment(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePayment(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.deletePayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Export a list of payments for the specified company.
         * @summary export payments
         * @param {string} companyId The unique identifier of the company where the payments will be exported from.
         * @param {string} [userId] The unique identifier of the specific user of which the payments will be exporeted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportPayment(companyId: string, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindPayments200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportPayment(companyId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.exportPayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of payments based on various filtering parameters. Returns an array of PaymentDto objects
         * @summary Get list of all payments
         * @param {string} companyId The unique identifier of the company for which payments will be retrieved.
         * @param {string} userId 
         * @param {FindPaymentsTypeEnum} [type] Filter payments by type.
         * @param {string} [integration] Filter payments by service integration ID or title.
         * @param {FindPaymentsStatusEnum} [status] Filter payments by status.
         * @param {number} [fromValue] Filter payments with values greater than or equal to this value.
         * @param {number} [toValue] Filter payments with values less than or equal to this value.
         * @param {string} [fromDate] Filter payments with dates on or after this date (in ISO 8601 format).
         * @param {string} [toDate] Filter payments with dates on or before this date (in ISO 8601 format).
         * @param {number} [currentPage] Specify the current page for paginated results.
         * @param {number} [perPage] Specify the number of items per page in the paginated results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findPayments(companyId: string, userId: string, type?: FindPaymentsTypeEnum, integration?: string, status?: FindPaymentsStatusEnum, fromValue?: number, toValue?: number, fromDate?: string, toDate?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindPayments200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findPayments(companyId, userId, type, integration, status, fromValue, toValue, fromDate, toDate, currentPage, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.findPayments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve detailed information about a payment by its unique identifier. Returns PaymentDto object
         * @summary Get a payment
         * @param {string} id The unique identifier of the payment.
         * @param {string} companyId The unique identifier of the company for which the payment belongs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayment(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPayment200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayment(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.getPayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing payment record in the specified company. Returns updated PaymentDto
         * @summary Update payment
         * @param {string} companyId The unique identifier of the company where the payment will be updated.
         * @param {string} id The unique identifier of the payment to be updated.
         * @param {PaymentDto} paymentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePayment(companyId: string, id: string, paymentDto: PaymentDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPayment200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePayment(companyId, id, paymentDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.updatePayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaymentsApi - factory interface
 * @export
 */
export const PaymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentsApiFp(configuration)
    return {
        /**
         * Initiate a payment with the provided payment details and obtain a redirect URL for payment processing. Returns PaymentRedirectUrlDto object
         * @summary Create a payment 
         * @param {string} companyId The unique identifier of the company where the payment will be made.
         * @param {PaymentDto} paymentDto Payment details for the payment request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayment(companyId: string, paymentDto: PaymentDto, options?: any): AxiosPromise<CreatePayment200Response> {
            return localVarFp.createPayment(companyId, paymentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a payment record in the specified company.
         * @summary Delete a payment
         * @param {string} id The unique identifier of the payment to be deleted.
         * @param {string} companyId The unique identifier of the company where the payment exists.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePayment(id: string, companyId: string, options?: any): AxiosPromise<GetInvoice200Response> {
            return localVarFp.deletePayment(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Export a list of payments for the specified company.
         * @summary export payments
         * @param {string} companyId The unique identifier of the company where the payments will be exported from.
         * @param {string} [userId] The unique identifier of the specific user of which the payments will be exporeted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportPayment(companyId: string, userId?: string, options?: any): AxiosPromise<FindPayments200Response> {
            return localVarFp.exportPayment(companyId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of payments based on various filtering parameters. Returns an array of PaymentDto objects
         * @summary Get list of all payments
         * @param {string} companyId The unique identifier of the company for which payments will be retrieved.
         * @param {string} userId 
         * @param {FindPaymentsTypeEnum} [type] Filter payments by type.
         * @param {string} [integration] Filter payments by service integration ID or title.
         * @param {FindPaymentsStatusEnum} [status] Filter payments by status.
         * @param {number} [fromValue] Filter payments with values greater than or equal to this value.
         * @param {number} [toValue] Filter payments with values less than or equal to this value.
         * @param {string} [fromDate] Filter payments with dates on or after this date (in ISO 8601 format).
         * @param {string} [toDate] Filter payments with dates on or before this date (in ISO 8601 format).
         * @param {number} [currentPage] Specify the current page for paginated results.
         * @param {number} [perPage] Specify the number of items per page in the paginated results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPayments(companyId: string, userId: string, type?: FindPaymentsTypeEnum, integration?: string, status?: FindPaymentsStatusEnum, fromValue?: number, toValue?: number, fromDate?: string, toDate?: string, currentPage?: number, perPage?: number, options?: any): AxiosPromise<FindPayments200Response> {
            return localVarFp.findPayments(companyId, userId, type, integration, status, fromValue, toValue, fromDate, toDate, currentPage, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve detailed information about a payment by its unique identifier. Returns PaymentDto object
         * @summary Get a payment
         * @param {string} id The unique identifier of the payment.
         * @param {string} companyId The unique identifier of the company for which the payment belongs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayment(id: string, companyId: string, options?: any): AxiosPromise<GetPayment200Response> {
            return localVarFp.getPayment(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing payment record in the specified company. Returns updated PaymentDto
         * @summary Update payment
         * @param {string} companyId The unique identifier of the company where the payment will be updated.
         * @param {string} id The unique identifier of the payment to be updated.
         * @param {PaymentDto} paymentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePayment(companyId: string, id: string, paymentDto: PaymentDto, options?: any): AxiosPromise<GetPayment200Response> {
            return localVarFp.updatePayment(companyId, id, paymentDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentsApi - object-oriented interface
 * @export
 * @class PaymentsApi
 * @extends {BaseAPI}
 */
export class PaymentsApi extends BaseAPI {
    /**
     * Initiate a payment with the provided payment details and obtain a redirect URL for payment processing. Returns PaymentRedirectUrlDto object
     * @summary Create a payment 
     * @param {string} companyId The unique identifier of the company where the payment will be made.
     * @param {PaymentDto} paymentDto Payment details for the payment request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public createPayment(companyId: string, paymentDto: PaymentDto, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).createPayment(companyId, paymentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a payment record in the specified company.
     * @summary Delete a payment
     * @param {string} id The unique identifier of the payment to be deleted.
     * @param {string} companyId The unique identifier of the company where the payment exists.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public deletePayment(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).deletePayment(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export a list of payments for the specified company.
     * @summary export payments
     * @param {string} companyId The unique identifier of the company where the payments will be exported from.
     * @param {string} [userId] The unique identifier of the specific user of which the payments will be exporeted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public exportPayment(companyId: string, userId?: string, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).exportPayment(companyId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of payments based on various filtering parameters. Returns an array of PaymentDto objects
     * @summary Get list of all payments
     * @param {string} companyId The unique identifier of the company for which payments will be retrieved.
     * @param {string} userId 
     * @param {FindPaymentsTypeEnum} [type] Filter payments by type.
     * @param {string} [integration] Filter payments by service integration ID or title.
     * @param {FindPaymentsStatusEnum} [status] Filter payments by status.
     * @param {number} [fromValue] Filter payments with values greater than or equal to this value.
     * @param {number} [toValue] Filter payments with values less than or equal to this value.
     * @param {string} [fromDate] Filter payments with dates on or after this date (in ISO 8601 format).
     * @param {string} [toDate] Filter payments with dates on or before this date (in ISO 8601 format).
     * @param {number} [currentPage] Specify the current page for paginated results.
     * @param {number} [perPage] Specify the number of items per page in the paginated results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public findPayments(companyId: string, userId: string, type?: FindPaymentsTypeEnum, integration?: string, status?: FindPaymentsStatusEnum, fromValue?: number, toValue?: number, fromDate?: string, toDate?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).findPayments(companyId, userId, type, integration, status, fromValue, toValue, fromDate, toDate, currentPage, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve detailed information about a payment by its unique identifier. Returns PaymentDto object
     * @summary Get a payment
     * @param {string} id The unique identifier of the payment.
     * @param {string} companyId The unique identifier of the company for which the payment belongs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public getPayment(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).getPayment(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing payment record in the specified company. Returns updated PaymentDto
     * @summary Update payment
     * @param {string} companyId The unique identifier of the company where the payment will be updated.
     * @param {string} id The unique identifier of the payment to be updated.
     * @param {PaymentDto} paymentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public updatePayment(companyId: string, id: string, paymentDto: PaymentDto, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).updatePayment(companyId, id, paymentDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const FindPaymentsTypeEnum = {
    Order: 'ORDER',
    Credits: 'CREDITS'
} as const;
export type FindPaymentsTypeEnum = typeof FindPaymentsTypeEnum[keyof typeof FindPaymentsTypeEnum];
/**
 * @export
 */
export const FindPaymentsStatusEnum = {
    Pending: 'PENDING',
    Processing: 'PROCESSING',
    Completed: 'COMPLETED',
    Cancel: 'CANCEL',
    Error: 'ERROR'
} as const;
export type FindPaymentsStatusEnum = typeof FindPaymentsStatusEnum[keyof typeof FindPaymentsStatusEnum];


/**
 * PoliciesApi - axios parameter creator
 * @export
 */
export const PoliciesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new policy for a company. Returns PolicyDto object
         * @summary make a policy
         * @param {string} companyId The unique identifier of the company for which the policy is created.
         * @param {PolicyDto} policyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicy: async (companyId: string, policyDto: PolicyDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('createPolicy', 'companyId', companyId)
            // verify required parameter 'policyDto' is not null or undefined
            assertParamExists('createPolicy', 'policyDto', policyDto)
            const localVarPath = `/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(policyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a policy associated with a company. Return true on success
         * @summary Delete a policy
         * @param {string} id The unique identifier of the policy to be deleted.
         * @param {string} companyId The unique identifier of the company associated with the policy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePolicy: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePolicy', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deletePolicy', 'companyId', companyId)
            const localVarPath = `/policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of policies associated with a specific company. Returns an array of PolicyDto objects
         * @summary Get list of all policies
         * @param {string} companyId The unique identifier of the company for which policies are retrieved.
         * @param {string} [query] A search query to filter policies based on their title or description.
         * @param {boolean} [_default] If set to true, retrieves only default policies. Default is false.
         * @param {number} [currentPage] The current page of results to retrieve.
         * @param {number} [perPage] The number of policies to retrieve per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPolicies: async (companyId: string, query?: string, _default?: boolean, currentPage?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('findPolicies', 'companyId', companyId)
            const localVarPath = `/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (_default !== undefined) {
                localVarQueryParameter['_default'] = _default;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific policy associated with a specific company.Returns PolicyDto object
         * @summary Get a policy
         * @param {string} id The unique identifier of the policy to retrieve.
         * @param {string} companyId The unique identifier of the company associated with the policy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicy: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPolicy', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getPolicy', 'companyId', companyId)
            const localVarPath = `/policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing policy for a company. Returns updated Policy
         * @summary Update policy
         * @param {string} companyId The unique identifier of the company associated with the policy.
         * @param {string} id The unique identifier of the policy to be updated.
         * @param {PolicyDto} policyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicy: async (companyId: string, id: string, policyDto: PolicyDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updatePolicy', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePolicy', 'id', id)
            // verify required parameter 'policyDto' is not null or undefined
            assertParamExists('updatePolicy', 'policyDto', policyDto)
            const localVarPath = `/policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(policyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PoliciesApi - functional programming interface
 * @export
 */
export const PoliciesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PoliciesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new policy for a company. Returns PolicyDto object
         * @summary make a policy
         * @param {string} companyId The unique identifier of the company for which the policy is created.
         * @param {PolicyDto} policyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPolicy(companyId: string, policyDto: PolicyDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePolicy200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPolicy(companyId, policyDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.createPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a policy associated with a company. Return true on success
         * @summary Delete a policy
         * @param {string} id The unique identifier of the policy to be deleted.
         * @param {string} companyId The unique identifier of the company associated with the policy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePolicy(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePolicy(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.deletePolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of policies associated with a specific company. Returns an array of PolicyDto objects
         * @summary Get list of all policies
         * @param {string} companyId The unique identifier of the company for which policies are retrieved.
         * @param {string} [query] A search query to filter policies based on their title or description.
         * @param {boolean} [_default] If set to true, retrieves only default policies. Default is false.
         * @param {number} [currentPage] The current page of results to retrieve.
         * @param {number} [perPage] The number of policies to retrieve per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findPolicies(companyId: string, query?: string, _default?: boolean, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindPolicies200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findPolicies(companyId, query, _default, currentPage, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.findPolicies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific policy associated with a specific company.Returns PolicyDto object
         * @summary Get a policy
         * @param {string} id The unique identifier of the policy to retrieve.
         * @param {string} companyId The unique identifier of the company associated with the policy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolicy(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePolicy200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicy(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.getPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing policy for a company. Returns updated Policy
         * @summary Update policy
         * @param {string} companyId The unique identifier of the company associated with the policy.
         * @param {string} id The unique identifier of the policy to be updated.
         * @param {PolicyDto} policyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePolicy(companyId: string, id: string, policyDto: PolicyDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePolicy200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePolicy(companyId, id, policyDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.updatePolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PoliciesApi - factory interface
 * @export
 */
export const PoliciesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PoliciesApiFp(configuration)
    return {
        /**
         * Create a new policy for a company. Returns PolicyDto object
         * @summary make a policy
         * @param {string} companyId The unique identifier of the company for which the policy is created.
         * @param {PolicyDto} policyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicy(companyId: string, policyDto: PolicyDto, options?: any): AxiosPromise<CreatePolicy200Response> {
            return localVarFp.createPolicy(companyId, policyDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a policy associated with a company. Return true on success
         * @summary Delete a policy
         * @param {string} id The unique identifier of the policy to be deleted.
         * @param {string} companyId The unique identifier of the company associated with the policy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePolicy(id: string, companyId: string, options?: any): AxiosPromise<GetInvoice200Response> {
            return localVarFp.deletePolicy(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of policies associated with a specific company. Returns an array of PolicyDto objects
         * @summary Get list of all policies
         * @param {string} companyId The unique identifier of the company for which policies are retrieved.
         * @param {string} [query] A search query to filter policies based on their title or description.
         * @param {boolean} [_default] If set to true, retrieves only default policies. Default is false.
         * @param {number} [currentPage] The current page of results to retrieve.
         * @param {number} [perPage] The number of policies to retrieve per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPolicies(companyId: string, query?: string, _default?: boolean, currentPage?: number, perPage?: number, options?: any): AxiosPromise<FindPolicies200Response> {
            return localVarFp.findPolicies(companyId, query, _default, currentPage, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific policy associated with a specific company.Returns PolicyDto object
         * @summary Get a policy
         * @param {string} id The unique identifier of the policy to retrieve.
         * @param {string} companyId The unique identifier of the company associated with the policy.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicy(id: string, companyId: string, options?: any): AxiosPromise<CreatePolicy200Response> {
            return localVarFp.getPolicy(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing policy for a company. Returns updated Policy
         * @summary Update policy
         * @param {string} companyId The unique identifier of the company associated with the policy.
         * @param {string} id The unique identifier of the policy to be updated.
         * @param {PolicyDto} policyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicy(companyId: string, id: string, policyDto: PolicyDto, options?: any): AxiosPromise<CreatePolicy200Response> {
            return localVarFp.updatePolicy(companyId, id, policyDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PoliciesApi - object-oriented interface
 * @export
 * @class PoliciesApi
 * @extends {BaseAPI}
 */
export class PoliciesApi extends BaseAPI {
    /**
     * Create a new policy for a company. Returns PolicyDto object
     * @summary make a policy
     * @param {string} companyId The unique identifier of the company for which the policy is created.
     * @param {PolicyDto} policyDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public createPolicy(companyId: string, policyDto: PolicyDto, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).createPolicy(companyId, policyDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a policy associated with a company. Return true on success
     * @summary Delete a policy
     * @param {string} id The unique identifier of the policy to be deleted.
     * @param {string} companyId The unique identifier of the company associated with the policy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public deletePolicy(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).deletePolicy(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of policies associated with a specific company. Returns an array of PolicyDto objects
     * @summary Get list of all policies
     * @param {string} companyId The unique identifier of the company for which policies are retrieved.
     * @param {string} [query] A search query to filter policies based on their title or description.
     * @param {boolean} [_default] If set to true, retrieves only default policies. Default is false.
     * @param {number} [currentPage] The current page of results to retrieve.
     * @param {number} [perPage] The number of policies to retrieve per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public findPolicies(companyId: string, query?: string, _default?: boolean, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).findPolicies(companyId, query, _default, currentPage, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific policy associated with a specific company.Returns PolicyDto object
     * @summary Get a policy
     * @param {string} id The unique identifier of the policy to retrieve.
     * @param {string} companyId The unique identifier of the company associated with the policy.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public getPolicy(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).getPolicy(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing policy for a company. Returns updated Policy
     * @summary Update policy
     * @param {string} companyId The unique identifier of the company associated with the policy.
     * @param {string} id The unique identifier of the policy to be updated.
     * @param {PolicyDto} policyDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public updatePolicy(companyId: string, id: string, policyDto: PolicyDto, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).updatePolicy(companyId, id, policyDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductCategoriesApi - axios parameter creator
 * @export
 */
export const ProductCategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Recieve the unique identifiers of a company(companyId) as well as the information needed for the creation of a product category. it the creates the product category and then returns the product category data as created
         * @summary Creates a new product category
         * @param {string} companyId The ID of the company to create the product category for
         * @param {ProductCategoryDto} productCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductCategory: async (companyId: string, productCategoryDto: ProductCategoryDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('createProductCategory', 'companyId', companyId)
            // verify required parameter 'productCategoryDto' is not null or undefined
            assertParamExists('createProductCategory', 'productCategoryDto', productCategoryDto)
            const localVarPath = `/product-categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productCategoryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Recieve the unique identifiers of a company(companyId) and the product category(id) and deletes it. It then returns success or not
         * @summary Delete an product category
         * @param {string} id Product Category ID
         * @param {string} companyId The ID of the company to delete the product category from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductCategory: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProductCategory', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deleteProductCategory', 'companyId', companyId)
            const localVarPath = `/product-categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receive  the unique identifier of the company(companyId) and return all product categories associated with it. In the case of also recieving a query, these categories are filtered based on this query by title and/or description  
         * @summary Get list of all product categories
         * @param {string} companyId The ID of the company to get product categories for
         * @param {string} [query] A search query to filter results by title and description
         * @param {number} [currentPage] The current page number
         * @param {number} [perPage] The number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProductCategories: async (companyId: string, query?: string, currentPage?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('findProductCategories', 'companyId', companyId)
            const localVarPath = `/product-categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Recieve the unique identifiers of a company(companyId) and a product category(id) and return the product category information/data.
         * @summary Get a product category
         * @param {string} id  The ID of the product category belonging to the company
         * @param {string} companyId The ID of the company to get product categories for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductCategory: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProductCategory', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getProductCategory', 'companyId', companyId)
            const localVarPath = `/product-categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Recieve the unique identifiers of a company(companyId) and a product category(id) as well as the updated Product category data. It then udates it and returns the updated product category information/data
         * @summary Update product category
         * @param {string} id Product Category ID
         * @param {string} companyId The ID of the company to update the product category for
         * @param {ProductCategoryDto} productCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductCategory: async (id: string, companyId: string, productCategoryDto: ProductCategoryDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProductCategory', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateProductCategory', 'companyId', companyId)
            // verify required parameter 'productCategoryDto' is not null or undefined
            assertParamExists('updateProductCategory', 'productCategoryDto', productCategoryDto)
            const localVarPath = `/product-categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productCategoryDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductCategoriesApi - functional programming interface
 * @export
 */
export const ProductCategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductCategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         *  Recieve the unique identifiers of a company(companyId) as well as the information needed for the creation of a product category. it the creates the product category and then returns the product category data as created
         * @summary Creates a new product category
         * @param {string} companyId The ID of the company to create the product category for
         * @param {ProductCategoryDto} productCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProductCategory(companyId: string, productCategoryDto: ProductCategoryDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProductCategory201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProductCategory(companyId, productCategoryDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductCategoriesApi.createProductCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Recieve the unique identifiers of a company(companyId) and the product category(id) and deletes it. It then returns success or not
         * @summary Delete an product category
         * @param {string} id Product Category ID
         * @param {string} companyId The ID of the company to delete the product category from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProductCategory(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProductCategory(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductCategoriesApi.deleteProductCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Receive  the unique identifier of the company(companyId) and return all product categories associated with it. In the case of also recieving a query, these categories are filtered based on this query by title and/or description  
         * @summary Get list of all product categories
         * @param {string} companyId The ID of the company to get product categories for
         * @param {string} [query] A search query to filter results by title and description
         * @param {number} [currentPage] The current page number
         * @param {number} [perPage] The number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findProductCategories(companyId: string, query?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindProductCategories200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findProductCategories(companyId, query, currentPage, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductCategoriesApi.findProductCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Recieve the unique identifiers of a company(companyId) and a product category(id) and return the product category information/data.
         * @summary Get a product category
         * @param {string} id  The ID of the product category belonging to the company
         * @param {string} companyId The ID of the company to get product categories for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductCategory(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProductCategory201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductCategory(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductCategoriesApi.getProductCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Recieve the unique identifiers of a company(companyId) and a product category(id) as well as the updated Product category data. It then udates it and returns the updated product category information/data
         * @summary Update product category
         * @param {string} id Product Category ID
         * @param {string} companyId The ID of the company to update the product category for
         * @param {ProductCategoryDto} productCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProductCategory(id: string, companyId: string, productCategoryDto: ProductCategoryDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProductCategory201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProductCategory(id, companyId, productCategoryDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductCategoriesApi.updateProductCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductCategoriesApi - factory interface
 * @export
 */
export const ProductCategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductCategoriesApiFp(configuration)
    return {
        /**
         *  Recieve the unique identifiers of a company(companyId) as well as the information needed for the creation of a product category. it the creates the product category and then returns the product category data as created
         * @summary Creates a new product category
         * @param {string} companyId The ID of the company to create the product category for
         * @param {ProductCategoryDto} productCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductCategory(companyId: string, productCategoryDto: ProductCategoryDto, options?: any): AxiosPromise<CreateProductCategory201Response> {
            return localVarFp.createProductCategory(companyId, productCategoryDto, options).then((request) => request(axios, basePath));
        },
        /**
         *  Recieve the unique identifiers of a company(companyId) and the product category(id) and deletes it. It then returns success or not
         * @summary Delete an product category
         * @param {string} id Product Category ID
         * @param {string} companyId The ID of the company to delete the product category from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductCategory(id: string, companyId: string, options?: any): AxiosPromise<GetInvoice200Response> {
            return localVarFp.deleteProductCategory(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Receive  the unique identifier of the company(companyId) and return all product categories associated with it. In the case of also recieving a query, these categories are filtered based on this query by title and/or description  
         * @summary Get list of all product categories
         * @param {string} companyId The ID of the company to get product categories for
         * @param {string} [query] A search query to filter results by title and description
         * @param {number} [currentPage] The current page number
         * @param {number} [perPage] The number of items per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProductCategories(companyId: string, query?: string, currentPage?: number, perPage?: number, options?: any): AxiosPromise<FindProductCategories200Response> {
            return localVarFp.findProductCategories(companyId, query, currentPage, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         *  Recieve the unique identifiers of a company(companyId) and a product category(id) and return the product category information/data.
         * @summary Get a product category
         * @param {string} id  The ID of the product category belonging to the company
         * @param {string} companyId The ID of the company to get product categories for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductCategory(id: string, companyId: string, options?: any): AxiosPromise<CreateProductCategory201Response> {
            return localVarFp.getProductCategory(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         *  Recieve the unique identifiers of a company(companyId) and a product category(id) as well as the updated Product category data. It then udates it and returns the updated product category information/data
         * @summary Update product category
         * @param {string} id Product Category ID
         * @param {string} companyId The ID of the company to update the product category for
         * @param {ProductCategoryDto} productCategoryDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductCategory(id: string, companyId: string, productCategoryDto: ProductCategoryDto, options?: any): AxiosPromise<CreateProductCategory201Response> {
            return localVarFp.updateProductCategory(id, companyId, productCategoryDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductCategoriesApi - object-oriented interface
 * @export
 * @class ProductCategoriesApi
 * @extends {BaseAPI}
 */
export class ProductCategoriesApi extends BaseAPI {
    /**
     *  Recieve the unique identifiers of a company(companyId) as well as the information needed for the creation of a product category. it the creates the product category and then returns the product category data as created
     * @summary Creates a new product category
     * @param {string} companyId The ID of the company to create the product category for
     * @param {ProductCategoryDto} productCategoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    public createProductCategory(companyId: string, productCategoryDto: ProductCategoryDto, options?: RawAxiosRequestConfig) {
        return ProductCategoriesApiFp(this.configuration).createProductCategory(companyId, productCategoryDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Recieve the unique identifiers of a company(companyId) and the product category(id) and deletes it. It then returns success or not
     * @summary Delete an product category
     * @param {string} id Product Category ID
     * @param {string} companyId The ID of the company to delete the product category from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    public deleteProductCategory(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ProductCategoriesApiFp(this.configuration).deleteProductCategory(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Receive  the unique identifier of the company(companyId) and return all product categories associated with it. In the case of also recieving a query, these categories are filtered based on this query by title and/or description  
     * @summary Get list of all product categories
     * @param {string} companyId The ID of the company to get product categories for
     * @param {string} [query] A search query to filter results by title and description
     * @param {number} [currentPage] The current page number
     * @param {number} [perPage] The number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    public findProductCategories(companyId: string, query?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return ProductCategoriesApiFp(this.configuration).findProductCategories(companyId, query, currentPage, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Recieve the unique identifiers of a company(companyId) and a product category(id) and return the product category information/data.
     * @summary Get a product category
     * @param {string} id  The ID of the product category belonging to the company
     * @param {string} companyId The ID of the company to get product categories for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    public getProductCategory(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ProductCategoriesApiFp(this.configuration).getProductCategory(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Recieve the unique identifiers of a company(companyId) and a product category(id) as well as the updated Product category data. It then udates it and returns the updated product category information/data
     * @summary Update product category
     * @param {string} id Product Category ID
     * @param {string} companyId The ID of the company to update the product category for
     * @param {ProductCategoryDto} productCategoryDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    public updateProductCategory(id: string, companyId: string, productCategoryDto: ProductCategoryDto, options?: RawAxiosRequestConfig) {
        return ProductCategoriesApiFp(this.configuration).updateProductCategory(id, companyId, productCategoryDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Enables auto renew feature for a single product. Using params companyId and id wich reflects the id of the product.
         * @summary Auto renew a product
         * @param {string} id A unigue identifier for the product you wish to renew.
         * @param {string} companyId A unigue identifier for the company you wish to renew a product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoRenewProduct: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('autoRenewProduct', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('autoRenewProduct', 'companyId', companyId)
            const localVarPath = `/products/{id}/autoRenew`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new product. Using params companyId and as a body a ProductDto.
         * @summary Creates a new product
         * @param {string} companyId A unigue identifier for the company you wish to create a product.
         * @param {ProductDto} productDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct: async (companyId: string, productDto: ProductDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('createProduct', 'companyId', companyId)
            // verify required parameter 'productDto' is not null or undefined
            assertParamExists('createProduct', 'productDto', productDto)
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new version of a single product. Using params companyId and id wich reflects the id of the product and as body a ProductDto.
         * @summary Creates a new product version
         * @param {string} companyId A unigue identifier for the company you wish to create a new product version.
         * @param {string} id The id of the product we will clone
         * @param {UpdateProductDto} updateProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductVersion: async (companyId: string, id: string, updateProductDto: UpdateProductDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('createProductVersion', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createProductVersion', 'id', id)
            // verify required parameter 'updateProductDto' is not null or undefined
            assertParamExists('createProductVersion', 'updateProductDto', updateProductDto)
            const localVarPath = `/products/{id}/versions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProductDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a single product. Using params companyId and id wich reflects the id of the product.
         * @summary Delete a product
         * @param {string} id A unigue identifier for the product you wish to delete.
         * @param {string} companyId A unigue identifier for the company you wish to delete a product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProduct', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deleteProduct', 'companyId', companyId)
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disables a single product. Using params companyId and id wich reflects the id of the product.
         * @summary Disables a product
         * @param {string} id A unigue identifier for the product you wish to disable.
         * @param {string} companyId A unigue identifier for the company you wish to disable a product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableProduct: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('disableProduct', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('disableProduct', 'companyId', companyId)
            const localVarPath = `/products/{id}/disable`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enables a single product. Using params companyId and id wich reflects the id of the product.
         * @summary Enables a product
         * @param {string} id A unigue identifier for the product you wish to enable.
         * @param {string} companyId A unigue identifier for the company you wish to enable a product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableProduct: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('enableProduct', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('enableProduct', 'companyId', companyId)
            const localVarPath = `/products/{id}/enable`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Exports all products owned by a company. Using param companyId.
         * @summary Export products
         * @param {string} companyId A unigue identifier for the company you wish to export a product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportProducts: async (companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('exportProducts', 'companyId', companyId)
            const localVarPath = `/products/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of all prosucts a company owns. Using params companyId.
         * @summary Get list of all products
         * @param {string} companyId A unigue identifier for the company you wish to get products.
         * @param {string} [integrationId] A unigue identifier for the integration you wish to get products.
         * @param {string} [categoryId] A unigue identifier for the category you wish to get products.
         * @param {boolean} [enabled] enabled
         * @param {string} [query] Searches in title and description
         * @param {boolean} [isDomain] Indicates if a product is enabled.
         * @param {number} [currentPage] Number that indicates the current page.
         * @param {number} [perPage] Number per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProducts: async (companyId: string, integrationId?: string, categoryId?: string, enabled?: boolean, query?: string, isDomain?: boolean, currentPage?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('findProducts', 'companyId', companyId)
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (integrationId !== undefined) {
                localVarQueryParameter['integrationId'] = integrationId;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['categoryId'] = categoryId;
            }

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (isDomain !== undefined) {
                localVarQueryParameter['isDomain'] = isDomain;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single product from a company. Using params companyId and id which reflects the id of the product.
         * @summary Get a product
         * @param {string} id A unigue identifier for the product you wish to get.
         * @param {string} companyId A unigue identifier of the company you wish to get product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProduct', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getProduct', 'companyId', companyId)
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a single product. Using params companyId and id wich reflects the id of the product and as body a ProductDto.
         * @summary Update a product
         * @param {string} id A unigue identifier for the product you wish to update.
         * @param {string} companyId A unigue identifier for the company you wish to update a product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProduct', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateProduct', 'companyId', companyId)
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * Enables auto renew feature for a single product. Using params companyId and id wich reflects the id of the product.
         * @summary Auto renew a product
         * @param {string} id A unigue identifier for the product you wish to renew.
         * @param {string} companyId A unigue identifier for the company you wish to renew a product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoRenewProduct(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProduct201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoRenewProduct(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.autoRenewProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new product. Using params companyId and as a body a ProductDto.
         * @summary Creates a new product
         * @param {string} companyId A unigue identifier for the company you wish to create a product.
         * @param {ProductDto} productDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProduct(companyId: string, productDto: ProductDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProduct201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProduct(companyId, productDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.createProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new version of a single product. Using params companyId and id wich reflects the id of the product and as body a ProductDto.
         * @summary Creates a new product version
         * @param {string} companyId A unigue identifier for the company you wish to create a new product version.
         * @param {string} id The id of the product we will clone
         * @param {UpdateProductDto} updateProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProductVersion(companyId: string, id: string, updateProductDto: UpdateProductDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProduct201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProductVersion(companyId, id, updateProductDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.createProductVersion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a single product. Using params companyId and id wich reflects the id of the product.
         * @summary Delete a product
         * @param {string} id A unigue identifier for the product you wish to delete.
         * @param {string} companyId A unigue identifier for the company you wish to delete a product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProduct(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProduct(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.deleteProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Disables a single product. Using params companyId and id wich reflects the id of the product.
         * @summary Disables a product
         * @param {string} id A unigue identifier for the product you wish to disable.
         * @param {string} companyId A unigue identifier for the company you wish to disable a product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableProduct(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableProduct(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.disableProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Enables a single product. Using params companyId and id wich reflects the id of the product.
         * @summary Enables a product
         * @param {string} id A unigue identifier for the product you wish to enable.
         * @param {string} companyId A unigue identifier for the company you wish to enable a product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableProduct(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProduct201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableProduct(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.enableProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Exports all products owned by a company. Using param companyId.
         * @summary Export products
         * @param {string} companyId A unigue identifier for the company you wish to export a product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportProducts(companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProduct201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportProducts(companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.exportProducts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns an array of all prosucts a company owns. Using params companyId.
         * @summary Get list of all products
         * @param {string} companyId A unigue identifier for the company you wish to get products.
         * @param {string} [integrationId] A unigue identifier for the integration you wish to get products.
         * @param {string} [categoryId] A unigue identifier for the category you wish to get products.
         * @param {boolean} [enabled] enabled
         * @param {string} [query] Searches in title and description
         * @param {boolean} [isDomain] Indicates if a product is enabled.
         * @param {number} [currentPage] Number that indicates the current page.
         * @param {number} [perPage] Number per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findProducts(companyId: string, integrationId?: string, categoryId?: string, enabled?: boolean, query?: string, isDomain?: boolean, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindProducts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findProducts(companyId, integrationId, categoryId, enabled, query, isDomain, currentPage, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.findProducts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a single product from a company. Using params companyId and id which reflects the id of the product.
         * @summary Get a product
         * @param {string} id A unigue identifier for the product you wish to get.
         * @param {string} companyId A unigue identifier of the company you wish to get product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProduct(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProduct201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProduct(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.getProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a single product. Using params companyId and id wich reflects the id of the product and as body a ProductDto.
         * @summary Update a product
         * @param {string} id A unigue identifier for the product you wish to update.
         * @param {string} companyId A unigue identifier for the company you wish to update a product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProduct(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProduct201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProduct(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.updateProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsApiFp(configuration)
    return {
        /**
         * Enables auto renew feature for a single product. Using params companyId and id wich reflects the id of the product.
         * @summary Auto renew a product
         * @param {string} id A unigue identifier for the product you wish to renew.
         * @param {string} companyId A unigue identifier for the company you wish to renew a product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoRenewProduct(id: string, companyId: string, options?: any): AxiosPromise<CreateProduct201Response> {
            return localVarFp.autoRenewProduct(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new product. Using params companyId and as a body a ProductDto.
         * @summary Creates a new product
         * @param {string} companyId A unigue identifier for the company you wish to create a product.
         * @param {ProductDto} productDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct(companyId: string, productDto: ProductDto, options?: any): AxiosPromise<CreateProduct201Response> {
            return localVarFp.createProduct(companyId, productDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new version of a single product. Using params companyId and id wich reflects the id of the product and as body a ProductDto.
         * @summary Creates a new product version
         * @param {string} companyId A unigue identifier for the company you wish to create a new product version.
         * @param {string} id The id of the product we will clone
         * @param {UpdateProductDto} updateProductDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductVersion(companyId: string, id: string, updateProductDto: UpdateProductDto, options?: any): AxiosPromise<CreateProduct201Response> {
            return localVarFp.createProductVersion(companyId, id, updateProductDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a single product. Using params companyId and id wich reflects the id of the product.
         * @summary Delete a product
         * @param {string} id A unigue identifier for the product you wish to delete.
         * @param {string} companyId A unigue identifier for the company you wish to delete a product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct(id: string, companyId: string, options?: any): AxiosPromise<GetInvoice200Response> {
            return localVarFp.deleteProduct(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Disables a single product. Using params companyId and id wich reflects the id of the product.
         * @summary Disables a product
         * @param {string} id A unigue identifier for the product you wish to disable.
         * @param {string} companyId A unigue identifier for the company you wish to disable a product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableProduct(id: string, companyId: string, options?: any): AxiosPromise<GetInvoice200Response> {
            return localVarFp.disableProduct(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Enables a single product. Using params companyId and id wich reflects the id of the product.
         * @summary Enables a product
         * @param {string} id A unigue identifier for the product you wish to enable.
         * @param {string} companyId A unigue identifier for the company you wish to enable a product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableProduct(id: string, companyId: string, options?: any): AxiosPromise<CreateProduct201Response> {
            return localVarFp.enableProduct(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Exports all products owned by a company. Using param companyId.
         * @summary Export products
         * @param {string} companyId A unigue identifier for the company you wish to export a product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportProducts(companyId: string, options?: any): AxiosPromise<CreateProduct201Response> {
            return localVarFp.exportProducts(companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of all prosucts a company owns. Using params companyId.
         * @summary Get list of all products
         * @param {string} companyId A unigue identifier for the company you wish to get products.
         * @param {string} [integrationId] A unigue identifier for the integration you wish to get products.
         * @param {string} [categoryId] A unigue identifier for the category you wish to get products.
         * @param {boolean} [enabled] enabled
         * @param {string} [query] Searches in title and description
         * @param {boolean} [isDomain] Indicates if a product is enabled.
         * @param {number} [currentPage] Number that indicates the current page.
         * @param {number} [perPage] Number per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProducts(companyId: string, integrationId?: string, categoryId?: string, enabled?: boolean, query?: string, isDomain?: boolean, currentPage?: number, perPage?: number, options?: any): AxiosPromise<FindProducts200Response> {
            return localVarFp.findProducts(companyId, integrationId, categoryId, enabled, query, isDomain, currentPage, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single product from a company. Using params companyId and id which reflects the id of the product.
         * @summary Get a product
         * @param {string} id A unigue identifier for the product you wish to get.
         * @param {string} companyId A unigue identifier of the company you wish to get product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct(id: string, companyId: string, options?: any): AxiosPromise<CreateProduct201Response> {
            return localVarFp.getProduct(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a single product. Using params companyId and id wich reflects the id of the product and as body a ProductDto.
         * @summary Update a product
         * @param {string} id A unigue identifier for the product you wish to update.
         * @param {string} companyId A unigue identifier for the company you wish to update a product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct(id: string, companyId: string, options?: any): AxiosPromise<CreateProduct201Response> {
            return localVarFp.updateProduct(id, companyId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * Enables auto renew feature for a single product. Using params companyId and id wich reflects the id of the product.
     * @summary Auto renew a product
     * @param {string} id A unigue identifier for the product you wish to renew.
     * @param {string} companyId A unigue identifier for the company you wish to renew a product.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public autoRenewProduct(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).autoRenewProduct(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new product. Using params companyId and as a body a ProductDto.
     * @summary Creates a new product
     * @param {string} companyId A unigue identifier for the company you wish to create a product.
     * @param {ProductDto} productDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public createProduct(companyId: string, productDto: ProductDto, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).createProduct(companyId, productDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new version of a single product. Using params companyId and id wich reflects the id of the product and as body a ProductDto.
     * @summary Creates a new product version
     * @param {string} companyId A unigue identifier for the company you wish to create a new product version.
     * @param {string} id The id of the product we will clone
     * @param {UpdateProductDto} updateProductDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public createProductVersion(companyId: string, id: string, updateProductDto: UpdateProductDto, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).createProductVersion(companyId, id, updateProductDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a single product. Using params companyId and id wich reflects the id of the product.
     * @summary Delete a product
     * @param {string} id A unigue identifier for the product you wish to delete.
     * @param {string} companyId A unigue identifier for the company you wish to delete a product.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public deleteProduct(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).deleteProduct(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disables a single product. Using params companyId and id wich reflects the id of the product.
     * @summary Disables a product
     * @param {string} id A unigue identifier for the product you wish to disable.
     * @param {string} companyId A unigue identifier for the company you wish to disable a product.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public disableProduct(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).disableProduct(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enables a single product. Using params companyId and id wich reflects the id of the product.
     * @summary Enables a product
     * @param {string} id A unigue identifier for the product you wish to enable.
     * @param {string} companyId A unigue identifier for the company you wish to enable a product.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public enableProduct(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).enableProduct(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Exports all products owned by a company. Using param companyId.
     * @summary Export products
     * @param {string} companyId A unigue identifier for the company you wish to export a product.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public exportProducts(companyId: string, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).exportProducts(companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of all prosucts a company owns. Using params companyId.
     * @summary Get list of all products
     * @param {string} companyId A unigue identifier for the company you wish to get products.
     * @param {string} [integrationId] A unigue identifier for the integration you wish to get products.
     * @param {string} [categoryId] A unigue identifier for the category you wish to get products.
     * @param {boolean} [enabled] enabled
     * @param {string} [query] Searches in title and description
     * @param {boolean} [isDomain] Indicates if a product is enabled.
     * @param {number} [currentPage] Number that indicates the current page.
     * @param {number} [perPage] Number per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public findProducts(companyId: string, integrationId?: string, categoryId?: string, enabled?: boolean, query?: string, isDomain?: boolean, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).findProducts(companyId, integrationId, categoryId, enabled, query, isDomain, currentPage, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single product from a company. Using params companyId and id which reflects the id of the product.
     * @summary Get a product
     * @param {string} id A unigue identifier for the product you wish to get.
     * @param {string} companyId A unigue identifier of the company you wish to get product.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProduct(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).getProduct(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a single product. Using params companyId and id wich reflects the id of the product and as body a ProductDto.
     * @summary Update a product
     * @param {string} id A unigue identifier for the product you wish to update.
     * @param {string} companyId A unigue identifier for the company you wish to update a product.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public updateProduct(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).updateProduct(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TemplatesApi - axios parameter creator
 * @export
 */
export const TemplatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new template . Returns a TemplateDto.
         * @summary Creates a new template
         * @param {string} companyId companyId
         * @param {TemplateDto} templateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplate: async (companyId: string, templateDto: TemplateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('createTemplate', 'companyId', companyId)
            // verify required parameter 'templateDto' is not null or undefined
            assertParamExists('createTemplate', 'templateDto', templateDto)
            const localVarPath = `/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(templateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a certain template. Returns null.
         * @summary Delete a template
         * @param {string} id Template ID
         * @param {string} companyId companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTemplate', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deleteTemplate', 'companyId', companyId)
            const localVarPath = `/templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list all templates. Returns an array of TemplateDto.
         * @summary Get list of all templates
         * @param {string} companyId companyId
         * @param {FindTemplatesActionEnum} [action] get templates by action
         * @param {string} [title] 
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTemplates: async (companyId: string, action?: FindTemplatesActionEnum, title?: string, currentPage?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('findTemplates', 'companyId', companyId)
            const localVarPath = `/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a certain template. Returns a TemplateDto.
         * @summary Get a template
         * @param {string} companyId companyId
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplate: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getTemplate', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTemplate', 'id', id)
            const localVarPath = `/templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a certain template. Returns a TemplateDto.
         * @summary Update a template
         * @param {string} companyId companyId
         * @param {string} id Template ID
         * @param {TemplateDto} templateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTemplate: async (companyId: string, id: string, templateDto: TemplateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateTemplate', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTemplate', 'id', id)
            // verify required parameter 'templateDto' is not null or undefined
            assertParamExists('updateTemplate', 'templateDto', templateDto)
            const localVarPath = `/templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(templateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplatesApi - functional programming interface
 * @export
 */
export const TemplatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TemplatesApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new template . Returns a TemplateDto.
         * @summary Creates a new template
         * @param {string} companyId companyId
         * @param {TemplateDto} templateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTemplate(companyId: string, templateDto: TemplateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTemplate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTemplate(companyId, templateDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.createTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a certain template. Returns null.
         * @summary Delete a template
         * @param {string} id Template ID
         * @param {string} companyId companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTemplate(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTemplate(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.deleteTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list all templates. Returns an array of TemplateDto.
         * @summary Get list of all templates
         * @param {string} companyId companyId
         * @param {FindTemplatesActionEnum} [action] get templates by action
         * @param {string} [title] 
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTemplates(companyId: string, action?: FindTemplatesActionEnum, title?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindTemplates200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTemplates(companyId, action, title, currentPage, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.findTemplates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a certain template. Returns a TemplateDto.
         * @summary Get a template
         * @param {string} companyId companyId
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTemplate(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTemplate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTemplate(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.getTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a certain template. Returns a TemplateDto.
         * @summary Update a template
         * @param {string} companyId companyId
         * @param {string} id Template ID
         * @param {TemplateDto} templateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTemplate(companyId: string, id: string, templateDto: TemplateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTemplate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTemplate(companyId, id, templateDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.updateTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TemplatesApi - factory interface
 * @export
 */
export const TemplatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TemplatesApiFp(configuration)
    return {
        /**
         * Creates a new template . Returns a TemplateDto.
         * @summary Creates a new template
         * @param {string} companyId companyId
         * @param {TemplateDto} templateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplate(companyId: string, templateDto: TemplateDto, options?: any): AxiosPromise<CreateTemplate201Response> {
            return localVarFp.createTemplate(companyId, templateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a certain template. Returns null.
         * @summary Delete a template
         * @param {string} id Template ID
         * @param {string} companyId companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate(id: string, companyId: string, options?: any): AxiosPromise<GetInvoice200Response> {
            return localVarFp.deleteTemplate(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list all templates. Returns an array of TemplateDto.
         * @summary Get list of all templates
         * @param {string} companyId companyId
         * @param {FindTemplatesActionEnum} [action] get templates by action
         * @param {string} [title] 
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTemplates(companyId: string, action?: FindTemplatesActionEnum, title?: string, currentPage?: number, perPage?: number, options?: any): AxiosPromise<FindTemplates200Response> {
            return localVarFp.findTemplates(companyId, action, title, currentPage, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a certain template. Returns a TemplateDto.
         * @summary Get a template
         * @param {string} companyId companyId
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplate(companyId: string, id: string, options?: any): AxiosPromise<CreateTemplate201Response> {
            return localVarFp.getTemplate(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a certain template. Returns a TemplateDto.
         * @summary Update a template
         * @param {string} companyId companyId
         * @param {string} id Template ID
         * @param {TemplateDto} templateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTemplate(companyId: string, id: string, templateDto: TemplateDto, options?: any): AxiosPromise<CreateTemplate201Response> {
            return localVarFp.updateTemplate(companyId, id, templateDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TemplatesApi - object-oriented interface
 * @export
 * @class TemplatesApi
 * @extends {BaseAPI}
 */
export class TemplatesApi extends BaseAPI {
    /**
     * Creates a new template . Returns a TemplateDto.
     * @summary Creates a new template
     * @param {string} companyId companyId
     * @param {TemplateDto} templateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public createTemplate(companyId: string, templateDto: TemplateDto, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).createTemplate(companyId, templateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a certain template. Returns null.
     * @summary Delete a template
     * @param {string} id Template ID
     * @param {string} companyId companyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public deleteTemplate(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).deleteTemplate(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list all templates. Returns an array of TemplateDto.
     * @summary Get list of all templates
     * @param {string} companyId companyId
     * @param {FindTemplatesActionEnum} [action] get templates by action
     * @param {string} [title] 
     * @param {number} [currentPage] current page
     * @param {number} [perPage] per Page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public findTemplates(companyId: string, action?: FindTemplatesActionEnum, title?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).findTemplates(companyId, action, title, currentPage, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a certain template. Returns a TemplateDto.
     * @summary Get a template
     * @param {string} companyId companyId
     * @param {string} id ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public getTemplate(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).getTemplate(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a certain template. Returns a TemplateDto.
     * @summary Update a template
     * @param {string} companyId companyId
     * @param {string} id Template ID
     * @param {TemplateDto} templateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public updateTemplate(companyId: string, id: string, templateDto: TemplateDto, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).updateTemplate(companyId, id, templateDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const FindTemplatesActionEnum = {
    ItemCreate: 'item/create',
    ItemSuspend: 'item/suspend',
    ItemUnsuspend: 'item/unsuspend',
    ItemRenew: 'item/renew',
    ItemCancel: 'item/cancel',
    ItemDelete: 'item/delete',
    ItemUpgrade: 'item/upgrade',
    ItemUpdate: 'item/update',
    ItemDowngrade: 'item/downgrade',
    DomainCreate: 'domain/create',
    DomainLock: 'domain/lock',
    DomainUnlock: 'domain/unlock',
    DomainRenew: 'domain/renew',
    DomainBundleAdd: 'domain/bundle/add',
    DomainBundleRemove: 'domain/bundle/remove',
    DomainInfo: 'domain/info',
    DomainRecall: 'domain/recall',
    DomainTransferCheck: 'domain/transfer/check',
    DomainTransferCancel: 'domain/transfer/cancel',
    DomainTransferAccept: 'domain/transfer/accept',
    DomainSendAuthCode: 'domain/send-auth-code',
    DomainCheckAvailability: 'domain/check-availability',
    DomainShieldActivate: 'domain/shield/activate',
    DomainShieldDeactivate: 'domain/shield/deactivate',
    DomainDelete: 'domain/delete',
    DomainContactsInfo: 'domain/contacts/info',
    DomainContactsCreate: 'domain/contacts/create',
    DomainContactsUpdate: 'domain/contacts/update',
    DomainContactsDelete: 'domain/contacts/delete',
    DomainContactsRegistrant: 'domain/contacts/registrant',
    DomainContactsAdmin: 'domain/contacts/admin',
    DomainContactsTech: 'domain/contacts/tech',
    DomainContactsBilling: 'domain/contacts/billing',
    DomainResendVerificationEmail: 'domain/resend-verification-email',
    DomainCheckClaims: 'domain/check-claims',
    DomainModifyHosts: 'domain/modify-hosts',
    DomainModifyAuthcode: 'domain/modify-authcode',
    DomainGetTransferStatus: 'domain/get-transfer-status',
    DomainCancelTransfer: 'domain/cancel-transfer',
    DomainRequestTransferAway: 'domain/request-transfer-away',
    DomainRequestTransfer: 'domain/request-transfer',
    DomainCompleteTransferAway: 'domain/complete-transfer-away',
    DomainRejectTransferAway: 'domain/reject-transfer-away',
    DomainRejectTransferExpired: 'domain/reject-transfer-expired'
} as const;
export type FindTemplatesActionEnum = typeof FindTemplatesActionEnum[keyof typeof FindTemplatesActionEnum];


/**
 * TldsApi - axios parameter creator
 * @export
 */
export const TldsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new tld .Returns a TldDto
         * @summary Creates a tld
         * @param {string} companyId 
         * @param {TldDto} tldDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTld: async (companyId: string, tldDto: TldDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('createTld', 'companyId', companyId)
            // verify required parameter 'tldDto' is not null or undefined
            assertParamExists('createTld', 'tldDto', tldDto)
            const localVarPath = `/tlds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tldDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a certain tld .Returns null.
         * @summary Delete a tld
         * @param {string} companyId 
         * @param {string} id Tld id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTld: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deleteTld', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTld', 'id', id)
            const localVarPath = `/tlds/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all Tlds .Returns an arry of TldDto.
         * @summary Get list of all tlds
         * @param {string} companyId 
         * @param {string} [tld] tld name
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTlds: async (companyId: string, tld?: string, currentPage?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('findTlds', 'companyId', companyId)
            const localVarPath = `/tlds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (tld !== undefined) {
                localVarQueryParameter['tld'] = tld;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a certain tld .Returns a TldDto
         * @summary Get a tld
         * @param {string} companyId 
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTld: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getTld', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTld', 'id', id)
            const localVarPath = `/tlds/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a certain tld .Returns a TldDto
         * @summary Update tld
         * @param {string} companyId 
         * @param {string} id Tld Id
         * @param {TldDto} tldDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTld: async (companyId: string, id: string, tldDto: TldDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateTld', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTld', 'id', id)
            // verify required parameter 'tldDto' is not null or undefined
            assertParamExists('updateTld', 'tldDto', tldDto)
            const localVarPath = `/tlds/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tldDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TldsApi - functional programming interface
 * @export
 */
export const TldsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TldsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new tld .Returns a TldDto
         * @summary Creates a tld
         * @param {string} companyId 
         * @param {TldDto} tldDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTld(companyId: string, tldDto: TldDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTld200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTld(companyId, tldDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TldsApi.createTld']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a certain tld .Returns null.
         * @summary Delete a tld
         * @param {string} companyId 
         * @param {string} id Tld id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTld(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTld(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TldsApi.deleteTld']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all Tlds .Returns an arry of TldDto.
         * @summary Get list of all tlds
         * @param {string} companyId 
         * @param {string} [tld] tld name
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTlds(companyId: string, tld?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindTlds200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTlds(companyId, tld, currentPage, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TldsApi.findTlds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a certain tld .Returns a TldDto
         * @summary Get a tld
         * @param {string} companyId 
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTld(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTld200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTld(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TldsApi.getTld']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a certain tld .Returns a TldDto
         * @summary Update tld
         * @param {string} companyId 
         * @param {string} id Tld Id
         * @param {TldDto} tldDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTld(companyId: string, id: string, tldDto: TldDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTld200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTld(companyId, id, tldDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TldsApi.updateTld']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TldsApi - factory interface
 * @export
 */
export const TldsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TldsApiFp(configuration)
    return {
        /**
         * Creates a new tld .Returns a TldDto
         * @summary Creates a tld
         * @param {string} companyId 
         * @param {TldDto} tldDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTld(companyId: string, tldDto: TldDto, options?: any): AxiosPromise<CreateTld200Response> {
            return localVarFp.createTld(companyId, tldDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a certain tld .Returns null.
         * @summary Delete a tld
         * @param {string} companyId 
         * @param {string} id Tld id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTld(companyId: string, id: string, options?: any): AxiosPromise<GetInvoice200Response> {
            return localVarFp.deleteTld(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all Tlds .Returns an arry of TldDto.
         * @summary Get list of all tlds
         * @param {string} companyId 
         * @param {string} [tld] tld name
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTlds(companyId: string, tld?: string, currentPage?: number, perPage?: number, options?: any): AxiosPromise<FindTlds200Response> {
            return localVarFp.findTlds(companyId, tld, currentPage, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a certain tld .Returns a TldDto
         * @summary Get a tld
         * @param {string} companyId 
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTld(companyId: string, id: string, options?: any): AxiosPromise<CreateTld200Response> {
            return localVarFp.getTld(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a certain tld .Returns a TldDto
         * @summary Update tld
         * @param {string} companyId 
         * @param {string} id Tld Id
         * @param {TldDto} tldDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTld(companyId: string, id: string, tldDto: TldDto, options?: any): AxiosPromise<CreateTld200Response> {
            return localVarFp.updateTld(companyId, id, tldDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TldsApi - object-oriented interface
 * @export
 * @class TldsApi
 * @extends {BaseAPI}
 */
export class TldsApi extends BaseAPI {
    /**
     * Creates a new tld .Returns a TldDto
     * @summary Creates a tld
     * @param {string} companyId 
     * @param {TldDto} tldDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TldsApi
     */
    public createTld(companyId: string, tldDto: TldDto, options?: RawAxiosRequestConfig) {
        return TldsApiFp(this.configuration).createTld(companyId, tldDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a certain tld .Returns null.
     * @summary Delete a tld
     * @param {string} companyId 
     * @param {string} id Tld id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TldsApi
     */
    public deleteTld(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return TldsApiFp(this.configuration).deleteTld(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all Tlds .Returns an arry of TldDto.
     * @summary Get list of all tlds
     * @param {string} companyId 
     * @param {string} [tld] tld name
     * @param {number} [currentPage] current page
     * @param {number} [perPage] per Page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TldsApi
     */
    public findTlds(companyId: string, tld?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return TldsApiFp(this.configuration).findTlds(companyId, tld, currentPage, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a certain tld .Returns a TldDto
     * @summary Get a tld
     * @param {string} companyId 
     * @param {string} id ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TldsApi
     */
    public getTld(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return TldsApiFp(this.configuration).getTld(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a certain tld .Returns a TldDto
     * @summary Update tld
     * @param {string} companyId 
     * @param {string} id Tld Id
     * @param {TldDto} tldDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TldsApi
     */
    public updateTld(companyId: string, id: string, tldDto: TldDto, options?: RawAxiosRequestConfig) {
        return TldsApiFp(this.configuration).updateTld(companyId, id, tldDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add an additional notification email to a user related to a company. Identify the user by their unique ID and specify the company using the company ID. Returns an array of email addresses.
         * @summary Add additional notification emails to user
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to retrieve additional notification emails within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {string} newEmail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserAdditionalNotificationEmails: async (id: string, companyId: string, newEmail: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addUserAdditionalNotificationEmails', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('addUserAdditionalNotificationEmails', 'companyId', companyId)
            // verify required parameter 'newEmail' is not null or undefined
            assertParamExists('addUserAdditionalNotificationEmails', 'newEmail', newEmail)
            const localVarPath = `/users/{id}/additional-notification-emails`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (newEmail !== undefined) {
                localVarQueryParameter['newEmail'] = newEmail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a comment to a user within a company. Identify the user by their unique ID and specify the company using the company ID. Include the comment as a query parameter.Returns the updated user information.
         * @summary Add user comment
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to add a comment within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {string} comment The comment to be added to the user\&#39;s profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserComment: async (id: string, companyId: string, comment: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addUserComment', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('addUserComment', 'companyId', companyId)
            // verify required parameter 'comment' is not null or undefined
            assertParamExists('addUserComment', 'comment', comment)
            const localVarPath = `/users/{id}/comments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (comment !== undefined) {
                localVarQueryParameter['comment'] = comment;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a custom affiliate to a user related to a company. Identify the user by their unique ID and the company by its unique ID. Provide the details of the custom affiliate using the request body.Returns the updated user object.
         * @summary Update custom addon price policies
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user to which you want to add custom price policies within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {AffiliateDto} affiliateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserCustomAffiliate: async (id: string, companyId: string, affiliateDto: AffiliateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addUserCustomAffiliate', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('addUserCustomAffiliate', 'companyId', companyId)
            // verify required parameter 'affiliateDto' is not null or undefined
            assertParamExists('addUserCustomAffiliate', 'affiliateDto', affiliateDto)
            const localVarPath = `/users/{id}/affiliate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(affiliateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Activate a ban on a user within a specific company. You can specify the user by their unique ID and the company using its unique ID. Returns the updated user details in a UserDto object.
         * @summary Ban User
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user you want to ban within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        banUser: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('banUser', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('banUser', 'companyId', companyId)
            const localVarPath = `/users/{id}/ban`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a custom token for a user and return it
         * @param {string} companyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customToken: async (companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('customToken', 'companyId', companyId)
            const localVarPath = `/users/custom-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a user related to a specific company. You can specify the user by their unique ID and the company using its unique ID. The operation includes checks for balance, active payments, and parent-child relationships.Returns an empty response.
         * @summary Delete a user
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user you want to delete within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUser', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deleteUser', 'companyId', companyId)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Exports all users related to a company using the specified companyId. Returns data that may include user details in the form of a UserDto array of objects.
         * @summary Export users
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportUser: async (companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('exportUser', 'companyId', companyId)
            const localVarPath = `/users/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all users related to the specified company with optional filters applied. Returns an array of UserDto objects.
         * @summary Get list of all users
         * @param {string} companyId A unique identifier for the company. Use this parameter to specify the company for which you want to retrieve users.
         * @param {string} [email] Filter users by email address.
         * @param {boolean} [lockedPayments] Filter users by locked/unlocked status.
         * @param {string} [policyId] Filter users by policyId.
         * @param {number} [perPage] Specify the number of users to show per page.
         * @param {number} [currentPage] Specify the current page.
         * @param {string} [comment] Search for users based on comments.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUsers: async (companyId: string, email?: string, lockedPayments?: boolean, policyId?: string, perPage?: number, currentPage?: number, comment?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('findUsers', 'companyId', companyId)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (lockedPayments !== undefined) {
                localVarQueryParameter['lockedPayments'] = lockedPayments;
            }

            if (policyId !== undefined) {
                localVarQueryParameter['policyId'] = policyId;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (comment !== undefined) {
                localVarQueryParameter['comment'] = comment;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve detailed information about a user related to a specific company using the user\'s unique ID within the company as a parameter. Returns a single UserDto object containing user-related data.
         * @summary Get a user
         * @param {string} id A unique identifier for the user.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUser', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getUser', 'companyId', companyId)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the additional notification emails of a user related to a company. Identify the user by their unique ID and specify the company using the company ID. Returns an array of email addresses.
         * @summary Get additional notification emails of user
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to retrieve additional notification emails within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAdditionalNotificationEmails: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserAdditionalNotificationEmails', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getUserAdditionalNotificationEmails', 'companyId', companyId)
            const localVarPath = `/users/{id}/additional-notification-emails`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the user\'s shopping basket. This endpoint requires a valid JWT (JSON Web Token) for user authorization. This JWT must have JwtUserDto as payload. Returns a UserDto object
         * @summary Get basket
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBasket: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserBasket', 'id', id)
            const localVarPath = `/users/{id}/basket`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve comments related to a user within a company. Identify the user by their unique ID and specify the company using the company ID.Returns an array of comments.
         * @summary Get user comments
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to retrieve comments within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserComments: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserComments', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getUserComments', 'companyId', companyId)
            const localVarPath = `/users/{id}/comments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lock the payments for a user within a specific company. You can specify the user by their unique ID and the company using its unique ID. Returns the updated user details in a UserDto object.
         * @summary Lock User
         * @param {string} id User ID
         * @param {string} companyId companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockUser: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('lockUser', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('lockUser', 'companyId', companyId)
            const localVarPath = `/users/{id}/lock`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows a user to log out, terminating their session. It returns true upon successful logout.
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a comment from a user\'s profile within a company. Identify the user by their unique ID and specify the company using the company ID. Include the comment to be removed as a query parameter.Returns the updated user information.
         * @summary Remove user comment
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user from whom you want to remove a comment within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {string} comment The comment to be removed from the user\&#39;s profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserComment: async (id: string, companyId: string, comment: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeUserComment', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('removeUserComment', 'companyId', companyId)
            // verify required parameter 'comment' is not null or undefined
            assertParamExists('removeUserComment', 'comment', comment)
            const localVarPath = `/users/{id}/comments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (comment !== undefined) {
                localVarQueryParameter['comment'] = comment;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a custom affiliate from a user related to a company. Identify the user by their unique ID, the company by its unique ID, and the affiliate by its unique ID.Returns the updated user object.
         * @summary Remove custom affiliate 
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user from whom you want to remove a custom affiliate within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {string} affiliateId The unique ID of the custom affiliate to be removed from the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserCustomAffiliate: async (id: string, companyId: string, affiliateId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeUserCustomAffiliate', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('removeUserCustomAffiliate', 'companyId', companyId)
            // verify required parameter 'affiliateId' is not null or undefined
            assertParamExists('removeUserCustomAffiliate', 'affiliateId', affiliateId)
            const localVarPath = `/users/{id}/affiliate/{affiliateId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"affiliateId"}}`, encodeURIComponent(String(affiliateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save the user\'s shopping basket. This endpoint requires a valid JWT (JSON Web Token) in the form of JwtUserDto for user authorization. It updates the user\'s basket and returns the updated contents in an updated UserDto object.
         * @summary Save basket
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveUserBasket: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('saveUserBasket', 'id', id)
            const localVarPath = `/users/{id}/basket`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unban a previously banned user within a specific company. You can specify the user by their unique ID and the company using its unique ID. Returns the updated user details in a UserDto object.
         * @summary Unban User
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user you want to unban within the specified company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbanUser: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('unbanUser', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unbanUser', 'id', id)
            const localVarPath = `/users/{id}/unban`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unlock the payments of a previously locked user within a specific company. You can specify the user by their unique ID and the company using its unique ID.Returns the updated user details in a UserDto object.
         * @summary Unlock User
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user whose payments you want to unlock within the specified company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockUser: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('unlockUser', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unlockUser', 'id', id)
            const localVarPath = `/users/{id}/unlock`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a comment on a user\'s profile within a company. Identify the user by their unique ID and specify the company using the company ID. Provide the ID of the comment to be updated and the updated comment as query parameters.Returns the updated user information.
         * @summary Update user comment
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user on whose profile you want to update a comment within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {string} commentId The ID of the comment you want to update on the user\&#39;s profile.
         * @param {string} newComment The updated comment to replace the existing comment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserComment: async (id: string, companyId: string, commentId: string, newComment: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserComment', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateUserComment', 'companyId', companyId)
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('updateUserComment', 'commentId', commentId)
            // verify required parameter 'newComment' is not null or undefined
            assertParamExists('updateUserComment', 'newComment', newComment)
            const localVarPath = `/users/{id}/comments/{commentId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (newComment !== undefined) {
                localVarQueryParameter['newComment'] = newComment;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the credit balance of a user within a specific company. You can specify the user by their unique ID and the company using its unique ID. Provide the new credit balance as a query parameter.Returns the updated user details in a UserDto object.
         * @summary Update user credit balance
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user whose credit balance you want to update within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {number} creditBalance The new credit balance to update for the user. It should be a numerical value representing the user\&#39;s credit balance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserCreditBalance: async (id: string, companyId: string, creditBalance: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserCreditBalance', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateUserCreditBalance', 'companyId', companyId)
            // verify required parameter 'creditBalance' is not null or undefined
            assertParamExists('updateUserCreditBalance', 'creditBalance', creditBalance)
            const localVarPath = `/users/{id}/credit-balance`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (creditBalance !== undefined) {
                localVarQueryParameter['creditBalance'] = creditBalance;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add custom addon price policies to a user related to a company. Identify the user by their unique ID and the company by its unique ID. Provide an array of custom addon price policies using the request body. Returns the updated user object.
         * @summary Update custom addon price policies
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user to which you want to add custom price policies within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {Array<UserAddonPricePolicyDto>} userAddonPricePolicyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserCustomAddonPricePolicies: async (id: string, companyId: string, userAddonPricePolicyDto: Array<UserAddonPricePolicyDto>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserCustomAddonPricePolicies', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateUserCustomAddonPricePolicies', 'companyId', companyId)
            // verify required parameter 'userAddonPricePolicyDto' is not null or undefined
            assertParamExists('updateUserCustomAddonPricePolicies', 'userAddonPricePolicyDto', userAddonPricePolicyDto)
            const localVarPath = `/users/{id}/custom-addon-price-policies`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userAddonPricePolicyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add custom price policies to a user related to a company. Identify the user by their unique ID and the company by its unique ID. Provide an array of custom price policies using the request body. Returns the updated user object.
         * @summary Update custom price policies
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user to which you want to add custom price policies within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {Array<UserPricePolicyDto>} userPricePolicyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserCustomPricePolicies: async (id: string, companyId: string, userPricePolicyDto: Array<UserPricePolicyDto>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserCustomPricePolicies', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateUserCustomPricePolicies', 'companyId', companyId)
            // verify required parameter 'userPricePolicyDto' is not null or undefined
            assertParamExists('updateUserCustomPricePolicies', 'userPricePolicyDto', userPricePolicyDto)
            const localVarPath = `/users/{id}/custom-price-policies`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userPricePolicyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the invoice interval for a user related to a company. Identify the user by their unique ID and specify the new invoice interval.Returns the updated user object.
         * @summary Update invoice interval
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to update the invoice interval within the specified company.
         * @param {UpdateUserInvoiceIntervalInvoiceIntervalEnum} invoiceInterval The new invoice interval to be set for the user. Choose from available options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInvoiceInterval: async (companyId: string, id: string, invoiceInterval: UpdateUserInvoiceIntervalInvoiceIntervalEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateUserInvoiceInterval', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserInvoiceInterval', 'id', id)
            // verify required parameter 'invoiceInterval' is not null or undefined
            assertParamExists('updateUserInvoiceInterval', 'invoiceInterval', invoiceInterval)
            const localVarPath = `/users/{id}/invoice-interval`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (invoiceInterval !== undefined) {
                localVarQueryParameter['invoiceInterval'] = invoiceInterval;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the list of preferred languages for a user related to a specific company. You can specify the user by their unique ID and the company using its unique ID. Provide the new list of preferred languages using the \'languages\' query parameter.Returns an empty response.
         * @summary Update languages
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user whose preferred languages you want to update within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {Array<string>} languages The new list of preferred languages. Use this parameter to specify the updated list of preferred languages for the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserLanguages: async (id: string, companyId: string, languages: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserLanguages', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateUserLanguages', 'companyId', companyId)
            // verify required parameter 'languages' is not null or undefined
            assertParamExists('updateUserLanguages', 'languages', languages)
            const localVarPath = `/users/{id}/languages`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (languages) {
                localVarQueryParameter['languages'] = languages;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the policy of a user related to a specific company. You can specify the user by their unique ID and the company using its unique ID. Provide the new policy using the \'policyId\' query parameter.Returns an empty response.
         * @summary update policy
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user whose policy you want to update within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {string} policyId 
         * @param {string} uniqueIdentifierForThePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPolicy: async (id: string, companyId: string, policyId: string, uniqueIdentifierForThePolicy: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserPolicy', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateUserPolicy', 'companyId', companyId)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('updateUserPolicy', 'policyId', policyId)
            // verify required parameter 'uniqueIdentifierForThePolicy' is not null or undefined
            assertParamExists('updateUserPolicy', 'uniqueIdentifierForThePolicy', uniqueIdentifierForThePolicy)
            const localVarPath = `/users/{id}/policy`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (policyId !== undefined) {
                localVarQueryParameter['policyId'] = policyId;
            }

            if (uniqueIdentifierForThePolicy !== undefined) {
                localVarQueryParameter['Unique identifier for the policy'] = uniqueIdentifierForThePolicy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the tags associated with a user\'s profile within a company. Identify the user by their unique ID and specify the company using the company ID. Replace the existing tags with the provided array of updated tags. Returns the updated user information.
         * @summary Update user tags
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user on whose profile you want to update the tags within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {Array<string>} requestBody An array of tags to replace the existing tags on the user\&#39;s profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserTags: async (id: string, companyId: string, requestBody: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserTags', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateUserTags', 'companyId', companyId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('updateUserTags', 'requestBody', requestBody)
            const localVarPath = `/users/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} companyId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerAddUserToCompany: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('userControllerAddUserToCompany', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerAddUserToCompany', 'id', id)
            const localVarPath = `/users/{id}/add-user-to-company`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerCreate: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} companyId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetUserPayments: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('userControllerGetUserPayments', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerGetUserPayments', 'id', id)
            const localVarPath = `/users/{id}/get-user-payments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} companyId 
         * @param {string} emailToRemove 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerRemoveAdditionalNotificationEmail: async (id: string, companyId: string, emailToRemove: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerRemoveAdditionalNotificationEmail', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('userControllerRemoveAdditionalNotificationEmail', 'companyId', companyId)
            // verify required parameter 'emailToRemove' is not null or undefined
            assertParamExists('userControllerRemoveAdditionalNotificationEmail', 'emailToRemove', emailToRemove)
            const localVarPath = `/users/{id}/additional-notification-emails`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (emailToRemove !== undefined) {
                localVarQueryParameter['emailToRemove'] = emailToRemove;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} companyId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerRemoveUserFromCompany: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('userControllerRemoveUserFromCompany', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerRemoveUserFromCompany', 'id', id)
            const localVarPath = `/users/{id}/remove-user-from-company`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} companyId 
         * @param {string} id 
         * @param {string} invoiceContactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdateInvoiceContact: async (companyId: string, id: string, invoiceContactId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('userControllerUpdateInvoiceContact', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerUpdateInvoiceContact', 'id', id)
            // verify required parameter 'invoiceContactId' is not null or undefined
            assertParamExists('userControllerUpdateInvoiceContact', 'invoiceContactId', invoiceContactId)
            const localVarPath = `/users/{id}/invoice-contact`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (invoiceContactId !== undefined) {
                localVarQueryParameter['invoiceContactId'] = invoiceContactId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} companyId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUploadUserPhoto: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('userControllerUploadUserPhoto', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerUploadUserPhoto', 'id', id)
            const localVarPath = `/users/{id}/upload-photo`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Add an additional notification email to a user related to a company. Identify the user by their unique ID and specify the company using the company ID. Returns an array of email addresses.
         * @summary Add additional notification emails to user
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to retrieve additional notification emails within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {string} newEmail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserAdditionalNotificationEmails(id: string, companyId: string, newEmail: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUserAdditionalNotificationEmails(id, companyId, newEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.addUserAdditionalNotificationEmails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add a comment to a user within a company. Identify the user by their unique ID and specify the company using the company ID. Include the comment as a query parameter.Returns the updated user information.
         * @summary Add user comment
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to add a comment within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {string} comment The comment to be added to the user\&#39;s profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserComment(id: string, companyId: string, comment: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUserComment(id, companyId, comment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.addUserComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add a custom affiliate to a user related to a company. Identify the user by their unique ID and the company by its unique ID. Provide the details of the custom affiliate using the request body.Returns the updated user object.
         * @summary Update custom addon price policies
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user to which you want to add custom price policies within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {AffiliateDto} affiliateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserCustomAffiliate(id: string, companyId: string, affiliateDto: AffiliateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUserCustomAffiliate(id, companyId, affiliateDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.addUserCustomAffiliate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Activate a ban on a user within a specific company. You can specify the user by their unique ID and the company using its unique ID. Returns the updated user details in a UserDto object.
         * @summary Ban User
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user you want to ban within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async banUser(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.banUser(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.banUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a custom token for a user and return it
         * @param {string} companyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customToken(companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomToken200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customToken(companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.customToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a user related to a specific company. You can specify the user by their unique ID and the company using its unique ID. The operation includes checks for balance, active payments, and parent-child relationships.Returns an empty response.
         * @summary Delete a user
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user you want to delete within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.deleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Exports all users related to a company using the specified companyId. Returns data that may include user details in the form of a UserDto array of objects.
         * @summary Export users
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportUser(companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportUser(companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.exportUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all users related to the specified company with optional filters applied. Returns an array of UserDto objects.
         * @summary Get list of all users
         * @param {string} companyId A unique identifier for the company. Use this parameter to specify the company for which you want to retrieve users.
         * @param {string} [email] Filter users by email address.
         * @param {boolean} [lockedPayments] Filter users by locked/unlocked status.
         * @param {string} [policyId] Filter users by policyId.
         * @param {number} [perPage] Specify the number of users to show per page.
         * @param {number} [currentPage] Specify the current page.
         * @param {string} [comment] Search for users based on comments.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findUsers(companyId: string, email?: string, lockedPayments?: boolean, policyId?: string, perPage?: number, currentPage?: number, comment?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findUsers(companyId, email, lockedPayments, policyId, perPage, currentPage, comment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.findUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve detailed information about a user related to a specific company using the user\'s unique ID within the company as a parameter. Returns a single UserDto object containing user-related data.
         * @summary Get a user
         * @param {string} id A unique identifier for the user.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the additional notification emails of a user related to a company. Identify the user by their unique ID and specify the company using the company ID. Returns an array of email addresses.
         * @summary Get additional notification emails of user
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to retrieve additional notification emails within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAdditionalNotificationEmails(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAdditionalNotificationEmails(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUserAdditionalNotificationEmails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the user\'s shopping basket. This endpoint requires a valid JWT (JSON Web Token) for user authorization. This JWT must have JwtUserDto as payload. Returns a UserDto object
         * @summary Get basket
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserBasket(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserBasket(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUserBasket']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve comments related to a user within a company. Identify the user by their unique ID and specify the company using the company ID.Returns an array of comments.
         * @summary Get user comments
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to retrieve comments within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserComments(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserComments(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUserComments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lock the payments for a user within a specific company. You can specify the user by their unique ID and the company using its unique ID. Returns the updated user details in a UserDto object.
         * @summary Lock User
         * @param {string} id User ID
         * @param {string} companyId companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lockUser(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lockUser(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.lockUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint allows a user to log out, terminating their session. It returns true upon successful logout.
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoutUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logoutUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.logoutUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a comment from a user\'s profile within a company. Identify the user by their unique ID and specify the company using the company ID. Include the comment to be removed as a query parameter.Returns the updated user information.
         * @summary Remove user comment
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user from whom you want to remove a comment within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {string} comment The comment to be removed from the user\&#39;s profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUserComment(id: string, companyId: string, comment: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeUserComment(id, companyId, comment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.removeUserComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a custom affiliate from a user related to a company. Identify the user by their unique ID, the company by its unique ID, and the affiliate by its unique ID.Returns the updated user object.
         * @summary Remove custom affiliate 
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user from whom you want to remove a custom affiliate within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {string} affiliateId The unique ID of the custom affiliate to be removed from the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUserCustomAffiliate(id: string, companyId: string, affiliateId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeUserCustomAffiliate(id, companyId, affiliateId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.removeUserCustomAffiliate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Save the user\'s shopping basket. This endpoint requires a valid JWT (JSON Web Token) in the form of JwtUserDto for user authorization. It updates the user\'s basket and returns the updated contents in an updated UserDto object.
         * @summary Save basket
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveUserBasket(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveUserBasket(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.saveUserBasket']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unban a previously banned user within a specific company. You can specify the user by their unique ID and the company using its unique ID. Returns the updated user details in a UserDto object.
         * @summary Unban User
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user you want to unban within the specified company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unbanUser(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unbanUser(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.unbanUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unlock the payments of a previously locked user within a specific company. You can specify the user by their unique ID and the company using its unique ID.Returns the updated user details in a UserDto object.
         * @summary Unlock User
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user whose payments you want to unlock within the specified company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlockUser(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlockUser(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.unlockUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a comment on a user\'s profile within a company. Identify the user by their unique ID and specify the company using the company ID. Provide the ID of the comment to be updated and the updated comment as query parameters.Returns the updated user information.
         * @summary Update user comment
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user on whose profile you want to update a comment within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {string} commentId The ID of the comment you want to update on the user\&#39;s profile.
         * @param {string} newComment The updated comment to replace the existing comment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserComment(id: string, companyId: string, commentId: string, newComment: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserComment(id, companyId, commentId, newComment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUserComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the credit balance of a user within a specific company. You can specify the user by their unique ID and the company using its unique ID. Provide the new credit balance as a query parameter.Returns the updated user details in a UserDto object.
         * @summary Update user credit balance
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user whose credit balance you want to update within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {number} creditBalance The new credit balance to update for the user. It should be a numerical value representing the user\&#39;s credit balance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserCreditBalance(id: string, companyId: string, creditBalance: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserCreditBalance(id, companyId, creditBalance, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUserCreditBalance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add custom addon price policies to a user related to a company. Identify the user by their unique ID and the company by its unique ID. Provide an array of custom addon price policies using the request body. Returns the updated user object.
         * @summary Update custom addon price policies
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user to which you want to add custom price policies within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {Array<UserAddonPricePolicyDto>} userAddonPricePolicyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserCustomAddonPricePolicies(id: string, companyId: string, userAddonPricePolicyDto: Array<UserAddonPricePolicyDto>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserCustomAddonPricePolicies(id, companyId, userAddonPricePolicyDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUserCustomAddonPricePolicies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add custom price policies to a user related to a company. Identify the user by their unique ID and the company by its unique ID. Provide an array of custom price policies using the request body. Returns the updated user object.
         * @summary Update custom price policies
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user to which you want to add custom price policies within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {Array<UserPricePolicyDto>} userPricePolicyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserCustomPricePolicies(id: string, companyId: string, userPricePolicyDto: Array<UserPricePolicyDto>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserCustomPricePolicies(id, companyId, userPricePolicyDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUserCustomPricePolicies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the invoice interval for a user related to a company. Identify the user by their unique ID and specify the new invoice interval.Returns the updated user object.
         * @summary Update invoice interval
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to update the invoice interval within the specified company.
         * @param {UpdateUserInvoiceIntervalInvoiceIntervalEnum} invoiceInterval The new invoice interval to be set for the user. Choose from available options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserInvoiceInterval(companyId: string, id: string, invoiceInterval: UpdateUserInvoiceIntervalInvoiceIntervalEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserInvoiceInterval(companyId, id, invoiceInterval, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUserInvoiceInterval']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the list of preferred languages for a user related to a specific company. You can specify the user by their unique ID and the company using its unique ID. Provide the new list of preferred languages using the \'languages\' query parameter.Returns an empty response.
         * @summary Update languages
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user whose preferred languages you want to update within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {Array<string>} languages The new list of preferred languages. Use this parameter to specify the updated list of preferred languages for the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserLanguages(id: string, companyId: string, languages: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserLanguages(id, companyId, languages, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUserLanguages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the policy of a user related to a specific company. You can specify the user by their unique ID and the company using its unique ID. Provide the new policy using the \'policyId\' query parameter.Returns an empty response.
         * @summary update policy
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user whose policy you want to update within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {string} policyId 
         * @param {string} uniqueIdentifierForThePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserPolicy(id: string, companyId: string, policyId: string, uniqueIdentifierForThePolicy: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserPolicy(id, companyId, policyId, uniqueIdentifierForThePolicy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUserPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the tags associated with a user\'s profile within a company. Identify the user by their unique ID and specify the company using the company ID. Replace the existing tags with the provided array of updated tags. Returns the updated user information.
         * @summary Update user tags
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user on whose profile you want to update the tags within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {Array<string>} requestBody An array of tags to replace the existing tags on the user\&#39;s profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserTags(id: string, companyId: string, requestBody: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserTags(id, companyId, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUserTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} companyId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerAddUserToCompany(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerAddUserToCompany(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerAddUserToCompany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerCreate(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerCreate(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} companyId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerGetUserPayments(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerGetUserPayments(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerGetUserPayments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} companyId 
         * @param {string} emailToRemove 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerRemoveAdditionalNotificationEmail(id: string, companyId: string, emailToRemove: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerRemoveAdditionalNotificationEmail(id, companyId, emailToRemove, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerRemoveAdditionalNotificationEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} companyId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerRemoveUserFromCompany(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerRemoveUserFromCompany(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerRemoveUserFromCompany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} companyId 
         * @param {string} id 
         * @param {string} invoiceContactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerUpdateInvoiceContact(companyId: string, id: string, invoiceContactId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUpdateInvoiceContact(companyId, id, invoiceContactId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerUpdateInvoiceContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} companyId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerUploadUserPhoto(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUploadUserPhoto(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerUploadUserPhoto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Add an additional notification email to a user related to a company. Identify the user by their unique ID and specify the company using the company ID. Returns an array of email addresses.
         * @summary Add additional notification emails to user
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to retrieve additional notification emails within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {string} newEmail 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserAdditionalNotificationEmails(id: string, companyId: string, newEmail: string, options?: any): AxiosPromise<GetUser200Response> {
            return localVarFp.addUserAdditionalNotificationEmails(id, companyId, newEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a comment to a user within a company. Identify the user by their unique ID and specify the company using the company ID. Include the comment as a query parameter.Returns the updated user information.
         * @summary Add user comment
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to add a comment within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {string} comment The comment to be added to the user\&#39;s profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserComment(id: string, companyId: string, comment: string, options?: any): AxiosPromise<GetUser200Response> {
            return localVarFp.addUserComment(id, companyId, comment, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a custom affiliate to a user related to a company. Identify the user by their unique ID and the company by its unique ID. Provide the details of the custom affiliate using the request body.Returns the updated user object.
         * @summary Update custom addon price policies
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user to which you want to add custom price policies within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {AffiliateDto} affiliateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserCustomAffiliate(id: string, companyId: string, affiliateDto: AffiliateDto, options?: any): AxiosPromise<GetUser200Response> {
            return localVarFp.addUserCustomAffiliate(id, companyId, affiliateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Activate a ban on a user within a specific company. You can specify the user by their unique ID and the company using its unique ID. Returns the updated user details in a UserDto object.
         * @summary Ban User
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user you want to ban within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        banUser(id: string, companyId: string, options?: any): AxiosPromise<GetUser200Response> {
            return localVarFp.banUser(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a custom token for a user and return it
         * @param {string} companyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customToken(companyId: string, options?: any): AxiosPromise<CustomToken200Response> {
            return localVarFp.customToken(companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a user related to a specific company. You can specify the user by their unique ID and the company using its unique ID. The operation includes checks for balance, active payments, and parent-child relationships.Returns an empty response.
         * @summary Delete a user
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user you want to delete within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: string, companyId: string, options?: any): AxiosPromise<GetInvoice200Response> {
            return localVarFp.deleteUser(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Exports all users related to a company using the specified companyId. Returns data that may include user details in the form of a UserDto array of objects.
         * @summary Export users
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportUser(companyId: string, options?: any): AxiosPromise<GetUser200Response> {
            return localVarFp.exportUser(companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all users related to the specified company with optional filters applied. Returns an array of UserDto objects.
         * @summary Get list of all users
         * @param {string} companyId A unique identifier for the company. Use this parameter to specify the company for which you want to retrieve users.
         * @param {string} [email] Filter users by email address.
         * @param {boolean} [lockedPayments] Filter users by locked/unlocked status.
         * @param {string} [policyId] Filter users by policyId.
         * @param {number} [perPage] Specify the number of users to show per page.
         * @param {number} [currentPage] Specify the current page.
         * @param {string} [comment] Search for users based on comments.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUsers(companyId: string, email?: string, lockedPayments?: boolean, policyId?: string, perPage?: number, currentPage?: number, comment?: string, options?: any): AxiosPromise<FindUsers200Response> {
            return localVarFp.findUsers(companyId, email, lockedPayments, policyId, perPage, currentPage, comment, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve detailed information about a user related to a specific company using the user\'s unique ID within the company as a parameter. Returns a single UserDto object containing user-related data.
         * @summary Get a user
         * @param {string} id A unique identifier for the user.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: string, companyId: string, options?: any): AxiosPromise<GetUser200Response> {
            return localVarFp.getUser(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the additional notification emails of a user related to a company. Identify the user by their unique ID and specify the company using the company ID. Returns an array of email addresses.
         * @summary Get additional notification emails of user
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to retrieve additional notification emails within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAdditionalNotificationEmails(id: string, companyId: string, options?: any): AxiosPromise<GetUser200Response> {
            return localVarFp.getUserAdditionalNotificationEmails(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the user\'s shopping basket. This endpoint requires a valid JWT (JSON Web Token) for user authorization. This JWT must have JwtUserDto as payload. Returns a UserDto object
         * @summary Get basket
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBasket(id: string, options?: any): AxiosPromise<GetUser200Response> {
            return localVarFp.getUserBasket(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve comments related to a user within a company. Identify the user by their unique ID and specify the company using the company ID.Returns an array of comments.
         * @summary Get user comments
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to retrieve comments within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserComments(id: string, companyId: string, options?: any): AxiosPromise<GetUser200Response> {
            return localVarFp.getUserComments(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lock the payments for a user within a specific company. You can specify the user by their unique ID and the company using its unique ID. Returns the updated user details in a UserDto object.
         * @summary Lock User
         * @param {string} id User ID
         * @param {string} companyId companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockUser(id: string, companyId: string, options?: any): AxiosPromise<GetUser200Response> {
            return localVarFp.lockUser(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows a user to log out, terminating their session. It returns true upon successful logout.
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUser(options?: any): AxiosPromise<GetInvoice200Response> {
            return localVarFp.logoutUser(options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a comment from a user\'s profile within a company. Identify the user by their unique ID and specify the company using the company ID. Include the comment to be removed as a query parameter.Returns the updated user information.
         * @summary Remove user comment
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user from whom you want to remove a comment within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {string} comment The comment to be removed from the user\&#39;s profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserComment(id: string, companyId: string, comment: string, options?: any): AxiosPromise<GetUser200Response> {
            return localVarFp.removeUserComment(id, companyId, comment, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a custom affiliate from a user related to a company. Identify the user by their unique ID, the company by its unique ID, and the affiliate by its unique ID.Returns the updated user object.
         * @summary Remove custom affiliate 
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user from whom you want to remove a custom affiliate within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {string} affiliateId The unique ID of the custom affiliate to be removed from the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserCustomAffiliate(id: string, companyId: string, affiliateId: string, options?: any): AxiosPromise<GetUser200Response> {
            return localVarFp.removeUserCustomAffiliate(id, companyId, affiliateId, options).then((request) => request(axios, basePath));
        },
        /**
         * Save the user\'s shopping basket. This endpoint requires a valid JWT (JSON Web Token) in the form of JwtUserDto for user authorization. It updates the user\'s basket and returns the updated contents in an updated UserDto object.
         * @summary Save basket
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveUserBasket(id: string, options?: any): AxiosPromise<GetUser200Response> {
            return localVarFp.saveUserBasket(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Unban a previously banned user within a specific company. You can specify the user by their unique ID and the company using its unique ID. Returns the updated user details in a UserDto object.
         * @summary Unban User
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user you want to unban within the specified company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbanUser(companyId: string, id: string, options?: any): AxiosPromise<GetUser200Response> {
            return localVarFp.unbanUser(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Unlock the payments of a previously locked user within a specific company. You can specify the user by their unique ID and the company using its unique ID.Returns the updated user details in a UserDto object.
         * @summary Unlock User
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user whose payments you want to unlock within the specified company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockUser(companyId: string, id: string, options?: any): AxiosPromise<GetUser200Response> {
            return localVarFp.unlockUser(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a comment on a user\'s profile within a company. Identify the user by their unique ID and specify the company using the company ID. Provide the ID of the comment to be updated and the updated comment as query parameters.Returns the updated user information.
         * @summary Update user comment
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user on whose profile you want to update a comment within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {string} commentId The ID of the comment you want to update on the user\&#39;s profile.
         * @param {string} newComment The updated comment to replace the existing comment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserComment(id: string, companyId: string, commentId: string, newComment: string, options?: any): AxiosPromise<GetUser200Response> {
            return localVarFp.updateUserComment(id, companyId, commentId, newComment, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the credit balance of a user within a specific company. You can specify the user by their unique ID and the company using its unique ID. Provide the new credit balance as a query parameter.Returns the updated user details in a UserDto object.
         * @summary Update user credit balance
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user whose credit balance you want to update within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {number} creditBalance The new credit balance to update for the user. It should be a numerical value representing the user\&#39;s credit balance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserCreditBalance(id: string, companyId: string, creditBalance: number, options?: any): AxiosPromise<GetUser200Response> {
            return localVarFp.updateUserCreditBalance(id, companyId, creditBalance, options).then((request) => request(axios, basePath));
        },
        /**
         * Add custom addon price policies to a user related to a company. Identify the user by their unique ID and the company by its unique ID. Provide an array of custom addon price policies using the request body. Returns the updated user object.
         * @summary Update custom addon price policies
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user to which you want to add custom price policies within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {Array<UserAddonPricePolicyDto>} userAddonPricePolicyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserCustomAddonPricePolicies(id: string, companyId: string, userAddonPricePolicyDto: Array<UserAddonPricePolicyDto>, options?: any): AxiosPromise<GetUser200Response> {
            return localVarFp.updateUserCustomAddonPricePolicies(id, companyId, userAddonPricePolicyDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Add custom price policies to a user related to a company. Identify the user by their unique ID and the company by its unique ID. Provide an array of custom price policies using the request body. Returns the updated user object.
         * @summary Update custom price policies
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user to which you want to add custom price policies within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {Array<UserPricePolicyDto>} userPricePolicyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserCustomPricePolicies(id: string, companyId: string, userPricePolicyDto: Array<UserPricePolicyDto>, options?: any): AxiosPromise<GetUser200Response> {
            return localVarFp.updateUserCustomPricePolicies(id, companyId, userPricePolicyDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the invoice interval for a user related to a company. Identify the user by their unique ID and specify the new invoice interval.Returns the updated user object.
         * @summary Update invoice interval
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to update the invoice interval within the specified company.
         * @param {UpdateUserInvoiceIntervalInvoiceIntervalEnum} invoiceInterval The new invoice interval to be set for the user. Choose from available options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInvoiceInterval(companyId: string, id: string, invoiceInterval: UpdateUserInvoiceIntervalInvoiceIntervalEnum, options?: any): AxiosPromise<GetUser200Response> {
            return localVarFp.updateUserInvoiceInterval(companyId, id, invoiceInterval, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the list of preferred languages for a user related to a specific company. You can specify the user by their unique ID and the company using its unique ID. Provide the new list of preferred languages using the \'languages\' query parameter.Returns an empty response.
         * @summary Update languages
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user whose preferred languages you want to update within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {Array<string>} languages The new list of preferred languages. Use this parameter to specify the updated list of preferred languages for the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserLanguages(id: string, companyId: string, languages: Array<string>, options?: any): AxiosPromise<GetInvoice200Response> {
            return localVarFp.updateUserLanguages(id, companyId, languages, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the policy of a user related to a specific company. You can specify the user by their unique ID and the company using its unique ID. Provide the new policy using the \'policyId\' query parameter.Returns an empty response.
         * @summary update policy
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user whose policy you want to update within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {string} policyId 
         * @param {string} uniqueIdentifierForThePolicy 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPolicy(id: string, companyId: string, policyId: string, uniqueIdentifierForThePolicy: string, options?: any): AxiosPromise<GetInvoice200Response> {
            return localVarFp.updateUserPolicy(id, companyId, policyId, uniqueIdentifierForThePolicy, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the tags associated with a user\'s profile within a company. Identify the user by their unique ID and specify the company using the company ID. Replace the existing tags with the provided array of updated tags. Returns the updated user information.
         * @summary Update user tags
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user on whose profile you want to update the tags within the specified company.
         * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
         * @param {Array<string>} requestBody An array of tags to replace the existing tags on the user\&#39;s profile.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserTags(id: string, companyId: string, requestBody: Array<string>, options?: any): AxiosPromise<GetUser200Response> {
            return localVarFp.updateUserTags(id, companyId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} companyId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerAddUserToCompany(companyId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.userControllerAddUserToCompany(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerCreate(options?: any): AxiosPromise<void> {
            return localVarFp.userControllerCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} companyId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetUserPayments(companyId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.userControllerGetUserPayments(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} companyId 
         * @param {string} emailToRemove 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerRemoveAdditionalNotificationEmail(id: string, companyId: string, emailToRemove: string, options?: any): AxiosPromise<void> {
            return localVarFp.userControllerRemoveAdditionalNotificationEmail(id, companyId, emailToRemove, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} companyId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerRemoveUserFromCompany(companyId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.userControllerRemoveUserFromCompany(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} companyId 
         * @param {string} id 
         * @param {string} invoiceContactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdateInvoiceContact(companyId: string, id: string, invoiceContactId: string, options?: any): AxiosPromise<void> {
            return localVarFp.userControllerUpdateInvoiceContact(companyId, id, invoiceContactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} companyId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUploadUserPhoto(companyId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.userControllerUploadUserPhoto(companyId, id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Add an additional notification email to a user related to a company. Identify the user by their unique ID and specify the company using the company ID. Returns an array of email addresses.
     * @summary Add additional notification emails to user
     * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to retrieve additional notification emails within the specified company.
     * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
     * @param {string} newEmail 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public addUserAdditionalNotificationEmails(id: string, companyId: string, newEmail: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).addUserAdditionalNotificationEmails(id, companyId, newEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a comment to a user within a company. Identify the user by their unique ID and specify the company using the company ID. Include the comment as a query parameter.Returns the updated user information.
     * @summary Add user comment
     * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to add a comment within the specified company.
     * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
     * @param {string} comment The comment to be added to the user\&#39;s profile.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public addUserComment(id: string, companyId: string, comment: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).addUserComment(id, companyId, comment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a custom affiliate to a user related to a company. Identify the user by their unique ID and the company by its unique ID. Provide the details of the custom affiliate using the request body.Returns the updated user object.
     * @summary Update custom addon price policies
     * @param {string} id A unique identifier for the user. Use this parameter to specify the user to which you want to add custom price policies within the specified company.
     * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
     * @param {AffiliateDto} affiliateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public addUserCustomAffiliate(id: string, companyId: string, affiliateDto: AffiliateDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).addUserCustomAffiliate(id, companyId, affiliateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Activate a ban on a user within a specific company. You can specify the user by their unique ID and the company using its unique ID. Returns the updated user details in a UserDto object.
     * @summary Ban User
     * @param {string} id A unique identifier for the user. Use this parameter to specify the user you want to ban within the specified company.
     * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public banUser(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).banUser(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a custom token for a user and return it
     * @param {string} companyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public customToken(companyId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).customToken(companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a user related to a specific company. You can specify the user by their unique ID and the company using its unique ID. The operation includes checks for balance, active payments, and parent-child relationships.Returns an empty response.
     * @summary Delete a user
     * @param {string} id A unique identifier for the user. Use this parameter to specify the user you want to delete within the specified company.
     * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUser(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Exports all users related to a company using the specified companyId. Returns data that may include user details in the form of a UserDto array of objects.
     * @summary Export users
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public exportUser(companyId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).exportUser(companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all users related to the specified company with optional filters applied. Returns an array of UserDto objects.
     * @summary Get list of all users
     * @param {string} companyId A unique identifier for the company. Use this parameter to specify the company for which you want to retrieve users.
     * @param {string} [email] Filter users by email address.
     * @param {boolean} [lockedPayments] Filter users by locked/unlocked status.
     * @param {string} [policyId] Filter users by policyId.
     * @param {number} [perPage] Specify the number of users to show per page.
     * @param {number} [currentPage] Specify the current page.
     * @param {string} [comment] Search for users based on comments.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public findUsers(companyId: string, email?: string, lockedPayments?: boolean, policyId?: string, perPage?: number, currentPage?: number, comment?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).findUsers(companyId, email, lockedPayments, policyId, perPage, currentPage, comment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve detailed information about a user related to a specific company using the user\'s unique ID within the company as a parameter. Returns a single UserDto object containing user-related data.
     * @summary Get a user
     * @param {string} id A unique identifier for the user.
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUser(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the additional notification emails of a user related to a company. Identify the user by their unique ID and specify the company using the company ID. Returns an array of email addresses.
     * @summary Get additional notification emails of user
     * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to retrieve additional notification emails within the specified company.
     * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserAdditionalNotificationEmails(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserAdditionalNotificationEmails(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the user\'s shopping basket. This endpoint requires a valid JWT (JSON Web Token) for user authorization. This JWT must have JwtUserDto as payload. Returns a UserDto object
     * @summary Get basket
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserBasket(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserBasket(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve comments related to a user within a company. Identify the user by their unique ID and specify the company using the company ID.Returns an array of comments.
     * @summary Get user comments
     * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to retrieve comments within the specified company.
     * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserComments(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserComments(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lock the payments for a user within a specific company. You can specify the user by their unique ID and the company using its unique ID. Returns the updated user details in a UserDto object.
     * @summary Lock User
     * @param {string} id User ID
     * @param {string} companyId companyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public lockUser(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).lockUser(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows a user to log out, terminating their session. It returns true upon successful logout.
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public logoutUser(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).logoutUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a comment from a user\'s profile within a company. Identify the user by their unique ID and specify the company using the company ID. Include the comment to be removed as a query parameter.Returns the updated user information.
     * @summary Remove user comment
     * @param {string} id A unique identifier for the user. Use this parameter to specify the user from whom you want to remove a comment within the specified company.
     * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
     * @param {string} comment The comment to be removed from the user\&#39;s profile.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public removeUserComment(id: string, companyId: string, comment: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).removeUserComment(id, companyId, comment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a custom affiliate from a user related to a company. Identify the user by their unique ID, the company by its unique ID, and the affiliate by its unique ID.Returns the updated user object.
     * @summary Remove custom affiliate 
     * @param {string} id A unique identifier for the user. Use this parameter to specify the user from whom you want to remove a custom affiliate within the specified company.
     * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
     * @param {string} affiliateId The unique ID of the custom affiliate to be removed from the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public removeUserCustomAffiliate(id: string, companyId: string, affiliateId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).removeUserCustomAffiliate(id, companyId, affiliateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Save the user\'s shopping basket. This endpoint requires a valid JWT (JSON Web Token) in the form of JwtUserDto for user authorization. It updates the user\'s basket and returns the updated contents in an updated UserDto object.
     * @summary Save basket
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public saveUserBasket(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).saveUserBasket(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unban a previously banned user within a specific company. You can specify the user by their unique ID and the company using its unique ID. Returns the updated user details in a UserDto object.
     * @summary Unban User
     * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
     * @param {string} id A unique identifier for the user. Use this parameter to specify the user you want to unban within the specified company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public unbanUser(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).unbanUser(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unlock the payments of a previously locked user within a specific company. You can specify the user by their unique ID and the company using its unique ID.Returns the updated user details in a UserDto object.
     * @summary Unlock User
     * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
     * @param {string} id A unique identifier for the user. Use this parameter to specify the user whose payments you want to unlock within the specified company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public unlockUser(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).unlockUser(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a comment on a user\'s profile within a company. Identify the user by their unique ID and specify the company using the company ID. Provide the ID of the comment to be updated and the updated comment as query parameters.Returns the updated user information.
     * @summary Update user comment
     * @param {string} id A unique identifier for the user. Use this parameter to specify the user on whose profile you want to update a comment within the specified company.
     * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
     * @param {string} commentId The ID of the comment you want to update on the user\&#39;s profile.
     * @param {string} newComment The updated comment to replace the existing comment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserComment(id: string, companyId: string, commentId: string, newComment: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserComment(id, companyId, commentId, newComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the credit balance of a user within a specific company. You can specify the user by their unique ID and the company using its unique ID. Provide the new credit balance as a query parameter.Returns the updated user details in a UserDto object.
     * @summary Update user credit balance
     * @param {string} id A unique identifier for the user. Use this parameter to specify the user whose credit balance you want to update within the specified company.
     * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
     * @param {number} creditBalance The new credit balance to update for the user. It should be a numerical value representing the user\&#39;s credit balance.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserCreditBalance(id: string, companyId: string, creditBalance: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserCreditBalance(id, companyId, creditBalance, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add custom addon price policies to a user related to a company. Identify the user by their unique ID and the company by its unique ID. Provide an array of custom addon price policies using the request body. Returns the updated user object.
     * @summary Update custom addon price policies
     * @param {string} id A unique identifier for the user. Use this parameter to specify the user to which you want to add custom price policies within the specified company.
     * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
     * @param {Array<UserAddonPricePolicyDto>} userAddonPricePolicyDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserCustomAddonPricePolicies(id: string, companyId: string, userAddonPricePolicyDto: Array<UserAddonPricePolicyDto>, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserCustomAddonPricePolicies(id, companyId, userAddonPricePolicyDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add custom price policies to a user related to a company. Identify the user by their unique ID and the company by its unique ID. Provide an array of custom price policies using the request body. Returns the updated user object.
     * @summary Update custom price policies
     * @param {string} id A unique identifier for the user. Use this parameter to specify the user to which you want to add custom price policies within the specified company.
     * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
     * @param {Array<UserPricePolicyDto>} userPricePolicyDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserCustomPricePolicies(id: string, companyId: string, userPricePolicyDto: Array<UserPricePolicyDto>, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserCustomPricePolicies(id, companyId, userPricePolicyDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the invoice interval for a user related to a company. Identify the user by their unique ID and specify the new invoice interval.Returns the updated user object.
     * @summary Update invoice interval
     * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
     * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to update the invoice interval within the specified company.
     * @param {UpdateUserInvoiceIntervalInvoiceIntervalEnum} invoiceInterval The new invoice interval to be set for the user. Choose from available options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserInvoiceInterval(companyId: string, id: string, invoiceInterval: UpdateUserInvoiceIntervalInvoiceIntervalEnum, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserInvoiceInterval(companyId, id, invoiceInterval, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the list of preferred languages for a user related to a specific company. You can specify the user by their unique ID and the company using its unique ID. Provide the new list of preferred languages using the \'languages\' query parameter.Returns an empty response.
     * @summary Update languages
     * @param {string} id A unique identifier for the user. Use this parameter to specify the user whose preferred languages you want to update within the specified company.
     * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
     * @param {Array<string>} languages The new list of preferred languages. Use this parameter to specify the updated list of preferred languages for the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserLanguages(id: string, companyId: string, languages: Array<string>, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserLanguages(id, companyId, languages, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the policy of a user related to a specific company. You can specify the user by their unique ID and the company using its unique ID. Provide the new policy using the \'policyId\' query parameter.Returns an empty response.
     * @summary update policy
     * @param {string} id A unique identifier for the user. Use this parameter to specify the user whose policy you want to update within the specified company.
     * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
     * @param {string} policyId 
     * @param {string} uniqueIdentifierForThePolicy 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserPolicy(id: string, companyId: string, policyId: string, uniqueIdentifierForThePolicy: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserPolicy(id, companyId, policyId, uniqueIdentifierForThePolicy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the tags associated with a user\'s profile within a company. Identify the user by their unique ID and specify the company using the company ID. Replace the existing tags with the provided array of updated tags. Returns the updated user information.
     * @summary Update user tags
     * @param {string} id A unique identifier for the user. Use this parameter to specify the user on whose profile you want to update the tags within the specified company.
     * @param {string} companyId A unique identifier for the company. Specify the company to which the user belongs.
     * @param {Array<string>} requestBody An array of tags to replace the existing tags on the user\&#39;s profile.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserTags(id: string, companyId: string, requestBody: Array<string>, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserTags(id, companyId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} companyId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerAddUserToCompany(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerAddUserToCompany(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerCreate(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} companyId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerGetUserPayments(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerGetUserPayments(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} companyId 
     * @param {string} emailToRemove 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerRemoveAdditionalNotificationEmail(id: string, companyId: string, emailToRemove: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerRemoveAdditionalNotificationEmail(id, companyId, emailToRemove, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} companyId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerRemoveUserFromCompany(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerRemoveUserFromCompany(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} companyId 
     * @param {string} id 
     * @param {string} invoiceContactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerUpdateInvoiceContact(companyId: string, id: string, invoiceContactId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerUpdateInvoiceContact(companyId, id, invoiceContactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} companyId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerUploadUserPhoto(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerUploadUserPhoto(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const UpdateUserInvoiceIntervalInvoiceIntervalEnum = {
    Instant: 'instant',
    Weekly: 'weekly',
    Monthly: 'monthly',
    PerRequest: 'per request'
} as const;
export type UpdateUserInvoiceIntervalInvoiceIntervalEnum = typeof UpdateUserInvoiceIntervalInvoiceIntervalEnum[keyof typeof UpdateUserInvoiceIntervalInvoiceIntervalEnum];


