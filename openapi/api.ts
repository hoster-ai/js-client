/* tslint:disable */
/* eslint-disable */
/**
 * Hoster API
 * Hosting automation. The easy way
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AcceptedNotificationMethodsDto
 */
export interface AcceptedNotificationMethodsDto {
    /**
     * 
     * @type {boolean}
     * @memberof AcceptedNotificationMethodsDto
     */
    'email': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AcceptedNotificationMethodsDto
     */
    'sms': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AcceptedNotificationMethodsDto
     */
    'push': boolean;
}
/**
 * 
 * @export
 * @interface ActionDto
 */
export interface ActionDto {
    /**
     * Name of the icon to display for the action.
     * @type {string}
     * @memberof ActionDto
     */
    'icon': string;
    /**
     * Text label for the action.
     * @type {string}
     * @memberof ActionDto
     */
    'label'?: string;
    /**
     * Method by which the action\'s URL should be opened.
     * @type {string}
     * @memberof ActionDto
     */
    'openMethod': ActionDtoOpenMethodEnum;
    /**
     * URL to navigate to when the action is triggered.
     * @type {string}
     * @memberof ActionDto
     */
    'url': string;
}

export const ActionDtoOpenMethodEnum = {
    AjaxCall: 'ajax_call',
    SmallIframe: 'small_iframe',
    MediumIframe: 'medium_iframe',
    LargeIframe: 'large_iframe'
} as const;

export type ActionDtoOpenMethodEnum = typeof ActionDtoOpenMethodEnum[keyof typeof ActionDtoOpenMethodEnum];

/**
 * 
 * @export
 * @interface AddonOptionsDto
 */
export interface AddonOptionsDto {
    /**
     * The unique identifier of the option, typically used as the HTML id attribute for the option element.
     * @type {string}
     * @memberof AddonOptionsDto
     */
    'id': string;
    /**
     * An array of the addon option title in all supported languages. This allows you to provide the title of the option in different languages, enabling multilingual support for your addon options.
     * @type {Array<MultilangTextDto>}
     * @memberof AddonOptionsDto
     */
    'title': Array<MultilangTextDto>;
    /**
     * An array of prices for the addon option. Each price object contains information about the price structure, including the currency and amount. This allows you to define different prices for the addon option based on various criteria.
     * @type {PricesDto}
     * @memberof AddonOptionsDto
     */
    'prices': PricesDto;
    /**
     * An array that holds all the price policies applied to the addon option. Each price policy defines the price structure when the addon is selected with this specific option. This helps determine the cost of the addon based on the chosen option.
     * @type {Array<PolicyPricesResponseDto>}
     * @memberof AddonOptionsDto
     */
    'policyPrices': Array<PolicyPricesResponseDto>;
}
/**
 * 
 * @export
 * @interface AddonRequestDto
 */
export interface AddonRequestDto {
    /**
     * An array of the addon\'s title in all supported languages. This field ensures that the addon has a localized title for each supported language, allowing it to be displayed appropriately across different regions and languages.
     * @type {Array<MultilangTextDto>}
     * @memberof AddonRequestDto
     */
    'title': Array<MultilangTextDto>;
    /**
     * An array that holds a brief description of the addon in all supported languages. This allows for multi-language support, ensuring that users from different regions can view the addon’s description in their native language.
     * @type {Array<MultilangTextDto>}
     * @memberof AddonRequestDto
     */
    'description': Array<MultilangTextDto>;
    /**
     * A URL pointing to the icon image of the addon. This icon will be displayed in the user interface to visually represent the addon. It should be an accessible URL to an image file (e.g., PNG, JPG, etc.).
     * @type {string}
     * @memberof AddonRequestDto
     */
    'iconUrl': string;
    /**
     * Defines the type of input element that the addon will display on the frontend. This determines how the addon will be presented to the user, such as a text box, checkbox, radio button, etc.
     * @type {string}
     * @memberof AddonRequestDto
     */
    'type': AddonRequestDtoTypeEnum;
    /**
     * Indicates whether the addon is mandatory for the user to select or not.
     * @type {boolean}
     * @memberof AddonRequestDto
     */
    'required': boolean;
    /**
     * Indicate if the addon is active or not.
     * @type {boolean}
     * @memberof AddonRequestDto
     */
    'active': boolean;
    /**
     * An array that contains all the available options for the addon. Each option defines a specific choice or setting that the user can select when using the addon.
     * @type {Array<AddonOptionsDto>}
     * @memberof AddonRequestDto
     */
    'options': Array<AddonOptionsDto>;
}

export const AddonRequestDtoTypeEnum = {
    TextBox: 'TEXT_BOX',
    TextArea: 'TEXT_AREA',
    List: 'LIST',
    RadioBox: 'RADIO_BOX',
    Checkbox: 'CHECKBOX',
    Slider: 'SLIDER'
} as const;

export type AddonRequestDtoTypeEnum = typeof AddonRequestDtoTypeEnum[keyof typeof AddonRequestDtoTypeEnum];

/**
 * 
 * @export
 * @interface AddonResponseDto
 */
export interface AddonResponseDto {
    /**
     * An array of the addon\'s title in all supported languages. This field ensures that the addon has a localized title for each supported language, allowing it to be displayed appropriately across different regions and languages.
     * @type {Array<MultilangTextDto>}
     * @memberof AddonResponseDto
     */
    'title': Array<MultilangTextDto>;
    /**
     * An array that holds a brief description of the addon in all supported languages. This allows for multi-language support, ensuring that users from different regions can view the addon’s description in their native language.
     * @type {Array<MultilangTextDto>}
     * @memberof AddonResponseDto
     */
    'description': Array<MultilangTextDto>;
    /**
     * A URL pointing to the icon image of the addon. This icon will be displayed in the user interface to visually represent the addon. It should be an accessible URL to an image file (e.g., PNG, JPG, etc.).
     * @type {string}
     * @memberof AddonResponseDto
     */
    'iconUrl': string;
    /**
     * Defines the type of input element that the addon will display on the frontend. This determines how the addon will be presented to the user, such as a text box, checkbox, radio button, etc.
     * @type {string}
     * @memberof AddonResponseDto
     */
    'type': AddonResponseDtoTypeEnum;
    /**
     * Indicates whether the addon is mandatory for the user to select or not.
     * @type {boolean}
     * @memberof AddonResponseDto
     */
    'required': boolean;
    /**
     * Indicate if the addon is active or not.
     * @type {boolean}
     * @memberof AddonResponseDto
     */
    'active': boolean;
    /**
     * An array that contains all the available options for the addon. Each option defines a specific choice or setting that the user can select when using the addon.
     * @type {Array<AddonOptionsDto>}
     * @memberof AddonResponseDto
     */
    'options': Array<AddonOptionsDto>;
    /**
     * A unique identifier for the addon, used to reference it within the system.
     * @type {string}
     * @memberof AddonResponseDto
     */
    'id': string;
    /**
     * 
     * @type {Company6}
     * @memberof AddonResponseDto
     */
    'company': Company6;
    /**
     * The date the addon created.
     * @type {string}
     * @memberof AddonResponseDto
     */
    'createdAt': string;
    /**
     * The date the addon updated.
     * @type {string}
     * @memberof AddonResponseDto
     */
    'updatedAt': string;
}

export const AddonResponseDtoTypeEnum = {
    TextBox: 'TEXT_BOX',
    TextArea: 'TEXT_AREA',
    List: 'LIST',
    RadioBox: 'RADIO_BOX',
    Checkbox: 'CHECKBOX',
    Slider: 'SLIDER'
} as const;

export type AddonResponseDtoTypeEnum = typeof AddonResponseDtoTypeEnum[keyof typeof AddonResponseDtoTypeEnum];

/**
 * 
 * @export
 * @interface AdminPanelDto
 */
export interface AdminPanelDto {
    /**
     * 
     * @type {Tabs}
     * @memberof AdminPanelDto
     */
    'tabs'?: Tabs;
    /**
     * 
     * @type {MoreActions}
     * @memberof AdminPanelDto
     */
    'moreActions'?: MoreActions;
    /**
     * 
     * @type {Menu}
     * @memberof AdminPanelDto
     */
    'menu'?: Menu;
    /**
     * 
     * @type {Settings}
     * @memberof AdminPanelDto
     */
    'settings'?: Settings;
}
/**
 * 
 * @export
 * @interface AdminPanelMoreActionsDto
 */
export interface AdminPanelMoreActionsDto {
    /**
     * Additional actions available on the client page.
     * @type {Array<ActionDto>}
     * @memberof AdminPanelMoreActionsDto
     */
    'client'?: Array<ActionDto>;
    /**
     * Additional actions available on the item page.
     * @type {Array<ActionDto>}
     * @memberof AdminPanelMoreActionsDto
     */
    'item'?: Array<ActionDto>;
    /**
     * Additional actions available on the invoice page.
     * @type {Array<ActionDto>}
     * @memberof AdminPanelMoreActionsDto
     */
    'invoice'?: Array<ActionDto>;
    /**
     * Additional actions available on the user page.
     * @type {Array<ActionDto>}
     * @memberof AdminPanelMoreActionsDto
     */
    'user'?: Array<ActionDto>;
    /**
     * Additional actions available on the order page.
     * @type {Array<ActionDto>}
     * @memberof AdminPanelMoreActionsDto
     */
    'order'?: Array<ActionDto>;
}
/**
 * 
 * @export
 * @interface AdminPanelTabsDto
 */
export interface AdminPanelTabsDto {
    /**
     * Tabs shown on the product detail page in Admin panel.
     * @type {Array<TabDto>}
     * @memberof AdminPanelTabsDto
     */
    'product'?: Array<TabDto>;
    /**
     * Tabs shown on the item detail page in Admin panel.
     * @type {Array<TabDto>}
     * @memberof AdminPanelTabsDto
     */
    'item'?: Array<TabDto>;
    /**
     * Tabs shown on the client profile page in Admin panel.
     * @type {Array<TabDto>}
     * @memberof AdminPanelTabsDto
     */
    'client'?: Array<TabDto>;
    /**
     * Tabs shown on the user page in Admin panel.
     * @type {Array<TabDto>}
     * @memberof AdminPanelTabsDto
     */
    'user'?: Array<TabDto>;
    /**
     * Tabs shown on the order page in Admin panel.
     * @type {Array<TabDto>}
     * @memberof AdminPanelTabsDto
     */
    'order'?: Array<TabDto>;
}
/**
 * @type Affiliate
 * The identifier of the user supplies affiliate.
 * @export
 */
export type Affiliate = AffiliateResponseDto | string;

/**
 * Information about the affiliate associated with the item, relevant if the item originated from an affiliate link and includes commission details.
 * @export
 * @interface AffiliateData
 */
export interface AffiliateData {
    /**
     * 
     * @type {Affiliate}
     * @memberof AffiliateData
     */
    'affiliate': Affiliate;
    /**
     * 
     * @type {User2}
     * @memberof AffiliateData
     */
    'user': User2;
    /**
     * The type of affiliate,
     * @type {any}
     * @memberof AffiliateData
     */
    'affiliateType': AffiliateDataAffiliateTypeEnum;
    /**
     * Indicates if the item has been paid or not.
     * @type {any}
     * @memberof AffiliateData
     */
    'paid': any;
    /**
     * The date and time when the payment was made.
     * @type {any}
     * @memberof AffiliateData
     */
    'paidAt': any;
    /**
     * The monetary value to be paid.
     * @type {any}
     * @memberof AffiliateData
     */
    'value': any;
    /**
     * 
     * @type {any}
     * @memberof AffiliateData
     */
    'status': AffiliateDataStatusEnum;
}

export const AffiliateDataAffiliateTypeEnum = {
    Fixed: 'fixed',
    Percentage: 'percentage'
} as const;

export type AffiliateDataAffiliateTypeEnum = typeof AffiliateDataAffiliateTypeEnum[keyof typeof AffiliateDataAffiliateTypeEnum];
export const AffiliateDataStatusEnum = {
    Pending: 'pending',
    Accepted: 'accepted',
    Rejected: 'rejected'
} as const;

export type AffiliateDataStatusEnum = typeof AffiliateDataStatusEnum[keyof typeof AffiliateDataStatusEnum];

/**
 * 
 * @export
 * @interface AffiliateDataRequestDto
 */
export interface AffiliateDataRequestDto {
    /**
     * The identifier of the user supplies affiliate.
     * @type {string}
     * @memberof AffiliateDataRequestDto
     */
    'affiliate': string;
    /**
     * The identifier of the user who will receive the affiliate commission.
     * @type {string}
     * @memberof AffiliateDataRequestDto
     */
    'user': string;
}
/**
 * 
 * @export
 * @interface AffiliateRequestDto
 */
export interface AffiliateRequestDto {
    /**
     * An array of selected durations for the product. These are the durations during which the affiliate applies to the product.
     * @type {Array<string>}
     * @memberof AffiliateRequestDto
     */
    'durations': Array<AffiliateRequestDtoDurationsEnum>;
    /**
     * The type of the product affiliate, which determines whether the affiliate commission is a fixed amount or a percentage.
     * @type {string}
     * @memberof AffiliateRequestDto
     */
    'type': AffiliateRequestDtoTypeEnum;
    /**
     * The numeric value for the product affiliate. This value can either represent a fixed amount or a percentage. The type of value depends on the \'Affiliate Type\'
     * @type {number}
     * @memberof AffiliateRequestDto
     */
    'value': number;
    /**
     * The list of actions for which the affiliate will be applicable.
     * @type {Array<string>}
     * @memberof AffiliateRequestDto
     */
    'action': Array<AffiliateRequestDtoActionEnum>;
    /**
     * The number of days after which the affiliate can receive their commission. This period allows for the completion of any pending actions or verifications (such as payment or order fulfillment) before the affiliate\'s commission is released.
     * @type {number}
     * @memberof AffiliateRequestDto
     */
    'releaseCommisionAfterDays': number;
    /**
     * An array of products that are associated with the affiliate. This helps identify which products the affiliate is linked to.
     * @type {Array<string>}
     * @memberof AffiliateRequestDto
     */
    'products': Array<string>;
}

export const AffiliateRequestDtoDurationsEnum = {
    _0: '0',
    _1: '1',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5',
    _6: '6',
    _7: '7',
    _8: '8',
    _9: '9',
    _10: '10',
    _11: '11',
    _12: '12',
    _24: '24',
    _36: '36',
    _48: '48',
    _60: '60',
    _72: '72',
    _84: '84',
    _96: '96',
    _108: '108',
    _120: '120'
} as const;

export type AffiliateRequestDtoDurationsEnum = typeof AffiliateRequestDtoDurationsEnum[keyof typeof AffiliateRequestDtoDurationsEnum];
export const AffiliateRequestDtoTypeEnum = {
    Fixed: 'fixed',
    Percentage: 'percentage'
} as const;

export type AffiliateRequestDtoTypeEnum = typeof AffiliateRequestDtoTypeEnum[keyof typeof AffiliateRequestDtoTypeEnum];
export const AffiliateRequestDtoActionEnum = {
    Create: 'item/create',
    Suspend: 'item/suspend',
    Unsuspend: 'item/unsuspend',
    Renew: 'item/renew',
    Cancel: 'item/cancel',
    Delete: 'item/delete',
    Upgrade: 'item/upgrade',
    Downgrade: 'item/downgrade'
} as const;

export type AffiliateRequestDtoActionEnum = typeof AffiliateRequestDtoActionEnum[keyof typeof AffiliateRequestDtoActionEnum];

/**
 * 
 * @export
 * @interface AffiliateResponseDto
 */
export interface AffiliateResponseDto {
    /**
     * An array of selected durations for the product. These are the durations during which the affiliate applies to the product.
     * @type {Array<string>}
     * @memberof AffiliateResponseDto
     */
    'durations': Array<AffiliateResponseDtoDurationsEnum>;
    /**
     * The type of the product affiliate, which determines whether the affiliate commission is a fixed amount or a percentage.
     * @type {string}
     * @memberof AffiliateResponseDto
     */
    'type': AffiliateResponseDtoTypeEnum;
    /**
     * The numeric value for the product affiliate. This value can either represent a fixed amount or a percentage. The type of value depends on the \'Affiliate Type\'
     * @type {number}
     * @memberof AffiliateResponseDto
     */
    'value': number;
    /**
     * The list of actions for which the affiliate will be applicable.
     * @type {Array<string>}
     * @memberof AffiliateResponseDto
     */
    'action': Array<AffiliateResponseDtoActionEnum>;
    /**
     * The number of days after which the affiliate can receive their commission. This period allows for the completion of any pending actions or verifications (such as payment or order fulfillment) before the affiliate\'s commission is released.
     * @type {number}
     * @memberof AffiliateResponseDto
     */
    'releaseCommisionAfterDays': number;
    /**
     * The unique identifier of the affiliate
     * @type {string}
     * @memberof AffiliateResponseDto
     */
    'id': string;
    /**
     * 
     * @type {Company7}
     * @memberof AffiliateResponseDto
     */
    'company': Company7;
    /**
     * An array of products that are associated with the affiliate. This helps identify which products the affiliate is linked to.
     * @type {Array<ProductVersionDtoProductInner>}
     * @memberof AffiliateResponseDto
     */
    'products': Array<ProductVersionDtoProductInner>;
    /**
     * The date when the affiliate was created.
     * @type {string}
     * @memberof AffiliateResponseDto
     */
    'createdAt': string;
    /**
     * The date when the affiliate was updated.
     * @type {string}
     * @memberof AffiliateResponseDto
     */
    'updatedAt': string;
}

export const AffiliateResponseDtoDurationsEnum = {
    _0: '0',
    _1: '1',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5',
    _6: '6',
    _7: '7',
    _8: '8',
    _9: '9',
    _10: '10',
    _11: '11',
    _12: '12',
    _24: '24',
    _36: '36',
    _48: '48',
    _60: '60',
    _72: '72',
    _84: '84',
    _96: '96',
    _108: '108',
    _120: '120'
} as const;

export type AffiliateResponseDtoDurationsEnum = typeof AffiliateResponseDtoDurationsEnum[keyof typeof AffiliateResponseDtoDurationsEnum];
export const AffiliateResponseDtoTypeEnum = {
    Fixed: 'fixed',
    Percentage: 'percentage'
} as const;

export type AffiliateResponseDtoTypeEnum = typeof AffiliateResponseDtoTypeEnum[keyof typeof AffiliateResponseDtoTypeEnum];
export const AffiliateResponseDtoActionEnum = {
    Create: 'item/create',
    Suspend: 'item/suspend',
    Unsuspend: 'item/unsuspend',
    Renew: 'item/renew',
    Cancel: 'item/cancel',
    Delete: 'item/delete',
    Upgrade: 'item/upgrade',
    Downgrade: 'item/downgrade'
} as const;

export type AffiliateResponseDtoActionEnum = typeof AffiliateResponseDtoActionEnum[keyof typeof AffiliateResponseDtoActionEnum];

/**
 * 
 * @export
 * @interface AfnicAdditionalDataDto
 */
export interface AfnicAdditionalDataDto {
    /**
     * This field represents the date of birth of the contact in ISO format.
     * @type {string}
     * @memberof AfnicAdditionalDataDto
     */
    'birthDate': string;
    /**
     * This field represents the ISO country code for the contact\'s birthplace.
     * @type {string}
     * @memberof AfnicAdditionalDataDto
     */
    'birthCc': AfnicAdditionalDataDtoBirthCcEnum;
    /**
     * This field represents the birth city of the contact.
     * @type {string}
     * @memberof AfnicAdditionalDataDto
     */
    'birthCity'?: string;
    /**
     * This field represents the postal code of the contact\'s birthplace.
     * @type {string}
     * @memberof AfnicAdditionalDataDto
     */
    'birthPc'?: string;
}

export const AfnicAdditionalDataDtoBirthCcEnum = {
    Af: 'AF',
    Al: 'AL',
    Dz: 'DZ',
    As: 'AS',
    Ad: 'AD',
    Ao: 'AO',
    Ai: 'AI',
    Aq: 'AQ',
    Ag: 'AG',
    Ar: 'AR',
    Am: 'AM',
    Aw: 'AW',
    Au: 'AU',
    At: 'AT',
    Az: 'AZ',
    Bs: 'BS',
    Bh: 'BH',
    Bd: 'BD',
    Bb: 'BB',
    By: 'BY',
    Be: 'BE',
    Bz: 'BZ',
    Bj: 'BJ',
    Bm: 'BM',
    Bt: 'BT',
    Bo: 'BO',
    Bq: 'BQ',
    Ba: 'BA',
    Bw: 'BW',
    Bv: 'BV',
    Br: 'BR',
    Io: 'IO',
    Bn: 'BN',
    Bg: 'BG',
    Bf: 'BF',
    Bi: 'BI',
    Kh: 'KH',
    Cm: 'CM',
    Ca: 'CA',
    Cv: 'CV',
    Ky: 'KY',
    Cf: 'CF',
    Td: 'TD',
    Cl: 'CL',
    Cn: 'CN',
    Cx: 'CX',
    Cc: 'CC',
    Co: 'CO',
    Km: 'KM',
    Cg: 'CG',
    Cd: 'CD',
    Ck: 'CK',
    Cr: 'CR',
    Ci: 'CI',
    Hr: 'HR',
    Cu: 'CU',
    Cw: 'CW',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Dj: 'DJ',
    Dm: 'DM',
    Do: 'DO',
    Ec: 'EC',
    Eg: 'EG',
    Sv: 'SV',
    Gq: 'GQ',
    Er: 'ER',
    Ee: 'EE',
    Et: 'ET',
    Fk: 'FK',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Gf: 'GF',
    Pf: 'PF',
    Tf: 'TF',
    Ga: 'GA',
    Gm: 'GM',
    Ge: 'GE',
    De: 'DE',
    Gh: 'GH',
    Gi: 'GI',
    Gr: 'GR',
    Gl: 'GL',
    Gd: 'GD',
    Gp: 'GP',
    Gu: 'GU',
    Gt: 'GT',
    Gg: 'GG',
    Gn: 'GN',
    Gw: 'GW',
    Gy: 'GY',
    Ht: 'HT',
    Hm: 'HM',
    Va: 'VA',
    Hn: 'HN',
    Hk: 'HK',
    Hu: 'HU',
    Is: 'IS',
    In: 'IN',
    Id: 'ID',
    Ir: 'IR',
    Iq: 'IQ',
    Ie: 'IE',
    Im: 'IM',
    Il: 'IL',
    It: 'IT',
    Jm: 'JM',
    Jp: 'JP',
    Je: 'JE',
    Jo: 'JO',
    Kz: 'KZ',
    Ke: 'KE',
    Ki: 'KI',
    Kp: 'KP',
    Kr: 'KR',
    Kw: 'KW',
    Kg: 'KG',
    La: 'LA',
    Lv: 'LV',
    Lb: 'LB',
    Ls: 'LS',
    Lr: 'LR',
    Ly: 'LY',
    Li: 'LI',
    Lt: 'LT',
    Lu: 'LU',
    Mo: 'MO',
    Mk: 'MK',
    Mg: 'MG',
    Mw: 'MW',
    My: 'MY',
    Mv: 'MV',
    Ml: 'ML',
    Mt: 'MT',
    Mh: 'MH',
    Mq: 'MQ',
    Mr: 'MR',
    Mu: 'MU',
    Tn: 'TN',
    Tr: 'TR',
    Tm: 'TM',
    Tc: 'TC',
    Tv: 'TV',
    Ug: 'UG',
    Ua: 'UA',
    Ae: 'AE',
    Gb: 'GB',
    Us: 'US',
    Um: 'UM',
    Uy: 'UY',
    Uz: 'UZ',
    Vu: 'VU',
    Ve: 'VE',
    Vn: 'VN',
    Vg: 'VG',
    Vi: 'VI',
    Wf: 'WF',
    Eh: 'EH',
    Ye: 'YE',
    Zm: 'ZM',
    Zw: 'ZW',
    Yt: 'YT',
    Mx: 'MX',
    Fm: 'FM',
    Md: 'MD',
    Mc: 'MC',
    Mn: 'MN',
    Me: 'ME',
    Ms: 'MS',
    Ma: 'MA',
    Mz: 'MZ',
    Mm: 'MM',
    Na: 'NA',
    Nr: 'NR',
    Np: 'NP',
    Nl: 'NL',
    Nc: 'NC',
    Nz: 'NZ',
    Ni: 'NI',
    Ne: 'NE',
    Ng: 'NG',
    Nu: 'NU',
    Nf: 'NF',
    Mp: 'MP',
    No: 'NO',
    Om: 'OM',
    Pk: 'PK',
    Pw: 'PW',
    Ps: 'PS',
    Pa: 'PA',
    Pg: 'PG',
    Py: 'PY',
    Pe: 'PE',
    Ph: 'PH',
    Pn: 'PN',
    Pl: 'PL',
    Pt: 'PT',
    Pr: 'PR',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Ru: 'RU',
    Rw: 'RW',
    Bl: 'BL',
    Sh: 'SH',
    Kn: 'KN',
    Lc: 'LC',
    Mf: 'MF',
    Pm: 'PM',
    Vc: 'VC',
    Ws: 'WS',
    Sm: 'SM',
    St: 'ST',
    Sa: 'SA',
    Sn: 'SN',
    Rs: 'RS',
    Sc: 'SC',
    Sl: 'SL',
    Sg: 'SG',
    Sx: 'SX',
    Sk: 'SK',
    Si: 'SI',
    Sb: 'SB',
    So: 'SO',
    Za: 'ZA',
    Gs: 'GS',
    Ss: 'SS',
    Es: 'ES',
    Lk: 'LK',
    Sd: 'SD',
    Sr: 'SR',
    Sj: 'SJ',
    Sz: 'SZ',
    Se: 'SE',
    Ch: 'CH',
    Sy: 'SY',
    Tw: 'TW',
    Tj: 'TJ',
    Tz: 'TZ',
    Th: 'TH',
    Tl: 'TL',
    Tg: 'TG',
    Tk: 'TK',
    To: 'TO',
    Tt: 'TT'
} as const;

export type AfnicAdditionalDataDtoBirthCcEnum = typeof AfnicAdditionalDataDtoBirthCcEnum[keyof typeof AfnicAdditionalDataDtoBirthCcEnum];

/**
 * 
 * @export
 * @interface AttachmentDto
 */
export interface AttachmentDto {
    /**
     * The filename of the attachment
     * @type {string}
     * @memberof AttachmentDto
     */
    'filename': string;
    /**
     * The base64-encoded content of the attachment
     * @type {string}
     * @memberof AttachmentDto
     */
    'content': string;
    /**
     * The content type of the attachment
     * @type {string}
     * @memberof AttachmentDto
     */
    'contentType'?: string;
}
/**
 * 
 * @export
 * @interface BalanceResponseDto
 */
export interface BalanceResponseDto {
    /**
     * Represents the user\'s account balance, which may include funds available for transactions or other purposes within the system.
     * @type {number}
     * @memberof BalanceResponseDto
     */
    'balance': number;
    /**
     * Represents the balance, primarily accumulated from affiliate programs, that can be applied as a discount on products. This balance is not related to credits but serves as a discount mechanism.
     * @type {number}
     * @memberof BalanceResponseDto
     */
    'discountBalance': number;
    /**
     * The amount of money that is temporarily reserved from the user\'s account. This balance is typically used for services or products that charge on a time-based or usage-based model, such as hourly rental fees.
     * @type {number}
     * @memberof BalanceResponseDto
     */
    'reservedBalance': number;
    /**
     * The amount of money that is available for the user to spend. This balance is typically used for services or products that charge on a time-based or usage-based model, such as hourly rental fees.
     * @type {number}
     * @memberof BalanceResponseDto
     */
    'creditBalance': number;
}
/**
 * 
 * @export
 * @interface BaseMenuDto
 */
export interface BaseMenuDto {
    /**
     * Icon for the menu item.
     * @type {string}
     * @memberof BaseMenuDto
     */
    'icon': string;
    /**
     * Label for the menu item.
     * @type {string}
     * @memberof BaseMenuDto
     */
    'label': string;
}
/**
 * @type BundledWithItem
 * Unique identifier for the primary item in the bundle under which other items were added.
 * @export
 */
export type BundledWithItem = ItemResponseDto | string;

/**
 * @type CancelTemplate
 * The template for canceling a product. This field represents the official name or identifier for the template, and it cannot be empty.
 * @export
 */
export type CancelTemplate = TemplateResponseDto | string;

/**
 * 
 * @export
 * @interface CatAdditionalDataDto
 */
export interface CatAdditionalDataDto {
    /**
     * This field represents the language of the contact in the form of an enum.
     * @type {string}
     * @memberof CatAdditionalDataDto
     */
    'language': CatAdditionalDataDtoLanguageEnum;
    /**
     * The name of the person responsible for maintaining this contact.
     * @type {string}
     * @memberof CatAdditionalDataDto
     */
    'maintainer': string;
}

export const CatAdditionalDataDtoLanguageEnum = {
    Ab: 'AB',
    Aa: 'AA',
    Af: 'AF',
    Ak: 'AK',
    Sq: 'SQ',
    Am: 'AM',
    Ar: 'AR',
    An: 'AN',
    Hy: 'HY',
    As: 'AS',
    Av: 'AV',
    Ae: 'AE',
    Ay: 'AY',
    Az: 'AZ',
    Bm: 'BM',
    Ba: 'BA',
    Eu: 'EU',
    Be: 'BE',
    Bn: 'BN',
    Bi: 'BI',
    Bs: 'BS',
    Br: 'BR',
    Bg: 'BG',
    My: 'MY',
    Ca: 'CA',
    Km: 'KM',
    Ch: 'CH',
    Ce: 'CE',
    Ny: 'NY',
    Zh: 'ZH',
    Cu: 'CU',
    Cv: 'CV',
    Kw: 'KW',
    Co: 'CO',
    Cr: 'CR',
    Hr: 'HR',
    Cs: 'CS',
    Da: 'DA',
    Dv: 'DV',
    Nl: 'NL',
    Dz: 'DZ',
    En: 'EN',
    Eo: 'EO',
    Et: 'ET',
    Ee: 'EE',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Ff: 'FF',
    Gl: 'GL',
    Lg: 'LG',
    Ka: 'KA',
    De: 'DE',
    El: 'EL',
    Gn: 'GN',
    Gu: 'GU',
    Ht: 'HT',
    Ha: 'HA',
    He: 'HE',
    Hz: 'HZ',
    Hi: 'HI',
    Ho: 'HO',
    Hu: 'HU',
    Is: 'IS',
    Io: 'IO',
    Ig: 'IG',
    Id: 'ID',
    Ia: 'IA',
    Ie: 'IE',
    Iu: 'IU',
    Ik: 'IK',
    Ga: 'GA',
    It: 'IT',
    Ja: 'JA',
    Jv: 'JV',
    Kl: 'KL',
    Kn: 'KN',
    Kr: 'KR',
    Ks: 'KS',
    Kk: 'KK',
    Ki: 'KI',
    Rw: 'RW',
    Ky: 'KY',
    Kv: 'KV',
    Kg: 'KG',
    Ko: 'KO',
    Kj: 'KJ',
    Ku: 'KU',
    Lo: 'LO',
    La: 'LA',
    Lv: 'LV',
    Li: 'LI',
    Ln: 'LN',
    Lt: 'LT',
    Lu: 'LU',
    Lb: 'LB',
    Mk: 'MK',
    Mg: 'MG',
    Ms: 'MS',
    Ml: 'ML',
    Mt: 'MT',
    Gv: 'GV',
    Mi: 'MI',
    Mr: 'MR',
    Mh: 'MH',
    Mn: 'MN',
    Na: 'NA',
    Nv: 'NV',
    Nd: 'ND',
    Nr: 'NR',
    Ng: 'NG',
    Ne: 'NE',
    Se: 'SE',
    No: 'NO',
    Nb: 'NB',
    Nn: 'NN',
    Ii: 'II',
    Oc: 'OC',
    Oj: 'OJ',
    Or: 'OR',
    Om: 'OM',
    Os: 'OS',
    Pi: 'PI',
    Ps: 'PS',
    Fa: 'FA',
    Pl: 'PL',
    Pt: 'PT',
    Pa: 'PA',
    Qu: 'QU',
    Ro: 'RO',
    Rm: 'RM',
    Rn: 'RN',
    Ru: 'RU',
    Sm: 'SM',
    Sg: 'SG',
    Sa: 'SA',
    Sc: 'SC',
    Gd: 'GD',
    Sr: 'SR',
    Sn: 'SN',
    Ii2: 'II',
    Sd: 'SD',
    Si: 'SI',
    Sk: 'SK',
    Sl: 'SL',
    So: 'SO',
    St: 'ST',
    Es: 'ES',
    Su: 'SU',
    Sw: 'SW',
    Ss: 'SS',
    Sv: 'SV',
    Tl: 'TL',
    Ty: 'TY',
    Tg: 'TG',
    Ta: 'TA',
    Tt: 'TT',
    Te: 'TE',
    Th: 'TH',
    Bo: 'BO',
    Ti: 'TI',
    To: 'TO',
    Ts: 'TS',
    Tn: 'TN',
    Tr: 'TR',
    Tk: 'TK',
    Tw: 'TW',
    Ug: 'UG',
    Uk: 'UK',
    Ur: 'UR',
    Uz: 'UZ',
    Ve: 'VE',
    Vi: 'VI',
    Vo: 'VO',
    Wa: 'WA',
    Cy: 'CY',
    Fy: 'FY',
    Wo: 'WO',
    Xh: 'XH',
    Yi: 'YI',
    Yo: 'YO',
    Za: 'ZA',
    Zu: 'ZU'
} as const;

export type CatAdditionalDataDtoLanguageEnum = typeof CatAdditionalDataDtoLanguageEnum[keyof typeof CatAdditionalDataDtoLanguageEnum];

/**
 * 
 * @export
 * @interface CatParameterDataDto
 */
export interface CatParameterDataDto {
    /**
     * A string containing maintainer information. Maximum length 128 characters.
     * @type {string}
     * @memberof CatParameterDataDto
     */
    'maintainer': string;
    /**
     * A string describing the intended use for the domain. Maximum length 250 characters.
     * @type {string}
     * @memberof CatParameterDataDto
     */
    'intendedUse': string;
}
/**
 * 
 * @export
 * @interface ChallengeParametersDataDto
 */
export interface ChallengeParametersDataDto {
    /**
     * A collection of challenge questions and their corresponding answers for domain verification.
     * @type {Array<ChallengeQuestionAnswerDto>}
     * @memberof ChallengeParametersDataDto
     */
    'challenges': Array<ChallengeQuestionAnswerDto>;
}
/**
 * 
 * @export
 * @interface ChallengeQuestionAnswerDto
 */
export interface ChallengeQuestionAnswerDto {
    /**
     * The question associated with the domain challenge.
     * @type {string}
     * @memberof ChallengeQuestionAnswerDto
     */
    'question': string;
    /**
     * The answer to the challenge question.
     * @type {string}
     * @memberof ChallengeQuestionAnswerDto
     */
    'answer': string;
}
/**
 * 
 * @export
 * @interface ClaimsTokenDataDto
 */
export interface ClaimsTokenDataDto {
    /**
     * A unique token associated with trademark claims for a domain.
     * @type {string}
     * @memberof ClaimsTokenDataDto
     */
    'claimsToken': string;
}
/**
 * @type ClientCompany
 * A unique identifier for the client company associated with this item, used to link the item to a specific client organization.
 * @export
 */
export type ClientCompany = CompanyResponseDto | string;

/**
 * @type ClientCompany1
 * A unique identifier assigned to the client company associated with this order, ensuring the order is linked to the correct client company.
 * @export
 */
export type ClientCompany1 = CompanyResponseDto | string;

/**
 * @type ClientCompany2
 * The unique identifier of the client company associated with the transaction.
 * @export
 */
export type ClientCompany2 = CompanyResponseDto | string;

/**
 * 
 * @export
 * @interface ClientPanelDto
 */
export interface ClientPanelDto {
    /**
     * 
     * @type {Tabs1}
     * @memberof ClientPanelDto
     */
    'tabs'?: Tabs1;
    /**
     * 
     * @type {MoreActions1}
     * @memberof ClientPanelDto
     */
    'moreActions'?: MoreActions1;
    /**
     * 
     * @type {Menu1}
     * @memberof ClientPanelDto
     */
    'menu'?: Menu1;
}
/**
 * 
 * @export
 * @interface ClientPanelMoreActionsDto
 */
export interface ClientPanelMoreActionsDto {
    /**
     * Additional actions available on the item page in Client panel.
     * @type {Array<ActionDto>}
     * @memberof ClientPanelMoreActionsDto
     */
    'item'?: Array<ActionDto>;
}
/**
 * 
 * @export
 * @interface ClientPanelTabsDto
 */
export interface ClientPanelTabsDto {
    /**
     * Tabs shown on the item page in Client panel.
     * @type {Array<TabDto>}
     * @memberof ClientPanelTabsDto
     */
    'item'?: Array<TabDto>;
}
/**
 * @type Company
 * The company details associated with the assigned roles, including relevant metadata and identification.
 * @export
 */
export type Company = CompanyResponseDto | string;

/**
 * @type Company1
 * Details of the company the user is associated with, including its unique identifier and relevant metadata.
 * @export
 */
export type Company1 = CompanyResponseDto | string;

/**
 * @type Company10
 * Identifier of the company associated with this order.
 * @export
 */
export type Company10 = CompanyResponseDto | string;

/**
 * @type Company11
 * The unique identifier of the company associated with this domain contact.
 * @export
 */
export type Company11 = CompanyResponseDto | string;

/**
 * @type Company12
 * Id of the company that published the invoice
 * @export
 */
export type Company12 = CompanyResponseDto | string;

/**
 * @type Company13
 * The unique identifier of the company associated with the transaction.
 * @export
 */
export type Company13 = CompanyResponseDto | string;

/**
 * @type Company2
 * The company associated with this policy.
 * @export
 */
export type Company2 = CompanyResponseDto | string;

/**
 * @type Company3
 * The unique identifier of the company associated with this contact.
 * @export
 */
export type Company3 = CompanyResponseDto | string;

/**
 * @type Company4
 * Uniquely identifies the company associated with a product or service, ensuring accurate linkage to its organization within the system.
 * @export
 */
export type Company4 = CompanyResponseDto | string;

/**
 * @type Company5
 * The unique identifier of the company.
 * @export
 */
export type Company5 = CompanyResponseDto | string;

/**
 * @type Company6
 * The unique identifier for the company associated with the addon.
 * @export
 */
export type Company6 = CompanyResponseDto | string;

/**
 * @type Company7
 * The unique identifier of the company that is associated with the affiliate. This ID links the affiliate to the specific company in the system.
 * @export
 */
export type Company7 = CompanyResponseDto | string;

/**
 * @type Company8
 * The unique identifier for the company associated with the price policy.
 * @export
 */
export type Company8 = CompanyResponseDto | string;

/**
 * @type Company9
 * A unique identifier for the company linked to the item, used to associate the item with a specific organization.
 * @export
 */
export type Company9 = CompanyResponseDto | string;

/**
 * 
 * @export
 * @interface CompanyBalanceResponseDto
 */
export interface CompanyBalanceResponseDto {
    /**
     * The current balance of the company.
     * @type {number}
     * @memberof CompanyBalanceResponseDto
     */
    'balance': number;
    /**
     * Represents the amount of credit available to the company. This can be used for purchasing services or may reflect a pre-paid amount.
     * @type {number}
     * @memberof CompanyBalanceResponseDto
     */
    'creditBalance': number;
    /**
     * The current balance of the company\'s wallet. This is the total amount of funds available to the company in their wallet.
     * @type {number}
     * @memberof CompanyBalanceResponseDto
     */
    'walletBalance': number;
}
/**
 * 
 * @export
 * @interface CompanyFindResponseDto
 */
export interface CompanyFindResponseDto {
    /**
     * An array that contains objects with company informations.
     * @type {Array<CompanyResponseDto>}
     * @memberof CompanyFindResponseDto
     */
    'results': Array<CompanyResponseDto>;
    /**
     * A number that indicates the current page being shown.
     * @type {number}
     * @memberof CompanyFindResponseDto
     */
    'currentPage': number;
    /**
     * A number that indicates the number of results per page.
     * @type {number}
     * @memberof CompanyFindResponseDto
     */
    'perPage': number;
    /**
     * A number that indicates the total pages will be shown.
     * @type {number}
     * @memberof CompanyFindResponseDto
     */
    'totalPages': number;
}
/**
 * @type CompanyID
 * A unique identifier for the company associated with the coupon. This ID is used to link the coupon to a specific company within the system.
 * @export
 */
export type CompanyID = CompanyResponseDto | string;

/**
 * @type CompanyId
 * Represents the company that owns this product. This field provides detailed information about the associated company.
 * @export
 */
export type CompanyId = CompanyResponseDto | string;

/**
 * 
 * @export
 * @interface CompanyPublicInfoDto
 */
export interface CompanyPublicInfoDto {
    /**
     * The name of the company. This is a required field and represents the official title or identifier of the company.
     * @type {string}
     * @memberof CompanyPublicInfoDto
     */
    'name': string;
    /**
     * The username of the company. This value must be unique and contain only lowercase letters, numbers, and dashes (-). It is also used as the first part of the URL for the company on Hoster, e.g., \'my-company.hoster.ai\'.
     * @type {string}
     * @memberof CompanyPublicInfoDto
     */
    'username': string;
    /**
     * The public email address that users can use to contact the company. This is optional and should be in a valid email format.
     * @type {string}
     * @memberof CompanyPublicInfoDto
     */
    'publicEmail'?: string;
    /**
     * The official website URL of the company.
     * @type {string}
     * @memberof CompanyPublicInfoDto
     */
    'url'?: string;
    /**
     * The official contact phone number for the company. This should be in a valid phone number format.
     * @type {string}
     * @memberof CompanyPublicInfoDto
     */
    'telephone'?: string;
    /**
     * The primary address line, typically including the street name and number.
     * @type {string}
     * @memberof CompanyPublicInfoDto
     */
    'address1'?: string;
    /**
     * The secondary address line, typically used for additional details such as building or floor.
     * @type {string}
     * @memberof CompanyPublicInfoDto
     */
    'address2'?: string;
    /**
     * The tertiary address line, typically used for area, district, or additional comments.
     * @type {string}
     * @memberof CompanyPublicInfoDto
     */
    'address3'?: string;
    /**
     * The postal code associated with the company’s official address.
     * @type {string}
     * @memberof CompanyPublicInfoDto
     */
    'postcode'?: string;
    /**
     * The city where the company is officially registered or operates.
     * @type {string}
     * @memberof CompanyPublicInfoDto
     */
    'city'?: string;
    /**
     * The country where the company is officially registered.
     * @type {string}
     * @memberof CompanyPublicInfoDto
     */
    'country'?: CompanyPublicInfoDtoCountryEnum;
    /**
     * The state, region, or administrative division where the company is located.
     * @type {string}
     * @memberof CompanyPublicInfoDto
     */
    'state'?: string;
    /**
     * The URL pointing to the company’s official logo. This logo is typically used for branding purposes on websites and documents.
     * @type {string}
     * @memberof CompanyPublicInfoDto
     */
    'logoUrl'?: string;
    /**
     * The URL pointing to the company’s official icon. This icon is typically used for small-scale branding, such as favicon or app icons.
     * @type {string}
     * @memberof CompanyPublicInfoDto
     */
    'iconUrl'?: string;
    /**
     * The URL pointing to the company’s privacy policy. This document outlines how the company handles user data and privacy concerns.
     * @type {string}
     * @memberof CompanyPublicInfoDto
     */
    'privacyPolicyUrl'?: string;
    /**
     * A unique identifier for the tenant associated with the company. This ID links the company to its tenant within a multi-tenant architecture or system, ensuring proper segregation and management of data and resources.
     * @type {string}
     * @memberof CompanyPublicInfoDto
     */
    'tenantId'?: string;
    /**
     * An enum that defines the default language used by the company. If no translations are available, this language will be used. Additionally, it serves as the fallback language if the user has not selected a different preference.
     * @type {string}
     * @memberof CompanyPublicInfoDto
     */
    'defaultLanguage': CompanyPublicInfoDtoDefaultLanguageEnum;
    /**
     * An array that specifies all the languages required for translations in multilingual fields. These languages determine the set of translations to be provided for product-related content or other fields that support multiple languages.
     * @type {Array<string>}
     * @memberof CompanyPublicInfoDto
     */
    'languages'?: Array<CompanyPublicInfoDtoLanguagesEnum>;
}

export const CompanyPublicInfoDtoCountryEnum = {
    Af: 'AF',
    Ax: 'AX',
    Al: 'AL',
    Dz: 'DZ',
    As: 'AS',
    Ad: 'AD',
    Ao: 'AO',
    Ai: 'AI',
    Aq: 'AQ',
    Ag: 'AG',
    Ar: 'AR',
    Am: 'AM',
    Aw: 'AW',
    Au: 'AU',
    At: 'AT',
    Az: 'AZ',
    Bs: 'BS',
    Bh: 'BH',
    Bd: 'BD',
    Bb: 'BB',
    By: 'BY',
    Be: 'BE',
    Bz: 'BZ',
    Bj: 'BJ',
    Bm: 'BM',
    Bt: 'BT',
    Bo: 'BO',
    Bq: 'BQ',
    Ba: 'BA',
    Bw: 'BW',
    Bv: 'BV',
    Br: 'BR',
    Io: 'IO',
    Bn: 'BN',
    Bg: 'BG',
    Bf: 'BF',
    Bi: 'BI',
    Kh: 'KH',
    Cm: 'CM',
    Ca: 'CA',
    Cv: 'CV',
    Ky: 'KY',
    Cf: 'CF',
    Td: 'TD',
    Cl: 'CL',
    Cn: 'CN',
    Cx: 'CX',
    Cc: 'CC',
    Co: 'CO',
    Km: 'KM',
    Cg: 'CG',
    Cd: 'CD',
    Ck: 'CK',
    Cr: 'CR',
    Ci: 'CI',
    Hr: 'HR',
    Cu: 'CU',
    Cw: 'CW',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Dj: 'DJ',
    Dm: 'DM',
    Do: 'DO',
    Ec: 'EC',
    Eg: 'EG',
    Sv: 'SV',
    Gq: 'GQ',
    Er: 'ER',
    Ee: 'EE',
    Et: 'ET',
    Fk: 'FK',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Gf: 'GF',
    Pf: 'PF',
    Tf: 'TF',
    Ga: 'GA',
    Gm: 'GM',
    Ge: 'GE',
    De: 'DE',
    Gh: 'GH',
    Gi: 'GI',
    Gr: 'GR',
    Gl: 'GL',
    Gd: 'GD',
    Gp: 'GP',
    Gu: 'GU',
    Gt: 'GT',
    Gg: 'GG',
    Gn: 'GN',
    Gw: 'GW',
    Gy: 'GY',
    Ht: 'HT',
    Hm: 'HM',
    Va: 'VA',
    Hn: 'HN',
    Hk: 'HK',
    Hu: 'HU',
    Is: 'IS',
    In: 'IN',
    Id: 'ID',
    Ir: 'IR',
    Iq: 'IQ',
    Ie: 'IE',
    Im: 'IM',
    Il: 'IL',
    It: 'IT',
    Jm: 'JM',
    Jp: 'JP',
    Je: 'JE',
    Jo: 'JO',
    Kz: 'KZ',
    Ke: 'KE',
    Ki: 'KI',
    Kp: 'KP',
    Kr: 'KR',
    Kw: 'KW',
    Kg: 'KG',
    La: 'LA',
    Lv: 'LV',
    Lb: 'LB',
    Ls: 'LS',
    Lr: 'LR',
    Ly: 'LY',
    Li: 'LI',
    Lt: 'LT',
    Lu: 'LU',
    Mo: 'MO',
    Mk: 'MK',
    Mg: 'MG',
    Mw: 'MW',
    My: 'MY',
    Mv: 'MV',
    Ml: 'ML',
    Mt: 'MT',
    Mh: 'MH',
    Mq: 'MQ',
    Mr: 'MR',
    Mu: 'MU',
    Tn: 'TN',
    Tr: 'TR',
    Tm: 'TM',
    Tc: 'TC',
    Tv: 'TV',
    Ug: 'UG',
    Ua: 'UA',
    Ae: 'AE',
    Gb: 'GB',
    Us: 'US',
    Um: 'UM',
    Uy: 'UY',
    Uz: 'UZ',
    Vu: 'VU',
    Ve: 'VE',
    Vn: 'VN',
    Vg: 'VG',
    Vi: 'VI',
    Wf: 'WF',
    Eh: 'EH',
    Ye: 'YE',
    Zm: 'ZM',
    Zw: 'ZW',
    Yt: 'YT',
    Mx: 'MX',
    Fm: 'FM',
    Md: 'MD',
    Mc: 'MC',
    Mn: 'MN',
    Me: 'ME',
    Ms: 'MS',
    Ma: 'MA',
    Mz: 'MZ',
    Mm: 'MM',
    Na: 'NA',
    Nr: 'NR',
    Np: 'NP',
    Nl: 'NL',
    Nc: 'NC',
    Nz: 'NZ',
    Ni: 'NI',
    Ne: 'NE',
    Ng: 'NG',
    Nu: 'NU',
    Nf: 'NF',
    Mp: 'MP',
    No: 'NO',
    Om: 'OM',
    Pk: 'PK',
    Pw: 'PW',
    Ps: 'PS',
    Pa: 'PA',
    Pg: 'PG',
    Py: 'PY',
    Pe: 'PE',
    Ph: 'PH',
    Pn: 'PN',
    Pl: 'PL',
    Pt: 'PT',
    Pr: 'PR',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Ru: 'RU',
    Rw: 'RW',
    Bl: 'BL',
    Sh: 'SH',
    Kn: 'KN',
    Lc: 'LC',
    Mf: 'MF',
    Pm: 'PM',
    Vc: 'VC',
    Ws: 'WS',
    Sm: 'SM',
    St: 'ST',
    Sa: 'SA',
    Sn: 'SN',
    Rs: 'RS',
    Sc: 'SC',
    Sl: 'SL',
    Sg: 'SG',
    Sx: 'SX',
    Sk: 'SK',
    Si: 'SI',
    Sb: 'SB',
    So: 'SO',
    Za: 'ZA',
    Gs: 'GS',
    Ss: 'SS',
    Es: 'ES',
    Lk: 'LK',
    Sd: 'SD',
    Sr: 'SR',
    Sj: 'SJ',
    Sz: 'SZ',
    Se: 'SE',
    Ch: 'CH',
    Sy: 'SY',
    Tw: 'TW',
    Tj: 'TJ',
    Tz: 'TZ',
    Th: 'TH',
    Tl: 'TL',
    Tg: 'TG',
    Tk: 'TK',
    To: 'TO',
    Tt: 'TT'
} as const;

export type CompanyPublicInfoDtoCountryEnum = typeof CompanyPublicInfoDtoCountryEnum[keyof typeof CompanyPublicInfoDtoCountryEnum];
export const CompanyPublicInfoDtoDefaultLanguageEnum = {
    Ab: 'AB',
    Aa: 'AA',
    Af: 'AF',
    Ak: 'AK',
    Sq: 'SQ',
    Am: 'AM',
    Ar: 'AR',
    An: 'AN',
    Hy: 'HY',
    As: 'AS',
    Av: 'AV',
    Ae: 'AE',
    Ay: 'AY',
    Az: 'AZ',
    Bm: 'BM',
    Ba: 'BA',
    Eu: 'EU',
    Be: 'BE',
    Bn: 'BN',
    Bi: 'BI',
    Bs: 'BS',
    Br: 'BR',
    Bg: 'BG',
    My: 'MY',
    Ca: 'CA',
    Km: 'KM',
    Ch: 'CH',
    Ce: 'CE',
    Ny: 'NY',
    Zh: 'ZH',
    Cu: 'CU',
    Cv: 'CV',
    Kw: 'KW',
    Co: 'CO',
    Cr: 'CR',
    Hr: 'HR',
    Cs: 'CS',
    Da: 'DA',
    Dv: 'DV',
    Nl: 'NL',
    Dz: 'DZ',
    En: 'EN',
    Eo: 'EO',
    Et: 'ET',
    Ee: 'EE',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Ff: 'FF',
    Gl: 'GL',
    Lg: 'LG',
    Ka: 'KA',
    De: 'DE',
    El: 'EL',
    Gn: 'GN',
    Gu: 'GU',
    Ht: 'HT',
    Ha: 'HA',
    He: 'HE',
    Hz: 'HZ',
    Hi: 'HI',
    Ho: 'HO',
    Hu: 'HU',
    Is: 'IS',
    Io: 'IO',
    Ig: 'IG',
    Id: 'ID',
    Ia: 'IA',
    Ie: 'IE',
    Iu: 'IU',
    Ik: 'IK',
    Ga: 'GA',
    It: 'IT',
    Ja: 'JA',
    Jv: 'JV',
    Kl: 'KL',
    Kn: 'KN',
    Kr: 'KR',
    Ks: 'KS',
    Kk: 'KK',
    Ki: 'KI',
    Rw: 'RW',
    Ky: 'KY',
    Kv: 'KV',
    Kg: 'KG',
    Ko: 'KO',
    Kj: 'KJ',
    Ku: 'KU',
    Lo: 'LO',
    La: 'LA',
    Lv: 'LV',
    Li: 'LI',
    Ln: 'LN',
    Lt: 'LT',
    Lu: 'LU',
    Lb: 'LB',
    Mk: 'MK',
    Mg: 'MG',
    Ms: 'MS',
    Ml: 'ML',
    Mt: 'MT',
    Gv: 'GV',
    Mi: 'MI',
    Mr: 'MR',
    Mh: 'MH',
    Mn: 'MN',
    Na: 'NA',
    Nv: 'NV',
    Nd: 'ND',
    Nr: 'NR',
    Ng: 'NG',
    Ne: 'NE',
    Se: 'SE',
    No: 'NO',
    Nb: 'NB',
    Nn: 'NN',
    Ii: 'II',
    Oc: 'OC',
    Oj: 'OJ',
    Or: 'OR',
    Om: 'OM',
    Os: 'OS',
    Pi: 'PI',
    Ps: 'PS',
    Fa: 'FA',
    Pl: 'PL',
    Pt: 'PT',
    Pa: 'PA',
    Qu: 'QU',
    Ro: 'RO',
    Rm: 'RM',
    Rn: 'RN',
    Ru: 'RU',
    Sm: 'SM',
    Sg: 'SG',
    Sa: 'SA',
    Sc: 'SC',
    Gd: 'GD',
    Sr: 'SR',
    Sn: 'SN',
    Ii2: 'II',
    Sd: 'SD',
    Si: 'SI',
    Sk: 'SK',
    Sl: 'SL',
    So: 'SO',
    St: 'ST',
    Es: 'ES',
    Su: 'SU',
    Sw: 'SW',
    Ss: 'SS',
    Sv: 'SV',
    Tl: 'TL',
    Ty: 'TY',
    Tg: 'TG',
    Ta: 'TA',
    Tt: 'TT',
    Te: 'TE',
    Th: 'TH',
    Bo: 'BO',
    Ti: 'TI',
    To: 'TO',
    Ts: 'TS',
    Tn: 'TN',
    Tr: 'TR',
    Tk: 'TK',
    Tw: 'TW',
    Ug: 'UG',
    Uk: 'UK',
    Ur: 'UR',
    Uz: 'UZ',
    Ve: 'VE',
    Vi: 'VI',
    Vo: 'VO',
    Wa: 'WA',
    Cy: 'CY',
    Fy: 'FY',
    Wo: 'WO',
    Xh: 'XH',
    Yi: 'YI',
    Yo: 'YO',
    Za: 'ZA',
    Zu: 'ZU'
} as const;

export type CompanyPublicInfoDtoDefaultLanguageEnum = typeof CompanyPublicInfoDtoDefaultLanguageEnum[keyof typeof CompanyPublicInfoDtoDefaultLanguageEnum];
export const CompanyPublicInfoDtoLanguagesEnum = {
    Ab: 'AB',
    Aa: 'AA',
    Af: 'AF',
    Ak: 'AK',
    Sq: 'SQ',
    Am: 'AM',
    Ar: 'AR',
    An: 'AN',
    Hy: 'HY',
    As: 'AS',
    Av: 'AV',
    Ae: 'AE',
    Ay: 'AY',
    Az: 'AZ',
    Bm: 'BM',
    Ba: 'BA',
    Eu: 'EU',
    Be: 'BE',
    Bn: 'BN',
    Bi: 'BI',
    Bs: 'BS',
    Br: 'BR',
    Bg: 'BG',
    My: 'MY',
    Ca: 'CA',
    Km: 'KM',
    Ch: 'CH',
    Ce: 'CE',
    Ny: 'NY',
    Zh: 'ZH',
    Cu: 'CU',
    Cv: 'CV',
    Kw: 'KW',
    Co: 'CO',
    Cr: 'CR',
    Hr: 'HR',
    Cs: 'CS',
    Da: 'DA',
    Dv: 'DV',
    Nl: 'NL',
    Dz: 'DZ',
    En: 'EN',
    Eo: 'EO',
    Et: 'ET',
    Ee: 'EE',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Ff: 'FF',
    Gl: 'GL',
    Lg: 'LG',
    Ka: 'KA',
    De: 'DE',
    El: 'EL',
    Gn: 'GN',
    Gu: 'GU',
    Ht: 'HT',
    Ha: 'HA',
    He: 'HE',
    Hz: 'HZ',
    Hi: 'HI',
    Ho: 'HO',
    Hu: 'HU',
    Is: 'IS',
    Io: 'IO',
    Ig: 'IG',
    Id: 'ID',
    Ia: 'IA',
    Ie: 'IE',
    Iu: 'IU',
    Ik: 'IK',
    Ga: 'GA',
    It: 'IT',
    Ja: 'JA',
    Jv: 'JV',
    Kl: 'KL',
    Kn: 'KN',
    Kr: 'KR',
    Ks: 'KS',
    Kk: 'KK',
    Ki: 'KI',
    Rw: 'RW',
    Ky: 'KY',
    Kv: 'KV',
    Kg: 'KG',
    Ko: 'KO',
    Kj: 'KJ',
    Ku: 'KU',
    Lo: 'LO',
    La: 'LA',
    Lv: 'LV',
    Li: 'LI',
    Ln: 'LN',
    Lt: 'LT',
    Lu: 'LU',
    Lb: 'LB',
    Mk: 'MK',
    Mg: 'MG',
    Ms: 'MS',
    Ml: 'ML',
    Mt: 'MT',
    Gv: 'GV',
    Mi: 'MI',
    Mr: 'MR',
    Mh: 'MH',
    Mn: 'MN',
    Na: 'NA',
    Nv: 'NV',
    Nd: 'ND',
    Nr: 'NR',
    Ng: 'NG',
    Ne: 'NE',
    Se: 'SE',
    No: 'NO',
    Nb: 'NB',
    Nn: 'NN',
    Ii: 'II',
    Oc: 'OC',
    Oj: 'OJ',
    Or: 'OR',
    Om: 'OM',
    Os: 'OS',
    Pi: 'PI',
    Ps: 'PS',
    Fa: 'FA',
    Pl: 'PL',
    Pt: 'PT',
    Pa: 'PA',
    Qu: 'QU',
    Ro: 'RO',
    Rm: 'RM',
    Rn: 'RN',
    Ru: 'RU',
    Sm: 'SM',
    Sg: 'SG',
    Sa: 'SA',
    Sc: 'SC',
    Gd: 'GD',
    Sr: 'SR',
    Sn: 'SN',
    Ii2: 'II',
    Sd: 'SD',
    Si: 'SI',
    Sk: 'SK',
    Sl: 'SL',
    So: 'SO',
    St: 'ST',
    Es: 'ES',
    Su: 'SU',
    Sw: 'SW',
    Ss: 'SS',
    Sv: 'SV',
    Tl: 'TL',
    Ty: 'TY',
    Tg: 'TG',
    Ta: 'TA',
    Tt: 'TT',
    Te: 'TE',
    Th: 'TH',
    Bo: 'BO',
    Ti: 'TI',
    To: 'TO',
    Ts: 'TS',
    Tn: 'TN',
    Tr: 'TR',
    Tk: 'TK',
    Tw: 'TW',
    Ug: 'UG',
    Uk: 'UK',
    Ur: 'UR',
    Uz: 'UZ',
    Ve: 'VE',
    Vi: 'VI',
    Vo: 'VO',
    Wa: 'WA',
    Cy: 'CY',
    Fy: 'FY',
    Wo: 'WO',
    Xh: 'XH',
    Yi: 'YI',
    Yo: 'YO',
    Za: 'ZA',
    Zu: 'ZU'
} as const;

export type CompanyPublicInfoDtoLanguagesEnum = typeof CompanyPublicInfoDtoLanguagesEnum[keyof typeof CompanyPublicInfoDtoLanguagesEnum];

/**
 * 
 * @export
 * @interface CompanyRequestDto
 */
export interface CompanyRequestDto {
    /**
     * The name of the company. This is a required field and represents the official title or identifier of the company.
     * @type {string}
     * @memberof CompanyRequestDto
     */
    'name': string;
    /**
     * The username of the company. This value must be unique and contain only lowercase letters, numbers, and dashes (-). It is also used as the first part of the URL for the company on Hoster, e.g., \'my-company.hoster.ai\'.
     * @type {string}
     * @memberof CompanyRequestDto
     */
    'username': string;
    /**
     * The public email address that users can use to contact the company. This is optional and should be in a valid email format.
     * @type {string}
     * @memberof CompanyRequestDto
     */
    'publicEmail'?: string;
    /**
     * The official website URL of the company.
     * @type {string}
     * @memberof CompanyRequestDto
     */
    'url'?: string;
    /**
     * A list of email addresses used by the company for various purposes, such as support, inquiries, and general communication. Each email should be in a valid email format. This field is optional.
     * @type {Array<string>}
     * @memberof CompanyRequestDto
     */
    'emails'?: Array<string>;
    /**
     * The URL pointing to the company’s official logo. This logo is typically used for branding purposes on websites and documents.
     * @type {string}
     * @memberof CompanyRequestDto
     */
    'logoUrl'?: string;
    /**
     * The URL pointing to the company’s official icon. This icon is typically used for small-scale branding, such as favicon or app icons.
     * @type {string}
     * @memberof CompanyRequestDto
     */
    'iconUrl'?: string;
    /**
     * The URL pointing to the company’s privacy policy. This document outlines how the company handles user data and privacy concerns.
     * @type {string}
     * @memberof CompanyRequestDto
     */
    'privacyPolicyUrl'?: string;
    /**
     * This object contains the notification integrations the company has chosen to use for sending notification messages. It includes the integration IDs for email, SMS, and push notifications that the company uses to send alerts or messages to users.
     * @type {SelectedNotificationIntegrationsDto}
     * @memberof CompanyRequestDto
     */
    'selectedNotificationIntegrations'?: SelectedNotificationIntegrationsDto;
    /**
     * The unique identifier of the invoice integration the company has chosen to use for sending invoice notifications.
     * @type {string}
     * @memberof CompanyRequestDto
     */
    'selectedInvoiceIntegration'?: string;
    /**
     * Represents the amount of credit available to the company. This can be used for purchasing services or may reflect a pre-paid amount.
     * @type {number}
     * @memberof CompanyRequestDto
     */
    'creditBalance': number;
    /**
     * Indicates whether the company is restricted from making payments. When enabled, the company can manage their account and orders but cannot complete payment transactions.
     * @type {boolean}
     * @memberof CompanyRequestDto
     */
    'locked': boolean;
    /**
     * An internal comment associated with the company, not visible to the company owner. This field is optional.
     * @type {string}
     * @memberof CompanyRequestDto
     */
    'comment'?: string;
    /**
     * An enum that defines the default language used by the company. If no translations are available, this language will be used. Additionally, it serves as the fallback language if the user has not selected a different preference.
     * @type {string}
     * @memberof CompanyRequestDto
     */
    'defaultLanguage'?: CompanyRequestDtoDefaultLanguageEnum;
    /**
     * An array that specifies all the languages required for translations in multilingual fields. These languages determine the set of translations to be provided for product-related content or other fields that support multiple languages.
     * @type {Array<string>}
     * @memberof CompanyRequestDto
     */
    'languages': Array<CompanyRequestDtoLanguagesEnum>;
    /**
     * The unique identifier of the invoice contact associated with billing and invoicing details.
     * @type {string}
     * @memberof CompanyRequestDto
     */
    'invoiceContact'?: string;
    /**
     * A unique identifier for the owner of the company. This field refers to the individual or entity that legally owns or controls the company. It is used to associate the company with its owner in the system.
     * @type {string}
     * @memberof CompanyRequestDto
     */
    'owner'?: string;
    /**
     * An array of roles representing the access permissions a user has within the company. Each role defines the specific rights a user has to interact with various company resources and functionalities.
     * @type {Array<UserRolesRequestDto>}
     * @memberof CompanyRequestDto
     */
    'userRoles': Array<UserRolesRequestDto>;
    /**
     * This array contains unique identifiers for service integrations attached to the company, along with the roles the integration has access to. These roles define the permissions the integration has within the company system, specifying which actions or resources it can access.
     * @type {Array<IntegrationsInfoRequestDto>}
     * @memberof CompanyRequestDto
     */
    'integrations'?: Array<IntegrationsInfoRequestDto>;
    /**
     * A list of the most popular TLDs for the company, ranked by priority.
     * @type {Array<PopularTldRequestDto>}
     * @memberof CompanyRequestDto
     */
    'popularTlds'?: Array<PopularTldRequestDto>;
}

export const CompanyRequestDtoDefaultLanguageEnum = {
    Ab: 'AB',
    Aa: 'AA',
    Af: 'AF',
    Ak: 'AK',
    Sq: 'SQ',
    Am: 'AM',
    Ar: 'AR',
    An: 'AN',
    Hy: 'HY',
    As: 'AS',
    Av: 'AV',
    Ae: 'AE',
    Ay: 'AY',
    Az: 'AZ',
    Bm: 'BM',
    Ba: 'BA',
    Eu: 'EU',
    Be: 'BE',
    Bn: 'BN',
    Bi: 'BI',
    Bs: 'BS',
    Br: 'BR',
    Bg: 'BG',
    My: 'MY',
    Ca: 'CA',
    Km: 'KM',
    Ch: 'CH',
    Ce: 'CE',
    Ny: 'NY',
    Zh: 'ZH',
    Cu: 'CU',
    Cv: 'CV',
    Kw: 'KW',
    Co: 'CO',
    Cr: 'CR',
    Hr: 'HR',
    Cs: 'CS',
    Da: 'DA',
    Dv: 'DV',
    Nl: 'NL',
    Dz: 'DZ',
    En: 'EN',
    Eo: 'EO',
    Et: 'ET',
    Ee: 'EE',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Ff: 'FF',
    Gl: 'GL',
    Lg: 'LG',
    Ka: 'KA',
    De: 'DE',
    El: 'EL',
    Gn: 'GN',
    Gu: 'GU',
    Ht: 'HT',
    Ha: 'HA',
    He: 'HE',
    Hz: 'HZ',
    Hi: 'HI',
    Ho: 'HO',
    Hu: 'HU',
    Is: 'IS',
    Io: 'IO',
    Ig: 'IG',
    Id: 'ID',
    Ia: 'IA',
    Ie: 'IE',
    Iu: 'IU',
    Ik: 'IK',
    Ga: 'GA',
    It: 'IT',
    Ja: 'JA',
    Jv: 'JV',
    Kl: 'KL',
    Kn: 'KN',
    Kr: 'KR',
    Ks: 'KS',
    Kk: 'KK',
    Ki: 'KI',
    Rw: 'RW',
    Ky: 'KY',
    Kv: 'KV',
    Kg: 'KG',
    Ko: 'KO',
    Kj: 'KJ',
    Ku: 'KU',
    Lo: 'LO',
    La: 'LA',
    Lv: 'LV',
    Li: 'LI',
    Ln: 'LN',
    Lt: 'LT',
    Lu: 'LU',
    Lb: 'LB',
    Mk: 'MK',
    Mg: 'MG',
    Ms: 'MS',
    Ml: 'ML',
    Mt: 'MT',
    Gv: 'GV',
    Mi: 'MI',
    Mr: 'MR',
    Mh: 'MH',
    Mn: 'MN',
    Na: 'NA',
    Nv: 'NV',
    Nd: 'ND',
    Nr: 'NR',
    Ng: 'NG',
    Ne: 'NE',
    Se: 'SE',
    No: 'NO',
    Nb: 'NB',
    Nn: 'NN',
    Ii: 'II',
    Oc: 'OC',
    Oj: 'OJ',
    Or: 'OR',
    Om: 'OM',
    Os: 'OS',
    Pi: 'PI',
    Ps: 'PS',
    Fa: 'FA',
    Pl: 'PL',
    Pt: 'PT',
    Pa: 'PA',
    Qu: 'QU',
    Ro: 'RO',
    Rm: 'RM',
    Rn: 'RN',
    Ru: 'RU',
    Sm: 'SM',
    Sg: 'SG',
    Sa: 'SA',
    Sc: 'SC',
    Gd: 'GD',
    Sr: 'SR',
    Sn: 'SN',
    Ii2: 'II',
    Sd: 'SD',
    Si: 'SI',
    Sk: 'SK',
    Sl: 'SL',
    So: 'SO',
    St: 'ST',
    Es: 'ES',
    Su: 'SU',
    Sw: 'SW',
    Ss: 'SS',
    Sv: 'SV',
    Tl: 'TL',
    Ty: 'TY',
    Tg: 'TG',
    Ta: 'TA',
    Tt: 'TT',
    Te: 'TE',
    Th: 'TH',
    Bo: 'BO',
    Ti: 'TI',
    To: 'TO',
    Ts: 'TS',
    Tn: 'TN',
    Tr: 'TR',
    Tk: 'TK',
    Tw: 'TW',
    Ug: 'UG',
    Uk: 'UK',
    Ur: 'UR',
    Uz: 'UZ',
    Ve: 'VE',
    Vi: 'VI',
    Vo: 'VO',
    Wa: 'WA',
    Cy: 'CY',
    Fy: 'FY',
    Wo: 'WO',
    Xh: 'XH',
    Yi: 'YI',
    Yo: 'YO',
    Za: 'ZA',
    Zu: 'ZU'
} as const;

export type CompanyRequestDtoDefaultLanguageEnum = typeof CompanyRequestDtoDefaultLanguageEnum[keyof typeof CompanyRequestDtoDefaultLanguageEnum];
export const CompanyRequestDtoLanguagesEnum = {
    Ab: 'AB',
    Aa: 'AA',
    Af: 'AF',
    Ak: 'AK',
    Sq: 'SQ',
    Am: 'AM',
    Ar: 'AR',
    An: 'AN',
    Hy: 'HY',
    As: 'AS',
    Av: 'AV',
    Ae: 'AE',
    Ay: 'AY',
    Az: 'AZ',
    Bm: 'BM',
    Ba: 'BA',
    Eu: 'EU',
    Be: 'BE',
    Bn: 'BN',
    Bi: 'BI',
    Bs: 'BS',
    Br: 'BR',
    Bg: 'BG',
    My: 'MY',
    Ca: 'CA',
    Km: 'KM',
    Ch: 'CH',
    Ce: 'CE',
    Ny: 'NY',
    Zh: 'ZH',
    Cu: 'CU',
    Cv: 'CV',
    Kw: 'KW',
    Co: 'CO',
    Cr: 'CR',
    Hr: 'HR',
    Cs: 'CS',
    Da: 'DA',
    Dv: 'DV',
    Nl: 'NL',
    Dz: 'DZ',
    En: 'EN',
    Eo: 'EO',
    Et: 'ET',
    Ee: 'EE',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Ff: 'FF',
    Gl: 'GL',
    Lg: 'LG',
    Ka: 'KA',
    De: 'DE',
    El: 'EL',
    Gn: 'GN',
    Gu: 'GU',
    Ht: 'HT',
    Ha: 'HA',
    He: 'HE',
    Hz: 'HZ',
    Hi: 'HI',
    Ho: 'HO',
    Hu: 'HU',
    Is: 'IS',
    Io: 'IO',
    Ig: 'IG',
    Id: 'ID',
    Ia: 'IA',
    Ie: 'IE',
    Iu: 'IU',
    Ik: 'IK',
    Ga: 'GA',
    It: 'IT',
    Ja: 'JA',
    Jv: 'JV',
    Kl: 'KL',
    Kn: 'KN',
    Kr: 'KR',
    Ks: 'KS',
    Kk: 'KK',
    Ki: 'KI',
    Rw: 'RW',
    Ky: 'KY',
    Kv: 'KV',
    Kg: 'KG',
    Ko: 'KO',
    Kj: 'KJ',
    Ku: 'KU',
    Lo: 'LO',
    La: 'LA',
    Lv: 'LV',
    Li: 'LI',
    Ln: 'LN',
    Lt: 'LT',
    Lu: 'LU',
    Lb: 'LB',
    Mk: 'MK',
    Mg: 'MG',
    Ms: 'MS',
    Ml: 'ML',
    Mt: 'MT',
    Gv: 'GV',
    Mi: 'MI',
    Mr: 'MR',
    Mh: 'MH',
    Mn: 'MN',
    Na: 'NA',
    Nv: 'NV',
    Nd: 'ND',
    Nr: 'NR',
    Ng: 'NG',
    Ne: 'NE',
    Se: 'SE',
    No: 'NO',
    Nb: 'NB',
    Nn: 'NN',
    Ii: 'II',
    Oc: 'OC',
    Oj: 'OJ',
    Or: 'OR',
    Om: 'OM',
    Os: 'OS',
    Pi: 'PI',
    Ps: 'PS',
    Fa: 'FA',
    Pl: 'PL',
    Pt: 'PT',
    Pa: 'PA',
    Qu: 'QU',
    Ro: 'RO',
    Rm: 'RM',
    Rn: 'RN',
    Ru: 'RU',
    Sm: 'SM',
    Sg: 'SG',
    Sa: 'SA',
    Sc: 'SC',
    Gd: 'GD',
    Sr: 'SR',
    Sn: 'SN',
    Ii2: 'II',
    Sd: 'SD',
    Si: 'SI',
    Sk: 'SK',
    Sl: 'SL',
    So: 'SO',
    St: 'ST',
    Es: 'ES',
    Su: 'SU',
    Sw: 'SW',
    Ss: 'SS',
    Sv: 'SV',
    Tl: 'TL',
    Ty: 'TY',
    Tg: 'TG',
    Ta: 'TA',
    Tt: 'TT',
    Te: 'TE',
    Th: 'TH',
    Bo: 'BO',
    Ti: 'TI',
    To: 'TO',
    Ts: 'TS',
    Tn: 'TN',
    Tr: 'TR',
    Tk: 'TK',
    Tw: 'TW',
    Ug: 'UG',
    Uk: 'UK',
    Ur: 'UR',
    Uz: 'UZ',
    Ve: 'VE',
    Vi: 'VI',
    Vo: 'VO',
    Wa: 'WA',
    Cy: 'CY',
    Fy: 'FY',
    Wo: 'WO',
    Xh: 'XH',
    Yi: 'YI',
    Yo: 'YO',
    Za: 'ZA',
    Zu: 'ZU'
} as const;

export type CompanyRequestDtoLanguagesEnum = typeof CompanyRequestDtoLanguagesEnum[keyof typeof CompanyRequestDtoLanguagesEnum];

/**
 * 
 * @export
 * @interface CompanyResponseDto
 */
export interface CompanyResponseDto {
    /**
     * The name of the company. This is a required field and represents the official title or identifier of the company.
     * @type {string}
     * @memberof CompanyResponseDto
     */
    'name': string;
    /**
     * The username of the company. This value must be unique and contain only lowercase letters, numbers, and dashes (-). It is also used as the first part of the URL for the company on Hoster, e.g., \'my-company.hoster.ai\'.
     * @type {string}
     * @memberof CompanyResponseDto
     */
    'username': string;
    /**
     * The public email address that users can use to contact the company. This is optional and should be in a valid email format.
     * @type {string}
     * @memberof CompanyResponseDto
     */
    'publicEmail'?: string;
    /**
     * The official website URL of the company.
     * @type {string}
     * @memberof CompanyResponseDto
     */
    'url'?: string;
    /**
     * A list of email addresses used by the company for various purposes, such as support, inquiries, and general communication. Each email should be in a valid email format. This field is optional.
     * @type {Array<string>}
     * @memberof CompanyResponseDto
     */
    'emails'?: Array<string>;
    /**
     * The URL pointing to the company’s official logo. This logo is typically used for branding purposes on websites and documents.
     * @type {string}
     * @memberof CompanyResponseDto
     */
    'logoUrl'?: string;
    /**
     * The URL pointing to the company’s official icon. This icon is typically used for small-scale branding, such as favicon or app icons.
     * @type {string}
     * @memberof CompanyResponseDto
     */
    'iconUrl'?: string;
    /**
     * The URL pointing to the company’s privacy policy. This document outlines how the company handles user data and privacy concerns.
     * @type {string}
     * @memberof CompanyResponseDto
     */
    'privacyPolicyUrl'?: string;
    /**
     * This object contains the notification integrations the company has chosen to use for sending notification messages. It includes the integration IDs for email, SMS, and push notifications that the company uses to send alerts or messages to users.
     * @type {SelectedNotificationIntegrationsDto}
     * @memberof CompanyResponseDto
     */
    'selectedNotificationIntegrations'?: SelectedNotificationIntegrationsDto;
    /**
     * The unique identifier of the invoice integration the company has chosen to use for sending invoice notifications.
     * @type {string}
     * @memberof CompanyResponseDto
     */
    'selectedInvoiceIntegration'?: string;
    /**
     * Represents the amount of credit available to the company. This can be used for purchasing services or may reflect a pre-paid amount.
     * @type {number}
     * @memberof CompanyResponseDto
     */
    'creditBalance': number;
    /**
     * Indicates whether the company is restricted from making payments. When enabled, the company can manage their account and orders but cannot complete payment transactions.
     * @type {boolean}
     * @memberof CompanyResponseDto
     */
    'locked': boolean;
    /**
     * An internal comment associated with the company, not visible to the company owner. This field is optional.
     * @type {string}
     * @memberof CompanyResponseDto
     */
    'comment'?: string;
    /**
     * An enum that defines the default language used by the company. If no translations are available, this language will be used. Additionally, it serves as the fallback language if the user has not selected a different preference.
     * @type {string}
     * @memberof CompanyResponseDto
     */
    'defaultLanguage'?: CompanyResponseDtoDefaultLanguageEnum;
    /**
     * An array that specifies all the languages required for translations in multilingual fields. These languages determine the set of translations to be provided for product-related content or other fields that support multiple languages.
     * @type {Array<string>}
     * @memberof CompanyResponseDto
     */
    'languages': Array<CompanyResponseDtoLanguagesEnum>;
    /**
     * A unique identifier for the company.
     * @type {string}
     * @memberof CompanyResponseDto
     */
    'id': string;
    /**
     * 
     * @type {InvoiceContact}
     * @memberof CompanyResponseDto
     */
    'invoiceContact'?: InvoiceContact;
    /**
     * 
     * @type {Owner}
     * @memberof CompanyResponseDto
     */
    'owner': Owner;
    /**
     * An array of roles representing the access permissions a user has within the company. Each role defines the specific rights a user has to interact with various company resources and functionalities.
     * @type {Array<UserRolesResponseDto>}
     * @memberof CompanyResponseDto
     */
    'userRoles': Array<UserRolesResponseDto>;
    /**
     * This array contains unique identifiers for service integrations attached to the company, along with the roles the integration has access to. These roles define the permissions the integration has within the company system, specifying which actions or resources it can access.
     * @type {Array<IntegrationsInfoResponseDto>}
     * @memberof CompanyResponseDto
     */
    'integrations'?: Array<IntegrationsInfoResponseDto>;
    /**
     * The current balance of the company.
     * @type {number}
     * @memberof CompanyResponseDto
     */
    'balance': number;
    /**
     * The current balance of the company\'s wallet. This is the total amount of funds available to the company in their wallet.
     * @type {number}
     * @memberof CompanyResponseDto
     */
    'walletBalance'?: number;
    /**
     * A unique identifier for the tenant associated with the company. This ID links the company to its tenant within a multi-tenant architecture or system, ensuring proper segregation and management of data and resources.
     * @type {string}
     * @memberof CompanyResponseDto
     */
    'tenantId'?: string;
    /**
     * A list of the most popular TLDs for the company, ranked by priority.
     * @type {Array<PopularTldResponseDto>}
     * @memberof CompanyResponseDto
     */
    'popularTlds'?: Array<PopularTldResponseDto>;
    /**
     * The date a product created.
     * @type {string}
     * @memberof CompanyResponseDto
     */
    'createdAt'?: string;
    /**
     * The date a product updated.
     * @type {string}
     * @memberof CompanyResponseDto
     */
    'updatedAt'?: string;
}

export const CompanyResponseDtoDefaultLanguageEnum = {
    Ab: 'AB',
    Aa: 'AA',
    Af: 'AF',
    Ak: 'AK',
    Sq: 'SQ',
    Am: 'AM',
    Ar: 'AR',
    An: 'AN',
    Hy: 'HY',
    As: 'AS',
    Av: 'AV',
    Ae: 'AE',
    Ay: 'AY',
    Az: 'AZ',
    Bm: 'BM',
    Ba: 'BA',
    Eu: 'EU',
    Be: 'BE',
    Bn: 'BN',
    Bi: 'BI',
    Bs: 'BS',
    Br: 'BR',
    Bg: 'BG',
    My: 'MY',
    Ca: 'CA',
    Km: 'KM',
    Ch: 'CH',
    Ce: 'CE',
    Ny: 'NY',
    Zh: 'ZH',
    Cu: 'CU',
    Cv: 'CV',
    Kw: 'KW',
    Co: 'CO',
    Cr: 'CR',
    Hr: 'HR',
    Cs: 'CS',
    Da: 'DA',
    Dv: 'DV',
    Nl: 'NL',
    Dz: 'DZ',
    En: 'EN',
    Eo: 'EO',
    Et: 'ET',
    Ee: 'EE',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Ff: 'FF',
    Gl: 'GL',
    Lg: 'LG',
    Ka: 'KA',
    De: 'DE',
    El: 'EL',
    Gn: 'GN',
    Gu: 'GU',
    Ht: 'HT',
    Ha: 'HA',
    He: 'HE',
    Hz: 'HZ',
    Hi: 'HI',
    Ho: 'HO',
    Hu: 'HU',
    Is: 'IS',
    Io: 'IO',
    Ig: 'IG',
    Id: 'ID',
    Ia: 'IA',
    Ie: 'IE',
    Iu: 'IU',
    Ik: 'IK',
    Ga: 'GA',
    It: 'IT',
    Ja: 'JA',
    Jv: 'JV',
    Kl: 'KL',
    Kn: 'KN',
    Kr: 'KR',
    Ks: 'KS',
    Kk: 'KK',
    Ki: 'KI',
    Rw: 'RW',
    Ky: 'KY',
    Kv: 'KV',
    Kg: 'KG',
    Ko: 'KO',
    Kj: 'KJ',
    Ku: 'KU',
    Lo: 'LO',
    La: 'LA',
    Lv: 'LV',
    Li: 'LI',
    Ln: 'LN',
    Lt: 'LT',
    Lu: 'LU',
    Lb: 'LB',
    Mk: 'MK',
    Mg: 'MG',
    Ms: 'MS',
    Ml: 'ML',
    Mt: 'MT',
    Gv: 'GV',
    Mi: 'MI',
    Mr: 'MR',
    Mh: 'MH',
    Mn: 'MN',
    Na: 'NA',
    Nv: 'NV',
    Nd: 'ND',
    Nr: 'NR',
    Ng: 'NG',
    Ne: 'NE',
    Se: 'SE',
    No: 'NO',
    Nb: 'NB',
    Nn: 'NN',
    Ii: 'II',
    Oc: 'OC',
    Oj: 'OJ',
    Or: 'OR',
    Om: 'OM',
    Os: 'OS',
    Pi: 'PI',
    Ps: 'PS',
    Fa: 'FA',
    Pl: 'PL',
    Pt: 'PT',
    Pa: 'PA',
    Qu: 'QU',
    Ro: 'RO',
    Rm: 'RM',
    Rn: 'RN',
    Ru: 'RU',
    Sm: 'SM',
    Sg: 'SG',
    Sa: 'SA',
    Sc: 'SC',
    Gd: 'GD',
    Sr: 'SR',
    Sn: 'SN',
    Ii2: 'II',
    Sd: 'SD',
    Si: 'SI',
    Sk: 'SK',
    Sl: 'SL',
    So: 'SO',
    St: 'ST',
    Es: 'ES',
    Su: 'SU',
    Sw: 'SW',
    Ss: 'SS',
    Sv: 'SV',
    Tl: 'TL',
    Ty: 'TY',
    Tg: 'TG',
    Ta: 'TA',
    Tt: 'TT',
    Te: 'TE',
    Th: 'TH',
    Bo: 'BO',
    Ti: 'TI',
    To: 'TO',
    Ts: 'TS',
    Tn: 'TN',
    Tr: 'TR',
    Tk: 'TK',
    Tw: 'TW',
    Ug: 'UG',
    Uk: 'UK',
    Ur: 'UR',
    Uz: 'UZ',
    Ve: 'VE',
    Vi: 'VI',
    Vo: 'VO',
    Wa: 'WA',
    Cy: 'CY',
    Fy: 'FY',
    Wo: 'WO',
    Xh: 'XH',
    Yi: 'YI',
    Yo: 'YO',
    Za: 'ZA',
    Zu: 'ZU'
} as const;

export type CompanyResponseDtoDefaultLanguageEnum = typeof CompanyResponseDtoDefaultLanguageEnum[keyof typeof CompanyResponseDtoDefaultLanguageEnum];
export const CompanyResponseDtoLanguagesEnum = {
    Ab: 'AB',
    Aa: 'AA',
    Af: 'AF',
    Ak: 'AK',
    Sq: 'SQ',
    Am: 'AM',
    Ar: 'AR',
    An: 'AN',
    Hy: 'HY',
    As: 'AS',
    Av: 'AV',
    Ae: 'AE',
    Ay: 'AY',
    Az: 'AZ',
    Bm: 'BM',
    Ba: 'BA',
    Eu: 'EU',
    Be: 'BE',
    Bn: 'BN',
    Bi: 'BI',
    Bs: 'BS',
    Br: 'BR',
    Bg: 'BG',
    My: 'MY',
    Ca: 'CA',
    Km: 'KM',
    Ch: 'CH',
    Ce: 'CE',
    Ny: 'NY',
    Zh: 'ZH',
    Cu: 'CU',
    Cv: 'CV',
    Kw: 'KW',
    Co: 'CO',
    Cr: 'CR',
    Hr: 'HR',
    Cs: 'CS',
    Da: 'DA',
    Dv: 'DV',
    Nl: 'NL',
    Dz: 'DZ',
    En: 'EN',
    Eo: 'EO',
    Et: 'ET',
    Ee: 'EE',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Ff: 'FF',
    Gl: 'GL',
    Lg: 'LG',
    Ka: 'KA',
    De: 'DE',
    El: 'EL',
    Gn: 'GN',
    Gu: 'GU',
    Ht: 'HT',
    Ha: 'HA',
    He: 'HE',
    Hz: 'HZ',
    Hi: 'HI',
    Ho: 'HO',
    Hu: 'HU',
    Is: 'IS',
    Io: 'IO',
    Ig: 'IG',
    Id: 'ID',
    Ia: 'IA',
    Ie: 'IE',
    Iu: 'IU',
    Ik: 'IK',
    Ga: 'GA',
    It: 'IT',
    Ja: 'JA',
    Jv: 'JV',
    Kl: 'KL',
    Kn: 'KN',
    Kr: 'KR',
    Ks: 'KS',
    Kk: 'KK',
    Ki: 'KI',
    Rw: 'RW',
    Ky: 'KY',
    Kv: 'KV',
    Kg: 'KG',
    Ko: 'KO',
    Kj: 'KJ',
    Ku: 'KU',
    Lo: 'LO',
    La: 'LA',
    Lv: 'LV',
    Li: 'LI',
    Ln: 'LN',
    Lt: 'LT',
    Lu: 'LU',
    Lb: 'LB',
    Mk: 'MK',
    Mg: 'MG',
    Ms: 'MS',
    Ml: 'ML',
    Mt: 'MT',
    Gv: 'GV',
    Mi: 'MI',
    Mr: 'MR',
    Mh: 'MH',
    Mn: 'MN',
    Na: 'NA',
    Nv: 'NV',
    Nd: 'ND',
    Nr: 'NR',
    Ng: 'NG',
    Ne: 'NE',
    Se: 'SE',
    No: 'NO',
    Nb: 'NB',
    Nn: 'NN',
    Ii: 'II',
    Oc: 'OC',
    Oj: 'OJ',
    Or: 'OR',
    Om: 'OM',
    Os: 'OS',
    Pi: 'PI',
    Ps: 'PS',
    Fa: 'FA',
    Pl: 'PL',
    Pt: 'PT',
    Pa: 'PA',
    Qu: 'QU',
    Ro: 'RO',
    Rm: 'RM',
    Rn: 'RN',
    Ru: 'RU',
    Sm: 'SM',
    Sg: 'SG',
    Sa: 'SA',
    Sc: 'SC',
    Gd: 'GD',
    Sr: 'SR',
    Sn: 'SN',
    Ii2: 'II',
    Sd: 'SD',
    Si: 'SI',
    Sk: 'SK',
    Sl: 'SL',
    So: 'SO',
    St: 'ST',
    Es: 'ES',
    Su: 'SU',
    Sw: 'SW',
    Ss: 'SS',
    Sv: 'SV',
    Tl: 'TL',
    Ty: 'TY',
    Tg: 'TG',
    Ta: 'TA',
    Tt: 'TT',
    Te: 'TE',
    Th: 'TH',
    Bo: 'BO',
    Ti: 'TI',
    To: 'TO',
    Ts: 'TS',
    Tn: 'TN',
    Tr: 'TR',
    Tk: 'TK',
    Tw: 'TW',
    Ug: 'UG',
    Uk: 'UK',
    Ur: 'UR',
    Uz: 'UZ',
    Ve: 'VE',
    Vi: 'VI',
    Vo: 'VO',
    Wa: 'WA',
    Cy: 'CY',
    Fy: 'FY',
    Wo: 'WO',
    Xh: 'XH',
    Yi: 'YI',
    Yo: 'YO',
    Za: 'ZA',
    Zu: 'ZU'
} as const;

export type CompanyResponseDtoLanguagesEnum = typeof CompanyResponseDtoLanguagesEnum[keyof typeof CompanyResponseDtoLanguagesEnum];

/**
 * 
 * @export
 * @interface CompanyRolesResponseDto
 */
export interface CompanyRolesResponseDto {
    /**
     * A list of roles granted to the user, defining its permissions and access levels.
     * @type {Array<string>}
     * @memberof CompanyRolesResponseDto
     */
    'roles': Array<CompanyRolesResponseDtoRolesEnum>;
    /**
     * 
     * @type {Company}
     * @memberof CompanyRolesResponseDto
     */
    'company': Company;
}

export const CompanyRolesResponseDtoRolesEnum = {
    SimpleUser: 'SIMPLE_USER',
    FullAccess: 'FULL_ACCESS',
    SuperAdmin: 'SUPER_ADMIN',
    OrderRead: 'ORDER_READ',
    OrderWrite: 'ORDER_WRITE',
    AddonRead: 'ADDON_READ',
    AddonWrite: 'ADDON_WRITE',
    AffiliateRead: 'AFFILIATE_READ',
    AffiliateWrite: 'AFFILIATE_WRITE',
    CompanyRead: 'COMPANY_READ',
    CompanyWrite: 'COMPANY_WRITE',
    TemplateRead: 'TEMPLATE_READ',
    TemplateWrite: 'TEMPLATE_WRITE',
    CouponRead: 'COUPON_READ',
    CouponWrite: 'COUPON_WRITE',
    DomainCategoryRead: 'DOMAIN_CATEGORY_READ',
    DomainCategoryWrite: 'DOMAIN_CATEGORY_WRITE',
    DomainContactRead: 'DOMAIN_CONTACT_READ',
    DomainContactWrite: 'DOMAIN_CONTACT_WRITE',
    DomainNameRead: 'DOMAIN_NAME_READ',
    DomainNameWrite: 'DOMAIN_NAME_WRITE',
    InvoiceContactRead: 'INVOICE_CONTACT_READ',
    InvoiceContactWrite: 'INVOICE_CONTACT_WRITE',
    InvoiceRead: 'INVOICE_READ',
    InvoiceWrite: 'INVOICE_WRITE',
    IpGroupsRead: 'IP_GROUPS_READ',
    IpGroupsWrite: 'IP_GROUPS_WRITE',
    IpsRead: 'IPS_READ',
    IpsWrite: 'IPS_WRITE',
    ItemsRead: 'ITEMS_READ',
    ItemsWrite: 'ITEMS_WRITE',
    OrdersRead: 'ORDERS_READ',
    OrdersWrite: 'ORDERS_WRITE',
    TransactionsRead: 'TRANSACTIONS_READ',
    TransactionsWrite: 'TRANSACTIONS_WRITE',
    PoliciesRead: 'POLICIES_READ',
    PoliciesWrite: 'POLICIES_WRITE',
    ProductCategoriesRead: 'PRODUCT_CATEGORIES_READ',
    ProductCategoriesWrite: 'PRODUCT_CATEGORIES_WRITE',
    ProductsRead: 'PRODUCTS_READ',
    ProductsWrite: 'PRODUCTS_WRITE',
    SettingsRead: 'SETTINGS_READ',
    SettingsWrite: 'SETTINGS_WRITE',
    IntegrationsRead: 'INTEGRATIONS_READ',
    IntegrationsWrite: 'INTEGRATIONS_WRITE',
    TldsRead: 'TLDS_READ',
    TldsWrite: 'TLDS_WRITE',
    UsersRead: 'USERS_READ',
    UsersWrite: 'USERS_WRITE',
    IssuesWrite: 'ISSUES_WRITE',
    IssuesRead: 'ISSUES_READ',
    ActionLogsRead: 'ACTION_LOGS_READ'
} as const;

export type CompanyRolesResponseDtoRolesEnum = typeof CompanyRolesResponseDtoRolesEnum[keyof typeof CompanyRolesResponseDtoRolesEnum];

/**
 * 
 * @export
 * @interface CompanyUpdateRequestDto
 */
export interface CompanyUpdateRequestDto {
    /**
     * The name of the company. This is a required field and represents the official title or identifier of the company.
     * @type {string}
     * @memberof CompanyUpdateRequestDto
     */
    'name': string;
    /**
     * The public email address that users can use to contact the company. This is optional and should be in a valid email format.
     * @type {string}
     * @memberof CompanyUpdateRequestDto
     */
    'publicEmail': string;
    /**
     * A list of email addresses used by the company for various purposes, such as support, inquiries, and general communication. Each email should be in a valid email format. This field is optional.
     * @type {Array<string>}
     * @memberof CompanyUpdateRequestDto
     */
    'emails': Array<string>;
    /**
     * An array that specifies all the languages required for translations in multilingual fields. These languages determine the set of translations to be provided for product-related content or other fields that support multiple languages.
     * @type {Array<string>}
     * @memberof CompanyUpdateRequestDto
     */
    'languages': Array<CompanyUpdateRequestDtoLanguagesEnum>;
    /**
     * A list of the most popular TLDs for the company, ranked by priority.
     * @type {Array<PopularTldRequestDto>}
     * @memberof CompanyUpdateRequestDto
     */
    'popularTlds': Array<PopularTldRequestDto>;
    /**
     * This object contains the notification integrations the company has chosen to use for sending notification messages. It includes the integration IDs for email, SMS, and push notifications that the company uses to send alerts or messages to users.
     * @type {SelectedNotificationIntegrationsDto}
     * @memberof CompanyUpdateRequestDto
     */
    'selectedNotificationIntegrations': SelectedNotificationIntegrationsDto;
    /**
     * The unique identifier of the invoice integration the company has chosen to use for sending invoice notifications.
     * @type {string}
     * @memberof CompanyUpdateRequestDto
     */
    'selectedInvoiceIntegration': string;
}

export const CompanyUpdateRequestDtoLanguagesEnum = {
    Ab: 'AB',
    Aa: 'AA',
    Af: 'AF',
    Ak: 'AK',
    Sq: 'SQ',
    Am: 'AM',
    Ar: 'AR',
    An: 'AN',
    Hy: 'HY',
    As: 'AS',
    Av: 'AV',
    Ae: 'AE',
    Ay: 'AY',
    Az: 'AZ',
    Bm: 'BM',
    Ba: 'BA',
    Eu: 'EU',
    Be: 'BE',
    Bn: 'BN',
    Bi: 'BI',
    Bs: 'BS',
    Br: 'BR',
    Bg: 'BG',
    My: 'MY',
    Ca: 'CA',
    Km: 'KM',
    Ch: 'CH',
    Ce: 'CE',
    Ny: 'NY',
    Zh: 'ZH',
    Cu: 'CU',
    Cv: 'CV',
    Kw: 'KW',
    Co: 'CO',
    Cr: 'CR',
    Hr: 'HR',
    Cs: 'CS',
    Da: 'DA',
    Dv: 'DV',
    Nl: 'NL',
    Dz: 'DZ',
    En: 'EN',
    Eo: 'EO',
    Et: 'ET',
    Ee: 'EE',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Ff: 'FF',
    Gl: 'GL',
    Lg: 'LG',
    Ka: 'KA',
    De: 'DE',
    El: 'EL',
    Gn: 'GN',
    Gu: 'GU',
    Ht: 'HT',
    Ha: 'HA',
    He: 'HE',
    Hz: 'HZ',
    Hi: 'HI',
    Ho: 'HO',
    Hu: 'HU',
    Is: 'IS',
    Io: 'IO',
    Ig: 'IG',
    Id: 'ID',
    Ia: 'IA',
    Ie: 'IE',
    Iu: 'IU',
    Ik: 'IK',
    Ga: 'GA',
    It: 'IT',
    Ja: 'JA',
    Jv: 'JV',
    Kl: 'KL',
    Kn: 'KN',
    Kr: 'KR',
    Ks: 'KS',
    Kk: 'KK',
    Ki: 'KI',
    Rw: 'RW',
    Ky: 'KY',
    Kv: 'KV',
    Kg: 'KG',
    Ko: 'KO',
    Kj: 'KJ',
    Ku: 'KU',
    Lo: 'LO',
    La: 'LA',
    Lv: 'LV',
    Li: 'LI',
    Ln: 'LN',
    Lt: 'LT',
    Lu: 'LU',
    Lb: 'LB',
    Mk: 'MK',
    Mg: 'MG',
    Ms: 'MS',
    Ml: 'ML',
    Mt: 'MT',
    Gv: 'GV',
    Mi: 'MI',
    Mr: 'MR',
    Mh: 'MH',
    Mn: 'MN',
    Na: 'NA',
    Nv: 'NV',
    Nd: 'ND',
    Nr: 'NR',
    Ng: 'NG',
    Ne: 'NE',
    Se: 'SE',
    No: 'NO',
    Nb: 'NB',
    Nn: 'NN',
    Ii: 'II',
    Oc: 'OC',
    Oj: 'OJ',
    Or: 'OR',
    Om: 'OM',
    Os: 'OS',
    Pi: 'PI',
    Ps: 'PS',
    Fa: 'FA',
    Pl: 'PL',
    Pt: 'PT',
    Pa: 'PA',
    Qu: 'QU',
    Ro: 'RO',
    Rm: 'RM',
    Rn: 'RN',
    Ru: 'RU',
    Sm: 'SM',
    Sg: 'SG',
    Sa: 'SA',
    Sc: 'SC',
    Gd: 'GD',
    Sr: 'SR',
    Sn: 'SN',
    Ii2: 'II',
    Sd: 'SD',
    Si: 'SI',
    Sk: 'SK',
    Sl: 'SL',
    So: 'SO',
    St: 'ST',
    Es: 'ES',
    Su: 'SU',
    Sw: 'SW',
    Ss: 'SS',
    Sv: 'SV',
    Tl: 'TL',
    Ty: 'TY',
    Tg: 'TG',
    Ta: 'TA',
    Tt: 'TT',
    Te: 'TE',
    Th: 'TH',
    Bo: 'BO',
    Ti: 'TI',
    To: 'TO',
    Ts: 'TS',
    Tn: 'TN',
    Tr: 'TR',
    Tk: 'TK',
    Tw: 'TW',
    Ug: 'UG',
    Uk: 'UK',
    Ur: 'UR',
    Uz: 'UZ',
    Ve: 'VE',
    Vi: 'VI',
    Vo: 'VO',
    Wa: 'WA',
    Cy: 'CY',
    Fy: 'FY',
    Wo: 'WO',
    Xh: 'XH',
    Yi: 'YI',
    Yo: 'YO',
    Za: 'ZA',
    Zu: 'ZU'
} as const;

export type CompanyUpdateRequestDtoLanguagesEnum = typeof CompanyUpdateRequestDtoLanguagesEnum[keyof typeof CompanyUpdateRequestDtoLanguagesEnum];

/**
 * 
 * @export
 * @interface CompanyUpdateUserRolesRequest
 */
export interface CompanyUpdateUserRolesRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof CompanyUpdateUserRolesRequest
     */
    'roles'?: Array<CompanyUpdateUserRolesRequestRolesEnum>;
}

export const CompanyUpdateUserRolesRequestRolesEnum = {
    SimpleUser: 'SIMPLE_USER',
    FullAccess: 'FULL_ACCESS',
    SuperAdmin: 'SUPER_ADMIN',
    OrderRead: 'ORDER_READ',
    OrderWrite: 'ORDER_WRITE',
    AddonRead: 'ADDON_READ',
    AddonWrite: 'ADDON_WRITE',
    AffiliateRead: 'AFFILIATE_READ',
    AffiliateWrite: 'AFFILIATE_WRITE',
    CompanyRead: 'COMPANY_READ',
    CompanyWrite: 'COMPANY_WRITE',
    TemplateRead: 'TEMPLATE_READ',
    TemplateWrite: 'TEMPLATE_WRITE',
    CouponRead: 'COUPON_READ',
    CouponWrite: 'COUPON_WRITE',
    DomainCategoryRead: 'DOMAIN_CATEGORY_READ',
    DomainCategoryWrite: 'DOMAIN_CATEGORY_WRITE',
    DomainContactRead: 'DOMAIN_CONTACT_READ',
    DomainContactWrite: 'DOMAIN_CONTACT_WRITE',
    DomainNameRead: 'DOMAIN_NAME_READ',
    DomainNameWrite: 'DOMAIN_NAME_WRITE',
    InvoiceContactRead: 'INVOICE_CONTACT_READ',
    InvoiceContactWrite: 'INVOICE_CONTACT_WRITE',
    InvoiceRead: 'INVOICE_READ',
    InvoiceWrite: 'INVOICE_WRITE',
    IpGroupsRead: 'IP_GROUPS_READ',
    IpGroupsWrite: 'IP_GROUPS_WRITE',
    IpsRead: 'IPS_READ',
    IpsWrite: 'IPS_WRITE',
    ItemsRead: 'ITEMS_READ',
    ItemsWrite: 'ITEMS_WRITE',
    OrdersRead: 'ORDERS_READ',
    OrdersWrite: 'ORDERS_WRITE',
    TransactionsRead: 'TRANSACTIONS_READ',
    TransactionsWrite: 'TRANSACTIONS_WRITE',
    PoliciesRead: 'POLICIES_READ',
    PoliciesWrite: 'POLICIES_WRITE',
    ProductCategoriesRead: 'PRODUCT_CATEGORIES_READ',
    ProductCategoriesWrite: 'PRODUCT_CATEGORIES_WRITE',
    ProductsRead: 'PRODUCTS_READ',
    ProductsWrite: 'PRODUCTS_WRITE',
    SettingsRead: 'SETTINGS_READ',
    SettingsWrite: 'SETTINGS_WRITE',
    IntegrationsRead: 'INTEGRATIONS_READ',
    IntegrationsWrite: 'INTEGRATIONS_WRITE',
    TldsRead: 'TLDS_READ',
    TldsWrite: 'TLDS_WRITE',
    UsersRead: 'USERS_READ',
    UsersWrite: 'USERS_WRITE',
    IssuesWrite: 'ISSUES_WRITE',
    IssuesRead: 'ISSUES_READ',
    ActionLogsRead: 'ACTION_LOGS_READ'
} as const;

export type CompanyUpdateUserRolesRequestRolesEnum = typeof CompanyUpdateUserRolesRequestRolesEnum[keyof typeof CompanyUpdateUserRolesRequestRolesEnum];

/**
 * 
 * @export
 * @interface ContactAdditionalDto
 */
export interface ContactAdditionalDto {
    /**
     * Additional data for Afnic contact.
     * @type {AfnicAdditionalDataDto}
     * @memberof ContactAdditionalDto
     */
    'afnicAdditionalData': AfnicAdditionalDataDto;
    /**
     * Additional data for DE contact.
     * @type {DeAdditionalDataDto}
     * @memberof ContactAdditionalDto
     */
    'deAdditionalData': DeAdditionalDataDto;
    /**
     * Additional data for Cat contact.
     * @type {CatAdditionalDataDto}
     * @memberof ContactAdditionalDto
     */
    'catAdditionalData': CatAdditionalDataDto;
    /**
     * Additional data for ES contact.
     * @type {EsAdditionalDataDto}
     * @memberof ContactAdditionalDto
     */
    'esAdditionalData': EsAdditionalDataDto;
    /**
     * Additional data for EU/BE contact.
     * @type {EuBeAdditionalDataDto}
     * @memberof ContactAdditionalDto
     */
    'euAdditionalData': EuBeAdditionalDataDto;
    /**
     * Additional data for IT contact.
     * @type {ItAdditionalDataDto}
     * @memberof ContactAdditionalDto
     */
    'itAdditionalData': ItAdditionalDataDto;
    /**
     * Additional data for LV contact.
     * @type {LvAdditionalDataDto}
     * @memberof ContactAdditionalDto
     */
    'lvAdditionalData': LvAdditionalDataDto;
    /**
     * Additional data for NL contact.
     * @type {NlAdditionalDataDto}
     * @memberof ContactAdditionalDto
     */
    'nlAdditionalData': NlAdditionalDataDto;
    /**
     * Additional data for PRO contact.
     * @type {ProAdditionalDataDto}
     * @memberof ContactAdditionalDto
     */
    'proAdditionalData': ProAdditionalDataDto;
    /**
     * Additional data for UK contact.
     * @type {UkAdditionalDataDto}
     * @memberof ContactAdditionalDto
     */
    'ukAdditionalData': UkAdditionalDataDto;
    /**
     * Additional data for US contact.
     * @type {UsAdditionalDataDto}
     * @memberof ContactAdditionalDto
     */
    'usAdditionalData': UsAdditionalDataDto;
}
/**
 * 
 * @export
 * @interface ContactCodeDto
 */
export interface ContactCodeDto {
    /**
     * The unique identifier for the integration associated with this contact code.
     * @type {IntegrationResponseDto}
     * @memberof ContactCodeDto
     */
    'integration': IntegrationResponseDto;
    /**
     * A custom code representing the contact within a specific integration.
     * @type {string}
     * @memberof ContactCodeDto
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface CountryDto
 */
export interface CountryDto {
    /**
     * 
     * @type {string}
     * @memberof CountryDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CountryDto
     */
    'code': CountryDtoCodeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof CountryDto
     */
    'isEurope'?: boolean;
}

export const CountryDtoCodeEnum = {
    Af: 'AF',
    Ax: 'AX',
    Al: 'AL',
    Dz: 'DZ',
    As: 'AS',
    Ad: 'AD',
    Ao: 'AO',
    Ai: 'AI',
    Aq: 'AQ',
    Ag: 'AG',
    Ar: 'AR',
    Am: 'AM',
    Aw: 'AW',
    Au: 'AU',
    At: 'AT',
    Az: 'AZ',
    Bs: 'BS',
    Bh: 'BH',
    Bd: 'BD',
    Bb: 'BB',
    By: 'BY',
    Be: 'BE',
    Bz: 'BZ',
    Bj: 'BJ',
    Bm: 'BM',
    Bt: 'BT',
    Bo: 'BO',
    Bq: 'BQ',
    Ba: 'BA',
    Bw: 'BW',
    Bv: 'BV',
    Br: 'BR',
    Io: 'IO',
    Bn: 'BN',
    Bg: 'BG',
    Bf: 'BF',
    Bi: 'BI',
    Kh: 'KH',
    Cm: 'CM',
    Ca: 'CA',
    Cv: 'CV',
    Ky: 'KY',
    Cf: 'CF',
    Td: 'TD',
    Cl: 'CL',
    Cn: 'CN',
    Cx: 'CX',
    Cc: 'CC',
    Co: 'CO',
    Km: 'KM',
    Cg: 'CG',
    Cd: 'CD',
    Ck: 'CK',
    Cr: 'CR',
    Ci: 'CI',
    Hr: 'HR',
    Cu: 'CU',
    Cw: 'CW',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Dj: 'DJ',
    Dm: 'DM',
    Do: 'DO',
    Ec: 'EC',
    Eg: 'EG',
    Sv: 'SV',
    Gq: 'GQ',
    Er: 'ER',
    Ee: 'EE',
    Et: 'ET',
    Fk: 'FK',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Gf: 'GF',
    Pf: 'PF',
    Tf: 'TF',
    Ga: 'GA',
    Gm: 'GM',
    Ge: 'GE',
    De: 'DE',
    Gh: 'GH',
    Gi: 'GI',
    Gr: 'GR',
    Gl: 'GL',
    Gd: 'GD',
    Gp: 'GP',
    Gu: 'GU',
    Gt: 'GT',
    Gg: 'GG',
    Gn: 'GN',
    Gw: 'GW',
    Gy: 'GY',
    Ht: 'HT',
    Hm: 'HM',
    Va: 'VA',
    Hn: 'HN',
    Hk: 'HK',
    Hu: 'HU',
    Is: 'IS',
    In: 'IN',
    Id: 'ID',
    Ir: 'IR',
    Iq: 'IQ',
    Ie: 'IE',
    Im: 'IM',
    Il: 'IL',
    It: 'IT',
    Jm: 'JM',
    Jp: 'JP',
    Je: 'JE',
    Jo: 'JO',
    Kz: 'KZ',
    Ke: 'KE',
    Ki: 'KI',
    Kp: 'KP',
    Kr: 'KR',
    Kw: 'KW',
    Kg: 'KG',
    La: 'LA',
    Lv: 'LV',
    Lb: 'LB',
    Ls: 'LS',
    Lr: 'LR',
    Ly: 'LY',
    Li: 'LI',
    Lt: 'LT',
    Lu: 'LU',
    Mo: 'MO',
    Mk: 'MK',
    Mg: 'MG',
    Mw: 'MW',
    My: 'MY',
    Mv: 'MV',
    Ml: 'ML',
    Mt: 'MT',
    Mh: 'MH',
    Mq: 'MQ',
    Mr: 'MR',
    Mu: 'MU',
    Tn: 'TN',
    Tr: 'TR',
    Tm: 'TM',
    Tc: 'TC',
    Tv: 'TV',
    Ug: 'UG',
    Ua: 'UA',
    Ae: 'AE',
    Gb: 'GB',
    Us: 'US',
    Um: 'UM',
    Uy: 'UY',
    Uz: 'UZ',
    Vu: 'VU',
    Ve: 'VE',
    Vn: 'VN',
    Vg: 'VG',
    Vi: 'VI',
    Wf: 'WF',
    Eh: 'EH',
    Ye: 'YE',
    Zm: 'ZM',
    Zw: 'ZW',
    Yt: 'YT',
    Mx: 'MX',
    Fm: 'FM',
    Md: 'MD',
    Mc: 'MC',
    Mn: 'MN',
    Me: 'ME',
    Ms: 'MS',
    Ma: 'MA',
    Mz: 'MZ',
    Mm: 'MM',
    Na: 'NA',
    Nr: 'NR',
    Np: 'NP',
    Nl: 'NL',
    Nc: 'NC',
    Nz: 'NZ',
    Ni: 'NI',
    Ne: 'NE',
    Ng: 'NG',
    Nu: 'NU',
    Nf: 'NF',
    Mp: 'MP',
    No: 'NO',
    Om: 'OM',
    Pk: 'PK',
    Pw: 'PW',
    Ps: 'PS',
    Pa: 'PA',
    Pg: 'PG',
    Py: 'PY',
    Pe: 'PE',
    Ph: 'PH',
    Pn: 'PN',
    Pl: 'PL',
    Pt: 'PT',
    Pr: 'PR',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Ru: 'RU',
    Rw: 'RW',
    Bl: 'BL',
    Sh: 'SH',
    Kn: 'KN',
    Lc: 'LC',
    Mf: 'MF',
    Pm: 'PM',
    Vc: 'VC',
    Ws: 'WS',
    Sm: 'SM',
    St: 'ST',
    Sa: 'SA',
    Sn: 'SN',
    Rs: 'RS',
    Sc: 'SC',
    Sl: 'SL',
    Sg: 'SG',
    Sx: 'SX',
    Sk: 'SK',
    Si: 'SI',
    Sb: 'SB',
    So: 'SO',
    Za: 'ZA',
    Gs: 'GS',
    Ss: 'SS',
    Es: 'ES',
    Lk: 'LK',
    Sd: 'SD',
    Sr: 'SR',
    Sj: 'SJ',
    Sz: 'SZ',
    Se: 'SE',
    Ch: 'CH',
    Sy: 'SY',
    Tw: 'TW',
    Tj: 'TJ',
    Tz: 'TZ',
    Th: 'TH',
    Tl: 'TL',
    Tg: 'TG',
    Tk: 'TK',
    To: 'TO',
    Tt: 'TT'
} as const;

export type CountryDtoCodeEnum = typeof CountryDtoCodeEnum[keyof typeof CountryDtoCodeEnum];

/**
 * @type Coupon
 * The unique identifier for the discount coupon applied to this order. If no coupon is used, this field will be omitted.
 * @export
 */
export type Coupon = CouponResponseDto | string;

/**
 * 
 * @export
 * @interface CouponProductsRequestDto
 */
export interface CouponProductsRequestDto {
    /**
     * Specifies the product durations to which the coupon can be applied. Each duration represents a specific term (e.g., one year, two years) during which the discount or promotion will be valid for the selected product.
     * @type {Array<string>}
     * @memberof CouponProductsRequestDto
     */
    'appliedOnDurations': Array<CouponProductsRequestDtoAppliedOnDurationsEnum>;
    /**
     * Specifies the actions where the coupon can be applied. Actions define the specific use cases for the coupon, such as applying to new purchases, renewals, upgrades, or other applicable scenarios.
     * @type {Array<string>}
     * @memberof CouponProductsRequestDto
     */
    'appliedOnActions': Array<CouponProductsRequestDtoAppliedOnActionsEnum>;
    /**
     * Determines whether the coupon applies to add-ons associated with the product. If set to true, the coupon discount will include the price of applicable add-ons. If set to false, the add-ons will be excluded from the coupon\'s discount.
     * @type {boolean}
     * @memberof CouponProductsRequestDto
     */
    'appliedOnAddons': boolean;
    /**
     * The type of discount applied by the coupon. It defines how the discount is calculated and applied to the product. Options include percentage-based discounts, fixed amount discounts, or additional months of service.
     * @type {string}
     * @memberof CouponProductsRequestDto
     */
    'discountType': CouponProductsRequestDtoDiscountTypeEnum;
    /**
     * The value of the discount, which can vary depending on the coupon type (percentage, fixed amount, or extra months).
     * @type {number}
     * @memberof CouponProductsRequestDto
     */
    'value': number;
    /**
     * Select which products the coupon will apply to when there are multiple items in the cart. For example, if \'EVERYTHING\' is selected, the coupon applies to all items, whereas selecting a specific product limits the application of the coupon to only that item.
     * @type {string}
     * @memberof CouponProductsRequestDto
     */
    'applyTo': CouponProductsRequestDtoApplyToEnum;
    /**
     * The total number of times a coupon can be applied across all users. This limits how many times the coupon can be used in total, regardless of individual user usage. If left undefined, the coupon may be applied indefinitely.
     * @type {number}
     * @memberof CouponProductsRequestDto
     */
    'timesCanBeAppliedTotal'?: number;
    /**
     * The maximum number of times a coupon can be applied by a single user. This limits the coupon usage for each individual user. If left undefined, the coupon can be applied an unlimited number of times per user.
     * @type {number}
     * @memberof CouponProductsRequestDto
     */
    'timesCanBeAppliedPerUser'?: number;
    /**
     * An array of product IDs that the coupon can be applied to. Each ID corresponds to a specific product eligible for the coupon\'s discount or promotion.
     * @type {Array<string>}
     * @memberof CouponProductsRequestDto
     */
    'products': Array<string>;
}

export const CouponProductsRequestDtoAppliedOnDurationsEnum = {
    _0: '0',
    _1: '1',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5',
    _6: '6',
    _7: '7',
    _8: '8',
    _9: '9',
    _10: '10',
    _11: '11',
    _12: '12',
    _24: '24',
    _36: '36',
    _48: '48',
    _60: '60',
    _72: '72',
    _84: '84',
    _96: '96',
    _108: '108',
    _120: '120'
} as const;

export type CouponProductsRequestDtoAppliedOnDurationsEnum = typeof CouponProductsRequestDtoAppliedOnDurationsEnum[keyof typeof CouponProductsRequestDtoAppliedOnDurationsEnum];
export const CouponProductsRequestDtoAppliedOnActionsEnum = {
    Create: 'CREATE',
    Renew: 'RENEW',
    Setup: 'SETUP'
} as const;

export type CouponProductsRequestDtoAppliedOnActionsEnum = typeof CouponProductsRequestDtoAppliedOnActionsEnum[keyof typeof CouponProductsRequestDtoAppliedOnActionsEnum];
export const CouponProductsRequestDtoDiscountTypeEnum = {
    Percentage: 'PERCENTAGE',
    Fixed: 'FIXED',
    ExtraMonths: 'EXTRA_MONTHS'
} as const;

export type CouponProductsRequestDtoDiscountTypeEnum = typeof CouponProductsRequestDtoDiscountTypeEnum[keyof typeof CouponProductsRequestDtoDiscountTypeEnum];
export const CouponProductsRequestDtoApplyToEnum = {
    All: 'ALL',
    LowestPrice: 'LOWEST_PRICE',
    HighestPrice: 'HIGHEST_PRICE'
} as const;

export type CouponProductsRequestDtoApplyToEnum = typeof CouponProductsRequestDtoApplyToEnum[keyof typeof CouponProductsRequestDtoApplyToEnum];

/**
 * 
 * @export
 * @interface CouponProductsResponseDto
 */
export interface CouponProductsResponseDto {
    /**
     * Specifies the product durations to which the coupon can be applied. Each duration represents a specific term (e.g., one year, two years) during which the discount or promotion will be valid for the selected product.
     * @type {Array<string>}
     * @memberof CouponProductsResponseDto
     */
    'appliedOnDurations': Array<CouponProductsResponseDtoAppliedOnDurationsEnum>;
    /**
     * Specifies the actions where the coupon can be applied. Actions define the specific use cases for the coupon, such as applying to new purchases, renewals, upgrades, or other applicable scenarios.
     * @type {Array<string>}
     * @memberof CouponProductsResponseDto
     */
    'appliedOnActions': Array<CouponProductsResponseDtoAppliedOnActionsEnum>;
    /**
     * Determines whether the coupon applies to add-ons associated with the product. If set to true, the coupon discount will include the price of applicable add-ons. If set to false, the add-ons will be excluded from the coupon\'s discount.
     * @type {boolean}
     * @memberof CouponProductsResponseDto
     */
    'appliedOnAddons': boolean;
    /**
     * The type of discount applied by the coupon. It defines how the discount is calculated and applied to the product. Options include percentage-based discounts, fixed amount discounts, or additional months of service.
     * @type {string}
     * @memberof CouponProductsResponseDto
     */
    'discountType': CouponProductsResponseDtoDiscountTypeEnum;
    /**
     * The value of the discount, which can vary depending on the coupon type (percentage, fixed amount, or extra months).
     * @type {number}
     * @memberof CouponProductsResponseDto
     */
    'value': number;
    /**
     * Select which products the coupon will apply to when there are multiple items in the cart. For example, if \'EVERYTHING\' is selected, the coupon applies to all items, whereas selecting a specific product limits the application of the coupon to only that item.
     * @type {string}
     * @memberof CouponProductsResponseDto
     */
    'applyTo': CouponProductsResponseDtoApplyToEnum;
    /**
     * The total number of times a coupon can be applied across all users. This limits how many times the coupon can be used in total, regardless of individual user usage. If left undefined, the coupon may be applied indefinitely.
     * @type {number}
     * @memberof CouponProductsResponseDto
     */
    'timesCanBeAppliedTotal'?: number;
    /**
     * The maximum number of times a coupon can be applied by a single user. This limits the coupon usage for each individual user. If left undefined, the coupon can be applied an unlimited number of times per user.
     * @type {number}
     * @memberof CouponProductsResponseDto
     */
    'timesCanBeAppliedPerUser'?: number;
    /**
     * An array of product IDs that the coupon can be applied to. Each ID corresponds to a specific product eligible for the coupon\'s discount or promotion.
     * @type {Array<ProductVersionDtoProductInner>}
     * @memberof CouponProductsResponseDto
     */
    'products': Array<ProductVersionDtoProductInner>;
}

export const CouponProductsResponseDtoAppliedOnDurationsEnum = {
    _0: '0',
    _1: '1',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5',
    _6: '6',
    _7: '7',
    _8: '8',
    _9: '9',
    _10: '10',
    _11: '11',
    _12: '12',
    _24: '24',
    _36: '36',
    _48: '48',
    _60: '60',
    _72: '72',
    _84: '84',
    _96: '96',
    _108: '108',
    _120: '120'
} as const;

export type CouponProductsResponseDtoAppliedOnDurationsEnum = typeof CouponProductsResponseDtoAppliedOnDurationsEnum[keyof typeof CouponProductsResponseDtoAppliedOnDurationsEnum];
export const CouponProductsResponseDtoAppliedOnActionsEnum = {
    Create: 'CREATE',
    Renew: 'RENEW',
    Setup: 'SETUP'
} as const;

export type CouponProductsResponseDtoAppliedOnActionsEnum = typeof CouponProductsResponseDtoAppliedOnActionsEnum[keyof typeof CouponProductsResponseDtoAppliedOnActionsEnum];
export const CouponProductsResponseDtoDiscountTypeEnum = {
    Percentage: 'PERCENTAGE',
    Fixed: 'FIXED',
    ExtraMonths: 'EXTRA_MONTHS'
} as const;

export type CouponProductsResponseDtoDiscountTypeEnum = typeof CouponProductsResponseDtoDiscountTypeEnum[keyof typeof CouponProductsResponseDtoDiscountTypeEnum];
export const CouponProductsResponseDtoApplyToEnum = {
    All: 'ALL',
    LowestPrice: 'LOWEST_PRICE',
    HighestPrice: 'HIGHEST_PRICE'
} as const;

export type CouponProductsResponseDtoApplyToEnum = typeof CouponProductsResponseDtoApplyToEnum[keyof typeof CouponProductsResponseDtoApplyToEnum];

/**
 * 
 * @export
 * @interface CouponRequestDto
 */
export interface CouponRequestDto {
    /**
     * A unique alphanumeric code associated with the coupon that provides a discount, promotion, or special offer. This code is used during checkout or within the system to redeem the corresponding benefits.
     * @type {string}
     * @memberof CouponRequestDto
     */
    'couponCode': string;
    /**
     * Indicates whether the coupon is hidden from the user\'s panel. If set to true, the coupon will not appear in the user\'s interface. Otherwise, it will be visible.
     * @type {boolean}
     * @memberof CouponRequestDto
     */
    'hidden': boolean;
    /**
     * The start date from which the coupon becomes valid. This date indicates when the coupon can begin being used.
     * @type {string}
     * @memberof CouponRequestDto
     */
    'startDate': string;
    /**
     * The end date after which the coupon is no longer valid. This date marks the expiration of the coupon, and it will not be accepted for use after this time.
     * @type {string}
     * @memberof CouponRequestDto
     */
    'endDate': string;
    /**
     * Indicates whether the affiliate fee should be excluded. If true, no affiliate commission will be given for the transaction. If false, the standard affiliate commission is applied.
     * @type {boolean}
     * @memberof CouponRequestDto
     */
    'excludeAffiliateFee': boolean;
    /**
     * The unique identifier of the user associated with the coupon. If provided, the coupon is restricted to this specific user. If not, the coupon is considered global and available to all users.
     * @type {string}
     * @memberof CouponRequestDto
     */
    'user'?: string;
    /**
     * An array of product groups associated with the coupon. Each group allows applying different discounts to specific categories or products. For example, one group might offer a 20% discount on shared hosting, while another provides a 30% discount on reseller hosting.
     * @type {Array<CouponProductsRequestDto>}
     * @memberof CouponRequestDto
     */
    'couponProducts': Array<CouponProductsRequestDto>;
}
/**
 * 
 * @export
 * @interface CouponResponseDto
 */
export interface CouponResponseDto {
    /**
     * A unique alphanumeric code associated with the coupon that provides a discount, promotion, or special offer. This code is used during checkout or within the system to redeem the corresponding benefits.
     * @type {string}
     * @memberof CouponResponseDto
     */
    'couponCode': string;
    /**
     * Indicates whether the coupon is hidden from the user\'s panel. If set to true, the coupon will not appear in the user\'s interface. Otherwise, it will be visible.
     * @type {boolean}
     * @memberof CouponResponseDto
     */
    'hidden': boolean;
    /**
     * The start date from which the coupon becomes valid. This date indicates when the coupon can begin being used.
     * @type {string}
     * @memberof CouponResponseDto
     */
    'startDate': string;
    /**
     * The end date after which the coupon is no longer valid. This date marks the expiration of the coupon, and it will not be accepted for use after this time.
     * @type {string}
     * @memberof CouponResponseDto
     */
    'endDate': string;
    /**
     * Indicates whether the affiliate fee should be excluded. If true, no affiliate commission will be given for the transaction. If false, the standard affiliate commission is applied.
     * @type {boolean}
     * @memberof CouponResponseDto
     */
    'excludeAffiliateFee': boolean;
    /**
     * The unique identifier of the coupon.
     * @type {string}
     * @memberof CouponResponseDto
     */
    'id'?: string;
    /**
     * 
     * @type {CompanyID}
     * @memberof CouponResponseDto
     */
    'company': CompanyID;
    /**
     * 
     * @type {UserID}
     * @memberof CouponResponseDto
     */
    'user'?: UserID;
    /**
     * An array of product groups associated with the coupon. Each group allows applying different discounts to specific categories or products. For example, one group might offer a 20% discount on shared hosting, while another provides a 30% discount on reseller hosting.
     * @type {Array<CouponProductsResponseDto>}
     * @memberof CouponResponseDto
     */
    'couponProducts': Array<CouponProductsResponseDto>;
    /**
     * The date and time when the coupon was created.
     * @type {string}
     * @memberof CouponResponseDto
     */
    'createdAt': string;
    /**
     * The date and time when the coupon was updated.
     * @type {string}
     * @memberof CouponResponseDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface CreateAddon201Response
 */
export interface CreateAddon201Response {
    /**
     * The HTTP status code indicating the result of the operation.
     * @type {any}
     * @memberof CreateAddon201Response
     */
    'code': any;
    /**
     * A human-readable message providing more details about the response.
     * @type {any}
     * @memberof CreateAddon201Response
     */
    'message': any;
    /**
     * 
     * @type {AddonResponseDto}
     * @memberof CreateAddon201Response
     */
    'data': AddonResponseDto;
}
/**
 * 
 * @export
 * @interface CreateAffiliate201Response
 */
export interface CreateAffiliate201Response {
    /**
     * The HTTP status code indicating the result of the operation.
     * @type {any}
     * @memberof CreateAffiliate201Response
     */
    'code': any;
    /**
     * A human-readable message providing more details about the response.
     * @type {any}
     * @memberof CreateAffiliate201Response
     */
    'message': any;
    /**
     * 
     * @type {AffiliateResponseDto}
     * @memberof CreateAffiliate201Response
     */
    'data': AffiliateResponseDto;
}
/**
 * 
 * @export
 * @interface CreateCompany201Response
 */
export interface CreateCompany201Response {
    /**
     * The HTTP status code indicating the result of the operation.
     * @type {any}
     * @memberof CreateCompany201Response
     */
    'code': any;
    /**
     * A human-readable message providing more details about the response.
     * @type {any}
     * @memberof CreateCompany201Response
     */
    'message': any;
    /**
     * 
     * @type {CompanyResponseDto}
     * @memberof CreateCompany201Response
     */
    'data': CompanyResponseDto;
}
/**
 * 
 * @export
 * @interface CreateCoupon201Response
 */
export interface CreateCoupon201Response {
    /**
     * The HTTP status code indicating the result of the operation.
     * @type {any}
     * @memberof CreateCoupon201Response
     */
    'code': any;
    /**
     * A human-readable message providing more details about the response.
     * @type {any}
     * @memberof CreateCoupon201Response
     */
    'message': any;
    /**
     * 
     * @type {CouponResponseDto}
     * @memberof CreateCoupon201Response
     */
    'data': CouponResponseDto;
}
/**
 * 
 * @export
 * @interface CreateDomainCategory201Response
 */
export interface CreateDomainCategory201Response {
    /**
     * The HTTP status code indicating the result of the operation.
     * @type {any}
     * @memberof CreateDomainCategory201Response
     */
    'code': any;
    /**
     * A human-readable message providing more details about the response.
     * @type {any}
     * @memberof CreateDomainCategory201Response
     */
    'message': any;
    /**
     * 
     * @type {DomainCategoryResponseDto}
     * @memberof CreateDomainCategory201Response
     */
    'data': DomainCategoryResponseDto;
}
/**
 * 
 * @export
 * @interface CreateDomainContact201Response
 */
export interface CreateDomainContact201Response {
    /**
     * The HTTP status code indicating the result of the operation.
     * @type {any}
     * @memberof CreateDomainContact201Response
     */
    'code': any;
    /**
     * A human-readable message providing more details about the response.
     * @type {any}
     * @memberof CreateDomainContact201Response
     */
    'message': any;
    /**
     * 
     * @type {DomainContactResponseDto}
     * @memberof CreateDomainContact201Response
     */
    'data': DomainContactResponseDto;
}
/**
 * 
 * @export
 * @interface CreateIntegration201Response
 */
export interface CreateIntegration201Response {
    /**
     * The HTTP status code indicating the result of the operation.
     * @type {any}
     * @memberof CreateIntegration201Response
     */
    'code': any;
    /**
     * A human-readable message providing more details about the response.
     * @type {any}
     * @memberof CreateIntegration201Response
     */
    'message': any;
    /**
     * 
     * @type {IntegrationResponseDto}
     * @memberof CreateIntegration201Response
     */
    'data': IntegrationResponseDto;
}
/**
 * 
 * @export
 * @interface CreateIssue201Response
 */
export interface CreateIssue201Response {
    /**
     * The HTTP status code indicating the result of the operation.
     * @type {any}
     * @memberof CreateIssue201Response
     */
    'code': any;
    /**
     * A human-readable message providing more details about the response.
     * @type {any}
     * @memberof CreateIssue201Response
     */
    'message': any;
    /**
     * 
     * @type {IssueResponseDto}
     * @memberof CreateIssue201Response
     */
    'data': IssueResponseDto;
}
/**
 * 
 * @export
 * @interface CreatePolicy201Response
 */
export interface CreatePolicy201Response {
    /**
     * The HTTP status code indicating the result of the operation.
     * @type {any}
     * @memberof CreatePolicy201Response
     */
    'code': any;
    /**
     * A human-readable message providing more details about the response.
     * @type {any}
     * @memberof CreatePolicy201Response
     */
    'message': any;
    /**
     * 
     * @type {PolicyResponseDto}
     * @memberof CreatePolicy201Response
     */
    'data': PolicyResponseDto;
}
/**
 * 
 * @export
 * @interface CreateProduct201Response
 */
export interface CreateProduct201Response {
    /**
     * The HTTP status code indicating the result of the operation.
     * @type {any}
     * @memberof CreateProduct201Response
     */
    'code': any;
    /**
     * A human-readable message providing more details about the response.
     * @type {any}
     * @memberof CreateProduct201Response
     */
    'message': any;
    /**
     * 
     * @type {ProductResponseDto}
     * @memberof CreateProduct201Response
     */
    'data': ProductResponseDto;
}
/**
 * 
 * @export
 * @interface CreateProductCategory201Response
 */
export interface CreateProductCategory201Response {
    /**
     * The HTTP status code indicating the result of the operation.
     * @type {any}
     * @memberof CreateProductCategory201Response
     */
    'code': any;
    /**
     * A human-readable message providing more details about the response.
     * @type {any}
     * @memberof CreateProductCategory201Response
     */
    'message': any;
    /**
     * 
     * @type {ProductCategoryResponseDto}
     * @memberof CreateProductCategory201Response
     */
    'data': ProductCategoryResponseDto;
}
/**
 * 
 * @export
 * @interface CreateRequestDto
 */
export interface CreateRequestDto {
    /**
     * A comprehensive object containing all the necessary data to create a new product. This includes essential details such as the product\'s name, description, pricing policies, and category, as well as any associated integrations or addons.
     * @type {ProductRequestDto}
     * @memberof CreateRequestDto
     */
    'productDto': ProductRequestDto;
    /**
     * The unique identifier of an existing product. If provided, the new product will be created as a subsequent version of the specified product, inheriting its history and context. This is used for versioning and creating upgrade/downgrade paths.
     * @type {string}
     * @memberof CreateRequestDto
     */
    'previousProductId'?: string;
}
/**
 * @type CreateTemplate
 * The template for creating a new product. This field represents the official name or identifier for the template, and it cannot be empty.
 * @export
 */
export type CreateTemplate = TemplateResponseDto | string;

/**
 * 
 * @export
 * @interface CreateTemplate201Response
 */
export interface CreateTemplate201Response {
    /**
     * The HTTP status code indicating the result of the operation.
     * @type {any}
     * @memberof CreateTemplate201Response
     */
    'code': any;
    /**
     * A human-readable message providing more details about the response.
     * @type {any}
     * @memberof CreateTemplate201Response
     */
    'message': any;
    /**
     * 
     * @type {TemplateResponseDto}
     * @memberof CreateTemplate201Response
     */
    'data': TemplateResponseDto;
}
/**
 * 
 * @export
 * @interface CreateTld201Response
 */
export interface CreateTld201Response {
    /**
     * The HTTP status code indicating the result of the operation.
     * @type {any}
     * @memberof CreateTld201Response
     */
    'code': any;
    /**
     * A human-readable message providing more details about the response.
     * @type {any}
     * @memberof CreateTld201Response
     */
    'message': any;
    /**
     * 
     * @type {TldResponseDto}
     * @memberof CreateTld201Response
     */
    'data': TldResponseDto;
}
/**
 * 
 * @export
 * @interface CreateTransaction200Response
 */
export interface CreateTransaction200Response {
    /**
     * The HTTP status code indicating the result of the operation.
     * @type {any}
     * @memberof CreateTransaction200Response
     */
    'code': any;
    /**
     * A human-readable message providing more details about the response.
     * @type {any}
     * @memberof CreateTransaction200Response
     */
    'message': any;
    /**
     * 
     * @type {TransactionRedirectUrlResponseDto}
     * @memberof CreateTransaction200Response
     */
    'data': TransactionRedirectUrlResponseDto;
}
/**
 * @type CreatedByCompany
 * The company that created or submitted the integration.
 * @export
 */
export type CreatedByCompany = CompanyResponseDto | string;

/**
 * 
 * @export
 * @interface CustomPricesRequestDto
 */
export interface CustomPricesRequestDto {
    /**
     * Custom price for the item.
     * @type {number}
     * @memberof CustomPricesRequestDto
     */
    'customPrice'?: number;
    /**
     * Custom setup fee for the item.
     * @type {number}
     * @memberof CustomPricesRequestDto
     */
    'customSetupFee'?: number;
}
/**
 * 
 * @export
 * @interface CustomToken201Response
 */
export interface CustomToken201Response {
    /**
     * The HTTP status code indicating the result of the operation.
     * @type {any}
     * @memberof CustomToken201Response
     */
    'code': any;
    /**
     * A human-readable message providing more details about the response.
     * @type {any}
     * @memberof CustomToken201Response
     */
    'message': any;
    /**
     * 
     * @type {CustomTokenDto}
     * @memberof CustomToken201Response
     */
    'data': CustomTokenDto;
}
/**
 * 
 * @export
 * @interface CustomTokenDto
 */
export interface CustomTokenDto {
    /**
     * Custom token for the user.
     * @type {string}
     * @memberof CustomTokenDto
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface DeAdditionalDataDto
 */
export interface DeAdditionalDataDto {
    /**
     * Accepted values: PERSON - ROLE - ORG
     * @type {string}
     * @memberof DeAdditionalDataDto
     */
    'contactType': DeAdditionalDataDtoContactTypeEnum;
}

export const DeAdditionalDataDtoContactTypeEnum = {
    Person: 'PERSON',
    Role: 'ROLE',
    Org: 'ORG'
} as const;

export type DeAdditionalDataDtoContactTypeEnum = typeof DeAdditionalDataDtoContactTypeEnum[keyof typeof DeAdditionalDataDtoContactTypeEnum];

/**
 * @type DeleteTemplate
 * The template for deleting a product. This field represents the official name or identifier for the template, and it cannot be empty.
 * @export
 */
export type DeleteTemplate = TemplateResponseDto | string;

/**
 * @type DetachedFromOrder
 * Stores the identifier of the order from which this item was originally detached. This information is useful for tracking the item\'s origin.
 * @export
 */
export type DetachedFromOrder = OrderResponseDto | string;

/**
 * 
 * @export
 * @interface DomainAdditionalDto
 */
export interface DomainAdditionalDto {
    /**
     * Additional parameters for Cat domains.cat is the sponsored generic top-level domain (TLD) for the Catalan language. It isn\'t territorial, however, so anyone in the world can register a . cat domain name—the only requirement is that you belong to the linguistic community for Catalan speakers.
     * @type {CatParameterDataDto}
     * @memberof DomainAdditionalDto
     */
    'catParameterData'?: CatParameterDataDto;
    /**
     * Parameters for domain challenges.
     * @type {ChallengeParametersDataDto}
     * @memberof DomainAdditionalDto
     */
    'challengeParametersData'?: ChallengeParametersDataDto;
    /**
     * Data for trademark claims token.
     * @type {ClaimsTokenDataDto}
     * @memberof DomainAdditionalDto
     */
    'claimsTokenData'?: ClaimsTokenDataDto;
    /**
     * Additional parameters for Donuts premium domains.
     * @type {DonutsPriceCategoryDataDto}
     * @memberof DomainAdditionalDto
     */
    'donutsPriceCategoryData'?: DonutsPriceCategoryDataDto;
    /**
     * Intended use parameters for domain registration.
     * @type {IntendedUseParamsDataDto}
     * @memberof DomainAdditionalDto
     */
    'intendedUseParamsData'?: IntendedUseParamsDataDto;
    /**
     * If set to true and if the Proxy service is supported, the domain will have the Proxy service enabled when registered
     * @type {ProxyServiceDataDto}
     * @memberof DomainAdditionalDto
     */
    'proxyServiceData'?: ProxyServiceDataDto;
    /**
     * This is only required for domains that the registry specify have a premium price category associated with,Premium domain names are high-quality domains that have been previously registered but are available for sale at today\'s market value. A domain is considered to be high quality if the name is shorter, regularly searched, closely associated to the actual service or industry, and typically uses a TLD
     * @type {PremiumPriceCategoryDataDto}
     * @memberof DomainAdditionalDto
     */
    'premiumPriceCategory'?: PremiumPriceCategoryDataDto;
    /**
     * The SunriseData parameter must be supplied when sending the RegisterDomain command with a LaunchPhase of SR. A Sunrise Phase refers to a period during which, the trademark holders can register domain names corresponding to their marks before names are accessible to the general public.
     * @type {SunriseDataDto}
     * @memberof DomainAdditionalDto
     */
    'sunriseData'?: SunriseDataDto;
    /**
     * Additional data for .xxx domain names.
     * @type {XXXMemberDataDto}
     * @memberof DomainAdditionalDto
     */
    'xxxMemberData'?: XXXMemberDataDto;
    /**
     * Additional data for .uk direct domains.
     * @type {UKDirectDataDto}
     * @memberof DomainAdditionalDto
     */
    'ukDirectData'?: UKDirectDataDto;
}
/**
 * 
 * @export
 * @interface DomainAvailabilityDto
 */
export interface DomainAvailabilityDto {
    /**
     * The name of the domain.
     * @type {string}
     * @memberof DomainAvailabilityDto
     */
    'domainName': string;
    /**
     * Indicates whether the domain is available for registration.
     * @type {boolean}
     * @memberof DomainAvailabilityDto
     */
    'available': boolean;
}
/**
 * 
 * @export
 * @interface DomainAvailabilityWebsocketsDto
 */
export interface DomainAvailabilityWebsocketsDto {
    /**
     * The unique identifier of the WebSocket channel for domain availability updates.
     * @type {string}
     * @memberof DomainAvailabilityWebsocketsDto
     */
    'channelId': string;
}
/**
 * 
 * @export
 * @interface DomainBundleDto
 */
export interface DomainBundleDto {
    /**
     * The name of a domain within the bundle. This represents an individual domain name that is part of the domain bundle.
     * @type {string}
     * @memberof DomainBundleDto
     */
    'domainBundleName': string;
    /**
     * Indicates whether the domain bundle is chargeable. If true, the price for the product will be multiplied.
     * @type {boolean}
     * @memberof DomainBundleDto
     */
    'chargeable': boolean;
    /**
     * Specifies how the domain name is managed: DNAME for alias, DOMAIN for standalone.
     * @type {string}
     * @memberof DomainBundleDto
     */
    'recordType': DomainBundleDtoRecordTypeEnum;
}

export const DomainBundleDtoRecordTypeEnum = {
    Domain: 'DOMAIN',
    Dname: 'DNAME'
} as const;

export type DomainBundleDtoRecordTypeEnum = typeof DomainBundleDtoRecordTypeEnum[keyof typeof DomainBundleDtoRecordTypeEnum];

/**
 * 
 * @export
 * @interface DomainCategoryRequestDto
 */
export interface DomainCategoryRequestDto {
    /**
     * A multilingual array containing the title of the item. Each entry consists of a \'text\' field for the title and a \'language\' field for the language code.
     * @type {Array<MultilangTextDto>}
     * @memberof DomainCategoryRequestDto
     */
    'title': Array<MultilangTextDto>;
    /**
     * A multilingual array containing brief descriptions of the domain category. Each entry includes a \'text\' field for the description and a \'language\' field for the language code.
     * @type {Array<MultilangTextDto>}
     * @memberof DomainCategoryRequestDto
     */
    'description': Array<MultilangTextDto>;
    /**
     * The URL of the icon representing the domain category. It should point to a valid image resource.
     * @type {string}
     * @memberof DomainCategoryRequestDto
     */
    'iconUrl': string;
}
/**
 * 
 * @export
 * @interface DomainCategoryResponseDto
 */
export interface DomainCategoryResponseDto {
    /**
     * A multilingual array containing the title of the item. Each entry consists of a \'text\' field for the title and a \'language\' field for the language code.
     * @type {Array<MultilangTextDto>}
     * @memberof DomainCategoryResponseDto
     */
    'title': Array<MultilangTextDto>;
    /**
     * A multilingual array containing brief descriptions of the domain category. Each entry includes a \'text\' field for the description and a \'language\' field for the language code.
     * @type {Array<MultilangTextDto>}
     * @memberof DomainCategoryResponseDto
     */
    'description': Array<MultilangTextDto>;
    /**
     * The URL of the icon representing the domain category. It should point to a valid image resource.
     * @type {string}
     * @memberof DomainCategoryResponseDto
     */
    'iconUrl': string;
    /**
     * The unique identifier of the domain category.
     * @type {string}
     * @memberof DomainCategoryResponseDto
     */
    'id': string;
    /**
     * The date when the domain category was created.
     * @type {string}
     * @memberof DomainCategoryResponseDto
     */
    'createdAt': string;
    /**
     * The date when the domain category was last updated.
     * @type {string}
     * @memberof DomainCategoryResponseDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface DomainContactRequestDto
 */
export interface DomainContactRequestDto {
    /**
     * The first name of the contact. This field must be a non-empty string with a length between 1 and 125 characters.
     * @type {string}
     * @memberof DomainContactRequestDto
     */
    'firstName': string;
    /**
     * The last name of the contact. This field must be a non-empty string with a length between 1 and 125 characters.
     * @type {string}
     * @memberof DomainContactRequestDto
     */
    'lastName': string;
    /**
     * The name of the contact’s company or organization. This field is optional and can be up to 250 characters long.
     * @type {string}
     * @memberof DomainContactRequestDto
     */
    'organization'?: string;
    /**
     * The primary line of the contact\'s address, such as the house number and street name. This field is required and must be between 1 and 250 characters.
     * @type {string}
     * @memberof DomainContactRequestDto
     */
    'street1': string;
    /**
     * An optional second line for the contact\'s address, such as an apartment, suite, or unit number. Must not exceed 250 characters.
     * @type {string}
     * @memberof DomainContactRequestDto
     */
    'street2'?: string;
    /**
     * An optional third line for the contact\'s address, typically used for additional address details like a PO box or care-of information. Must not exceed 250 characters.
     * @type {string}
     * @memberof DomainContactRequestDto
     */
    'street3'?: string;
    /**
     * The city associated with the contact\'s address. This is a required field with a maximum length of 250 characters.
     * @type {string}
     * @memberof DomainContactRequestDto
     */
    'city': string;
    /**
     * The contact\'s state or province. This is a required field with a maximum length of 250 characters.
     * @type {string}
     * @memberof DomainContactRequestDto
     */
    'state': string;
    /**
     * The contact\'s Zip Code or Postal Code, which is required and can be between 1 and 16 characters in length.
     * @type {string}
     * @memberof DomainContactRequestDto
     */
    'postcode': string;
    /**
     * The ISO 3166-1-alpha-2 code for the country of the contact. This code represents the contact\'s country and must be a valid 2-letter country code.
     * @type {string}
     * @memberof DomainContactRequestDto
     */
    'countryCode': DomainContactRequestDtoCountryCodeEnum;
    /**
     * The telephone number of the contact, including the international dialing code. The format should be +<InternationalDialingCode>.<TelephoneNumber>.
     * @type {string}
     * @memberof DomainContactRequestDto
     */
    'telephone': string;
    /**
     * The fax number of the contact, including the international dialing code. The format should be +<InternationalDialingCode>.<FaxNumber>.
     * @type {string}
     * @memberof DomainContactRequestDto
     */
    'fax'?: string;
    /**
     * The email address of the contact. It must be a valid email format.
     * @type {string}
     * @memberof DomainContactRequestDto
     */
    'email': string;
    /**
     * Additional data associated with the contact.
     * @type {ContactAdditionalDto}
     * @memberof DomainContactRequestDto
     */
    'additional'?: ContactAdditionalDto;
    /**
     * A unique identifier representing the user associated with this domain contact. This value is required and cannot be empty.
     * @type {string}
     * @memberof DomainContactRequestDto
     */
    'user': string;
}

export const DomainContactRequestDtoCountryCodeEnum = {
    Af: 'AF',
    Al: 'AL',
    Dz: 'DZ',
    As: 'AS',
    Ad: 'AD',
    Ao: 'AO',
    Ai: 'AI',
    Aq: 'AQ',
    Ag: 'AG',
    Ar: 'AR',
    Am: 'AM',
    Aw: 'AW',
    Au: 'AU',
    At: 'AT',
    Az: 'AZ',
    Bs: 'BS',
    Bh: 'BH',
    Bd: 'BD',
    Bb: 'BB',
    By: 'BY',
    Be: 'BE',
    Bz: 'BZ',
    Bj: 'BJ',
    Bm: 'BM',
    Bt: 'BT',
    Bo: 'BO',
    Bq: 'BQ',
    Ba: 'BA',
    Bw: 'BW',
    Bv: 'BV',
    Br: 'BR',
    Io: 'IO',
    Bn: 'BN',
    Bg: 'BG',
    Bf: 'BF',
    Bi: 'BI',
    Kh: 'KH',
    Cm: 'CM',
    Ca: 'CA',
    Cv: 'CV',
    Ky: 'KY',
    Cf: 'CF',
    Td: 'TD',
    Cl: 'CL',
    Cn: 'CN',
    Cx: 'CX',
    Cc: 'CC',
    Co: 'CO',
    Km: 'KM',
    Cg: 'CG',
    Cd: 'CD',
    Ck: 'CK',
    Cr: 'CR',
    Ci: 'CI',
    Hr: 'HR',
    Cu: 'CU',
    Cw: 'CW',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Dj: 'DJ',
    Dm: 'DM',
    Do: 'DO',
    Ec: 'EC',
    Eg: 'EG',
    Sv: 'SV',
    Gq: 'GQ',
    Er: 'ER',
    Ee: 'EE',
    Et: 'ET',
    Fk: 'FK',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Gf: 'GF',
    Pf: 'PF',
    Tf: 'TF',
    Ga: 'GA',
    Gm: 'GM',
    Ge: 'GE',
    De: 'DE',
    Gh: 'GH',
    Gi: 'GI',
    Gr: 'GR',
    Gl: 'GL',
    Gd: 'GD',
    Gp: 'GP',
    Gu: 'GU',
    Gt: 'GT',
    Gg: 'GG',
    Gn: 'GN',
    Gw: 'GW',
    Gy: 'GY',
    Ht: 'HT',
    Hm: 'HM',
    Va: 'VA',
    Hn: 'HN',
    Hk: 'HK',
    Hu: 'HU',
    Is: 'IS',
    In: 'IN',
    Id: 'ID',
    Ir: 'IR',
    Iq: 'IQ',
    Ie: 'IE',
    Im: 'IM',
    Il: 'IL',
    It: 'IT',
    Jm: 'JM',
    Jp: 'JP',
    Je: 'JE',
    Jo: 'JO',
    Kz: 'KZ',
    Ke: 'KE',
    Ki: 'KI',
    Kp: 'KP',
    Kr: 'KR',
    Kw: 'KW',
    Kg: 'KG',
    La: 'LA',
    Lv: 'LV',
    Lb: 'LB',
    Ls: 'LS',
    Lr: 'LR',
    Ly: 'LY',
    Li: 'LI',
    Lt: 'LT',
    Lu: 'LU',
    Mo: 'MO',
    Mk: 'MK',
    Mg: 'MG',
    Mw: 'MW',
    My: 'MY',
    Mv: 'MV',
    Ml: 'ML',
    Mt: 'MT',
    Mh: 'MH',
    Mq: 'MQ',
    Mr: 'MR',
    Mu: 'MU',
    Tn: 'TN',
    Tr: 'TR',
    Tm: 'TM',
    Tc: 'TC',
    Tv: 'TV',
    Ug: 'UG',
    Ua: 'UA',
    Ae: 'AE',
    Gb: 'GB',
    Us: 'US',
    Um: 'UM',
    Uy: 'UY',
    Uz: 'UZ',
    Vu: 'VU',
    Ve: 'VE',
    Vn: 'VN',
    Vg: 'VG',
    Vi: 'VI',
    Wf: 'WF',
    Eh: 'EH',
    Ye: 'YE',
    Zm: 'ZM',
    Zw: 'ZW',
    Yt: 'YT',
    Mx: 'MX',
    Fm: 'FM',
    Md: 'MD',
    Mc: 'MC',
    Mn: 'MN',
    Me: 'ME',
    Ms: 'MS',
    Ma: 'MA',
    Mz: 'MZ',
    Mm: 'MM',
    Na: 'NA',
    Nr: 'NR',
    Np: 'NP',
    Nl: 'NL',
    Nc: 'NC',
    Nz: 'NZ',
    Ni: 'NI',
    Ne: 'NE',
    Ng: 'NG',
    Nu: 'NU',
    Nf: 'NF',
    Mp: 'MP',
    No: 'NO',
    Om: 'OM',
    Pk: 'PK',
    Pw: 'PW',
    Ps: 'PS',
    Pa: 'PA',
    Pg: 'PG',
    Py: 'PY',
    Pe: 'PE',
    Ph: 'PH',
    Pn: 'PN',
    Pl: 'PL',
    Pt: 'PT',
    Pr: 'PR',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Ru: 'RU',
    Rw: 'RW',
    Bl: 'BL',
    Sh: 'SH',
    Kn: 'KN',
    Lc: 'LC',
    Mf: 'MF',
    Pm: 'PM',
    Vc: 'VC',
    Ws: 'WS',
    Sm: 'SM',
    St: 'ST',
    Sa: 'SA',
    Sn: 'SN',
    Rs: 'RS',
    Sc: 'SC',
    Sl: 'SL',
    Sg: 'SG',
    Sx: 'SX',
    Sk: 'SK',
    Si: 'SI',
    Sb: 'SB',
    So: 'SO',
    Za: 'ZA',
    Gs: 'GS',
    Ss: 'SS',
    Es: 'ES',
    Lk: 'LK',
    Sd: 'SD',
    Sr: 'SR',
    Sj: 'SJ',
    Sz: 'SZ',
    Se: 'SE',
    Ch: 'CH',
    Sy: 'SY',
    Tw: 'TW',
    Tj: 'TJ',
    Tz: 'TZ',
    Th: 'TH',
    Tl: 'TL',
    Tg: 'TG',
    Tk: 'TK',
    To: 'TO',
    Tt: 'TT'
} as const;

export type DomainContactRequestDtoCountryCodeEnum = typeof DomainContactRequestDtoCountryCodeEnum[keyof typeof DomainContactRequestDtoCountryCodeEnum];

/**
 * 
 * @export
 * @interface DomainContactResponseDto
 */
export interface DomainContactResponseDto {
    /**
     * The first name of the contact. This field must be a non-empty string with a length between 1 and 125 characters.
     * @type {string}
     * @memberof DomainContactResponseDto
     */
    'firstName': string;
    /**
     * The last name of the contact. This field must be a non-empty string with a length between 1 and 125 characters.
     * @type {string}
     * @memberof DomainContactResponseDto
     */
    'lastName': string;
    /**
     * The name of the contact’s company or organization. This field is optional and can be up to 250 characters long.
     * @type {string}
     * @memberof DomainContactResponseDto
     */
    'organization'?: string;
    /**
     * The primary line of the contact\'s address, such as the house number and street name. This field is required and must be between 1 and 250 characters.
     * @type {string}
     * @memberof DomainContactResponseDto
     */
    'street1': string;
    /**
     * An optional second line for the contact\'s address, such as an apartment, suite, or unit number. Must not exceed 250 characters.
     * @type {string}
     * @memberof DomainContactResponseDto
     */
    'street2'?: string;
    /**
     * An optional third line for the contact\'s address, typically used for additional address details like a PO box or care-of information. Must not exceed 250 characters.
     * @type {string}
     * @memberof DomainContactResponseDto
     */
    'street3'?: string;
    /**
     * The city associated with the contact\'s address. This is a required field with a maximum length of 250 characters.
     * @type {string}
     * @memberof DomainContactResponseDto
     */
    'city': string;
    /**
     * The contact\'s state or province. This is a required field with a maximum length of 250 characters.
     * @type {string}
     * @memberof DomainContactResponseDto
     */
    'state': string;
    /**
     * The contact\'s Zip Code or Postal Code, which is required and can be between 1 and 16 characters in length.
     * @type {string}
     * @memberof DomainContactResponseDto
     */
    'postcode': string;
    /**
     * The ISO 3166-1-alpha-2 code for the country of the contact. This code represents the contact\'s country and must be a valid 2-letter country code.
     * @type {string}
     * @memberof DomainContactResponseDto
     */
    'countryCode': DomainContactResponseDtoCountryCodeEnum;
    /**
     * The telephone number of the contact, including the international dialing code. The format should be +<InternationalDialingCode>.<TelephoneNumber>.
     * @type {string}
     * @memberof DomainContactResponseDto
     */
    'telephone': string;
    /**
     * The fax number of the contact, including the international dialing code. The format should be +<InternationalDialingCode>.<FaxNumber>.
     * @type {string}
     * @memberof DomainContactResponseDto
     */
    'fax'?: string;
    /**
     * The email address of the contact. It must be a valid email format.
     * @type {string}
     * @memberof DomainContactResponseDto
     */
    'email': string;
    /**
     * Additional data associated with the contact.
     * @type {ContactAdditionalDto}
     * @memberof DomainContactResponseDto
     */
    'additional'?: ContactAdditionalDto;
    /**
     * The unique identifier of the contact.
     * @type {string}
     * @memberof DomainContactResponseDto
     */
    'id': string;
    /**
     * 
     * @type {Company11}
     * @memberof DomainContactResponseDto
     */
    'company': Company11;
    /**
     * A list of custom codes associated with the contact, organized by supplier or integration.
     * @type {Array<ContactCodeDto>}
     * @memberof DomainContactResponseDto
     */
    'contactCodes'?: Array<ContactCodeDto>;
    /**
     * 
     * @type {User5}
     * @memberof DomainContactResponseDto
     */
    'user': User5;
    /**
     * Timestamp indicating when the contact was created in the system.
     * @type {string}
     * @memberof DomainContactResponseDto
     */
    'createdAt'?: string;
    /**
     * Timestamp indicating the last time the contact information was last updated in the system.
     * @type {string}
     * @memberof DomainContactResponseDto
     */
    'updatedAt'?: string;
}

export const DomainContactResponseDtoCountryCodeEnum = {
    Af: 'AF',
    Al: 'AL',
    Dz: 'DZ',
    As: 'AS',
    Ad: 'AD',
    Ao: 'AO',
    Ai: 'AI',
    Aq: 'AQ',
    Ag: 'AG',
    Ar: 'AR',
    Am: 'AM',
    Aw: 'AW',
    Au: 'AU',
    At: 'AT',
    Az: 'AZ',
    Bs: 'BS',
    Bh: 'BH',
    Bd: 'BD',
    Bb: 'BB',
    By: 'BY',
    Be: 'BE',
    Bz: 'BZ',
    Bj: 'BJ',
    Bm: 'BM',
    Bt: 'BT',
    Bo: 'BO',
    Bq: 'BQ',
    Ba: 'BA',
    Bw: 'BW',
    Bv: 'BV',
    Br: 'BR',
    Io: 'IO',
    Bn: 'BN',
    Bg: 'BG',
    Bf: 'BF',
    Bi: 'BI',
    Kh: 'KH',
    Cm: 'CM',
    Ca: 'CA',
    Cv: 'CV',
    Ky: 'KY',
    Cf: 'CF',
    Td: 'TD',
    Cl: 'CL',
    Cn: 'CN',
    Cx: 'CX',
    Cc: 'CC',
    Co: 'CO',
    Km: 'KM',
    Cg: 'CG',
    Cd: 'CD',
    Ck: 'CK',
    Cr: 'CR',
    Ci: 'CI',
    Hr: 'HR',
    Cu: 'CU',
    Cw: 'CW',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Dj: 'DJ',
    Dm: 'DM',
    Do: 'DO',
    Ec: 'EC',
    Eg: 'EG',
    Sv: 'SV',
    Gq: 'GQ',
    Er: 'ER',
    Ee: 'EE',
    Et: 'ET',
    Fk: 'FK',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Gf: 'GF',
    Pf: 'PF',
    Tf: 'TF',
    Ga: 'GA',
    Gm: 'GM',
    Ge: 'GE',
    De: 'DE',
    Gh: 'GH',
    Gi: 'GI',
    Gr: 'GR',
    Gl: 'GL',
    Gd: 'GD',
    Gp: 'GP',
    Gu: 'GU',
    Gt: 'GT',
    Gg: 'GG',
    Gn: 'GN',
    Gw: 'GW',
    Gy: 'GY',
    Ht: 'HT',
    Hm: 'HM',
    Va: 'VA',
    Hn: 'HN',
    Hk: 'HK',
    Hu: 'HU',
    Is: 'IS',
    In: 'IN',
    Id: 'ID',
    Ir: 'IR',
    Iq: 'IQ',
    Ie: 'IE',
    Im: 'IM',
    Il: 'IL',
    It: 'IT',
    Jm: 'JM',
    Jp: 'JP',
    Je: 'JE',
    Jo: 'JO',
    Kz: 'KZ',
    Ke: 'KE',
    Ki: 'KI',
    Kp: 'KP',
    Kr: 'KR',
    Kw: 'KW',
    Kg: 'KG',
    La: 'LA',
    Lv: 'LV',
    Lb: 'LB',
    Ls: 'LS',
    Lr: 'LR',
    Ly: 'LY',
    Li: 'LI',
    Lt: 'LT',
    Lu: 'LU',
    Mo: 'MO',
    Mk: 'MK',
    Mg: 'MG',
    Mw: 'MW',
    My: 'MY',
    Mv: 'MV',
    Ml: 'ML',
    Mt: 'MT',
    Mh: 'MH',
    Mq: 'MQ',
    Mr: 'MR',
    Mu: 'MU',
    Tn: 'TN',
    Tr: 'TR',
    Tm: 'TM',
    Tc: 'TC',
    Tv: 'TV',
    Ug: 'UG',
    Ua: 'UA',
    Ae: 'AE',
    Gb: 'GB',
    Us: 'US',
    Um: 'UM',
    Uy: 'UY',
    Uz: 'UZ',
    Vu: 'VU',
    Ve: 'VE',
    Vn: 'VN',
    Vg: 'VG',
    Vi: 'VI',
    Wf: 'WF',
    Eh: 'EH',
    Ye: 'YE',
    Zm: 'ZM',
    Zw: 'ZW',
    Yt: 'YT',
    Mx: 'MX',
    Fm: 'FM',
    Md: 'MD',
    Mc: 'MC',
    Mn: 'MN',
    Me: 'ME',
    Ms: 'MS',
    Ma: 'MA',
    Mz: 'MZ',
    Mm: 'MM',
    Na: 'NA',
    Nr: 'NR',
    Np: 'NP',
    Nl: 'NL',
    Nc: 'NC',
    Nz: 'NZ',
    Ni: 'NI',
    Ne: 'NE',
    Ng: 'NG',
    Nu: 'NU',
    Nf: 'NF',
    Mp: 'MP',
    No: 'NO',
    Om: 'OM',
    Pk: 'PK',
    Pw: 'PW',
    Ps: 'PS',
    Pa: 'PA',
    Pg: 'PG',
    Py: 'PY',
    Pe: 'PE',
    Ph: 'PH',
    Pn: 'PN',
    Pl: 'PL',
    Pt: 'PT',
    Pr: 'PR',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Ru: 'RU',
    Rw: 'RW',
    Bl: 'BL',
    Sh: 'SH',
    Kn: 'KN',
    Lc: 'LC',
    Mf: 'MF',
    Pm: 'PM',
    Vc: 'VC',
    Ws: 'WS',
    Sm: 'SM',
    St: 'ST',
    Sa: 'SA',
    Sn: 'SN',
    Rs: 'RS',
    Sc: 'SC',
    Sl: 'SL',
    Sg: 'SG',
    Sx: 'SX',
    Sk: 'SK',
    Si: 'SI',
    Sb: 'SB',
    So: 'SO',
    Za: 'ZA',
    Gs: 'GS',
    Ss: 'SS',
    Es: 'ES',
    Lk: 'LK',
    Sd: 'SD',
    Sr: 'SR',
    Sj: 'SJ',
    Sz: 'SZ',
    Se: 'SE',
    Ch: 'CH',
    Sy: 'SY',
    Tw: 'TW',
    Tj: 'TJ',
    Tz: 'TZ',
    Th: 'TH',
    Tl: 'TL',
    Tg: 'TG',
    Tk: 'TK',
    To: 'TO',
    Tt: 'TT'
} as const;

export type DomainContactResponseDtoCountryCodeEnum = typeof DomainContactResponseDtoCountryCodeEnum[keyof typeof DomainContactResponseDtoCountryCodeEnum];

/**
 * 
 * @export
 * @interface DomainNameDataRequestDto
 */
export interface DomainNameDataRequestDto {
    /**
     * Contains the unique identifiers for the various roles associated with the domain (e.g., registrant, admin, tech, billing).
     * @type {RegistryContactsDto}
     * @memberof DomainNameDataRequestDto
     */
    'contacts': RegistryContactsDto;
    /**
     * A list of nameservers associated with the domain. Each nameserver includes the hostname and optional IP addresses.
     * @type {Array<NameserverDto>}
     * @memberof DomainNameDataRequestDto
     */
    'nameservers'?: Array<NameserverDto>;
    /**
     * The EPP (Extensible Provisioning Protocol) code or password associated with the domain name, primarily used for domain transfers.
     * @type {string}
     * @memberof DomainNameDataRequestDto
     */
    'password'?: string;
    /**
     * Indicates whether the domain is locked, preventing unauthorized changes or transfers. Typically used to secure the domain against malicious actions.
     * @type {boolean}
     * @memberof DomainNameDataRequestDto
     */
    'locked'?: boolean;
    /**
     * Indicates whether the domain owner\'s (registrar\'s) information is hidden from public WHOIS records for privacy protection.
     * @type {boolean}
     * @memberof DomainNameDataRequestDto
     */
    'idShield'?: boolean;
    /**
     * A list of domain names registered together as part of a single domain, typically for creating a comprehensive domain setup.
     * @type {Array<DomainBundleDto>}
     * @memberof DomainNameDataRequestDto
     */
    'bundles': Array<DomainBundleDto>;
    /**
     * Additional information required by the TLD (Top-Level Domain). This can include extra details that the registry requests when registering a domain.
     * @type {DomainAdditionalDto}
     * @memberof DomainNameDataRequestDto
     */
    'additional'?: DomainAdditionalDto;
    /**
     * The unique identifier of the top-level domain (TLD) associated with the domain name, representing the domain\'s extension.
     * @type {string}
     * @memberof DomainNameDataRequestDto
     */
    'tld': string;
}
/**
 * 
 * @export
 * @interface DomainNameDataResponseDto
 */
export interface DomainNameDataResponseDto {
    /**
     * Contains the unique identifiers for the various roles associated with the domain (e.g., registrant, admin, tech, billing).
     * @type {RegistryContactsDto}
     * @memberof DomainNameDataResponseDto
     */
    'contacts': RegistryContactsDto;
    /**
     * A list of nameservers associated with the domain. Each nameserver includes the hostname and optional IP addresses.
     * @type {Array<NameserverDto>}
     * @memberof DomainNameDataResponseDto
     */
    'nameservers'?: Array<NameserverDto>;
    /**
     * The EPP (Extensible Provisioning Protocol) code or password associated with the domain name, primarily used for domain transfers.
     * @type {string}
     * @memberof DomainNameDataResponseDto
     */
    'password'?: string;
    /**
     * Indicates whether the domain is locked, preventing unauthorized changes or transfers. Typically used to secure the domain against malicious actions.
     * @type {boolean}
     * @memberof DomainNameDataResponseDto
     */
    'locked'?: boolean;
    /**
     * Indicates whether the domain owner\'s (registrar\'s) information is hidden from public WHOIS records for privacy protection.
     * @type {boolean}
     * @memberof DomainNameDataResponseDto
     */
    'idShield'?: boolean;
    /**
     * A list of domain names registered together as part of a single domain, typically for creating a comprehensive domain setup.
     * @type {Array<DomainBundleDto>}
     * @memberof DomainNameDataResponseDto
     */
    'bundles': Array<DomainBundleDto>;
    /**
     * Additional information required by the TLD (Top-Level Domain). This can include extra details that the registry requests when registering a domain.
     * @type {DomainAdditionalDto}
     * @memberof DomainNameDataResponseDto
     */
    'additional'?: DomainAdditionalDto;
    /**
     * 
     * @type {Tld1}
     * @memberof DomainNameDataResponseDto
     */
    'tld': Tld1;
}
/**
 * 
 * @export
 * @interface DomainPricesDto
 */
export interface DomainPricesDto {
    /**
     * The price for domain transfer in cents.
     * @type {number}
     * @memberof DomainPricesDto
     */
    'transferPrice'?: number;
    /**
     * The price for domain lock in cents.
     * @type {number}
     * @memberof DomainPricesDto
     */
    'lockPrice'?: number;
    /**
     * The price for ID shield in cents.
     * @type {number}
     * @memberof DomainPricesDto
     */
    'idShieldPrice'?: number;
    /**
     * The price for domain proxy service in cents.
     * @type {number}
     * @memberof DomainPricesDto
     */
    'proxyPrice'?: number;
    /**
     * The soft quarantine fee for the domain in cents.
     * @type {number}
     * @memberof DomainPricesDto
     */
    'softQuarantineFee'?: number;
    /**
     * 
     * @type {number}
     * @memberof DomainPricesDto
     */
    'hardQuarantineFee'?: number;
}
/**
 * 
 * @export
 * @interface DonutsPriceCategoryDataDto
 */
export interface DonutsPriceCategoryDataDto {
    /**
     * An additional parameter if the domain checked is a Donuts premium domain
     * @type {string}
     * @memberof DonutsPriceCategoryDataDto
     */
    'priceCategory': DonutsPriceCategoryDataDtoPriceCategoryEnum;
}

export const DonutsPriceCategoryDataDtoPriceCategoryEnum = {
    Category1: 'Category1',
    Category2: 'Category2',
    Category3: 'Category3',
    Category4: 'Category4',
    Category5: 'Category5',
    Category6: 'Category6',
    Category7: 'Category7',
    Category8: 'Category8',
    Category9: 'Category9',
    Category10: 'Category10',
    Category11: 'Category11',
    Category12: 'Category12'
} as const;

export type DonutsPriceCategoryDataDtoPriceCategoryEnum = typeof DonutsPriceCategoryDataDtoPriceCategoryEnum[keyof typeof DonutsPriceCategoryDataDtoPriceCategoryEnum];

/**
 * @type DowngradeTemplate
 * The template for downgrading a product. This field represents the official name or identifier for the template, and it cannot be empty.
 * @export
 */
export type DowngradeTemplate = TemplateResponseDto | string;

/**
 * 
 * @export
 * @interface DynamicPriceDto
 */
export interface DynamicPriceDto {
    /**
     * A key representing the attribute for which the dynamic pricing applies, such as CPU, RAM, or storage.
     * @type {string}
     * @memberof DynamicPriceDto
     */
    'key': string;
    /**
     * The additional cost associated with the selected attribute, contributing to the final price.
     * @type {number}
     * @memberof DynamicPriceDto
     */
    'price': number;
}
/**
 * 
 * @export
 * @interface EditCompanyCommentRequest
 */
export interface EditCompanyCommentRequest {
    /**
     * 
     * @type {string}
     * @memberof EditCompanyCommentRequest
     */
    'comment'?: string;
}
/**
 * 
 * @export
 * @interface EmailPayloadDto
 */
export interface EmailPayloadDto {
    /**
     * The subject of the email
     * @type {string}
     * @memberof EmailPayloadDto
     */
    'subject': string;
    /**
     * The email message content
     * @type {string}
     * @memberof EmailPayloadDto
     */
    'body': string;
    /**
     * An array of attachments
     * @type {Array<AttachmentDto>}
     * @memberof EmailPayloadDto
     */
    'attachments': Array<AttachmentDto>;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {number}
     * @memberof ErrorResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'message': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ErrorResponse
     */
    'details': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface EsAdditionalDataDto
 */
export interface EsAdditionalDataDto {
    /**
     * - 0: Generic ID (a number than is not a Spanish DNI-NIF or NIE, eg passports foreign ID documents, company numbers) - 1: Spanish national personal ID/ company VAT numbers (DNI-NIF) (DNIs and NIFs can be recognized as they are comprised of an alphabetic control character plus a chain of eight numeric characters) - 3: Spanish resident alien ID Number (NIE) 
     * @type {number}
     * @memberof EsAdditionalDataDto
     */
    'identificationType': number;
    /**
     * The personal or corporate ID number of the contact. If the IdentificationType is 1 (DNI-NFI) or 3 (NIE), then this field will be validated to ensure the format is correct.
     * @type {number}
     * @memberof EsAdditionalDataDto
     */
    'identificationNumber': EsAdditionalDataDtoIdentificationNumberEnum;
    /**
     *  These entities are grouped into two types:  - Contacts type \'natural person\': Contacts registered to natural persons or individuals, that is, real persons capable of assuming rights and liabilities, capable of signing documents.  - Contacts type \'juridical person\': Contacts registered to organizations or juridical persons, that is, collective entities that may assume rights and liabilities, though in a limited fashion, such companies, associations, governmental agencies and organizations, etc.  For Contacts type \'natural person\' this field must be set to 1.  For ContactsValue type \'juridical person\' this field must be set to one of the following values:  value - Legal Entity Type * 39 - Economic Interest Grouping * 47 - Association * 59 - Sports Association * 68 - Trade Association * 124 - Savings Bank * 150 - Community Property * 152 - Condominium * 164 - Religious Order or Institution * 181 - Consulate * 197 - Public Law Association * 203 - Embassy * 229 - Municipality * 269 - Sports Federation * 286 - Foundation * 365 - Mutual Insurance Company * 434 - Provincial Government Body * 436 - National Government Body * 439 - Political Party * 476 - Trade Union * 510 - Farm Partnership * 524 - Public Limited Company / Corporation * 525 - Sports Public Limited Company * 554 - Partnership * 560 - General Partnership * 562 - Limited Partnership * 566 - Cooperative * 608 - Worker-owned Company * 612 - Limited Liability Company * 713 - Spanish (company) Branch * 717 - Temporary Consortium / Joint Venture * 744 - Worker-owned Limited Company * 745 - Provincial Government Entity * 746 - National Government Entity * 747 - Local Government Entity * 877 - Others * 878 - Designation of Origin Regulatory Council 
     * @type {number}
     * @memberof EsAdditionalDataDto
     */
    'contactType': EsAdditionalDataDtoContactTypeEnum;
}

export const EsAdditionalDataDtoIdentificationNumberEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_3: 3
} as const;

export type EsAdditionalDataDtoIdentificationNumberEnum = typeof EsAdditionalDataDtoIdentificationNumberEnum[keyof typeof EsAdditionalDataDtoIdentificationNumberEnum];
export const EsAdditionalDataDtoContactTypeEnum = {
    NUMBER_1: 1,
    NUMBER_39: 39,
    NUMBER_47: 47,
    NUMBER_59: 59,
    NUMBER_68: 68,
    NUMBER_124: 124,
    NUMBER_150: 150,
    NUMBER_152: 152,
    NUMBER_164: 164,
    NUMBER_181: 181,
    NUMBER_197: 197,
    NUMBER_203: 203,
    NUMBER_229: 229,
    NUMBER_269: 269,
    NUMBER_286: 286,
    NUMBER_365: 365,
    NUMBER_434: 434,
    NUMBER_436: 436,
    NUMBER_439: 439,
    NUMBER_476: 476,
    NUMBER_510: 510,
    NUMBER_524: 524,
    NUMBER_525: 525,
    NUMBER_554: 554,
    NUMBER_560: 560,
    NUMBER_562: 562,
    NUMBER_566: 566,
    NUMBER_508: 508,
    NUMBER_612: 612,
    NUMBER_713: 713,
    NUMBER_717: 717,
    NUMBER_744: 744,
    NUMBER_745: 745,
    NUMBER_746: 746,
    NUMBER_747: 747,
    NUMBER_877: 877,
    NUMBER_878: 878,
    NUMBER_879: 879
} as const;

export type EsAdditionalDataDtoContactTypeEnum = typeof EsAdditionalDataDtoContactTypeEnum[keyof typeof EsAdditionalDataDtoContactTypeEnum];

/**
 * 
 * @export
 * @interface EuBeAdditionalDataDto
 */
export interface EuBeAdditionalDataDto {
    /**
     * Accepted values: bg, cs, da, de, el, en, es, et, fi, fr, ga, hr, hu, it, lt, lv, mt, nl, pl, pt, ro, sk, sl, sv
     * @type {string}
     * @memberof EuBeAdditionalDataDto
     */
    'language': EuBeAdditionalDataDtoLanguageEnum;
    /**
     * A required string with a maximum length of 20 characters
     * @type {string}
     * @memberof EuBeAdditionalDataDto
     */
    'vatNumber'?: string;
    /**
     * Accepted values: registrant - tech - billing - on-site - reseller
     * @type {string}
     * @memberof EuBeAdditionalDataDto
     */
    'contactType': string;
    /**
     * Indicates whether the contact is a natural person
     * @type {boolean}
     * @memberof EuBeAdditionalDataDto
     */
    'naturalPerson': boolean;
    /**
     * Accepted values: AT, BE, BG, HR, CY, CZ, DK, EE, FI, FR, DE, GR, HU, IE, IT, LV, LT, LU, MT, NL, PL, PT, RO, SK, SI, ES, SE
     * @type {string}
     * @memberof EuBeAdditionalDataDto
     */
    'countryOfCitizenship'?: EuBeAdditionalDataDtoCountryOfCitizenshipEnum;
}

export const EuBeAdditionalDataDtoLanguageEnum = {
    Bg: 'bg',
    Cs: 'cs',
    Da: 'da',
    De: 'de',
    El: 'el',
    En: 'en',
    Es: 'es',
    Et: 'et',
    Fi: 'fi',
    Fr: 'fr',
    Ga: 'ga',
    Hr: 'hr',
    Hu: 'hu',
    It: 'it',
    Lt: 'lt',
    Lv: 'lv',
    Mt: 'mt',
    Nl: 'nl',
    Pl: 'pl',
    Pt: 'pt',
    Ro: 'ro',
    Sk: 'sk',
    Sl: 'sl',
    Sv: 'sv'
} as const;

export type EuBeAdditionalDataDtoLanguageEnum = typeof EuBeAdditionalDataDtoLanguageEnum[keyof typeof EuBeAdditionalDataDtoLanguageEnum];
export const EuBeAdditionalDataDtoCountryOfCitizenshipEnum = {
    At: 'AT',
    Be: 'BE',
    Bg: 'BG',
    Hr: 'HR',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Ee: 'EE',
    Fi: 'FI',
    Fr: 'FR',
    De: 'DE',
    Gr: 'GR',
    Hu: 'HU',
    Ie: 'IE',
    It: 'IT',
    Lv: 'LV',
    Lt: 'LT',
    Lu: 'LU',
    Mt: 'MT',
    Nl: 'NL',
    Pl: 'PL',
    Pt: 'PT',
    Ro: 'RO',
    Sk: 'SK',
    Si: 'SI',
    Es: 'ES',
    Se: 'SE'
} as const;

export type EuBeAdditionalDataDtoCountryOfCitizenshipEnum = typeof EuBeAdditionalDataDtoCountryOfCitizenshipEnum[keyof typeof EuBeAdditionalDataDtoCountryOfCitizenshipEnum];

/**
 * 
 * @export
 * @interface FieldDto
 */
export interface FieldDto {
    /**
     * Unique identifier for the field.
     * @type {string}
     * @memberof FieldDto
     */
    'id': string;
    /**
     * Multilingual label for the field.
     * @type {Array<MultilangTextDto>}
     * @memberof FieldDto
     */
    'label': Array<MultilangTextDto>;
    /**
     * 
     * @type {Value}
     * @memberof FieldDto
     */
    'value': Value;
    /**
     * Type of the field.
     * @type {string}
     * @memberof FieldDto
     */
    'type': FieldDtoTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof FieldDto
     */
    'repeatableMin'?: number;
    /**
     * 
     * @type {number}
     * @memberof FieldDto
     */
    'repeatableMax'?: number;
    /**
     * Whether the field is required.
     * @type {boolean}
     * @memberof FieldDto
     */
    'required': boolean;
    /**
     * Whether the field is disabled.
     * @type {boolean}
     * @memberof FieldDto
     */
    'disabled': boolean;
    /**
     * Whether the field is visible in order.
     * @type {boolean}
     * @memberof FieldDto
     */
    'visibleInOrder': boolean;
    /**
     * Whether the field is visible in client panel.
     * @type {boolean}
     * @memberof FieldDto
     */
    'visibleInClientPanel': boolean;
    /**
     * Optional regex to validate input.
     * @type {string}
     * @memberof FieldDto
     */
    'regexValidation'?: string;
    /**
     * Localized error message shown when regex validation fails.
     * @type {Array<MultilangTextDto>}
     * @memberof FieldDto
     */
    'regexValidationErrorMessage'?: Array<MultilangTextDto>;
    /**
     * If true, field triggers remote validation.
     * @type {boolean}
     * @memberof FieldDto
     */
    'triggersRemoteValidation'?: boolean;
    /**
     * Localized error messages for remote validation.
     * @type {Array<MultilangTextDto>}
     * @memberof FieldDto
     */
    'remoteValidationErrorMessage'?: Array<MultilangTextDto>;
    /**
     * Whether the item attribute is upgradable by the user.
     * @type {boolean}
     * @memberof FieldDto
     */
    'upgradable': boolean;
}

export const FieldDtoTypeEnum = {
    TextBox: 'TEXT_BOX',
    TextArea: 'TEXT_AREA',
    Select: 'SELECT',
    MultiSelect: 'MULTI_SELECT',
    Description: 'DESCRIPTION',
    RadioBox: 'RADIO_BOX',
    Checkbox: 'CHECKBOX',
    Slider: 'SLIDER'
} as const;

export type FieldDtoTypeEnum = typeof FieldDtoTypeEnum[keyof typeof FieldDtoTypeEnum];

/**
 * 
 * @export
 * @interface FieldOptionDto
 */
export interface FieldOptionDto {
    /**
     * Internal key for the option.
     * @type {string}
     * @memberof FieldOptionDto
     */
    'key': string;
    /**
     * Display value for the option.
     * @type {string}
     * @memberof FieldOptionDto
     */
    'value': string;
    /**
     * Whether the option is disabled.
     * @type {boolean}
     * @memberof FieldOptionDto
     */
    'disabled'?: boolean;
}
/**
 * 
 * @export
 * @interface FindAddons200Response
 */
export interface FindAddons200Response {
    /**
     * 
     * @type {any}
     * @memberof FindAddons200Response
     */
    'code': any;
    /**
     * 
     * @type {any}
     * @memberof FindAddons200Response
     */
    'message': any;
    /**
     * 
     * @type {Array<AddonResponseDto>}
     * @memberof FindAddons200Response
     */
    'data': Array<AddonResponseDto>;
    /**
     * 
     * @type {any}
     * @memberof FindAddons200Response
     */
    'currentPage': any;
    /**
     * 
     * @type {any}
     * @memberof FindAddons200Response
     */
    'totalPages': any;
    /**
     * 
     * @type {any}
     * @memberof FindAddons200Response
     */
    'perPage': any;
    /**
     * 
     * @type {any}
     * @memberof FindAddons200Response
     */
    'totalResults': any;
}
/**
 * 
 * @export
 * @interface FindAffiliate200Response
 */
export interface FindAffiliate200Response {
    /**
     * 
     * @type {any}
     * @memberof FindAffiliate200Response
     */
    'code': any;
    /**
     * 
     * @type {any}
     * @memberof FindAffiliate200Response
     */
    'message': any;
    /**
     * 
     * @type {Array<AffiliateResponseDto>}
     * @memberof FindAffiliate200Response
     */
    'data': Array<AffiliateResponseDto>;
    /**
     * 
     * @type {any}
     * @memberof FindAffiliate200Response
     */
    'currentPage': any;
    /**
     * 
     * @type {any}
     * @memberof FindAffiliate200Response
     */
    'totalPages': any;
    /**
     * 
     * @type {any}
     * @memberof FindAffiliate200Response
     */
    'perPage': any;
    /**
     * 
     * @type {any}
     * @memberof FindAffiliate200Response
     */
    'totalResults': any;
}
/**
 * 
 * @export
 * @interface FindCoupons200Response
 */
export interface FindCoupons200Response {
    /**
     * 
     * @type {any}
     * @memberof FindCoupons200Response
     */
    'code': any;
    /**
     * 
     * @type {any}
     * @memberof FindCoupons200Response
     */
    'message': any;
    /**
     * 
     * @type {Array<CouponResponseDto>}
     * @memberof FindCoupons200Response
     */
    'data': Array<CouponResponseDto>;
    /**
     * 
     * @type {any}
     * @memberof FindCoupons200Response
     */
    'currentPage': any;
    /**
     * 
     * @type {any}
     * @memberof FindCoupons200Response
     */
    'totalPages': any;
    /**
     * 
     * @type {any}
     * @memberof FindCoupons200Response
     */
    'perPage': any;
    /**
     * 
     * @type {any}
     * @memberof FindCoupons200Response
     */
    'totalResults': any;
}
/**
 * 
 * @export
 * @interface FindDomainCategories200Response
 */
export interface FindDomainCategories200Response {
    /**
     * 
     * @type {any}
     * @memberof FindDomainCategories200Response
     */
    'code': any;
    /**
     * 
     * @type {any}
     * @memberof FindDomainCategories200Response
     */
    'message': any;
    /**
     * 
     * @type {Array<DomainCategoryResponseDto>}
     * @memberof FindDomainCategories200Response
     */
    'data': Array<DomainCategoryResponseDto>;
    /**
     * 
     * @type {any}
     * @memberof FindDomainCategories200Response
     */
    'currentPage': any;
    /**
     * 
     * @type {any}
     * @memberof FindDomainCategories200Response
     */
    'totalPages': any;
    /**
     * 
     * @type {any}
     * @memberof FindDomainCategories200Response
     */
    'perPage': any;
    /**
     * 
     * @type {any}
     * @memberof FindDomainCategories200Response
     */
    'totalResults': any;
}
/**
 * 
 * @export
 * @interface FindDomainContacts200Response
 */
export interface FindDomainContacts200Response {
    /**
     * 
     * @type {any}
     * @memberof FindDomainContacts200Response
     */
    'code': any;
    /**
     * 
     * @type {any}
     * @memberof FindDomainContacts200Response
     */
    'message': any;
    /**
     * 
     * @type {Array<DomainContactResponseDto>}
     * @memberof FindDomainContacts200Response
     */
    'data': Array<DomainContactResponseDto>;
    /**
     * 
     * @type {any}
     * @memberof FindDomainContacts200Response
     */
    'currentPage': any;
    /**
     * 
     * @type {any}
     * @memberof FindDomainContacts200Response
     */
    'totalPages': any;
    /**
     * 
     * @type {any}
     * @memberof FindDomainContacts200Response
     */
    'perPage': any;
    /**
     * 
     * @type {any}
     * @memberof FindDomainContacts200Response
     */
    'totalResults': any;
}
/**
 * 
 * @export
 * @interface FindInvoices200Response
 */
export interface FindInvoices200Response {
    /**
     * 
     * @type {any}
     * @memberof FindInvoices200Response
     */
    'code': any;
    /**
     * 
     * @type {any}
     * @memberof FindInvoices200Response
     */
    'message': any;
    /**
     * 
     * @type {Array<InvoiceResponseDto>}
     * @memberof FindInvoices200Response
     */
    'data': Array<InvoiceResponseDto>;
    /**
     * 
     * @type {any}
     * @memberof FindInvoices200Response
     */
    'currentPage': any;
    /**
     * 
     * @type {any}
     * @memberof FindInvoices200Response
     */
    'totalPages': any;
    /**
     * 
     * @type {any}
     * @memberof FindInvoices200Response
     */
    'perPage': any;
    /**
     * 
     * @type {any}
     * @memberof FindInvoices200Response
     */
    'totalResults': any;
}
/**
 * 
 * @export
 * @interface FindIssues200Response
 */
export interface FindIssues200Response {
    /**
     * 
     * @type {any}
     * @memberof FindIssues200Response
     */
    'code': any;
    /**
     * 
     * @type {any}
     * @memberof FindIssues200Response
     */
    'message': any;
    /**
     * 
     * @type {Array<IssueResponseDto>}
     * @memberof FindIssues200Response
     */
    'data': Array<IssueResponseDto>;
    /**
     * 
     * @type {any}
     * @memberof FindIssues200Response
     */
    'currentPage': any;
    /**
     * 
     * @type {any}
     * @memberof FindIssues200Response
     */
    'totalPages': any;
    /**
     * 
     * @type {any}
     * @memberof FindIssues200Response
     */
    'perPage': any;
    /**
     * 
     * @type {any}
     * @memberof FindIssues200Response
     */
    'totalResults': any;
}
/**
 * 
 * @export
 * @interface FindPolicies200Response
 */
export interface FindPolicies200Response {
    /**
     * 
     * @type {any}
     * @memberof FindPolicies200Response
     */
    'code': any;
    /**
     * 
     * @type {any}
     * @memberof FindPolicies200Response
     */
    'message': any;
    /**
     * 
     * @type {Array<PolicyResponseDto>}
     * @memberof FindPolicies200Response
     */
    'data': Array<PolicyResponseDto>;
    /**
     * 
     * @type {any}
     * @memberof FindPolicies200Response
     */
    'currentPage': any;
    /**
     * 
     * @type {any}
     * @memberof FindPolicies200Response
     */
    'totalPages': any;
    /**
     * 
     * @type {any}
     * @memberof FindPolicies200Response
     */
    'perPage': any;
    /**
     * 
     * @type {any}
     * @memberof FindPolicies200Response
     */
    'totalResults': any;
}
/**
 * 
 * @export
 * @interface FindProductCategories200Response
 */
export interface FindProductCategories200Response {
    /**
     * 
     * @type {any}
     * @memberof FindProductCategories200Response
     */
    'code': any;
    /**
     * 
     * @type {any}
     * @memberof FindProductCategories200Response
     */
    'message': any;
    /**
     * 
     * @type {Array<ProductCategoryResponseDto>}
     * @memberof FindProductCategories200Response
     */
    'data': Array<ProductCategoryResponseDto>;
    /**
     * 
     * @type {any}
     * @memberof FindProductCategories200Response
     */
    'currentPage': any;
    /**
     * 
     * @type {any}
     * @memberof FindProductCategories200Response
     */
    'totalPages': any;
    /**
     * 
     * @type {any}
     * @memberof FindProductCategories200Response
     */
    'perPage': any;
    /**
     * 
     * @type {any}
     * @memberof FindProductCategories200Response
     */
    'totalResults': any;
}
/**
 * 
 * @export
 * @interface FindTemplates200Response
 */
export interface FindTemplates200Response {
    /**
     * 
     * @type {any}
     * @memberof FindTemplates200Response
     */
    'code': any;
    /**
     * 
     * @type {any}
     * @memberof FindTemplates200Response
     */
    'message': any;
    /**
     * 
     * @type {Array<TemplateResponseDto>}
     * @memberof FindTemplates200Response
     */
    'data': Array<TemplateResponseDto>;
    /**
     * 
     * @type {any}
     * @memberof FindTemplates200Response
     */
    'currentPage': any;
    /**
     * 
     * @type {any}
     * @memberof FindTemplates200Response
     */
    'totalPages': any;
    /**
     * 
     * @type {any}
     * @memberof FindTemplates200Response
     */
    'perPage': any;
    /**
     * 
     * @type {any}
     * @memberof FindTemplates200Response
     */
    'totalResults': any;
}
/**
 * 
 * @export
 * @interface FindTlds200Response
 */
export interface FindTlds200Response {
    /**
     * 
     * @type {any}
     * @memberof FindTlds200Response
     */
    'code': any;
    /**
     * 
     * @type {any}
     * @memberof FindTlds200Response
     */
    'message': any;
    /**
     * 
     * @type {Array<TldResponseDto>}
     * @memberof FindTlds200Response
     */
    'data': Array<TldResponseDto>;
    /**
     * 
     * @type {any}
     * @memberof FindTlds200Response
     */
    'currentPage': any;
    /**
     * 
     * @type {any}
     * @memberof FindTlds200Response
     */
    'totalPages': any;
    /**
     * 
     * @type {any}
     * @memberof FindTlds200Response
     */
    'perPage': any;
    /**
     * 
     * @type {any}
     * @memberof FindTlds200Response
     */
    'totalResults': any;
}
/**
 * 
 * @export
 * @interface FindTransactions200Response
 */
export interface FindTransactions200Response {
    /**
     * 
     * @type {any}
     * @memberof FindTransactions200Response
     */
    'code': any;
    /**
     * 
     * @type {any}
     * @memberof FindTransactions200Response
     */
    'message': any;
    /**
     * 
     * @type {Array<TransactionResponseDto>}
     * @memberof FindTransactions200Response
     */
    'data': Array<TransactionResponseDto>;
    /**
     * 
     * @type {any}
     * @memberof FindTransactions200Response
     */
    'currentPage': any;
    /**
     * 
     * @type {any}
     * @memberof FindTransactions200Response
     */
    'totalPages': any;
    /**
     * 
     * @type {any}
     * @memberof FindTransactions200Response
     */
    'perPage': any;
    /**
     * 
     * @type {any}
     * @memberof FindTransactions200Response
     */
    'totalResults': any;
}
/**
 * 
 * @export
 * @interface GetClientItem200Response
 */
export interface GetClientItem200Response {
    /**
     * The HTTP status code indicating the result of the operation.
     * @type {any}
     * @memberof GetClientItem200Response
     */
    'code': any;
    /**
     * A human-readable message providing more details about the response.
     * @type {any}
     * @memberof GetClientItem200Response
     */
    'message': any;
    /**
     * 
     * @type {ItemClientResponseDto}
     * @memberof GetClientItem200Response
     */
    'data': ItemClientResponseDto;
}
/**
 * 
 * @export
 * @interface GetCompanyBalance200Response
 */
export interface GetCompanyBalance200Response {
    /**
     * The HTTP status code indicating the result of the operation.
     * @type {any}
     * @memberof GetCompanyBalance200Response
     */
    'code': any;
    /**
     * A human-readable message providing more details about the response.
     * @type {any}
     * @memberof GetCompanyBalance200Response
     */
    'message': any;
    /**
     * 
     * @type {CompanyBalanceResponseDto}
     * @memberof GetCompanyBalance200Response
     */
    'data': CompanyBalanceResponseDto;
}
/**
 * 
 * @export
 * @interface GetCompanyPaginatedProducts200Response
 */
export interface GetCompanyPaginatedProducts200Response {
    /**
     * 
     * @type {any}
     * @memberof GetCompanyPaginatedProducts200Response
     */
    'code': any;
    /**
     * 
     * @type {any}
     * @memberof GetCompanyPaginatedProducts200Response
     */
    'message': any;
    /**
     * 
     * @type {Array<ProductResponseDto>}
     * @memberof GetCompanyPaginatedProducts200Response
     */
    'data': Array<ProductResponseDto>;
    /**
     * 
     * @type {any}
     * @memberof GetCompanyPaginatedProducts200Response
     */
    'currentPage': any;
    /**
     * 
     * @type {any}
     * @memberof GetCompanyPaginatedProducts200Response
     */
    'totalPages': any;
    /**
     * 
     * @type {any}
     * @memberof GetCompanyPaginatedProducts200Response
     */
    'perPage': any;
    /**
     * 
     * @type {any}
     * @memberof GetCompanyPaginatedProducts200Response
     */
    'totalResults': any;
}
/**
 * 
 * @export
 * @interface GetCompanyPaginatedUsers200Response
 */
export interface GetCompanyPaginatedUsers200Response {
    /**
     * 
     * @type {any}
     * @memberof GetCompanyPaginatedUsers200Response
     */
    'code': any;
    /**
     * 
     * @type {any}
     * @memberof GetCompanyPaginatedUsers200Response
     */
    'message': any;
    /**
     * 
     * @type {Array<UserResponseDto>}
     * @memberof GetCompanyPaginatedUsers200Response
     */
    'data': Array<UserResponseDto>;
    /**
     * 
     * @type {any}
     * @memberof GetCompanyPaginatedUsers200Response
     */
    'currentPage': any;
    /**
     * 
     * @type {any}
     * @memberof GetCompanyPaginatedUsers200Response
     */
    'totalPages': any;
    /**
     * 
     * @type {any}
     * @memberof GetCompanyPaginatedUsers200Response
     */
    'perPage': any;
    /**
     * 
     * @type {any}
     * @memberof GetCompanyPaginatedUsers200Response
     */
    'totalResults': any;
}
/**
 * 
 * @export
 * @interface GetCompanyPublicInfo200Response
 */
export interface GetCompanyPublicInfo200Response {
    /**
     * The HTTP status code indicating the result of the operation.
     * @type {any}
     * @memberof GetCompanyPublicInfo200Response
     */
    'code': any;
    /**
     * A human-readable message providing more details about the response.
     * @type {any}
     * @memberof GetCompanyPublicInfo200Response
     */
    'message': any;
    /**
     * 
     * @type {CompanyPublicInfoDto}
     * @memberof GetCompanyPublicInfo200Response
     */
    'data': CompanyPublicInfoDto;
}
/**
 * 
 * @export
 * @interface GetIntegrationPublicInfo200Response
 */
export interface GetIntegrationPublicInfo200Response {
    /**
     * The HTTP status code indicating the result of the operation.
     * @type {any}
     * @memberof GetIntegrationPublicInfo200Response
     */
    'code': any;
    /**
     * A human-readable message providing more details about the response.
     * @type {any}
     * @memberof GetIntegrationPublicInfo200Response
     */
    'message': any;
    /**
     * 
     * @type {IntegrationPublicDto}
     * @memberof GetIntegrationPublicInfo200Response
     */
    'data': IntegrationPublicDto;
}
/**
 * 
 * @export
 * @interface GetIntegrations200Response
 */
export interface GetIntegrations200Response {
    /**
     * 
     * @type {any}
     * @memberof GetIntegrations200Response
     */
    'code': any;
    /**
     * 
     * @type {any}
     * @memberof GetIntegrations200Response
     */
    'message': any;
    /**
     * 
     * @type {Array<IntegrationResponseDto>}
     * @memberof GetIntegrations200Response
     */
    'data': Array<IntegrationResponseDto>;
    /**
     * 
     * @type {any}
     * @memberof GetIntegrations200Response
     */
    'currentPage': any;
    /**
     * 
     * @type {any}
     * @memberof GetIntegrations200Response
     */
    'totalPages': any;
    /**
     * 
     * @type {any}
     * @memberof GetIntegrations200Response
     */
    'perPage': any;
    /**
     * 
     * @type {any}
     * @memberof GetIntegrations200Response
     */
    'totalResults': any;
}
/**
 * 
 * @export
 * @interface GetInvoice200Response
 */
export interface GetInvoice200Response {
    /**
     * The HTTP status code indicating the result of the operation.
     * @type {any}
     * @memberof GetInvoice200Response
     */
    'code': any;
    /**
     * A human-readable message providing more details about the response.
     * @type {any}
     * @memberof GetInvoice200Response
     */
    'message': any;
    /**
     * 
     * @type {InvoiceResponseDto}
     * @memberof GetInvoice200Response
     */
    'data': InvoiceResponseDto;
}
/**
 * 
 * @export
 * @interface GetItem200Response
 */
export interface GetItem200Response {
    /**
     * The HTTP status code indicating the result of the operation.
     * @type {any}
     * @memberof GetItem200Response
     */
    'code': any;
    /**
     * A human-readable message providing more details about the response.
     * @type {any}
     * @memberof GetItem200Response
     */
    'message': any;
    /**
     * 
     * @type {ItemResponseDto}
     * @memberof GetItem200Response
     */
    'data': ItemResponseDto;
}
/**
 * 
 * @export
 * @interface GetItemsForTransfer200Response
 */
export interface GetItemsForTransfer200Response {
    /**
     * The HTTP status code indicating the result of the operation.
     * @type {any}
     * @memberof GetItemsForTransfer200Response
     */
    'code': any;
    /**
     * A human-readable message providing more details about the response.
     * @type {any}
     * @memberof GetItemsForTransfer200Response
     */
    'message': any;
    /**
     * 
     * @type {Array<ItemResponseDto>}
     * @memberof GetItemsForTransfer200Response
     */
    'data': Array<ItemResponseDto>;
}
/**
 * 
 * @export
 * @interface GetPaginatedClientItems200Response
 */
export interface GetPaginatedClientItems200Response {
    /**
     * 
     * @type {any}
     * @memberof GetPaginatedClientItems200Response
     */
    'code': any;
    /**
     * 
     * @type {any}
     * @memberof GetPaginatedClientItems200Response
     */
    'message': any;
    /**
     * 
     * @type {Array<ItemClientResponseDto>}
     * @memberof GetPaginatedClientItems200Response
     */
    'data': Array<ItemClientResponseDto>;
    /**
     * 
     * @type {any}
     * @memberof GetPaginatedClientItems200Response
     */
    'currentPage': any;
    /**
     * 
     * @type {any}
     * @memberof GetPaginatedClientItems200Response
     */
    'totalPages': any;
    /**
     * 
     * @type {any}
     * @memberof GetPaginatedClientItems200Response
     */
    'perPage': any;
    /**
     * 
     * @type {any}
     * @memberof GetPaginatedClientItems200Response
     */
    'totalResults': any;
}
/**
 * 
 * @export
 * @interface GetPaginatedCompanies200Response
 */
export interface GetPaginatedCompanies200Response {
    /**
     * 
     * @type {any}
     * @memberof GetPaginatedCompanies200Response
     */
    'code': any;
    /**
     * 
     * @type {any}
     * @memberof GetPaginatedCompanies200Response
     */
    'message': any;
    /**
     * 
     * @type {Array<CompanyResponseDto>}
     * @memberof GetPaginatedCompanies200Response
     */
    'data': Array<CompanyResponseDto>;
    /**
     * 
     * @type {any}
     * @memberof GetPaginatedCompanies200Response
     */
    'currentPage': any;
    /**
     * 
     * @type {any}
     * @memberof GetPaginatedCompanies200Response
     */
    'totalPages': any;
    /**
     * 
     * @type {any}
     * @memberof GetPaginatedCompanies200Response
     */
    'perPage': any;
    /**
     * 
     * @type {any}
     * @memberof GetPaginatedCompanies200Response
     */
    'totalResults': any;
}
/**
 * 
 * @export
 * @interface GetPaginatedItems200Response
 */
export interface GetPaginatedItems200Response {
    /**
     * 
     * @type {any}
     * @memberof GetPaginatedItems200Response
     */
    'code': any;
    /**
     * 
     * @type {any}
     * @memberof GetPaginatedItems200Response
     */
    'message': any;
    /**
     * 
     * @type {Array<ItemResponseDto>}
     * @memberof GetPaginatedItems200Response
     */
    'data': Array<ItemResponseDto>;
    /**
     * 
     * @type {any}
     * @memberof GetPaginatedItems200Response
     */
    'currentPage': any;
    /**
     * 
     * @type {any}
     * @memberof GetPaginatedItems200Response
     */
    'totalPages': any;
    /**
     * 
     * @type {any}
     * @memberof GetPaginatedItems200Response
     */
    'perPage': any;
    /**
     * 
     * @type {any}
     * @memberof GetPaginatedItems200Response
     */
    'totalResults': any;
}
/**
 * 
 * @export
 * @interface GetProduct200Response
 */
export interface GetProduct200Response {
    /**
     * The HTTP status code indicating the result of the operation.
     * @type {any}
     * @memberof GetProduct200Response
     */
    'code': any;
    /**
     * A human-readable message providing more details about the response.
     * @type {any}
     * @memberof GetProduct200Response
     */
    'message': any;
    /**
     * 
     * @type {GetProductResponseDto}
     * @memberof GetProduct200Response
     */
    'data': GetProductResponseDto;
}
/**
 * 
 * @export
 * @interface GetProductResponseDto
 */
export interface GetProductResponseDto {
    /**
     * 
     * @type {Product2}
     * @memberof GetProductResponseDto
     */
    'product': Product2;
    /**
     * Indicates if this product has any associated items that are currently active.
     * @type {boolean}
     * @memberof GetProductResponseDto
     */
    'hasActiveItems': boolean;
}
/**
 * 
 * @export
 * @interface GetUser200Response
 */
export interface GetUser200Response {
    /**
     * The HTTP status code indicating the result of the operation.
     * @type {any}
     * @memberof GetUser200Response
     */
    'code': any;
    /**
     * A human-readable message providing more details about the response.
     * @type {any}
     * @memberof GetUser200Response
     */
    'message': any;
    /**
     * 
     * @type {UserResponseDto}
     * @memberof GetUser200Response
     */
    'data': UserResponseDto;
}
/**
 * 
 * @export
 * @interface GetUserAdditionalNotificationEmails200Response
 */
export interface GetUserAdditionalNotificationEmails200Response {
    /**
     * The HTTP status code indicating the result of the operation.
     * @type {any}
     * @memberof GetUserAdditionalNotificationEmails200Response
     */
    'code': any;
    /**
     * A human-readable message providing more details about the response.
     * @type {any}
     * @memberof GetUserAdditionalNotificationEmails200Response
     */
    'message': any;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetUserAdditionalNotificationEmails200Response
     */
    'data': Array<string>;
}
/**
 * 
 * @export
 * @interface GetUserBalance200Response
 */
export interface GetUserBalance200Response {
    /**
     * The HTTP status code indicating the result of the operation.
     * @type {any}
     * @memberof GetUserBalance200Response
     */
    'code': any;
    /**
     * A human-readable message providing more details about the response.
     * @type {any}
     * @memberof GetUserBalance200Response
     */
    'message': any;
    /**
     * 
     * @type {BalanceResponseDto}
     * @memberof GetUserBalance200Response
     */
    'data': BalanceResponseDto;
}
/**
 * 
 * @export
 * @interface GetUserTransactions200Response
 */
export interface GetUserTransactions200Response {
    /**
     * The HTTP status code indicating the result of the operation.
     * @type {any}
     * @memberof GetUserTransactions200Response
     */
    'code': any;
    /**
     * A human-readable message providing more details about the response.
     * @type {any}
     * @memberof GetUserTransactions200Response
     */
    'message': any;
    /**
     * 
     * @type {Array<TransactionResponseDto>}
     * @memberof GetUserTransactions200Response
     */
    'data': Array<TransactionResponseDto>;
}
/**
 * 
 * @export
 * @interface Gettransaction200Response
 */
export interface Gettransaction200Response {
    /**
     * The HTTP status code indicating the result of the operation.
     * @type {any}
     * @memberof Gettransaction200Response
     */
    'code': any;
    /**
     * A human-readable message providing more details about the response.
     * @type {any}
     * @memberof Gettransaction200Response
     */
    'message': any;
    /**
     * 
     * @type {TransactionResponseDto}
     * @memberof Gettransaction200Response
     */
    'data': TransactionResponseDto;
}
/**
 * 
 * @export
 * @interface InfoDto
 */
export interface InfoDto {
    /**
     * Integration display title.
     * @type {string}
     * @memberof InfoDto
     */
    'title': string;
    /**
     * Public HTTPS URL for the integration logo.
     * @type {string}
     * @memberof InfoDto
     */
    'logo'?: string;
    /**
     * Short description of the integration.
     * @type {string}
     * @memberof InfoDto
     */
    'description'?: string;
    /**
     * Locales supported by the integration.
     * @type {Array<string>}
     * @memberof InfoDto
     */
    'supportedLanguages': Array<InfoDtoSupportedLanguagesEnum>;
    /**
     * Actions supported by this integration.
     * @type {Array<string>}
     * @memberof InfoDto
     */
    'supportedActions'?: Array<InfoDtoSupportedActionsEnum>;
    /**
     * Platform events the integration can subscribe to.
     * @type {Array<string>}
     * @memberof InfoDto
     */
    'listenEvents'?: Array<InfoDtoListenEventsEnum>;
    /**
     * Roles required for this integration to operate.
     * @type {Array<string>}
     * @memberof InfoDto
     */
    'requiredRoles'?: Array<InfoDtoRequiredRolesEnum>;
    /**
     * Admin UI links, tabs, and actions provided by the integration.
     * @type {AdminPanelDto}
     * @memberof InfoDto
     */
    'adminPanel'?: AdminPanelDto;
    /**
     * Client UI links, tabs, and actions provided by the integration.
     * @type {ClientPanelDto}
     * @memberof InfoDto
     */
    'clientPanel'?: ClientPanelDto;
    /**
     * URL to onboard/configure the integration.
     * @type {string}
     * @memberof InfoDto
     */
    'onboardingUrl'?: string;
    /**
     * Configurable attributes that are used in the setup process.
     * @type {Array<FieldDto>}
     * @memberof InfoDto
     */
    'setupAttributes'?: Array<FieldDto>;
}

export const InfoDtoSupportedLanguagesEnum = {
    Ab: 'AB',
    Aa: 'AA',
    Af: 'AF',
    Ak: 'AK',
    Sq: 'SQ',
    Am: 'AM',
    Ar: 'AR',
    An: 'AN',
    Hy: 'HY',
    As: 'AS',
    Av: 'AV',
    Ae: 'AE',
    Ay: 'AY',
    Az: 'AZ',
    Bm: 'BM',
    Ba: 'BA',
    Eu: 'EU',
    Be: 'BE',
    Bn: 'BN',
    Bi: 'BI',
    Bs: 'BS',
    Br: 'BR',
    Bg: 'BG',
    My: 'MY',
    Ca: 'CA',
    Km: 'KM',
    Ch: 'CH',
    Ce: 'CE',
    Ny: 'NY',
    Zh: 'ZH',
    Cu: 'CU',
    Cv: 'CV',
    Kw: 'KW',
    Co: 'CO',
    Cr: 'CR',
    Hr: 'HR',
    Cs: 'CS',
    Da: 'DA',
    Dv: 'DV',
    Nl: 'NL',
    Dz: 'DZ',
    En: 'EN',
    Eo: 'EO',
    Et: 'ET',
    Ee: 'EE',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Ff: 'FF',
    Gl: 'GL',
    Lg: 'LG',
    Ka: 'KA',
    De: 'DE',
    El: 'EL',
    Gn: 'GN',
    Gu: 'GU',
    Ht: 'HT',
    Ha: 'HA',
    He: 'HE',
    Hz: 'HZ',
    Hi: 'HI',
    Ho: 'HO',
    Hu: 'HU',
    Is: 'IS',
    Io: 'IO',
    Ig: 'IG',
    Id: 'ID',
    Ia: 'IA',
    Ie: 'IE',
    Iu: 'IU',
    Ik: 'IK',
    Ga: 'GA',
    It: 'IT',
    Ja: 'JA',
    Jv: 'JV',
    Kl: 'KL',
    Kn: 'KN',
    Kr: 'KR',
    Ks: 'KS',
    Kk: 'KK',
    Ki: 'KI',
    Rw: 'RW',
    Ky: 'KY',
    Kv: 'KV',
    Kg: 'KG',
    Ko: 'KO',
    Kj: 'KJ',
    Ku: 'KU',
    Lo: 'LO',
    La: 'LA',
    Lv: 'LV',
    Li: 'LI',
    Ln: 'LN',
    Lt: 'LT',
    Lu: 'LU',
    Lb: 'LB',
    Mk: 'MK',
    Mg: 'MG',
    Ms: 'MS',
    Ml: 'ML',
    Mt: 'MT',
    Gv: 'GV',
    Mi: 'MI',
    Mr: 'MR',
    Mh: 'MH',
    Mn: 'MN',
    Na: 'NA',
    Nv: 'NV',
    Nd: 'ND',
    Nr: 'NR',
    Ng: 'NG',
    Ne: 'NE',
    Se: 'SE',
    No: 'NO',
    Nb: 'NB',
    Nn: 'NN',
    Ii: 'II',
    Oc: 'OC',
    Oj: 'OJ',
    Or: 'OR',
    Om: 'OM',
    Os: 'OS',
    Pi: 'PI',
    Ps: 'PS',
    Fa: 'FA',
    Pl: 'PL',
    Pt: 'PT',
    Pa: 'PA',
    Qu: 'QU',
    Ro: 'RO',
    Rm: 'RM',
    Rn: 'RN',
    Ru: 'RU',
    Sm: 'SM',
    Sg: 'SG',
    Sa: 'SA',
    Sc: 'SC',
    Gd: 'GD',
    Sr: 'SR',
    Sn: 'SN',
    Ii2: 'II',
    Sd: 'SD',
    Si: 'SI',
    Sk: 'SK',
    Sl: 'SL',
    So: 'SO',
    St: 'ST',
    Es: 'ES',
    Su: 'SU',
    Sw: 'SW',
    Ss: 'SS',
    Sv: 'SV',
    Tl: 'TL',
    Ty: 'TY',
    Tg: 'TG',
    Ta: 'TA',
    Tt: 'TT',
    Te: 'TE',
    Th: 'TH',
    Bo: 'BO',
    Ti: 'TI',
    To: 'TO',
    Ts: 'TS',
    Tn: 'TN',
    Tr: 'TR',
    Tk: 'TK',
    Tw: 'TW',
    Ug: 'UG',
    Uk: 'UK',
    Ur: 'UR',
    Uz: 'UZ',
    Ve: 'VE',
    Vi: 'VI',
    Vo: 'VO',
    Wa: 'WA',
    Cy: 'CY',
    Fy: 'FY',
    Wo: 'WO',
    Xh: 'XH',
    Yi: 'YI',
    Yo: 'YO',
    Za: 'ZA',
    Zu: 'ZU'
} as const;

export type InfoDtoSupportedLanguagesEnum = typeof InfoDtoSupportedLanguagesEnum[keyof typeof InfoDtoSupportedLanguagesEnum];
export const InfoDtoSupportedActionsEnum = {
    Create: 'create',
    Renew: 'renew',
    Upgrade: 'upgrade',
    Downgrade: 'downgrade',
    Transfer: 'transfer',
    Trade: 'trade',
    Suspend: 'suspend',
    Unsuspend: 'unsuspend',
    Delete: 'delete'
} as const;

export type InfoDtoSupportedActionsEnum = typeof InfoDtoSupportedActionsEnum[keyof typeof InfoDtoSupportedActionsEnum];
export const InfoDtoListenEventsEnum = {
    UserCreated: 'user/created',
    UserUpdated: 'user/updated',
    UserDeleted: 'user/deleted',
    UserBanned: 'user/banned',
    UserUnbanned: 'user/unbanned',
    UserCompanyAccessAdded: 'user/company/access/added',
    UserCompanyAccessRemoved: 'user/company/access/removed',
    UserLocked: 'user/locked',
    UserCreditBalanceUpdated: 'user/credit-balance/updated',
    UserUnlocked: 'user/unlocked',
    UserPasswordUpdated: 'user/password/updated',
    UserEmailUpdated: 'user/email/updated',
    UserCurrencyUpdated: 'user/currency/updated',
    UserInvoiceContactUpdated: 'user/invoice-contact/updated',
    UserPolicyUpdated: 'user/policy/updated',
    UserLanguagesUpdated: 'user/languages/updated',
    UserCustomPricePoliciesUpdated: 'user/custom-price-policies/updated',
    UserCustomAddonPricePoliciesUpdated: 'user/custom-addon-price-policies/updated',
    UserCustomAffiliateAdded: 'user/custom-affiliate/added',
    UserCustomAffiliateRemoved: 'user/custom-affiliate/removed',
    UserInvoiceIntervalUpdated: 'user/invoice-interval/updated',
    UserAdditionalNotificationEmailRemoved: 'user/additional-notification-email/removed',
    UserAdditionalNotificationEmailAdded: 'user/additional-notification-email/added',
    UserCommentAdded: 'user/comment/added',
    UserCommentRemoved: 'user/comment/removed',
    UserCommentUpdated: 'user/comment/updated',
    UserTagsUpdated: 'user/tags/updated',
    UserSettingAdded: 'user/setting/added',
    UserSettingRemoved: 'user/setting/removed',
    UserSettingUpdated: 'user/setting/updated',
    UserStartSelling: 'user/start-selling',
    UserRolesUpdated: 'user/roles/updated',
    UserRolesAdded: 'user/roles/added',
    UserRolesDeleted: 'user/roles/deleted',
    MessageCreated: 'message/created',
    MessageUpdated: 'message/updated',
    MessageDeleted: 'message/deleted',
    NotificationSent: 'notification/sent',
    PolicyCreated: 'policy/created',
    PolicyUpdated: 'policy/updated',
    PolicyDeleted: 'policy/deleted',
    ProductCategoryCreated: 'product-category/created',
    ProductCategoryUpdated: 'product-category/updated',
    ProductCategoryDeleted: 'product-category/deleted',
    InvoiceContactCreated: 'invoice-contact/created',
    InvoiceContactUpdated: 'invoice-contact/updated',
    InvoiceContactDeleted: 'invoice-contact/deleted',
    InvoiceCreated: 'invoice/created',
    InvoiceUpdated: 'invoice/updated',
    InvoiceDeleted: 'invoice/deleted',
    CurrencyCreated: 'currency/created',
    CurrencyUpdated: 'currency/updated',
    CurrencyDeleted: 'currency/deleted',
    AffiliateCreated: 'affiliate/created',
    AffiliateUpdated: 'affiliate/updated',
    AffiliateDeleted: 'affiliate/deleted',
    CompanyCreated: 'company/created',
    CompanyUpdated: 'company/updated',
    CompanyDeleted: 'company/deleted',
    OrganizationIntegrationAttached: 'organization/integration/attached',
    OrganizationIntegrationDetached: 'organization/integration/detached',
    TldCreated: 'tld/created',
    TldUpdated: 'tld/updated',
    TldDeleted: 'tld/deleted',
    IntegrationCreated: 'integration/created',
    IntegrationUpdated: 'integration/updated',
    IntegrationDeleted: 'integration/deleted',
    IntegrationInstalled: 'integration/installed',
    IntegrationUninstalled: 'integration/uninstalled',
    IntegrationActivated: 'integration/activated',
    IntegrationDeactivated: 'integration/deactivated',
    IntegrationMaintenanceStarted: 'integration/maintenance-started',
    IntegrationMaintenanceFinished: 'integration/maintenance-finished',
    DomainContactCreated: 'domain-contact/created',
    DomainContactUpdated: 'domain-contact/updated',
    DomainContactDeleted: 'domain-contact/deleted',
    DomainCategoryCreated: 'domain-category/created',
    DomainCategoryUpdated: 'domain-category/updated',
    DomainCategoryDeleted: 'domain-category/deleted',
    AddonCreated: 'addon/created',
    AddonUpdated: 'addon/updated',
    AddonDeleted: 'addon/deleted',
    TransactionCreated: 'transaction/created',
    TransactionCanceled: 'transaction/canceled',
    TransactionFailed: 'transaction/failed',
    TransactionSubscribed: 'transaction/subscribed',
    TransactionUnsubscribed: 'transaction/unsubscribed',
    TransactionUpdated: 'transaction/updated',
    TransactionDeleted: 'transaction/deleted',
    TransactionCompleted: 'transaction/completed',
    TransactionRefunded: 'transaction/refunded',
    TemplateCreated: 'template/created',
    TemplateUpdated: 'template/updated',
    TemplateDeleted: 'template/deleted',
    CouponCreated: 'coupon/created',
    CouponUpdated: 'coupon/updated',
    CouponDeleted: 'coupon/deleted',
    TemplateIntegrationCreated: 'template-integration/created',
    TemplateIntegrationUpdated: 'template-integration/updated',
    TemplateIntegrationDeleted: 'template-integration/deleted',
    OrderCreated: 'order/created',
    OrderStatusInProgress: 'order/status/in-progress',
    OrderStatusCompleted: 'order/status/completed',
    OrderStatusCanceled: 'order/status/canceled',
    OrderStatusPending: 'order/status/pending',
    OrderStatusArchived: 'order/status/archived',
    OrderInsufficientBalance: 'order/insufficient-balance',
    OrderItemDetached: 'order/item-detached',
    OrderInvoiceContactChanged: 'order/invoice-contact-changed',
    OrderUpdated: 'order/updated',
    OrderDeleted: 'order/deleted',
    SettingCreated: 'setting/created',
    SettingUpdated: 'setting/updated',
    SettingDeleted: 'setting/deleted',
    IssueCreated: 'issue/created',
    IssueUpdated: 'issue/updated',
    IssueDeleted: 'issue/deleted',
    TaskCreated: 'task/created',
    TaskUpdated: 'task/updated',
    TaskDeleted: 'task/deleted',
    TaskCanceled: 'task/canceled',
    TaskInProgress: 'task/in-progress',
    TaskCompleted: 'task/completed',
    TaskPercentageUpdated: 'task/percentage/updated',
    ProductCreated: 'product/created',
    ProductUpdated: 'product/updated',
    ProductDeleted: 'product/deleted',
    ProductAutoRenewUpdated: 'product/auto-renew/updated',
    ProductEnabled: 'product/enabled',
    ProductDisabled: 'product/disabled',
    ProductVersionCreated: 'product/version-created',
    IpGroupCreated: 'ip-group/created',
    IpGroupUpdated: 'ip-group/updated',
    IpGroupDeleted: 'ip-group/deleted',
    IpCreated: 'ip/created',
    IpUpdated: 'ip/updated',
    IpDeleted: 'ip/deleted',
    DomainNameCreated: 'domain-name/created',
    DomainNameUpdated: 'domain-name/updated',
    DomainNameDeleted: 'domain-name/deleted',
    DomainNameLocked: 'domain-name/locked',
    DomainNameUnlocked: 'domain-name/unlocked',
    DomainNameIdshieldActivated: 'domain-name/idshield-activated',
    DomainNameIdshieldDeactivated: 'domain-name/idshield-deactivated',
    DomainNameBundleAdded: 'domain-name/bundle-added',
    DomainNameBundleRemoved: 'domain-name/bundle-removed',
    DomainNameRegistrantUpdated: 'domain-name/registrant-updated',
    DomainNameAdminUpdated: 'domain-name/admin-updated',
    DomainNameTechUpdated: 'domain-name/tech-updated',
    DomainNameBillingUpdated: 'domain-name/billing-updated',
    DomainNameAdditionalUpdated: 'domain-name/additional-updated',
    ItemCreated: 'item/created',
    ItemUpdated: 'item/updated',
    ItemDeleted: 'item/deleted',
    ItemRenewed: 'item/renewed',
    ItemUpgraded: 'item/upgraded',
    ItemDowngraded: 'item/downgraded',
    ItemIpAttached: 'item/ip-attached',
    ItemIpDetached: 'item/ip-detached',
    ItemDetachedFromOrder: 'item/detached-from-order',
    ItemPostponed: 'item/postponed',
    ItemTransferredIn: 'item/transferred-in',
    ItemCanceled: 'item/canceled',
    ItemSuspended: 'item/suspended',
    ItemUnsuspended: 'item/unsuspended',
    ItemAffiliateAdded: 'item/affiliate/added',
    ItemBundleAttached: 'item/bundle/attached',
    ItemBundleDetached: 'item/bundle/detached',
    ItemActivated: 'item/activated',
    ItemSetInactive: 'item/set-inactive',
    ItemProcessed: 'item/processed',
    OrderPaid: 'order/paid',
    Test: 'test',
    DeadLettering: 'dead-lettering',
    CoreQueue: 'core-queue'
} as const;

export type InfoDtoListenEventsEnum = typeof InfoDtoListenEventsEnum[keyof typeof InfoDtoListenEventsEnum];
export const InfoDtoRequiredRolesEnum = {
    SimpleUser: 'SIMPLE_USER',
    FullAccess: 'FULL_ACCESS',
    SuperAdmin: 'SUPER_ADMIN',
    OrderRead: 'ORDER_READ',
    OrderWrite: 'ORDER_WRITE',
    AddonRead: 'ADDON_READ',
    AddonWrite: 'ADDON_WRITE',
    AffiliateRead: 'AFFILIATE_READ',
    AffiliateWrite: 'AFFILIATE_WRITE',
    CompanyRead: 'COMPANY_READ',
    CompanyWrite: 'COMPANY_WRITE',
    TemplateRead: 'TEMPLATE_READ',
    TemplateWrite: 'TEMPLATE_WRITE',
    CouponRead: 'COUPON_READ',
    CouponWrite: 'COUPON_WRITE',
    DomainCategoryRead: 'DOMAIN_CATEGORY_READ',
    DomainCategoryWrite: 'DOMAIN_CATEGORY_WRITE',
    DomainContactRead: 'DOMAIN_CONTACT_READ',
    DomainContactWrite: 'DOMAIN_CONTACT_WRITE',
    DomainNameRead: 'DOMAIN_NAME_READ',
    DomainNameWrite: 'DOMAIN_NAME_WRITE',
    InvoiceContactRead: 'INVOICE_CONTACT_READ',
    InvoiceContactWrite: 'INVOICE_CONTACT_WRITE',
    InvoiceRead: 'INVOICE_READ',
    InvoiceWrite: 'INVOICE_WRITE',
    IpGroupsRead: 'IP_GROUPS_READ',
    IpGroupsWrite: 'IP_GROUPS_WRITE',
    IpsRead: 'IPS_READ',
    IpsWrite: 'IPS_WRITE',
    ItemsRead: 'ITEMS_READ',
    ItemsWrite: 'ITEMS_WRITE',
    OrdersRead: 'ORDERS_READ',
    OrdersWrite: 'ORDERS_WRITE',
    TransactionsRead: 'TRANSACTIONS_READ',
    TransactionsWrite: 'TRANSACTIONS_WRITE',
    PoliciesRead: 'POLICIES_READ',
    PoliciesWrite: 'POLICIES_WRITE',
    ProductCategoriesRead: 'PRODUCT_CATEGORIES_READ',
    ProductCategoriesWrite: 'PRODUCT_CATEGORIES_WRITE',
    ProductsRead: 'PRODUCTS_READ',
    ProductsWrite: 'PRODUCTS_WRITE',
    SettingsRead: 'SETTINGS_READ',
    SettingsWrite: 'SETTINGS_WRITE',
    IntegrationsRead: 'INTEGRATIONS_READ',
    IntegrationsWrite: 'INTEGRATIONS_WRITE',
    TldsRead: 'TLDS_READ',
    TldsWrite: 'TLDS_WRITE',
    UsersRead: 'USERS_READ',
    UsersWrite: 'USERS_WRITE',
    IssuesWrite: 'ISSUES_WRITE',
    IssuesRead: 'ISSUES_READ',
    ActionLogsRead: 'ACTION_LOGS_READ'
} as const;

export type InfoDtoRequiredRolesEnum = typeof InfoDtoRequiredRolesEnum[keyof typeof InfoDtoRequiredRolesEnum];

/**
 * 
 * @export
 * @interface InstallCompanyIntegrationRequest
 */
export interface InstallCompanyIntegrationRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof InstallCompanyIntegrationRequest
     */
    'acceptedRoles'?: Array<InstallCompanyIntegrationRequestAcceptedRolesEnum>;
}

export const InstallCompanyIntegrationRequestAcceptedRolesEnum = {
    SimpleUser: 'SIMPLE_USER',
    FullAccess: 'FULL_ACCESS',
    SuperAdmin: 'SUPER_ADMIN',
    OrderRead: 'ORDER_READ',
    OrderWrite: 'ORDER_WRITE',
    AddonRead: 'ADDON_READ',
    AddonWrite: 'ADDON_WRITE',
    AffiliateRead: 'AFFILIATE_READ',
    AffiliateWrite: 'AFFILIATE_WRITE',
    CompanyRead: 'COMPANY_READ',
    CompanyWrite: 'COMPANY_WRITE',
    TemplateRead: 'TEMPLATE_READ',
    TemplateWrite: 'TEMPLATE_WRITE',
    CouponRead: 'COUPON_READ',
    CouponWrite: 'COUPON_WRITE',
    DomainCategoryRead: 'DOMAIN_CATEGORY_READ',
    DomainCategoryWrite: 'DOMAIN_CATEGORY_WRITE',
    DomainContactRead: 'DOMAIN_CONTACT_READ',
    DomainContactWrite: 'DOMAIN_CONTACT_WRITE',
    DomainNameRead: 'DOMAIN_NAME_READ',
    DomainNameWrite: 'DOMAIN_NAME_WRITE',
    InvoiceContactRead: 'INVOICE_CONTACT_READ',
    InvoiceContactWrite: 'INVOICE_CONTACT_WRITE',
    InvoiceRead: 'INVOICE_READ',
    InvoiceWrite: 'INVOICE_WRITE',
    IpGroupsRead: 'IP_GROUPS_READ',
    IpGroupsWrite: 'IP_GROUPS_WRITE',
    IpsRead: 'IPS_READ',
    IpsWrite: 'IPS_WRITE',
    ItemsRead: 'ITEMS_READ',
    ItemsWrite: 'ITEMS_WRITE',
    OrdersRead: 'ORDERS_READ',
    OrdersWrite: 'ORDERS_WRITE',
    TransactionsRead: 'TRANSACTIONS_READ',
    TransactionsWrite: 'TRANSACTIONS_WRITE',
    PoliciesRead: 'POLICIES_READ',
    PoliciesWrite: 'POLICIES_WRITE',
    ProductCategoriesRead: 'PRODUCT_CATEGORIES_READ',
    ProductCategoriesWrite: 'PRODUCT_CATEGORIES_WRITE',
    ProductsRead: 'PRODUCTS_READ',
    ProductsWrite: 'PRODUCTS_WRITE',
    SettingsRead: 'SETTINGS_READ',
    SettingsWrite: 'SETTINGS_WRITE',
    IntegrationsRead: 'INTEGRATIONS_READ',
    IntegrationsWrite: 'INTEGRATIONS_WRITE',
    TldsRead: 'TLDS_READ',
    TldsWrite: 'TLDS_WRITE',
    UsersRead: 'USERS_READ',
    UsersWrite: 'USERS_WRITE',
    IssuesWrite: 'ISSUES_WRITE',
    IssuesRead: 'ISSUES_READ',
    ActionLogsRead: 'ACTION_LOGS_READ'
} as const;

export type InstallCompanyIntegrationRequestAcceptedRolesEnum = typeof InstallCompanyIntegrationRequestAcceptedRolesEnum[keyof typeof InstallCompanyIntegrationRequestAcceptedRolesEnum];

/**
 * @type Integration
 * The integration associated with this payment subscription, including its details and configuration.
 * @export
 */
export type Integration = IntegrationResponseDto | string;

/**
 * @type Integration1
 * The integration id of the template
 * @export
 */
export type Integration1 = IntegrationResponseDto | string;

/**
 * @type Integration2
 * The unique identifier of the integration associated with the invoice.
 * @export
 */
export type Integration2 = IntegrationResponseDto | string;

/**
 * @type Integration3
 * A unique identifier that links the transaction to a specific integration. This field is optional and is used for tracking and reporting on transactions that have been processed through specific partnerships or integrations.
 * @export
 */
export type Integration3 = IntegrationResponseDto | string;

/**
 * @type IntegrationId
 * The unique identifier of the integration associated with the issue.
 * @export
 */
export type IntegrationId = IntegrationResponseDto | string;

/**
 * @type IntegrationInfo
 * All information available about the integration. This information is obtained by calling the /info endpoint of each integration.
 * @export
 */
export type IntegrationInfo = NotificationInfoDto | ProductInfoDto;

/**
 * 
 * @export
 * @interface IntegrationPublicDto
 */
export interface IntegrationPublicDto {
    /**
     * The title of the integration in many possible languages.
     * @type {string}
     * @memberof IntegrationPublicDto
     */
    'title': string;
    /**
     * The type of the service integration.
     * @type {string}
     * @memberof IntegrationPublicDto
     */
    'type': IntegrationPublicDtoTypeEnum;
    /**
     * Indicates if the integration is validated.
     * @type {boolean}
     * @memberof IntegrationPublicDto
     */
    'validated': boolean;
    /**
     * The start date of maintenance.
     * @type {string}
     * @memberof IntegrationPublicDto
     */
    'maintenanceStartDate': string;
    /**
     * The end date of maintenance.
     * @type {string}
     * @memberof IntegrationPublicDto
     */
    'maintenanceEndDate': string;
    /**
     * Indicates if the integration is active.
     * @type {boolean}
     * @memberof IntegrationPublicDto
     */
    'active': boolean;
    /**
     * Detailed information about the public integration.
     * @type {PublicIntegrationInfoDto}
     * @memberof IntegrationPublicDto
     */
    'info': PublicIntegrationInfoDto;
}

export const IntegrationPublicDtoTypeEnum = {
    Product: 'product',
    Notification: 'notification',
    Domain: 'domain',
    Application: 'application',
    Dns: 'dns',
    Payment: 'payment',
    Invoice: 'invoice'
} as const;

export type IntegrationPublicDtoTypeEnum = typeof IntegrationPublicDtoTypeEnum[keyof typeof IntegrationPublicDtoTypeEnum];

/**
 * 
 * @export
 * @interface IntegrationRequestDto
 */
export interface IntegrationRequestDto {
    /**
     * The title of the integration in many possible languages.
     * @type {string}
     * @memberof IntegrationRequestDto
     */
    'title': string;
    /**
     * The type of the service integration.
     * @type {string}
     * @memberof IntegrationRequestDto
     */
    'type': IntegrationRequestDtoTypeEnum;
    /**
     * Indicates whether the integration is public or not. Only public integrations will appear in the marketplace(the list of integrations a company may install)
     * @type {boolean}
     * @memberof IntegrationRequestDto
     */
    'isPublic'?: boolean;
    /**
     * Service integration\'s url.
     * @type {string}
     * @memberof IntegrationRequestDto
     */
    'url': string;
    /**
     * The date that the maintenance will occur. If does not exist then no maintenance is planned
     * @type {string}
     * @memberof IntegrationRequestDto
     */
    'maintenanceStartDate'?: string;
    /**
     * The date that the maintenance will end.
     * @type {string}
     * @memberof IntegrationRequestDto
     */
    'maintenanceEndDate'?: string;
    /**
     * An array of IP addresses that are allowed to access the resource.
     * @type {Array<string>}
     * @memberof IntegrationRequestDto
     */
    'allowedIps'?: Array<string>;
    /**
     * 
     * @type {IntegrationInfo}
     * @memberof IntegrationRequestDto
     */
    'info': IntegrationInfo;
}

export const IntegrationRequestDtoTypeEnum = {
    Product: 'product',
    Notification: 'notification',
    Domain: 'domain',
    Application: 'application',
    Dns: 'dns',
    Payment: 'payment',
    Invoice: 'invoice'
} as const;

export type IntegrationRequestDtoTypeEnum = typeof IntegrationRequestDtoTypeEnum[keyof typeof IntegrationRequestDtoTypeEnum];

/**
 * 
 * @export
 * @interface IntegrationResponseDto
 */
export interface IntegrationResponseDto {
    /**
     * The title of the integration in many possible languages.
     * @type {string}
     * @memberof IntegrationResponseDto
     */
    'title': string;
    /**
     * The type of the service integration.
     * @type {string}
     * @memberof IntegrationResponseDto
     */
    'type': IntegrationResponseDtoTypeEnum;
    /**
     * Indicates whether the integration is public or not. Only public integrations will appear in the marketplace(the list of integrations a company may install)
     * @type {boolean}
     * @memberof IntegrationResponseDto
     */
    'isPublic'?: boolean;
    /**
     * Service integration\'s url.
     * @type {string}
     * @memberof IntegrationResponseDto
     */
    'url': string;
    /**
     * The date that the maintenance will occur. If does not exist then no maintenance is planned
     * @type {string}
     * @memberof IntegrationResponseDto
     */
    'maintenanceStartDate'?: string;
    /**
     * The date that the maintenance will end.
     * @type {string}
     * @memberof IntegrationResponseDto
     */
    'maintenanceEndDate'?: string;
    /**
     * An array of IP addresses that are allowed to access the resource.
     * @type {Array<string>}
     * @memberof IntegrationResponseDto
     */
    'allowedIps'?: Array<string>;
    /**
     * 
     * @type {IntegrationInfo}
     * @memberof IntegrationResponseDto
     */
    'info': IntegrationInfo;
    /**
     * The unique identifier of the integration.
     * @type {string}
     * @memberof IntegrationResponseDto
     */
    'id': string;
    /**
     * 
     * @type {CreatedByCompany}
     * @memberof IntegrationResponseDto
     */
    'createdByCompany': CreatedByCompany;
    /**
     * Indicates whether the integration is active or not.
     * @type {boolean}
     * @memberof IntegrationResponseDto
     */
    'active': boolean;
    /**
     * Indicates whether the integration is validated or not.
     * @type {string}
     * @memberof IntegrationResponseDto
     */
    'validationStatus': IntegrationResponseDtoValidationStatusEnum;
    /**
     * The date and time when the service integration was created.
     * @type {string}
     * @memberof IntegrationResponseDto
     */
    'createdAt': string;
    /**
     * The date and time when the service integration was updated.
     * @type {string}
     * @memberof IntegrationResponseDto
     */
    'updatedAt': string;
}

export const IntegrationResponseDtoTypeEnum = {
    Product: 'product',
    Notification: 'notification',
    Domain: 'domain',
    Application: 'application',
    Dns: 'dns',
    Payment: 'payment',
    Invoice: 'invoice'
} as const;

export type IntegrationResponseDtoTypeEnum = typeof IntegrationResponseDtoTypeEnum[keyof typeof IntegrationResponseDtoTypeEnum];
export const IntegrationResponseDtoValidationStatusEnum = {
    NotValidated: 'not_validated',
    InProgress: 'in_progress',
    Validated: 'validated'
} as const;

export type IntegrationResponseDtoValidationStatusEnum = typeof IntegrationResponseDtoValidationStatusEnum[keyof typeof IntegrationResponseDtoValidationStatusEnum];

/**
 * 
 * @export
 * @interface IntegrationUpdateRequestDto
 */
export interface IntegrationUpdateRequestDto {
    /**
     * Integration title
     * @type {string}
     * @memberof IntegrationUpdateRequestDto
     */
    'title': string;
    /**
     * Integration description
     * @type {string}
     * @memberof IntegrationUpdateRequestDto
     */
    'description': string;
    /**
     * Integration URL
     * @type {string}
     * @memberof IntegrationUpdateRequestDto
     */
    'url': string;
    /**
     * Integration maintenance start date
     * @type {string}
     * @memberof IntegrationUpdateRequestDto
     */
    'maintenanceStartDate': string;
    /**
     * Integration maintenance end date
     * @type {string}
     * @memberof IntegrationUpdateRequestDto
     */
    'maintenanceEndDate': string;
}
/**
 * 
 * @export
 * @interface IntegrationsInfoRequestDto
 */
export interface IntegrationsInfoRequestDto {
    /**
     * A list of roles that the user has explicitly granted access to this integration.
     * @type {Array<string>}
     * @memberof IntegrationsInfoRequestDto
     */
    'acceptedRoles': Array<IntegrationsInfoRequestDtoAcceptedRolesEnum>;
    /**
     * The unique identifier of the integration associated with this configuration.
     * @type {string}
     * @memberof IntegrationsInfoRequestDto
     */
    'integration': string;
}

export const IntegrationsInfoRequestDtoAcceptedRolesEnum = {
    SimpleUser: 'SIMPLE_USER',
    FullAccess: 'FULL_ACCESS',
    SuperAdmin: 'SUPER_ADMIN',
    OrderRead: 'ORDER_READ',
    OrderWrite: 'ORDER_WRITE',
    AddonRead: 'ADDON_READ',
    AddonWrite: 'ADDON_WRITE',
    AffiliateRead: 'AFFILIATE_READ',
    AffiliateWrite: 'AFFILIATE_WRITE',
    CompanyRead: 'COMPANY_READ',
    CompanyWrite: 'COMPANY_WRITE',
    TemplateRead: 'TEMPLATE_READ',
    TemplateWrite: 'TEMPLATE_WRITE',
    CouponRead: 'COUPON_READ',
    CouponWrite: 'COUPON_WRITE',
    DomainCategoryRead: 'DOMAIN_CATEGORY_READ',
    DomainCategoryWrite: 'DOMAIN_CATEGORY_WRITE',
    DomainContactRead: 'DOMAIN_CONTACT_READ',
    DomainContactWrite: 'DOMAIN_CONTACT_WRITE',
    DomainNameRead: 'DOMAIN_NAME_READ',
    DomainNameWrite: 'DOMAIN_NAME_WRITE',
    InvoiceContactRead: 'INVOICE_CONTACT_READ',
    InvoiceContactWrite: 'INVOICE_CONTACT_WRITE',
    InvoiceRead: 'INVOICE_READ',
    InvoiceWrite: 'INVOICE_WRITE',
    IpGroupsRead: 'IP_GROUPS_READ',
    IpGroupsWrite: 'IP_GROUPS_WRITE',
    IpsRead: 'IPS_READ',
    IpsWrite: 'IPS_WRITE',
    ItemsRead: 'ITEMS_READ',
    ItemsWrite: 'ITEMS_WRITE',
    OrdersRead: 'ORDERS_READ',
    OrdersWrite: 'ORDERS_WRITE',
    TransactionsRead: 'TRANSACTIONS_READ',
    TransactionsWrite: 'TRANSACTIONS_WRITE',
    PoliciesRead: 'POLICIES_READ',
    PoliciesWrite: 'POLICIES_WRITE',
    ProductCategoriesRead: 'PRODUCT_CATEGORIES_READ',
    ProductCategoriesWrite: 'PRODUCT_CATEGORIES_WRITE',
    ProductsRead: 'PRODUCTS_READ',
    ProductsWrite: 'PRODUCTS_WRITE',
    SettingsRead: 'SETTINGS_READ',
    SettingsWrite: 'SETTINGS_WRITE',
    IntegrationsRead: 'INTEGRATIONS_READ',
    IntegrationsWrite: 'INTEGRATIONS_WRITE',
    TldsRead: 'TLDS_READ',
    TldsWrite: 'TLDS_WRITE',
    UsersRead: 'USERS_READ',
    UsersWrite: 'USERS_WRITE',
    IssuesWrite: 'ISSUES_WRITE',
    IssuesRead: 'ISSUES_READ',
    ActionLogsRead: 'ACTION_LOGS_READ'
} as const;

export type IntegrationsInfoRequestDtoAcceptedRolesEnum = typeof IntegrationsInfoRequestDtoAcceptedRolesEnum[keyof typeof IntegrationsInfoRequestDtoAcceptedRolesEnum];

/**
 * 
 * @export
 * @interface IntegrationsInfoResponseDto
 */
export interface IntegrationsInfoResponseDto {
    /**
     * A list of roles that the user has explicitly granted access to this integration.
     * @type {Array<string>}
     * @memberof IntegrationsInfoResponseDto
     */
    'acceptedRoles': Array<IntegrationsInfoResponseDtoAcceptedRolesEnum>;
    /**
     * 
     * @type {IntegrationId}
     * @memberof IntegrationsInfoResponseDto
     */
    'integration': IntegrationId;
}

export const IntegrationsInfoResponseDtoAcceptedRolesEnum = {
    SimpleUser: 'SIMPLE_USER',
    FullAccess: 'FULL_ACCESS',
    SuperAdmin: 'SUPER_ADMIN',
    OrderRead: 'ORDER_READ',
    OrderWrite: 'ORDER_WRITE',
    AddonRead: 'ADDON_READ',
    AddonWrite: 'ADDON_WRITE',
    AffiliateRead: 'AFFILIATE_READ',
    AffiliateWrite: 'AFFILIATE_WRITE',
    CompanyRead: 'COMPANY_READ',
    CompanyWrite: 'COMPANY_WRITE',
    TemplateRead: 'TEMPLATE_READ',
    TemplateWrite: 'TEMPLATE_WRITE',
    CouponRead: 'COUPON_READ',
    CouponWrite: 'COUPON_WRITE',
    DomainCategoryRead: 'DOMAIN_CATEGORY_READ',
    DomainCategoryWrite: 'DOMAIN_CATEGORY_WRITE',
    DomainContactRead: 'DOMAIN_CONTACT_READ',
    DomainContactWrite: 'DOMAIN_CONTACT_WRITE',
    DomainNameRead: 'DOMAIN_NAME_READ',
    DomainNameWrite: 'DOMAIN_NAME_WRITE',
    InvoiceContactRead: 'INVOICE_CONTACT_READ',
    InvoiceContactWrite: 'INVOICE_CONTACT_WRITE',
    InvoiceRead: 'INVOICE_READ',
    InvoiceWrite: 'INVOICE_WRITE',
    IpGroupsRead: 'IP_GROUPS_READ',
    IpGroupsWrite: 'IP_GROUPS_WRITE',
    IpsRead: 'IPS_READ',
    IpsWrite: 'IPS_WRITE',
    ItemsRead: 'ITEMS_READ',
    ItemsWrite: 'ITEMS_WRITE',
    OrdersRead: 'ORDERS_READ',
    OrdersWrite: 'ORDERS_WRITE',
    TransactionsRead: 'TRANSACTIONS_READ',
    TransactionsWrite: 'TRANSACTIONS_WRITE',
    PoliciesRead: 'POLICIES_READ',
    PoliciesWrite: 'POLICIES_WRITE',
    ProductCategoriesRead: 'PRODUCT_CATEGORIES_READ',
    ProductCategoriesWrite: 'PRODUCT_CATEGORIES_WRITE',
    ProductsRead: 'PRODUCTS_READ',
    ProductsWrite: 'PRODUCTS_WRITE',
    SettingsRead: 'SETTINGS_READ',
    SettingsWrite: 'SETTINGS_WRITE',
    IntegrationsRead: 'INTEGRATIONS_READ',
    IntegrationsWrite: 'INTEGRATIONS_WRITE',
    TldsRead: 'TLDS_READ',
    TldsWrite: 'TLDS_WRITE',
    UsersRead: 'USERS_READ',
    UsersWrite: 'USERS_WRITE',
    IssuesWrite: 'ISSUES_WRITE',
    IssuesRead: 'ISSUES_READ',
    ActionLogsRead: 'ACTION_LOGS_READ'
} as const;

export type IntegrationsInfoResponseDtoAcceptedRolesEnum = typeof IntegrationsInfoResponseDtoAcceptedRolesEnum[keyof typeof IntegrationsInfoResponseDtoAcceptedRolesEnum];

/**
 * 
 * @export
 * @interface IntendedUseParamsDataDto
 */
export interface IntendedUseParamsDataDto {
    /**
     * The intended use of the requested domain.
     * @type {string}
     * @memberof IntendedUseParamsDataDto
     */
    'intendedUse': string;
    /**
     * A reference URL to an existing public online presence of the authority.
     * @type {string}
     * @memberof IntendedUseParamsDataDto
     */
    'referenceUrl'?: string;
    /**
     * The trademark ID if applicable.
     * @type {string}
     * @memberof IntendedUseParamsDataDto
     */
    'trademarkId'?: string;
    /**
     * The issuer of the trademark, if applicable.
     * @type {string}
     * @memberof IntendedUseParamsDataDto
     */
    'trademarkIssuer'?: string;
}
/**
 * @type InvoiceContact
 * Optional contact details associated with invoicing, used for billing-related communications.
 * @export
 */
export type InvoiceContact = InvoiceContactResponseDto | string;

/**
 * @type InvoiceContact1
 * A unique identifier assigned to the billing contact to ensure precise reference within the system.
 * @export
 */
export type InvoiceContact1 = InvoiceContactResponseDto | string;

/**
 * Represents detailed information about the billing contact associated with this order. This includes the individual\'s unique identifier, name, and optionally, their company name. Essential for identifying the entity responsible for the invoice and order ownership.
 * @export
 * @interface InvoiceContact2
 */
export interface InvoiceContact2 {
    /**
     *  The first name of the individual designated as the billing contact.
     * @type {any}
     * @memberof InvoiceContact2
     */
    'firstName': any;
    /**
     * The last name of the billing contact, complementing their first name for full identification.
     * @type {any}
     * @memberof InvoiceContact2
     */
    'lastName': any;
    /**
     * The official name of the company associated with the billing contact, if applicable.
     * @type {any}
     * @memberof InvoiceContact2
     */
    'companyName': any;
    /**
     * 
     * @type {InvoiceContact1}
     * @memberof InvoiceContact2
     */
    'invoiceContact': InvoiceContact1;
}
/**
 * 
 * @export
 * @interface InvoiceContactInfoResponseDto
 */
export interface InvoiceContactInfoResponseDto {
    /**
     *  The first name of the individual designated as the billing contact.
     * @type {string}
     * @memberof InvoiceContactInfoResponseDto
     */
    'firstName': string;
    /**
     * The last name of the billing contact, complementing their first name for full identification.
     * @type {string}
     * @memberof InvoiceContactInfoResponseDto
     */
    'lastName': string;
    /**
     * The official name of the company associated with the billing contact, if applicable.
     * @type {string}
     * @memberof InvoiceContactInfoResponseDto
     */
    'companyName': string;
    /**
     * 
     * @type {InvoiceContact1}
     * @memberof InvoiceContactInfoResponseDto
     */
    'invoiceContact': InvoiceContact1;
}
/**
 * 
 * @export
 * @interface InvoiceContactRequestDto
 */
export interface InvoiceContactRequestDto {
    /**
     * Indicates whether the contact is associated with a company or represents an individual.
     * @type {boolean}
     * @memberof InvoiceContactRequestDto
     */
    'isCompany'?: boolean;
    /**
     * The email address of the contact.
     * @type {string}
     * @memberof InvoiceContactRequestDto
     */
    'email': string;
    /**
     * The first name of the contact.
     * @type {string}
     * @memberof InvoiceContactRequestDto
     */
    'firstName': string;
    /**
     * The last name of the contact.
     * @type {string}
     * @memberof InvoiceContactRequestDto
     */
    'lastName': string;
    /**
     * The name of the company if the contact represents a company.
     * @type {string}
     * @memberof InvoiceContactRequestDto
     */
    'companyName': string;
    /**
     * The telephone number of the contact.
     * @type {string}
     * @memberof InvoiceContactRequestDto
     */
    'telephone': string;
    /**
     * The mobile number of the contact.
     * @type {string}
     * @memberof InvoiceContactRequestDto
     */
    'mobile': string;
    /**
     * The first address line.
     * @type {string}
     * @memberof InvoiceContactRequestDto
     */
    'address1': string;
    /**
     * The second address line.
     * @type {string}
     * @memberof InvoiceContactRequestDto
     */
    'address2': string;
    /**
     * The third address line.
     * @type {string}
     * @memberof InvoiceContactRequestDto
     */
    'address3': string;
    /**
     * The postal code or ZIP code.
     * @type {string}
     * @memberof InvoiceContactRequestDto
     */
    'postcode': string;
    /**
     * The city where the contact is located.
     * @type {string}
     * @memberof InvoiceContactRequestDto
     */
    'city': string;
    /**
     * The country where the contact is located.
     * @type {string}
     * @memberof InvoiceContactRequestDto
     */
    'country': InvoiceContactRequestDtoCountryEnum;
    /**
     * The state or region where the contact is located.
     * @type {string}
     * @memberof InvoiceContactRequestDto
     */
    'state': string;
    /**
     * The Value Added Tax (VAT) number of the contact.
     * @type {string}
     * @memberof InvoiceContactRequestDto
     */
    'vat': string;
    /**
     * The tax office related to the contact.
     * @type {string}
     * @memberof InvoiceContactRequestDto
     */
    'taxOffice': string;
}

export const InvoiceContactRequestDtoCountryEnum = {
    Af: 'AF',
    Al: 'AL',
    Dz: 'DZ',
    As: 'AS',
    Ad: 'AD',
    Ao: 'AO',
    Ai: 'AI',
    Aq: 'AQ',
    Ag: 'AG',
    Ar: 'AR',
    Am: 'AM',
    Aw: 'AW',
    Au: 'AU',
    At: 'AT',
    Az: 'AZ',
    Bs: 'BS',
    Bh: 'BH',
    Bd: 'BD',
    Bb: 'BB',
    By: 'BY',
    Be: 'BE',
    Bz: 'BZ',
    Bj: 'BJ',
    Bm: 'BM',
    Bt: 'BT',
    Bo: 'BO',
    Bq: 'BQ',
    Ba: 'BA',
    Bw: 'BW',
    Bv: 'BV',
    Br: 'BR',
    Io: 'IO',
    Bn: 'BN',
    Bg: 'BG',
    Bf: 'BF',
    Bi: 'BI',
    Kh: 'KH',
    Cm: 'CM',
    Ca: 'CA',
    Cv: 'CV',
    Ky: 'KY',
    Cf: 'CF',
    Td: 'TD',
    Cl: 'CL',
    Cn: 'CN',
    Cx: 'CX',
    Cc: 'CC',
    Co: 'CO',
    Km: 'KM',
    Cg: 'CG',
    Cd: 'CD',
    Ck: 'CK',
    Cr: 'CR',
    Ci: 'CI',
    Hr: 'HR',
    Cu: 'CU',
    Cw: 'CW',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Dj: 'DJ',
    Dm: 'DM',
    Do: 'DO',
    Ec: 'EC',
    Eg: 'EG',
    Sv: 'SV',
    Gq: 'GQ',
    Er: 'ER',
    Ee: 'EE',
    Et: 'ET',
    Fk: 'FK',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Gf: 'GF',
    Pf: 'PF',
    Tf: 'TF',
    Ga: 'GA',
    Gm: 'GM',
    Ge: 'GE',
    De: 'DE',
    Gh: 'GH',
    Gi: 'GI',
    Gr: 'GR',
    Gl: 'GL',
    Gd: 'GD',
    Gp: 'GP',
    Gu: 'GU',
    Gt: 'GT',
    Gg: 'GG',
    Gn: 'GN',
    Gw: 'GW',
    Gy: 'GY',
    Ht: 'HT',
    Hm: 'HM',
    Va: 'VA',
    Hn: 'HN',
    Hk: 'HK',
    Hu: 'HU',
    Is: 'IS',
    In: 'IN',
    Id: 'ID',
    Ir: 'IR',
    Iq: 'IQ',
    Ie: 'IE',
    Im: 'IM',
    Il: 'IL',
    It: 'IT',
    Jm: 'JM',
    Jp: 'JP',
    Je: 'JE',
    Jo: 'JO',
    Kz: 'KZ',
    Ke: 'KE',
    Ki: 'KI',
    Kp: 'KP',
    Kr: 'KR',
    Kw: 'KW',
    Kg: 'KG',
    La: 'LA',
    Lv: 'LV',
    Lb: 'LB',
    Ls: 'LS',
    Lr: 'LR',
    Ly: 'LY',
    Li: 'LI',
    Lt: 'LT',
    Lu: 'LU',
    Mo: 'MO',
    Mk: 'MK',
    Mg: 'MG',
    Mw: 'MW',
    My: 'MY',
    Mv: 'MV',
    Ml: 'ML',
    Mt: 'MT',
    Mh: 'MH',
    Mq: 'MQ',
    Mr: 'MR',
    Mu: 'MU',
    Tn: 'TN',
    Tr: 'TR',
    Tm: 'TM',
    Tc: 'TC',
    Tv: 'TV',
    Ug: 'UG',
    Ua: 'UA',
    Ae: 'AE',
    Gb: 'GB',
    Us: 'US',
    Um: 'UM',
    Uy: 'UY',
    Uz: 'UZ',
    Vu: 'VU',
    Ve: 'VE',
    Vn: 'VN',
    Vg: 'VG',
    Vi: 'VI',
    Wf: 'WF',
    Eh: 'EH',
    Ye: 'YE',
    Zm: 'ZM',
    Zw: 'ZW',
    Yt: 'YT',
    Mx: 'MX',
    Fm: 'FM',
    Md: 'MD',
    Mc: 'MC',
    Mn: 'MN',
    Me: 'ME',
    Ms: 'MS',
    Ma: 'MA',
    Mz: 'MZ',
    Mm: 'MM',
    Na: 'NA',
    Nr: 'NR',
    Np: 'NP',
    Nl: 'NL',
    Nc: 'NC',
    Nz: 'NZ',
    Ni: 'NI',
    Ne: 'NE',
    Ng: 'NG',
    Nu: 'NU',
    Nf: 'NF',
    Mp: 'MP',
    No: 'NO',
    Om: 'OM',
    Pk: 'PK',
    Pw: 'PW',
    Ps: 'PS',
    Pa: 'PA',
    Pg: 'PG',
    Py: 'PY',
    Pe: 'PE',
    Ph: 'PH',
    Pn: 'PN',
    Pl: 'PL',
    Pt: 'PT',
    Pr: 'PR',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Ru: 'RU',
    Rw: 'RW',
    Bl: 'BL',
    Sh: 'SH',
    Kn: 'KN',
    Lc: 'LC',
    Mf: 'MF',
    Pm: 'PM',
    Vc: 'VC',
    Ws: 'WS',
    Sm: 'SM',
    St: 'ST',
    Sa: 'SA',
    Sn: 'SN',
    Rs: 'RS',
    Sc: 'SC',
    Sl: 'SL',
    Sg: 'SG',
    Sx: 'SX',
    Sk: 'SK',
    Si: 'SI',
    Sb: 'SB',
    So: 'SO',
    Za: 'ZA',
    Gs: 'GS',
    Ss: 'SS',
    Es: 'ES',
    Lk: 'LK',
    Sd: 'SD',
    Sr: 'SR',
    Sj: 'SJ',
    Sz: 'SZ',
    Se: 'SE',
    Ch: 'CH',
    Sy: 'SY',
    Tw: 'TW',
    Tj: 'TJ',
    Tz: 'TZ',
    Th: 'TH',
    Tl: 'TL',
    Tg: 'TG',
    Tk: 'TK',
    To: 'TO',
    Tt: 'TT'
} as const;

export type InvoiceContactRequestDtoCountryEnum = typeof InvoiceContactRequestDtoCountryEnum[keyof typeof InvoiceContactRequestDtoCountryEnum];

/**
 * 
 * @export
 * @interface InvoiceContactResponseDto
 */
export interface InvoiceContactResponseDto {
    /**
     * Indicates whether the contact is associated with a company or represents an individual.
     * @type {boolean}
     * @memberof InvoiceContactResponseDto
     */
    'isCompany'?: boolean;
    /**
     * The email address of the contact.
     * @type {string}
     * @memberof InvoiceContactResponseDto
     */
    'email': string;
    /**
     * The first name of the contact.
     * @type {string}
     * @memberof InvoiceContactResponseDto
     */
    'firstName': string;
    /**
     * The last name of the contact.
     * @type {string}
     * @memberof InvoiceContactResponseDto
     */
    'lastName': string;
    /**
     * The name of the company if the contact represents a company.
     * @type {string}
     * @memberof InvoiceContactResponseDto
     */
    'companyName': string;
    /**
     * The telephone number of the contact.
     * @type {string}
     * @memberof InvoiceContactResponseDto
     */
    'telephone': string;
    /**
     * The mobile number of the contact.
     * @type {string}
     * @memberof InvoiceContactResponseDto
     */
    'mobile': string;
    /**
     * The first address line.
     * @type {string}
     * @memberof InvoiceContactResponseDto
     */
    'address1': string;
    /**
     * The second address line.
     * @type {string}
     * @memberof InvoiceContactResponseDto
     */
    'address2': string;
    /**
     * The third address line.
     * @type {string}
     * @memberof InvoiceContactResponseDto
     */
    'address3': string;
    /**
     * The postal code or ZIP code.
     * @type {string}
     * @memberof InvoiceContactResponseDto
     */
    'postcode': string;
    /**
     * The city where the contact is located.
     * @type {string}
     * @memberof InvoiceContactResponseDto
     */
    'city': string;
    /**
     * The country where the contact is located.
     * @type {string}
     * @memberof InvoiceContactResponseDto
     */
    'country': InvoiceContactResponseDtoCountryEnum;
    /**
     * The state or region where the contact is located.
     * @type {string}
     * @memberof InvoiceContactResponseDto
     */
    'state': string;
    /**
     * The Value Added Tax (VAT) number of the contact.
     * @type {string}
     * @memberof InvoiceContactResponseDto
     */
    'vat': string;
    /**
     * The tax office related to the contact.
     * @type {string}
     * @memberof InvoiceContactResponseDto
     */
    'taxOffice': string;
    /**
     * The unique identifier for the contact.
     * @type {string}
     * @memberof InvoiceContactResponseDto
     */
    'id': string;
    /**
     * 
     * @type {Company3}
     * @memberof InvoiceContactResponseDto
     */
    'company': Company3;
    /**
     * 
     * @type {User1}
     * @memberof InvoiceContactResponseDto
     */
    'user': User1;
    /**
     * The date and time when the contact was created.
     * @type {string}
     * @memberof InvoiceContactResponseDto
     */
    'createdAt': string;
    /**
     * The date and time when the contact was last updated.
     * @type {string}
     * @memberof InvoiceContactResponseDto
     */
    'updatedAt': string;
}

export const InvoiceContactResponseDtoCountryEnum = {
    Af: 'AF',
    Al: 'AL',
    Dz: 'DZ',
    As: 'AS',
    Ad: 'AD',
    Ao: 'AO',
    Ai: 'AI',
    Aq: 'AQ',
    Ag: 'AG',
    Ar: 'AR',
    Am: 'AM',
    Aw: 'AW',
    Au: 'AU',
    At: 'AT',
    Az: 'AZ',
    Bs: 'BS',
    Bh: 'BH',
    Bd: 'BD',
    Bb: 'BB',
    By: 'BY',
    Be: 'BE',
    Bz: 'BZ',
    Bj: 'BJ',
    Bm: 'BM',
    Bt: 'BT',
    Bo: 'BO',
    Bq: 'BQ',
    Ba: 'BA',
    Bw: 'BW',
    Bv: 'BV',
    Br: 'BR',
    Io: 'IO',
    Bn: 'BN',
    Bg: 'BG',
    Bf: 'BF',
    Bi: 'BI',
    Kh: 'KH',
    Cm: 'CM',
    Ca: 'CA',
    Cv: 'CV',
    Ky: 'KY',
    Cf: 'CF',
    Td: 'TD',
    Cl: 'CL',
    Cn: 'CN',
    Cx: 'CX',
    Cc: 'CC',
    Co: 'CO',
    Km: 'KM',
    Cg: 'CG',
    Cd: 'CD',
    Ck: 'CK',
    Cr: 'CR',
    Ci: 'CI',
    Hr: 'HR',
    Cu: 'CU',
    Cw: 'CW',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Dj: 'DJ',
    Dm: 'DM',
    Do: 'DO',
    Ec: 'EC',
    Eg: 'EG',
    Sv: 'SV',
    Gq: 'GQ',
    Er: 'ER',
    Ee: 'EE',
    Et: 'ET',
    Fk: 'FK',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Gf: 'GF',
    Pf: 'PF',
    Tf: 'TF',
    Ga: 'GA',
    Gm: 'GM',
    Ge: 'GE',
    De: 'DE',
    Gh: 'GH',
    Gi: 'GI',
    Gr: 'GR',
    Gl: 'GL',
    Gd: 'GD',
    Gp: 'GP',
    Gu: 'GU',
    Gt: 'GT',
    Gg: 'GG',
    Gn: 'GN',
    Gw: 'GW',
    Gy: 'GY',
    Ht: 'HT',
    Hm: 'HM',
    Va: 'VA',
    Hn: 'HN',
    Hk: 'HK',
    Hu: 'HU',
    Is: 'IS',
    In: 'IN',
    Id: 'ID',
    Ir: 'IR',
    Iq: 'IQ',
    Ie: 'IE',
    Im: 'IM',
    Il: 'IL',
    It: 'IT',
    Jm: 'JM',
    Jp: 'JP',
    Je: 'JE',
    Jo: 'JO',
    Kz: 'KZ',
    Ke: 'KE',
    Ki: 'KI',
    Kp: 'KP',
    Kr: 'KR',
    Kw: 'KW',
    Kg: 'KG',
    La: 'LA',
    Lv: 'LV',
    Lb: 'LB',
    Ls: 'LS',
    Lr: 'LR',
    Ly: 'LY',
    Li: 'LI',
    Lt: 'LT',
    Lu: 'LU',
    Mo: 'MO',
    Mk: 'MK',
    Mg: 'MG',
    Mw: 'MW',
    My: 'MY',
    Mv: 'MV',
    Ml: 'ML',
    Mt: 'MT',
    Mh: 'MH',
    Mq: 'MQ',
    Mr: 'MR',
    Mu: 'MU',
    Tn: 'TN',
    Tr: 'TR',
    Tm: 'TM',
    Tc: 'TC',
    Tv: 'TV',
    Ug: 'UG',
    Ua: 'UA',
    Ae: 'AE',
    Gb: 'GB',
    Us: 'US',
    Um: 'UM',
    Uy: 'UY',
    Uz: 'UZ',
    Vu: 'VU',
    Ve: 'VE',
    Vn: 'VN',
    Vg: 'VG',
    Vi: 'VI',
    Wf: 'WF',
    Eh: 'EH',
    Ye: 'YE',
    Zm: 'ZM',
    Zw: 'ZW',
    Yt: 'YT',
    Mx: 'MX',
    Fm: 'FM',
    Md: 'MD',
    Mc: 'MC',
    Mn: 'MN',
    Me: 'ME',
    Ms: 'MS',
    Ma: 'MA',
    Mz: 'MZ',
    Mm: 'MM',
    Na: 'NA',
    Nr: 'NR',
    Np: 'NP',
    Nl: 'NL',
    Nc: 'NC',
    Nz: 'NZ',
    Ni: 'NI',
    Ne: 'NE',
    Ng: 'NG',
    Nu: 'NU',
    Nf: 'NF',
    Mp: 'MP',
    No: 'NO',
    Om: 'OM',
    Pk: 'PK',
    Pw: 'PW',
    Ps: 'PS',
    Pa: 'PA',
    Pg: 'PG',
    Py: 'PY',
    Pe: 'PE',
    Ph: 'PH',
    Pn: 'PN',
    Pl: 'PL',
    Pt: 'PT',
    Pr: 'PR',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Ru: 'RU',
    Rw: 'RW',
    Bl: 'BL',
    Sh: 'SH',
    Kn: 'KN',
    Lc: 'LC',
    Mf: 'MF',
    Pm: 'PM',
    Vc: 'VC',
    Ws: 'WS',
    Sm: 'SM',
    St: 'ST',
    Sa: 'SA',
    Sn: 'SN',
    Rs: 'RS',
    Sc: 'SC',
    Sl: 'SL',
    Sg: 'SG',
    Sx: 'SX',
    Sk: 'SK',
    Si: 'SI',
    Sb: 'SB',
    So: 'SO',
    Za: 'ZA',
    Gs: 'GS',
    Ss: 'SS',
    Es: 'ES',
    Lk: 'LK',
    Sd: 'SD',
    Sr: 'SR',
    Sj: 'SJ',
    Sz: 'SZ',
    Se: 'SE',
    Ch: 'CH',
    Sy: 'SY',
    Tw: 'TW',
    Tj: 'TJ',
    Tz: 'TZ',
    Th: 'TH',
    Tl: 'TL',
    Tg: 'TG',
    Tk: 'TK',
    To: 'TO',
    Tt: 'TT'
} as const;

export type InvoiceContactResponseDtoCountryEnum = typeof InvoiceContactResponseDtoCountryEnum[keyof typeof InvoiceContactResponseDtoCountryEnum];

/**
 * 
 * @export
 * @interface InvoiceResponseDto
 */
export interface InvoiceResponseDto {
    /**
     * A flag indicating whether the invoice is a debit (true) or a credit (false).
     * @type {boolean}
     * @memberof InvoiceResponseDto
     */
    'isDebit': boolean;
    /**
     * The unique identifier for the invoice.
     * @type {string}
     * @memberof InvoiceResponseDto
     */
    'id': string;
    /**
     * 
     * @type {User6}
     * @memberof InvoiceResponseDto
     */
    'user': User6;
    /**
     * 
     * @type {Company12}
     * @memberof InvoiceResponseDto
     */
    'company': Company12;
    /**
     * An array of order IDs associated with the invoice.
     * @type {Array<InvoiceResponseDtoOrdersInner>}
     * @memberof InvoiceResponseDto
     */
    'orders': Array<InvoiceResponseDtoOrdersInner>;
    /**
     * 
     * @type {Integration2}
     * @memberof InvoiceResponseDto
     */
    'integration': Integration2;
    /**
     * Indicates the current processing state of the invoice. Possible values: \'PENDING\' (awaiting payment), \'SUCCESS\' (successfully paid), and \'FAILED\' (payment was unsuccessful).
     * @type {string}
     * @memberof InvoiceResponseDto
     */
    'invoiceStatus': InvoiceResponseDtoInvoiceStatusEnum;
    /**
     * The interval at which the invoice is generated.
     * @type {string}
     * @memberof InvoiceResponseDto
     */
    'invoiceInterval': InvoiceResponseDtoInvoiceIntervalEnum;
    /**
     * The date and time when the invoice was created.
     * @type {string}
     * @memberof InvoiceResponseDto
     */
    'createdAt'?: string;
}

export const InvoiceResponseDtoInvoiceStatusEnum = {
    Pending: 'PENDING',
    Success: 'SUCCESS',
    Failed: 'FAILED'
} as const;

export type InvoiceResponseDtoInvoiceStatusEnum = typeof InvoiceResponseDtoInvoiceStatusEnum[keyof typeof InvoiceResponseDtoInvoiceStatusEnum];
export const InvoiceResponseDtoInvoiceIntervalEnum = {
    Instant: 'instant',
    Weekly: 'weekly',
    Monthly: 'monthly',
    PerRequest: 'per request'
} as const;

export type InvoiceResponseDtoInvoiceIntervalEnum = typeof InvoiceResponseDtoInvoiceIntervalEnum[keyof typeof InvoiceResponseDtoInvoiceIntervalEnum];

/**
 * @type InvoiceResponseDtoOrdersInner
 * @export
 */
export type InvoiceResponseDtoOrdersInner = OrderResponseDto | string;

/**
 * @type IssueItemId
 * The unique identifier of the item associated with the issue.
 * @export
 */
export type IssueItemId = ItemResponseDto | string;

/**
 * @type IssueOrderId
 * The unique identifier of the order associated with the issue.
 * @export
 */
export type IssueOrderId = OrderResponseDto | string;

/**
 * 
 * @export
 * @interface IssueRequestDto
 */
export interface IssueRequestDto {
    /**
     * The title of the issue.
     * @type {Array<MultilangTextDto>}
     * @memberof IssueRequestDto
     */
    'title': Array<MultilangTextDto>;
    /**
     * A brief text that describes the issue.
     * @type {MultilangTextDto}
     * @memberof IssueRequestDto
     */
    'description': MultilangTextDto;
    /**
     * Indicates the category of the issue.
     * @type {string}
     * @memberof IssueRequestDto
     */
    'category': IssueRequestDtoCategoryEnum;
    /**
     * Indicates the priority of the issue.
     * @type {string}
     * @memberof IssueRequestDto
     */
    'priority': IssueRequestDtoPriorityEnum;
    /**
     * Defines if the issue is resolved or not.
     * @type {boolean}
     * @memberof IssueRequestDto
     */
    'resolved': boolean;
    /**
     * An array that determines the actions taken.
     * @type {Array<MultilangTextDto>}
     * @memberof IssueRequestDto
     */
    'actionsDone'?: Array<MultilangTextDto>;
    /**
     * The unique identifier of the user associated with the issue.
     * @type {string}
     * @memberof IssueRequestDto
     */
    'forUser'?: string;
    /**
     * The unique identifier of the item associated with the issue.
     * @type {string}
     * @memberof IssueRequestDto
     */
    'forItem'?: string;
    /**
     * The unique identifier of the order associated with the issue.
     * @type {string}
     * @memberof IssueRequestDto
     */
    'forOrder'?: string;
    /**
     * The unique identifier of the integration associated with the issue.
     * @type {string}
     * @memberof IssueRequestDto
     */
    'createdFromIntegration'?: string;
}

export const IssueRequestDtoCategoryEnum = {
    Order: 'order',
    OrderItem: 'order_item',
    Other: 'other'
} as const;

export type IssueRequestDtoCategoryEnum = typeof IssueRequestDtoCategoryEnum[keyof typeof IssueRequestDtoCategoryEnum];
export const IssueRequestDtoPriorityEnum = {
    Low: 'low',
    Normal: 'normal',
    Critical: 'critical'
} as const;

export type IssueRequestDtoPriorityEnum = typeof IssueRequestDtoPriorityEnum[keyof typeof IssueRequestDtoPriorityEnum];

/**
 * 
 * @export
 * @interface IssueResponseDto
 */
export interface IssueResponseDto {
    /**
     * The title of the issue.
     * @type {Array<MultilangTextDto>}
     * @memberof IssueResponseDto
     */
    'title': Array<MultilangTextDto>;
    /**
     * A brief text that describes the issue.
     * @type {MultilangTextDto}
     * @memberof IssueResponseDto
     */
    'description': MultilangTextDto;
    /**
     * Indicates the category of the issue.
     * @type {string}
     * @memberof IssueResponseDto
     */
    'category': IssueResponseDtoCategoryEnum;
    /**
     * Indicates the priority of the issue.
     * @type {string}
     * @memberof IssueResponseDto
     */
    'priority': IssueResponseDtoPriorityEnum;
    /**
     * Defines if the issue is resolved or not.
     * @type {boolean}
     * @memberof IssueResponseDto
     */
    'resolved': boolean;
    /**
     * An array that determines the actions taken.
     * @type {Array<MultilangTextDto>}
     * @memberof IssueResponseDto
     */
    'actionsDone'?: Array<MultilangTextDto>;
    /**
     * The unique identifier for the issue.
     * @type {string}
     * @memberof IssueResponseDto
     */
    'id'?: string;
    /**
     * 
     * @type {ParentId}
     * @memberof IssueResponseDto
     */
    'company'?: ParentId;
    /**
     * 
     * @type {IssueUserId}
     * @memberof IssueResponseDto
     */
    'forUser'?: IssueUserId;
    /**
     * 
     * @type {IssueItemId}
     * @memberof IssueResponseDto
     */
    'forItem'?: IssueItemId;
    /**
     * 
     * @type {IssueOrderId}
     * @memberof IssueResponseDto
     */
    'forOrder'?: IssueOrderId;
    /**
     * 
     * @type {IntegrationId}
     * @memberof IssueResponseDto
     */
    'createdFromIntegration'?: IntegrationId;
    /**
     * The date and time when the issue was created.
     * @type {string}
     * @memberof IssueResponseDto
     */
    'createdAt'?: string;
    /**
     * The date and time when the issue was updated.
     * @type {string}
     * @memberof IssueResponseDto
     */
    'updatedAt'?: string;
}

export const IssueResponseDtoCategoryEnum = {
    Order: 'order',
    OrderItem: 'order_item',
    Other: 'other'
} as const;

export type IssueResponseDtoCategoryEnum = typeof IssueResponseDtoCategoryEnum[keyof typeof IssueResponseDtoCategoryEnum];
export const IssueResponseDtoPriorityEnum = {
    Low: 'low',
    Normal: 'normal',
    Critical: 'critical'
} as const;

export type IssueResponseDtoPriorityEnum = typeof IssueResponseDtoPriorityEnum[keyof typeof IssueResponseDtoPriorityEnum];

/**
 * @type IssueUserId
 * The unique identifier of the user associated with the issue.
 * @export
 */
export type IssueUserId = UserResponseDto | string;

/**
 * 
 * @export
 * @interface ItAdditionalDataDto
 */
export interface ItAdditionalDataDto {
    /**
     * The nationality of the contact
     * @type {string}
     * @memberof ItAdditionalDataDto
     */
    'nationality': string;
    /**
     * - 1. Italian and foreign natural persons     - 2. Companies/one man companies     - 3. Freelance workers/professionals     - 4. Non-profit organisations     - 5. Public organisations     - 6. Other subjects     - 7. Foreigners who match 2-6
     * @type {number}
     * @memberof ItAdditionalDataDto
     */
    'entityType': ItAdditionalDataDtoEntityTypeEnum;
    /**
     * The registration code (e.g. codice fiscal, document number, VAT number or numeric tax code) of the contact
     * @type {string}
     * @memberof ItAdditionalDataDto
     */
    'regCode': string;
}

export const ItAdditionalDataDtoEntityTypeEnum = {
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5,
    NUMBER_6: 6,
    NUMBER_7: 7
} as const;

export type ItAdditionalDataDtoEntityTypeEnum = typeof ItAdditionalDataDtoEntityTypeEnum[keyof typeof ItAdditionalDataDtoEntityTypeEnum];

/**
 * 
 * @export
 * @interface ItemAffiliateDto
 */
export interface ItemAffiliateDto {
    /**
     * 
     * @type {Affiliate}
     * @memberof ItemAffiliateDto
     */
    'affiliate': Affiliate;
    /**
     * 
     * @type {User2}
     * @memberof ItemAffiliateDto
     */
    'user': User2;
    /**
     * The type of affiliate,
     * @type {string}
     * @memberof ItemAffiliateDto
     */
    'affiliateType': ItemAffiliateDtoAffiliateTypeEnum;
    /**
     * Indicates if the item has been paid or not.
     * @type {boolean}
     * @memberof ItemAffiliateDto
     */
    'paid': boolean;
    /**
     * The date and time when the payment was made.
     * @type {string}
     * @memberof ItemAffiliateDto
     */
    'paidAt': string;
    /**
     * The monetary value to be paid.
     * @type {number}
     * @memberof ItemAffiliateDto
     */
    'value': number;
    /**
     * 
     * @type {string}
     * @memberof ItemAffiliateDto
     */
    'status': ItemAffiliateDtoStatusEnum;
}

export const ItemAffiliateDtoAffiliateTypeEnum = {
    Fixed: 'fixed',
    Percentage: 'percentage'
} as const;

export type ItemAffiliateDtoAffiliateTypeEnum = typeof ItemAffiliateDtoAffiliateTypeEnum[keyof typeof ItemAffiliateDtoAffiliateTypeEnum];
export const ItemAffiliateDtoStatusEnum = {
    Pending: 'pending',
    Accepted: 'accepted',
    Rejected: 'rejected'
} as const;

export type ItemAffiliateDtoStatusEnum = typeof ItemAffiliateDtoStatusEnum[keyof typeof ItemAffiliateDtoStatusEnum];

/**
 * 
 * @export
 * @interface ItemAttachToBundleRequest
 */
export interface ItemAttachToBundleRequest {
    /**
     * 
     * @type {string}
     * @memberof ItemAttachToBundleRequest
     */
    'parentItemId'?: string;
}
/**
 * 
 * @export
 * @interface ItemClientResponseDto
 */
export interface ItemClientResponseDto {
    /**
     * Represents the name of the item, such as a hosting domain, server IP, or the name of a domain.
     * @type {string}
     * @memberof ItemClientResponseDto
     */
    'resourceName': string;
    /**
     * The date and time when the item will be postponed.
     * @type {string}
     * @memberof ItemClientResponseDto
     */
    'postponedEndDate'?: string;
    /**
     * Specifies the action to be performed on the item, as defined in ItemActionsEnum. This action is executed when the order is paid.
     * @type {string}
     * @memberof ItemClientResponseDto
     */
    'action': ItemClientResponseDtoActionEnum;
    /**
     * These are additional attributes requested by the integration from the customer who purchases the product. They capture specific details or preferences from the buyer, which may be needed for fulfilling the order or for configuring the product according to the customer\'s needs.
     * @type {{ [key: string]: any; }}
     * @memberof ItemClientResponseDto
     */
    'itemAttributes'?: { [key: string]: any; };
    /**
     * Contains additional information related to the item addons. Each key-value pair represents an addon and its chosen option.
     * @type {{ [key: string]: any; }}
     * @memberof ItemClientResponseDto
     */
    'itemAddons'?: { [key: string]: any; };
    /**
     * Indicates whether the item will automatically renew. Default behavior follows the user\'s specified preference.
     * @type {boolean}
     * @memberof ItemClientResponseDto
     */
    'autorenew': boolean;
    /**
     * A comment associated with the item that can be accessed by all users.
     * @type {string}
     * @memberof ItemClientResponseDto
     */
    'publicComment'?: string;
    /**
     * Duration of the item\'s subscription in months. A value of 0 represents a one-time payment.
     * @type {string}
     * @memberof ItemClientResponseDto
     */
    'duration': ItemClientResponseDtoDurationEnum;
    /**
     * A unique identifier for the item, used for precise referencing within the system.
     * @type {string}
     * @memberof ItemClientResponseDto
     */
    'id': string;
    /**
     * 
     * @type {Company9}
     * @memberof ItemClientResponseDto
     */
    'company': Company9;
    /**
     * 
     * @type {User3}
     * @memberof ItemClientResponseDto
     */
    'user'?: User3;
    /**
     * 
     * @type {ClientCompany}
     * @memberof ItemClientResponseDto
     */
    'clientCompany'?: ClientCompany;
    /**
     * 
     * @type {DetachedFromOrder}
     * @memberof ItemClientResponseDto
     */
    'detachedFromOrder'?: DetachedFromOrder;
    /**
     * Stores the identifier of the primary item from which this item originates, in cases where it is not the original item.
     * @type {string}
     * @memberof ItemClientResponseDto
     */
    'ancestorItemId': string;
    /**
     * 
     * @type {ParentItem}
     * @memberof ItemClientResponseDto
     */
    'parentItem'?: ParentItem;
    /**
     * 
     * @type {Order}
     * @memberof ItemClientResponseDto
     */
    'order': Order;
    /**
     * Represents the current state of the item, as defined in ItemStatusEnum. The default value is IDLE.
     * @type {string}
     * @memberof ItemClientResponseDto
     */
    'status': ItemClientResponseDtoStatusEnum;
    /**
     * 
     * @type {ProductId}
     * @memberof ItemClientResponseDto
     */
    'product'?: ProductId;
    /**
     * An array of multilingual representations for the product\'s title. Each entry provides the title in a specific language.
     * @type {Array<string>}
     * @memberof ItemClientResponseDto
     */
    'productName'?: Array<string>;
    /**
     * The version number of the product used by the item. It helps track which specific version of the product is associated with the item in case the product is updated to a new version.
     * @type {number}
     * @memberof ItemClientResponseDto
     */
    'productVersion'?: number;
    /**
     * 
     * @type {ProductCategory}
     * @memberof ItemClientResponseDto
     */
    'productCategory'?: ProductCategory;
    /**
     * An array of multilingual representations for the product category\'s title. Each entry provides the title in a specific language.
     * @type {Array<MultilangTextDto>}
     * @memberof ItemClientResponseDto
     */
    'productCategoryTitle'?: Array<MultilangTextDto>;
    /**
     * Indicates whether the item has been transferred to a different registrar, such as when a domain is moved to another provider.
     * @type {boolean}
     * @memberof ItemClientResponseDto
     */
    'transferredOut': boolean;
    /**
     * 
     * @type {TransferredFromUser}
     * @memberof ItemClientResponseDto
     */
    'transferredFromUser': TransferredFromUser;
    /**
     * 
     * @type {TransferredToUser}
     * @memberof ItemClientResponseDto
     */
    'transferredToUser': TransferredToUser;
    /**
     * The default price of the item, representing the value of the product excluding VAT or commissions.
     * @type {number}
     * @memberof ItemClientResponseDto
     */
    'defaultPrice': number;
    /**
     * The default setup fee of the item, representing the value of the product excluding VAT or commissions.
     * @type {number}
     * @memberof ItemClientResponseDto
     */
    'defaultSetupFee': number;
    /**
     * The discount price of the item, representing the value of the product excluding VAT or commissions.
     * @type {number}
     * @memberof ItemClientResponseDto
     */
    'discountPrice'?: number;
    /**
     * The custom price of the item set by the company, representing the value of the product excluding VAT or commissions. If this exist the default price is ignored.
     * @type {number}
     * @memberof ItemClientResponseDto
     */
    'customPrice'?: number;
    /**
     * The custom setup fee of the item set by the company, representing the value of the product excluding VAT or commissions. If this exist the default setup fee is ignored.
     * @type {number}
     * @memberof ItemClientResponseDto
     */
    'customSetupFee'?: number;
    /**
     * Indicates whether the item should be excluded from coupon discounts.
     * @type {boolean}
     * @memberof ItemClientResponseDto
     */
    'excludeFromCoupon'?: boolean;
    /**
     * The subtotal of the item, representing the value of the product excluding VAT or commissions.
     * @type {number}
     * @memberof ItemClientResponseDto
     */
    'subtotal': number;
    /**
     * Unique identifiers for items that are bundled with this item. All bundled items must be renewed when renewing this product.
     * @type {Array<ItemResponseDtoItemBundlesInner>}
     * @memberof ItemClientResponseDto
     */
    'itemBundles'?: Array<ItemResponseDtoItemBundlesInner>;
    /**
     * 
     * @type {BundledWithItem}
     * @memberof ItemClientResponseDto
     */
    'bundledWithItem'?: BundledWithItem;
    /**
     * List of additional email addresses to which customer notifications will be sent.
     * @type {Array<string>}
     * @memberof ItemClientResponseDto
     */
    'additionalNotificationEmails'?: Array<string>;
    /**
     * List of additional phone numbers to which customer notifications will be sent.
     * @type {Array<string>}
     * @memberof ItemClientResponseDto
     */
    'additionalNotidficationPhoneNumbers'?: Array<string>;
    /**
     * Details of the domain name associated with the contact, including related data.
     * @type {DomainNameDataResponseDto}
     * @memberof ItemClientResponseDto
     */
    'domainNameData': DomainNameDataResponseDto;
    /**
     * Indicates whether the item is currently under maintenance.
     * @type {boolean}
     * @memberof ItemClientResponseDto
     */
    'inMaintenance': boolean;
    /**
     * The date when the subscription for the item begins.
     * @type {string}
     * @memberof ItemClientResponseDto
     */
    'startDate': string;
    /**
     * The date when the subscription for the item ends.
     * @type {string}
     * @memberof ItemClientResponseDto
     */
    'endDate': string;
    /**
     * List of dates when the payment for the item was postponed. Each date represents when the payment was delayed.
     * @type {Array<string>}
     * @memberof ItemClientResponseDto
     */
    'postponedDates'?: Array<string>;
    /**
     * The date the item created.
     * @type {string}
     * @memberof ItemClientResponseDto
     */
    'createdAt'?: string;
    /**
     * The date the item updated.
     * @type {string}
     * @memberof ItemClientResponseDto
     */
    'updatedAt'?: string;
}

export const ItemClientResponseDtoActionEnum = {
    Create: 'item/create',
    Suspend: 'item/suspend',
    Unsuspend: 'item/unsuspend',
    Renew: 'item/renew',
    Cancel: 'item/cancel',
    Delete: 'item/delete',
    Upgrade: 'item/upgrade',
    Downgrade: 'item/downgrade'
} as const;

export type ItemClientResponseDtoActionEnum = typeof ItemClientResponseDtoActionEnum[keyof typeof ItemClientResponseDtoActionEnum];
export const ItemClientResponseDtoDurationEnum = {
    _0: '0',
    _1: '1',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5',
    _6: '6',
    _7: '7',
    _8: '8',
    _9: '9',
    _10: '10',
    _11: '11',
    _12: '12',
    _24: '24',
    _36: '36',
    _48: '48',
    _60: '60',
    _72: '72',
    _84: '84',
    _96: '96',
    _108: '108',
    _120: '120'
} as const;

export type ItemClientResponseDtoDurationEnum = typeof ItemClientResponseDtoDurationEnum[keyof typeof ItemClientResponseDtoDurationEnum];
export const ItemClientResponseDtoStatusEnum = {
    Idle: 'idle',
    Inprogress: 'inprogress',
    Suspended: 'suspended',
    Active: 'active',
    Inactive: 'inactive',
    Expired: 'expired',
    Trial: 'trial',
    SoftDeleted: 'soft_deleted',
    HardDeleted: 'hard_deleted',
    Error: 'error',
    Canceled: 'canceled',
    Postponed: 'postponed',
    Refunded: 'refunded'
} as const;

export type ItemClientResponseDtoStatusEnum = typeof ItemClientResponseDtoStatusEnum[keyof typeof ItemClientResponseDtoStatusEnum];

/**
 * 
 * @export
 * @interface ItemRequestDto
 */
export interface ItemRequestDto {
    /**
     * Represents the name of the item, such as a hosting domain, server IP, or the name of a domain.
     * @type {string}
     * @memberof ItemRequestDto
     */
    'resourceName': string;
    /**
     * The date and time when the item will be postponed.
     * @type {string}
     * @memberof ItemRequestDto
     */
    'postponedEndDate'?: string;
    /**
     * Specifies the action to be performed on the item, as defined in ItemActionsEnum. This action is executed when the order is paid.
     * @type {string}
     * @memberof ItemRequestDto
     */
    'action': ItemRequestDtoActionEnum;
    /**
     * These are additional attributes requested by the integration from the customer who purchases the product. They capture specific details or preferences from the buyer, which may be needed for fulfilling the order or for configuring the product according to the customer\'s needs.
     * @type {{ [key: string]: any; }}
     * @memberof ItemRequestDto
     */
    'itemAttributes'?: { [key: string]: any; };
    /**
     * Contains additional information related to the item, used internally and not visible to simple users.
     * @type {{ [key: string]: any; }}
     * @memberof ItemRequestDto
     */
    'responseDataFieldNames': { [key: string]: any; };
    /**
     * Contains additional information related to the item addons. Each key-value pair represents an addon and its chosen option.
     * @type {{ [key: string]: any; }}
     * @memberof ItemRequestDto
     */
    'itemAddons'?: { [key: string]: any; };
    /**
     * Indicates whether the item will automatically renew. Default behavior follows the user\'s specified preference.
     * @type {boolean}
     * @memberof ItemRequestDto
     */
    'autorenew': boolean;
    /**
     * A comment associated with the item that can be accessed by all users.
     * @type {string}
     * @memberof ItemRequestDto
     */
    'publicComment'?: string;
    /**
     * Duration of the item\'s subscription in months. A value of 0 represents a one-time payment.
     * @type {string}
     * @memberof ItemRequestDto
     */
    'duration': ItemRequestDtoDurationEnum;
    /**
     * A unique identifier for the client company associated with this item, used to link the item to a specific client organization.
     * @type {string}
     * @memberof ItemRequestDto
     */
    'clientCompany'?: string;
    /**
     * A unique identifier for the product associated with this item.
     * @type {string}
     * @memberof ItemRequestDto
     */
    'product': string;
    /**
     * Stores the identifier of the order from which this item was originally detached. This information is useful for tracking the item\'s origin.
     * @type {string}
     * @memberof ItemRequestDto
     */
    'detachedFromOrder'?: string;
    /**
     * Details of the domain name associated with the contact, including related data.
     * @type {DomainNameDataRequestDto}
     * @memberof ItemRequestDto
     */
    'domainNameData': DomainNameDataRequestDto;
}

export const ItemRequestDtoActionEnum = {
    Create: 'item/create',
    Suspend: 'item/suspend',
    Unsuspend: 'item/unsuspend',
    Renew: 'item/renew',
    Cancel: 'item/cancel',
    Delete: 'item/delete',
    Upgrade: 'item/upgrade',
    Downgrade: 'item/downgrade'
} as const;

export type ItemRequestDtoActionEnum = typeof ItemRequestDtoActionEnum[keyof typeof ItemRequestDtoActionEnum];
export const ItemRequestDtoDurationEnum = {
    _0: '0',
    _1: '1',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5',
    _6: '6',
    _7: '7',
    _8: '8',
    _9: '9',
    _10: '10',
    _11: '11',
    _12: '12',
    _24: '24',
    _36: '36',
    _48: '48',
    _60: '60',
    _72: '72',
    _84: '84',
    _96: '96',
    _108: '108',
    _120: '120'
} as const;

export type ItemRequestDtoDurationEnum = typeof ItemRequestDtoDurationEnum[keyof typeof ItemRequestDtoDurationEnum];

/**
 * 
 * @export
 * @interface ItemResponseDto
 */
export interface ItemResponseDto {
    /**
     * Represents the name of the item, such as a hosting domain, server IP, or the name of a domain.
     * @type {string}
     * @memberof ItemResponseDto
     */
    'resourceName': string;
    /**
     * The date and time when the item will be postponed.
     * @type {string}
     * @memberof ItemResponseDto
     */
    'postponedEndDate'?: string;
    /**
     * Specifies the action to be performed on the item, as defined in ItemActionsEnum. This action is executed when the order is paid.
     * @type {string}
     * @memberof ItemResponseDto
     */
    'action': ItemResponseDtoActionEnum;
    /**
     * These are additional attributes requested by the integration from the customer who purchases the product. They capture specific details or preferences from the buyer, which may be needed for fulfilling the order or for configuring the product according to the customer\'s needs.
     * @type {{ [key: string]: any; }}
     * @memberof ItemResponseDto
     */
    'itemAttributes'?: { [key: string]: any; };
    /**
     * Contains additional information related to the item, used internally and not visible to simple users.
     * @type {{ [key: string]: any; }}
     * @memberof ItemResponseDto
     */
    'responseDataFieldNames': { [key: string]: any; };
    /**
     * Contains additional information related to the item addons. Each key-value pair represents an addon and its chosen option.
     * @type {{ [key: string]: any; }}
     * @memberof ItemResponseDto
     */
    'itemAddons'?: { [key: string]: any; };
    /**
     * Indicates whether the item will automatically renew. Default behavior follows the user\'s specified preference.
     * @type {boolean}
     * @memberof ItemResponseDto
     */
    'autorenew': boolean;
    /**
     * A comment associated with the item that can be accessed by all users.
     * @type {string}
     * @memberof ItemResponseDto
     */
    'publicComment'?: string;
    /**
     * Duration of the item\'s subscription in months. A value of 0 represents a one-time payment.
     * @type {string}
     * @memberof ItemResponseDto
     */
    'duration': ItemResponseDtoDurationEnum;
    /**
     * A unique identifier for the item, used for precise referencing within the system.
     * @type {string}
     * @memberof ItemResponseDto
     */
    'id': string;
    /**
     * 
     * @type {Company9}
     * @memberof ItemResponseDto
     */
    'company': Company9;
    /**
     * 
     * @type {User3}
     * @memberof ItemResponseDto
     */
    'user'?: User3;
    /**
     * 
     * @type {ClientCompany}
     * @memberof ItemResponseDto
     */
    'clientCompany'?: ClientCompany;
    /**
     * These are additional attributes required by the integration when the product is created by the seller. They provide specific details about the product that are necessary for the system to properly handle the product within its designated category or use case.
     * @type {{ [key: string]: any; }}
     * @memberof ItemResponseDto
     */
    'productAttributes'?: { [key: string]: any; };
    /**
     * 
     * @type {DetachedFromOrder}
     * @memberof ItemResponseDto
     */
    'detachedFromOrder'?: DetachedFromOrder;
    /**
     * Stores the identifier of the primary item from which this item originates, in cases where it is not the original item.
     * @type {string}
     * @memberof ItemResponseDto
     */
    'ancestorItemId': string;
    /**
     * 
     * @type {ParentItem}
     * @memberof ItemResponseDto
     */
    'parentItem'?: ParentItem;
    /**
     * 
     * @type {Order}
     * @memberof ItemResponseDto
     */
    'order': Order;
    /**
     * Represents the current state of the item, as defined in ItemStatusEnum. The default value is IDLE.
     * @type {string}
     * @memberof ItemResponseDto
     */
    'status': ItemResponseDtoStatusEnum;
    /**
     * 
     * @type {ProductId}
     * @memberof ItemResponseDto
     */
    'product'?: ProductId;
    /**
     * An array of multilingual representations for the product\'s title. Each entry provides the title in a specific language.
     * @type {Array<string>}
     * @memberof ItemResponseDto
     */
    'productName'?: Array<string>;
    /**
     * The version number of the product used by the item. It helps track which specific version of the product is associated with the item in case the product is updated to a new version.
     * @type {number}
     * @memberof ItemResponseDto
     */
    'productVersion'?: number;
    /**
     * 
     * @type {ProductCategory}
     * @memberof ItemResponseDto
     */
    'productCategory'?: ProductCategory;
    /**
     * An array of multilingual representations for the product category\'s title. Each entry provides the title in a specific language.
     * @type {Array<MultilangTextDto>}
     * @memberof ItemResponseDto
     */
    'productCategoryTitle'?: Array<MultilangTextDto>;
    /**
     * Indicates whether the item has been transferred to a different registrar, such as when a domain is moved to another provider.
     * @type {boolean}
     * @memberof ItemResponseDto
     */
    'transferredOut': boolean;
    /**
     * 
     * @type {TransferredFromUser}
     * @memberof ItemResponseDto
     */
    'transferredFromUser': TransferredFromUser;
    /**
     * 
     * @type {TransferredToUser}
     * @memberof ItemResponseDto
     */
    'transferredToUser': TransferredToUser;
    /**
     * A comment associated with the item. This information is restricted and cannot be accessed by simple users.
     * @type {string}
     * @memberof ItemResponseDto
     */
    'privateComment': string;
    /**
     * The default price of the item, representing the value of the product excluding VAT or commissions.
     * @type {number}
     * @memberof ItemResponseDto
     */
    'defaultPrice': number;
    /**
     * The default setup fee of the item, representing the value of the product excluding VAT or commissions.
     * @type {number}
     * @memberof ItemResponseDto
     */
    'defaultSetupFee': number;
    /**
     * The discount price of the item, representing the value of the product excluding VAT or commissions.
     * @type {number}
     * @memberof ItemResponseDto
     */
    'discountPrice'?: number;
    /**
     * The custom price of the item set by the company, representing the value of the product excluding VAT or commissions. If this exist the default price is ignored.
     * @type {number}
     * @memberof ItemResponseDto
     */
    'customPrice'?: number;
    /**
     * The custom setup fee of the item set by the company, representing the value of the product excluding VAT or commissions. If this exist the default setup fee is ignored.
     * @type {number}
     * @memberof ItemResponseDto
     */
    'customSetupFee'?: number;
    /**
     * Indicates whether the item should be excluded from coupon discounts.
     * @type {boolean}
     * @memberof ItemResponseDto
     */
    'excludeFromCoupon'?: boolean;
    /**
     * The subtotal of the item, representing the value of the product excluding VAT or commissions.
     * @type {number}
     * @memberof ItemResponseDto
     */
    'subtotal': number;
    /**
     * Unique identifiers for items that are bundled with this item. All bundled items must be renewed when renewing this product.
     * @type {Array<ItemResponseDtoItemBundlesInner>}
     * @memberof ItemResponseDto
     */
    'itemBundles'?: Array<ItemResponseDtoItemBundlesInner>;
    /**
     * 
     * @type {BundledWithItem}
     * @memberof ItemResponseDto
     */
    'bundledWithItem'?: BundledWithItem;
    /**
     * List of additional email addresses to which customer notifications will be sent.
     * @type {Array<string>}
     * @memberof ItemResponseDto
     */
    'additionalNotificationEmails'?: Array<string>;
    /**
     * List of additional phone numbers to which customer notifications will be sent.
     * @type {Array<string>}
     * @memberof ItemResponseDto
     */
    'additionalNotidficationPhoneNumbers'?: Array<string>;
    /**
     * Details of the domain name associated with the contact, including related data.
     * @type {DomainNameDataResponseDto}
     * @memberof ItemResponseDto
     */
    'domainNameData': DomainNameDataResponseDto;
    /**
     * 
     * @type {AffiliateData}
     * @memberof ItemResponseDto
     */
    'itemAffiliateData': AffiliateData;
    /**
     * Indicates whether the item is currently under maintenance.
     * @type {boolean}
     * @memberof ItemResponseDto
     */
    'inMaintenance': boolean;
    /**
     * The date when the subscription for the item begins.
     * @type {string}
     * @memberof ItemResponseDto
     */
    'startDate': string;
    /**
     * The date when the subscription for the item ends.
     * @type {string}
     * @memberof ItemResponseDto
     */
    'endDate': string;
    /**
     * List of dates when the payment for the item was postponed. Each date represents when the payment was delayed.
     * @type {Array<string>}
     * @memberof ItemResponseDto
     */
    'postponedDates'?: Array<string>;
    /**
     * The date the item created.
     * @type {string}
     * @memberof ItemResponseDto
     */
    'createdAt'?: string;
    /**
     * The date the item updated.
     * @type {string}
     * @memberof ItemResponseDto
     */
    'updatedAt'?: string;
}

export const ItemResponseDtoActionEnum = {
    Create: 'item/create',
    Suspend: 'item/suspend',
    Unsuspend: 'item/unsuspend',
    Renew: 'item/renew',
    Cancel: 'item/cancel',
    Delete: 'item/delete',
    Upgrade: 'item/upgrade',
    Downgrade: 'item/downgrade'
} as const;

export type ItemResponseDtoActionEnum = typeof ItemResponseDtoActionEnum[keyof typeof ItemResponseDtoActionEnum];
export const ItemResponseDtoDurationEnum = {
    _0: '0',
    _1: '1',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5',
    _6: '6',
    _7: '7',
    _8: '8',
    _9: '9',
    _10: '10',
    _11: '11',
    _12: '12',
    _24: '24',
    _36: '36',
    _48: '48',
    _60: '60',
    _72: '72',
    _84: '84',
    _96: '96',
    _108: '108',
    _120: '120'
} as const;

export type ItemResponseDtoDurationEnum = typeof ItemResponseDtoDurationEnum[keyof typeof ItemResponseDtoDurationEnum];
export const ItemResponseDtoStatusEnum = {
    Idle: 'idle',
    Inprogress: 'inprogress',
    Suspended: 'suspended',
    Active: 'active',
    Inactive: 'inactive',
    Expired: 'expired',
    Trial: 'trial',
    SoftDeleted: 'soft_deleted',
    HardDeleted: 'hard_deleted',
    Error: 'error',
    Canceled: 'canceled',
    Postponed: 'postponed',
    Refunded: 'refunded'
} as const;

export type ItemResponseDtoStatusEnum = typeof ItemResponseDtoStatusEnum[keyof typeof ItemResponseDtoStatusEnum];

/**
 * @type ItemResponseDtoItemBundlesInner
 * @export
 */
export type ItemResponseDtoItemBundlesInner = ItemResponseDto | string;

/**
 * 
 * @export
 * @interface ItemUpdateRequestDto
 */
export interface ItemUpdateRequestDto {
    /**
     * Represents the name of the item, such as a hosting domain, server IP, or the name of a domain.
     * @type {string}
     * @memberof ItemUpdateRequestDto
     */
    'resourceName': string;
    /**
     * Indicates whether the item will automatically renew. Default behavior follows the user\'s specified preference.
     * @type {boolean}
     * @memberof ItemUpdateRequestDto
     */
    'autorenew': boolean;
    /**
     * A comment associated with the item. This information is restricted and cannot be accessed by simple users.
     * @type {string}
     * @memberof ItemUpdateRequestDto
     */
    'privateComment': string;
    /**
     * A comment associated with the item that can be accessed by all users.
     * @type {string}
     * @memberof ItemUpdateRequestDto
     */
    'publicComment': string;
    /**
     * List of additional email addresses to which customer notifications will be sent.
     * @type {Array<string>}
     * @memberof ItemUpdateRequestDto
     */
    'additionalNotificationEmails': Array<string>;
    /**
     * List of additional phone numbers to which customer notifications will be sent.
     * @type {Array<string>}
     * @memberof ItemUpdateRequestDto
     */
    'additionalNotificationPhoneNumbers': Array<string>;
    /**
     * The date when the subscription for the item begins.
     * @type {string}
     * @memberof ItemUpdateRequestDto
     */
    'startDate': string;
    /**
     * The date when the subscription for the item ends.
     * @type {string}
     * @memberof ItemUpdateRequestDto
     */
    'endDate': string;
}
/**
 * 
 * @export
 * @interface LoginResponseDto
 */
export interface LoginResponseDto {
    /**
     * 
     * @type {string}
     * @memberof LoginResponseDto
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface LvAdditionalDataDto
 */
export interface LvAdditionalDataDto {
    /**
     * The official registration number of the contact in Latvia.
     * @type {string}
     * @memberof LvAdditionalDataDto
     */
    'registrationNumber': string;
    /**
     * The Value Added Tax (VAT) number of the contact, if applicable.
     * @type {string}
     * @memberof LvAdditionalDataDto
     */
    'vatNumber'?: string;
}
/**
 * @type Menu
 * Admin panel main menu (URL or submenu variant).
 * @export
 */
export type Menu = MenuDtoWithSubmenu | MenuDtoWithUrl;

/**
 * @type Menu1
 * Client panel main menu (URL or submenu variant).
 * @export
 */
export type Menu1 = MenuDtoWithSubmenu | MenuDtoWithUrl;

/**
 * 
 * @export
 * @interface MenuDtoWithSubmenu
 */
export interface MenuDtoWithSubmenu {
    /**
     * Type of the menu item.
     * @type {string}
     * @memberof MenuDtoWithSubmenu
     */
    'type': MenuDtoWithSubmenuTypeEnum;
    /**
     * List of tabs that will appear in the submenu.
     * @type {Array<TabDto>}
     * @memberof MenuDtoWithSubmenu
     */
    'submenu': Array<TabDto>;
    /**
     * Icon for the menu item.
     * @type {string}
     * @memberof MenuDtoWithSubmenu
     */
    'icon': string;
    /**
     * Label for the menu item.
     * @type {string}
     * @memberof MenuDtoWithSubmenu
     */
    'label': string;
}

export const MenuDtoWithSubmenuTypeEnum = {
    WithSubmenu: 'with-submenu'
} as const;

export type MenuDtoWithSubmenuTypeEnum = typeof MenuDtoWithSubmenuTypeEnum[keyof typeof MenuDtoWithSubmenuTypeEnum];

/**
 * 
 * @export
 * @interface MenuDtoWithUrl
 */
export interface MenuDtoWithUrl {
    /**
     * Type of the menu item.
     * @type {string}
     * @memberof MenuDtoWithUrl
     */
    'type': MenuDtoWithUrlTypeEnum;
    /**
     * URL associated with the menu item.
     * @type {string}
     * @memberof MenuDtoWithUrl
     */
    'url': string;
    /**
     * Icon for the menu item.
     * @type {string}
     * @memberof MenuDtoWithUrl
     */
    'icon': string;
    /**
     * Label for the menu item.
     * @type {string}
     * @memberof MenuDtoWithUrl
     */
    'label': string;
}

export const MenuDtoWithUrlTypeEnum = {
    OnlyUrl: 'only-url'
} as const;

export type MenuDtoWithUrlTypeEnum = typeof MenuDtoWithUrlTypeEnum[keyof typeof MenuDtoWithUrlTypeEnum];

/**
 * Additional actions in Admin panel sections.
 * @export
 * @interface MoreActions
 */
export interface MoreActions {
    /**
     * 
     * @type {AdminPanelMoreActionsDto}
     * @memberof MoreActions
     */
    'moreActions'?: AdminPanelMoreActionsDto;
}
/**
 * Additional actions in Client panel.
 * @export
 * @interface MoreActions1
 */
export interface MoreActions1 {
    /**
     * 
     * @type {ClientPanelMoreActionsDto}
     * @memberof MoreActions1
     */
    'moreActions'?: ClientPanelMoreActionsDto;
}
/**
 * 
 * @export
 * @interface MultilangTextDto
 */
export interface MultilangTextDto {
    /**
     * 
     * @type {string}
     * @memberof MultilangTextDto
     */
    'language': MultilangTextDtoLanguageEnum;
    /**
     * 
     * @type {string}
     * @memberof MultilangTextDto
     */
    'text': string;
}

export const MultilangTextDtoLanguageEnum = {
    Ab: 'AB',
    Aa: 'AA',
    Af: 'AF',
    Ak: 'AK',
    Sq: 'SQ',
    Am: 'AM',
    Ar: 'AR',
    An: 'AN',
    Hy: 'HY',
    As: 'AS',
    Av: 'AV',
    Ae: 'AE',
    Ay: 'AY',
    Az: 'AZ',
    Bm: 'BM',
    Ba: 'BA',
    Eu: 'EU',
    Be: 'BE',
    Bn: 'BN',
    Bi: 'BI',
    Bs: 'BS',
    Br: 'BR',
    Bg: 'BG',
    My: 'MY',
    Ca: 'CA',
    Km: 'KM',
    Ch: 'CH',
    Ce: 'CE',
    Ny: 'NY',
    Zh: 'ZH',
    Cu: 'CU',
    Cv: 'CV',
    Kw: 'KW',
    Co: 'CO',
    Cr: 'CR',
    Hr: 'HR',
    Cs: 'CS',
    Da: 'DA',
    Dv: 'DV',
    Nl: 'NL',
    Dz: 'DZ',
    En: 'EN',
    Eo: 'EO',
    Et: 'ET',
    Ee: 'EE',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Ff: 'FF',
    Gl: 'GL',
    Lg: 'LG',
    Ka: 'KA',
    De: 'DE',
    El: 'EL',
    Gn: 'GN',
    Gu: 'GU',
    Ht: 'HT',
    Ha: 'HA',
    He: 'HE',
    Hz: 'HZ',
    Hi: 'HI',
    Ho: 'HO',
    Hu: 'HU',
    Is: 'IS',
    Io: 'IO',
    Ig: 'IG',
    Id: 'ID',
    Ia: 'IA',
    Ie: 'IE',
    Iu: 'IU',
    Ik: 'IK',
    Ga: 'GA',
    It: 'IT',
    Ja: 'JA',
    Jv: 'JV',
    Kl: 'KL',
    Kn: 'KN',
    Kr: 'KR',
    Ks: 'KS',
    Kk: 'KK',
    Ki: 'KI',
    Rw: 'RW',
    Ky: 'KY',
    Kv: 'KV',
    Kg: 'KG',
    Ko: 'KO',
    Kj: 'KJ',
    Ku: 'KU',
    Lo: 'LO',
    La: 'LA',
    Lv: 'LV',
    Li: 'LI',
    Ln: 'LN',
    Lt: 'LT',
    Lu: 'LU',
    Lb: 'LB',
    Mk: 'MK',
    Mg: 'MG',
    Ms: 'MS',
    Ml: 'ML',
    Mt: 'MT',
    Gv: 'GV',
    Mi: 'MI',
    Mr: 'MR',
    Mh: 'MH',
    Mn: 'MN',
    Na: 'NA',
    Nv: 'NV',
    Nd: 'ND',
    Nr: 'NR',
    Ng: 'NG',
    Ne: 'NE',
    Se: 'SE',
    No: 'NO',
    Nb: 'NB',
    Nn: 'NN',
    Ii: 'II',
    Oc: 'OC',
    Oj: 'OJ',
    Or: 'OR',
    Om: 'OM',
    Os: 'OS',
    Pi: 'PI',
    Ps: 'PS',
    Fa: 'FA',
    Pl: 'PL',
    Pt: 'PT',
    Pa: 'PA',
    Qu: 'QU',
    Ro: 'RO',
    Rm: 'RM',
    Rn: 'RN',
    Ru: 'RU',
    Sm: 'SM',
    Sg: 'SG',
    Sa: 'SA',
    Sc: 'SC',
    Gd: 'GD',
    Sr: 'SR',
    Sn: 'SN',
    Ii2: 'II',
    Sd: 'SD',
    Si: 'SI',
    Sk: 'SK',
    Sl: 'SL',
    So: 'SO',
    St: 'ST',
    Es: 'ES',
    Su: 'SU',
    Sw: 'SW',
    Ss: 'SS',
    Sv: 'SV',
    Tl: 'TL',
    Ty: 'TY',
    Tg: 'TG',
    Ta: 'TA',
    Tt: 'TT',
    Te: 'TE',
    Th: 'TH',
    Bo: 'BO',
    Ti: 'TI',
    To: 'TO',
    Ts: 'TS',
    Tn: 'TN',
    Tr: 'TR',
    Tk: 'TK',
    Tw: 'TW',
    Ug: 'UG',
    Uk: 'UK',
    Ur: 'UR',
    Uz: 'UZ',
    Ve: 'VE',
    Vi: 'VI',
    Vo: 'VO',
    Wa: 'WA',
    Cy: 'CY',
    Fy: 'FY',
    Wo: 'WO',
    Xh: 'XH',
    Yi: 'YI',
    Yo: 'YO',
    Za: 'ZA',
    Zu: 'ZU'
} as const;

export type MultilangTextDtoLanguageEnum = typeof MultilangTextDtoLanguageEnum[keyof typeof MultilangTextDtoLanguageEnum];

/**
 * 
 * @export
 * @interface NameserverDto
 */
export interface NameserverDto {
    /**
     * The hostname of the nameserver.
     * @type {string}
     * @memberof NameserverDto
     */
    'hostName': string;
    /**
     * An optional list of IPv4 addresses associated with the nameserver.
     * @type {Array<string>}
     * @memberof NameserverDto
     */
    'ipV4Addresses'?: Array<string>;
    /**
     * An optional list of IPv6 addresses associated with the nameserver.
     * @type {Array<string>}
     * @memberof NameserverDto
     */
    'ipV6Addresses'?: Array<string>;
}
/**
 * 
 * @export
 * @interface NlAdditionalDataDto
 */
export interface NlAdditionalDataDto {
    /**
     * The legal form of the contact, e.g., \'B.V.\' or \'N.V.\'
     * @type {string}
     * @memberof NlAdditionalDataDto
     */
    'legalType': NlAdditionalDataDtoLegalTypeEnum;
    /**
     * The registration number associated with the legal form, if applicable.
     * @type {string}
     * @memberof NlAdditionalDataDto
     */
    'legalTypeRegistrationNumber': string;
}

export const NlAdditionalDataDtoLegalTypeEnum = {
    Anders: 'ANDERS',
    Bgg: 'BGG',
    Bro: 'BRO',
    Bvi: 'BVI',
    Coop: 'COOP',
    Cv: 'CV',
    Eenmanszaak: 'EENMANSZAAK',
    Eesv: 'EESV',
    Maatschap: 'MAATSCHAP',
    Nv: 'NV',
    Owm: 'OWM'
} as const;

export type NlAdditionalDataDtoLegalTypeEnum = typeof NlAdditionalDataDtoLegalTypeEnum[keyof typeof NlAdditionalDataDtoLegalTypeEnum];

/**
 * 
 * @export
 * @interface NotificationInfoDto
 */
export interface NotificationInfoDto {
    /**
     * Notification channel type.
     * @type {string}
     * @memberof NotificationInfoDto
     */
    'type': NotificationInfoDtoTypeEnum;
    /**
     * Optional metering units for pay-per-use billing.
     * @type {Array<UnitDto>}
     * @memberof NotificationInfoDto
     */
    'payPerUseUnits'?: Array<UnitDto>;
    /**
     * Integration display title.
     * @type {string}
     * @memberof NotificationInfoDto
     */
    'title': string;
    /**
     * Public HTTPS URL for the integration logo.
     * @type {string}
     * @memberof NotificationInfoDto
     */
    'logo'?: string;
    /**
     * Short description of the integration.
     * @type {string}
     * @memberof NotificationInfoDto
     */
    'description'?: string;
    /**
     * Locales supported by the integration.
     * @type {Array<string>}
     * @memberof NotificationInfoDto
     */
    'supportedLanguages': Array<NotificationInfoDtoSupportedLanguagesEnum>;
    /**
     * Actions supported by this integration.
     * @type {Array<string>}
     * @memberof NotificationInfoDto
     */
    'supportedActions'?: Array<NotificationInfoDtoSupportedActionsEnum>;
    /**
     * Platform events the integration can subscribe to.
     * @type {Array<string>}
     * @memberof NotificationInfoDto
     */
    'listenEvents'?: Array<NotificationInfoDtoListenEventsEnum>;
    /**
     * Roles required for this integration to operate.
     * @type {Array<string>}
     * @memberof NotificationInfoDto
     */
    'requiredRoles'?: Array<NotificationInfoDtoRequiredRolesEnum>;
    /**
     * Admin UI links, tabs, and actions provided by the integration.
     * @type {AdminPanelDto}
     * @memberof NotificationInfoDto
     */
    'adminPanel'?: AdminPanelDto;
    /**
     * Client UI links, tabs, and actions provided by the integration.
     * @type {ClientPanelDto}
     * @memberof NotificationInfoDto
     */
    'clientPanel'?: ClientPanelDto;
    /**
     * URL to onboard/configure the integration.
     * @type {string}
     * @memberof NotificationInfoDto
     */
    'onboardingUrl'?: string;
    /**
     * Configurable attributes that are used in the setup process.
     * @type {Array<FieldDto>}
     * @memberof NotificationInfoDto
     */
    'setupAttributes'?: Array<FieldDto>;
}

export const NotificationInfoDtoTypeEnum = {
    Email: 'email',
    Sms: 'sms',
    Push: 'push'
} as const;

export type NotificationInfoDtoTypeEnum = typeof NotificationInfoDtoTypeEnum[keyof typeof NotificationInfoDtoTypeEnum];
export const NotificationInfoDtoSupportedLanguagesEnum = {
    Ab: 'AB',
    Aa: 'AA',
    Af: 'AF',
    Ak: 'AK',
    Sq: 'SQ',
    Am: 'AM',
    Ar: 'AR',
    An: 'AN',
    Hy: 'HY',
    As: 'AS',
    Av: 'AV',
    Ae: 'AE',
    Ay: 'AY',
    Az: 'AZ',
    Bm: 'BM',
    Ba: 'BA',
    Eu: 'EU',
    Be: 'BE',
    Bn: 'BN',
    Bi: 'BI',
    Bs: 'BS',
    Br: 'BR',
    Bg: 'BG',
    My: 'MY',
    Ca: 'CA',
    Km: 'KM',
    Ch: 'CH',
    Ce: 'CE',
    Ny: 'NY',
    Zh: 'ZH',
    Cu: 'CU',
    Cv: 'CV',
    Kw: 'KW',
    Co: 'CO',
    Cr: 'CR',
    Hr: 'HR',
    Cs: 'CS',
    Da: 'DA',
    Dv: 'DV',
    Nl: 'NL',
    Dz: 'DZ',
    En: 'EN',
    Eo: 'EO',
    Et: 'ET',
    Ee: 'EE',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Ff: 'FF',
    Gl: 'GL',
    Lg: 'LG',
    Ka: 'KA',
    De: 'DE',
    El: 'EL',
    Gn: 'GN',
    Gu: 'GU',
    Ht: 'HT',
    Ha: 'HA',
    He: 'HE',
    Hz: 'HZ',
    Hi: 'HI',
    Ho: 'HO',
    Hu: 'HU',
    Is: 'IS',
    Io: 'IO',
    Ig: 'IG',
    Id: 'ID',
    Ia: 'IA',
    Ie: 'IE',
    Iu: 'IU',
    Ik: 'IK',
    Ga: 'GA',
    It: 'IT',
    Ja: 'JA',
    Jv: 'JV',
    Kl: 'KL',
    Kn: 'KN',
    Kr: 'KR',
    Ks: 'KS',
    Kk: 'KK',
    Ki: 'KI',
    Rw: 'RW',
    Ky: 'KY',
    Kv: 'KV',
    Kg: 'KG',
    Ko: 'KO',
    Kj: 'KJ',
    Ku: 'KU',
    Lo: 'LO',
    La: 'LA',
    Lv: 'LV',
    Li: 'LI',
    Ln: 'LN',
    Lt: 'LT',
    Lu: 'LU',
    Lb: 'LB',
    Mk: 'MK',
    Mg: 'MG',
    Ms: 'MS',
    Ml: 'ML',
    Mt: 'MT',
    Gv: 'GV',
    Mi: 'MI',
    Mr: 'MR',
    Mh: 'MH',
    Mn: 'MN',
    Na: 'NA',
    Nv: 'NV',
    Nd: 'ND',
    Nr: 'NR',
    Ng: 'NG',
    Ne: 'NE',
    Se: 'SE',
    No: 'NO',
    Nb: 'NB',
    Nn: 'NN',
    Ii: 'II',
    Oc: 'OC',
    Oj: 'OJ',
    Or: 'OR',
    Om: 'OM',
    Os: 'OS',
    Pi: 'PI',
    Ps: 'PS',
    Fa: 'FA',
    Pl: 'PL',
    Pt: 'PT',
    Pa: 'PA',
    Qu: 'QU',
    Ro: 'RO',
    Rm: 'RM',
    Rn: 'RN',
    Ru: 'RU',
    Sm: 'SM',
    Sg: 'SG',
    Sa: 'SA',
    Sc: 'SC',
    Gd: 'GD',
    Sr: 'SR',
    Sn: 'SN',
    Ii2: 'II',
    Sd: 'SD',
    Si: 'SI',
    Sk: 'SK',
    Sl: 'SL',
    So: 'SO',
    St: 'ST',
    Es: 'ES',
    Su: 'SU',
    Sw: 'SW',
    Ss: 'SS',
    Sv: 'SV',
    Tl: 'TL',
    Ty: 'TY',
    Tg: 'TG',
    Ta: 'TA',
    Tt: 'TT',
    Te: 'TE',
    Th: 'TH',
    Bo: 'BO',
    Ti: 'TI',
    To: 'TO',
    Ts: 'TS',
    Tn: 'TN',
    Tr: 'TR',
    Tk: 'TK',
    Tw: 'TW',
    Ug: 'UG',
    Uk: 'UK',
    Ur: 'UR',
    Uz: 'UZ',
    Ve: 'VE',
    Vi: 'VI',
    Vo: 'VO',
    Wa: 'WA',
    Cy: 'CY',
    Fy: 'FY',
    Wo: 'WO',
    Xh: 'XH',
    Yi: 'YI',
    Yo: 'YO',
    Za: 'ZA',
    Zu: 'ZU'
} as const;

export type NotificationInfoDtoSupportedLanguagesEnum = typeof NotificationInfoDtoSupportedLanguagesEnum[keyof typeof NotificationInfoDtoSupportedLanguagesEnum];
export const NotificationInfoDtoSupportedActionsEnum = {
    Create: 'create',
    Renew: 'renew',
    Upgrade: 'upgrade',
    Downgrade: 'downgrade',
    Transfer: 'transfer',
    Trade: 'trade',
    Suspend: 'suspend',
    Unsuspend: 'unsuspend',
    Delete: 'delete'
} as const;

export type NotificationInfoDtoSupportedActionsEnum = typeof NotificationInfoDtoSupportedActionsEnum[keyof typeof NotificationInfoDtoSupportedActionsEnum];
export const NotificationInfoDtoListenEventsEnum = {
    UserCreated: 'user/created',
    UserUpdated: 'user/updated',
    UserDeleted: 'user/deleted',
    UserBanned: 'user/banned',
    UserUnbanned: 'user/unbanned',
    UserCompanyAccessAdded: 'user/company/access/added',
    UserCompanyAccessRemoved: 'user/company/access/removed',
    UserLocked: 'user/locked',
    UserCreditBalanceUpdated: 'user/credit-balance/updated',
    UserUnlocked: 'user/unlocked',
    UserPasswordUpdated: 'user/password/updated',
    UserEmailUpdated: 'user/email/updated',
    UserCurrencyUpdated: 'user/currency/updated',
    UserInvoiceContactUpdated: 'user/invoice-contact/updated',
    UserPolicyUpdated: 'user/policy/updated',
    UserLanguagesUpdated: 'user/languages/updated',
    UserCustomPricePoliciesUpdated: 'user/custom-price-policies/updated',
    UserCustomAddonPricePoliciesUpdated: 'user/custom-addon-price-policies/updated',
    UserCustomAffiliateAdded: 'user/custom-affiliate/added',
    UserCustomAffiliateRemoved: 'user/custom-affiliate/removed',
    UserInvoiceIntervalUpdated: 'user/invoice-interval/updated',
    UserAdditionalNotificationEmailRemoved: 'user/additional-notification-email/removed',
    UserAdditionalNotificationEmailAdded: 'user/additional-notification-email/added',
    UserCommentAdded: 'user/comment/added',
    UserCommentRemoved: 'user/comment/removed',
    UserCommentUpdated: 'user/comment/updated',
    UserTagsUpdated: 'user/tags/updated',
    UserSettingAdded: 'user/setting/added',
    UserSettingRemoved: 'user/setting/removed',
    UserSettingUpdated: 'user/setting/updated',
    UserStartSelling: 'user/start-selling',
    UserRolesUpdated: 'user/roles/updated',
    UserRolesAdded: 'user/roles/added',
    UserRolesDeleted: 'user/roles/deleted',
    MessageCreated: 'message/created',
    MessageUpdated: 'message/updated',
    MessageDeleted: 'message/deleted',
    NotificationSent: 'notification/sent',
    PolicyCreated: 'policy/created',
    PolicyUpdated: 'policy/updated',
    PolicyDeleted: 'policy/deleted',
    ProductCategoryCreated: 'product-category/created',
    ProductCategoryUpdated: 'product-category/updated',
    ProductCategoryDeleted: 'product-category/deleted',
    InvoiceContactCreated: 'invoice-contact/created',
    InvoiceContactUpdated: 'invoice-contact/updated',
    InvoiceContactDeleted: 'invoice-contact/deleted',
    InvoiceCreated: 'invoice/created',
    InvoiceUpdated: 'invoice/updated',
    InvoiceDeleted: 'invoice/deleted',
    CurrencyCreated: 'currency/created',
    CurrencyUpdated: 'currency/updated',
    CurrencyDeleted: 'currency/deleted',
    AffiliateCreated: 'affiliate/created',
    AffiliateUpdated: 'affiliate/updated',
    AffiliateDeleted: 'affiliate/deleted',
    CompanyCreated: 'company/created',
    CompanyUpdated: 'company/updated',
    CompanyDeleted: 'company/deleted',
    OrganizationIntegrationAttached: 'organization/integration/attached',
    OrganizationIntegrationDetached: 'organization/integration/detached',
    TldCreated: 'tld/created',
    TldUpdated: 'tld/updated',
    TldDeleted: 'tld/deleted',
    IntegrationCreated: 'integration/created',
    IntegrationUpdated: 'integration/updated',
    IntegrationDeleted: 'integration/deleted',
    IntegrationInstalled: 'integration/installed',
    IntegrationUninstalled: 'integration/uninstalled',
    IntegrationActivated: 'integration/activated',
    IntegrationDeactivated: 'integration/deactivated',
    IntegrationMaintenanceStarted: 'integration/maintenance-started',
    IntegrationMaintenanceFinished: 'integration/maintenance-finished',
    DomainContactCreated: 'domain-contact/created',
    DomainContactUpdated: 'domain-contact/updated',
    DomainContactDeleted: 'domain-contact/deleted',
    DomainCategoryCreated: 'domain-category/created',
    DomainCategoryUpdated: 'domain-category/updated',
    DomainCategoryDeleted: 'domain-category/deleted',
    AddonCreated: 'addon/created',
    AddonUpdated: 'addon/updated',
    AddonDeleted: 'addon/deleted',
    TransactionCreated: 'transaction/created',
    TransactionCanceled: 'transaction/canceled',
    TransactionFailed: 'transaction/failed',
    TransactionSubscribed: 'transaction/subscribed',
    TransactionUnsubscribed: 'transaction/unsubscribed',
    TransactionUpdated: 'transaction/updated',
    TransactionDeleted: 'transaction/deleted',
    TransactionCompleted: 'transaction/completed',
    TransactionRefunded: 'transaction/refunded',
    TemplateCreated: 'template/created',
    TemplateUpdated: 'template/updated',
    TemplateDeleted: 'template/deleted',
    CouponCreated: 'coupon/created',
    CouponUpdated: 'coupon/updated',
    CouponDeleted: 'coupon/deleted',
    TemplateIntegrationCreated: 'template-integration/created',
    TemplateIntegrationUpdated: 'template-integration/updated',
    TemplateIntegrationDeleted: 'template-integration/deleted',
    OrderCreated: 'order/created',
    OrderStatusInProgress: 'order/status/in-progress',
    OrderStatusCompleted: 'order/status/completed',
    OrderStatusCanceled: 'order/status/canceled',
    OrderStatusPending: 'order/status/pending',
    OrderStatusArchived: 'order/status/archived',
    OrderInsufficientBalance: 'order/insufficient-balance',
    OrderItemDetached: 'order/item-detached',
    OrderInvoiceContactChanged: 'order/invoice-contact-changed',
    OrderUpdated: 'order/updated',
    OrderDeleted: 'order/deleted',
    SettingCreated: 'setting/created',
    SettingUpdated: 'setting/updated',
    SettingDeleted: 'setting/deleted',
    IssueCreated: 'issue/created',
    IssueUpdated: 'issue/updated',
    IssueDeleted: 'issue/deleted',
    TaskCreated: 'task/created',
    TaskUpdated: 'task/updated',
    TaskDeleted: 'task/deleted',
    TaskCanceled: 'task/canceled',
    TaskInProgress: 'task/in-progress',
    TaskCompleted: 'task/completed',
    TaskPercentageUpdated: 'task/percentage/updated',
    ProductCreated: 'product/created',
    ProductUpdated: 'product/updated',
    ProductDeleted: 'product/deleted',
    ProductAutoRenewUpdated: 'product/auto-renew/updated',
    ProductEnabled: 'product/enabled',
    ProductDisabled: 'product/disabled',
    ProductVersionCreated: 'product/version-created',
    IpGroupCreated: 'ip-group/created',
    IpGroupUpdated: 'ip-group/updated',
    IpGroupDeleted: 'ip-group/deleted',
    IpCreated: 'ip/created',
    IpUpdated: 'ip/updated',
    IpDeleted: 'ip/deleted',
    DomainNameCreated: 'domain-name/created',
    DomainNameUpdated: 'domain-name/updated',
    DomainNameDeleted: 'domain-name/deleted',
    DomainNameLocked: 'domain-name/locked',
    DomainNameUnlocked: 'domain-name/unlocked',
    DomainNameIdshieldActivated: 'domain-name/idshield-activated',
    DomainNameIdshieldDeactivated: 'domain-name/idshield-deactivated',
    DomainNameBundleAdded: 'domain-name/bundle-added',
    DomainNameBundleRemoved: 'domain-name/bundle-removed',
    DomainNameRegistrantUpdated: 'domain-name/registrant-updated',
    DomainNameAdminUpdated: 'domain-name/admin-updated',
    DomainNameTechUpdated: 'domain-name/tech-updated',
    DomainNameBillingUpdated: 'domain-name/billing-updated',
    DomainNameAdditionalUpdated: 'domain-name/additional-updated',
    ItemCreated: 'item/created',
    ItemUpdated: 'item/updated',
    ItemDeleted: 'item/deleted',
    ItemRenewed: 'item/renewed',
    ItemUpgraded: 'item/upgraded',
    ItemDowngraded: 'item/downgraded',
    ItemIpAttached: 'item/ip-attached',
    ItemIpDetached: 'item/ip-detached',
    ItemDetachedFromOrder: 'item/detached-from-order',
    ItemPostponed: 'item/postponed',
    ItemTransferredIn: 'item/transferred-in',
    ItemCanceled: 'item/canceled',
    ItemSuspended: 'item/suspended',
    ItemUnsuspended: 'item/unsuspended',
    ItemAffiliateAdded: 'item/affiliate/added',
    ItemBundleAttached: 'item/bundle/attached',
    ItemBundleDetached: 'item/bundle/detached',
    ItemActivated: 'item/activated',
    ItemSetInactive: 'item/set-inactive',
    ItemProcessed: 'item/processed',
    OrderPaid: 'order/paid',
    Test: 'test',
    DeadLettering: 'dead-lettering',
    CoreQueue: 'core-queue'
} as const;

export type NotificationInfoDtoListenEventsEnum = typeof NotificationInfoDtoListenEventsEnum[keyof typeof NotificationInfoDtoListenEventsEnum];
export const NotificationInfoDtoRequiredRolesEnum = {
    SimpleUser: 'SIMPLE_USER',
    FullAccess: 'FULL_ACCESS',
    SuperAdmin: 'SUPER_ADMIN',
    OrderRead: 'ORDER_READ',
    OrderWrite: 'ORDER_WRITE',
    AddonRead: 'ADDON_READ',
    AddonWrite: 'ADDON_WRITE',
    AffiliateRead: 'AFFILIATE_READ',
    AffiliateWrite: 'AFFILIATE_WRITE',
    CompanyRead: 'COMPANY_READ',
    CompanyWrite: 'COMPANY_WRITE',
    TemplateRead: 'TEMPLATE_READ',
    TemplateWrite: 'TEMPLATE_WRITE',
    CouponRead: 'COUPON_READ',
    CouponWrite: 'COUPON_WRITE',
    DomainCategoryRead: 'DOMAIN_CATEGORY_READ',
    DomainCategoryWrite: 'DOMAIN_CATEGORY_WRITE',
    DomainContactRead: 'DOMAIN_CONTACT_READ',
    DomainContactWrite: 'DOMAIN_CONTACT_WRITE',
    DomainNameRead: 'DOMAIN_NAME_READ',
    DomainNameWrite: 'DOMAIN_NAME_WRITE',
    InvoiceContactRead: 'INVOICE_CONTACT_READ',
    InvoiceContactWrite: 'INVOICE_CONTACT_WRITE',
    InvoiceRead: 'INVOICE_READ',
    InvoiceWrite: 'INVOICE_WRITE',
    IpGroupsRead: 'IP_GROUPS_READ',
    IpGroupsWrite: 'IP_GROUPS_WRITE',
    IpsRead: 'IPS_READ',
    IpsWrite: 'IPS_WRITE',
    ItemsRead: 'ITEMS_READ',
    ItemsWrite: 'ITEMS_WRITE',
    OrdersRead: 'ORDERS_READ',
    OrdersWrite: 'ORDERS_WRITE',
    TransactionsRead: 'TRANSACTIONS_READ',
    TransactionsWrite: 'TRANSACTIONS_WRITE',
    PoliciesRead: 'POLICIES_READ',
    PoliciesWrite: 'POLICIES_WRITE',
    ProductCategoriesRead: 'PRODUCT_CATEGORIES_READ',
    ProductCategoriesWrite: 'PRODUCT_CATEGORIES_WRITE',
    ProductsRead: 'PRODUCTS_READ',
    ProductsWrite: 'PRODUCTS_WRITE',
    SettingsRead: 'SETTINGS_READ',
    SettingsWrite: 'SETTINGS_WRITE',
    IntegrationsRead: 'INTEGRATIONS_READ',
    IntegrationsWrite: 'INTEGRATIONS_WRITE',
    TldsRead: 'TLDS_READ',
    TldsWrite: 'TLDS_WRITE',
    UsersRead: 'USERS_READ',
    UsersWrite: 'USERS_WRITE',
    IssuesWrite: 'ISSUES_WRITE',
    IssuesRead: 'ISSUES_READ',
    ActionLogsRead: 'ACTION_LOGS_READ'
} as const;

export type NotificationInfoDtoRequiredRolesEnum = typeof NotificationInfoDtoRequiredRolesEnum[keyof typeof NotificationInfoDtoRequiredRolesEnum];

/**
 * 
 * @export
 * @interface NotificationTemplatesRequestDto
 */
export interface NotificationTemplatesRequestDto {
    /**
     * The template for creating a new product. This field represents the official name or identifier for the template, and it cannot be empty.
     * @type {string}
     * @memberof NotificationTemplatesRequestDto
     */
    'create': string;
    /**
     * The template for renewing a product. This field represents the official name or identifier for the template, and it cannot be empty.
     * @type {string}
     * @memberof NotificationTemplatesRequestDto
     */
    'renew': string;
    /**
     * The template for suspending a product. This field represents the official name or identifier for the template, and it cannot be empty.
     * @type {string}
     * @memberof NotificationTemplatesRequestDto
     */
    'suspend': string;
    /**
     * The template for unsuspending a product. This field represents the official name or identifier for the template, and it cannot be empty.
     * @type {string}
     * @memberof NotificationTemplatesRequestDto
     */
    'unsuspend': string;
    /**
     * The template for deleting a product. This field represents the official name or identifier for the template, and it cannot be empty.
     * @type {string}
     * @memberof NotificationTemplatesRequestDto
     */
    'delete': string;
    /**
     * The template for upgrading a product. This field represents the official name or identifier for the template, and it cannot be empty.
     * @type {string}
     * @memberof NotificationTemplatesRequestDto
     */
    'upgrade': string;
    /**
     * The template for downgrading a product. This field represents the official name or identifier for the template, and it cannot be empty.
     * @type {string}
     * @memberof NotificationTemplatesRequestDto
     */
    'downgrade': string;
    /**
     * The template for updating a product. This field represents the official name or identifier for the template, and it cannot be empty.
     * @type {string}
     * @memberof NotificationTemplatesRequestDto
     */
    'update': string;
    /**
     * The template for canceling a product. This field represents the official name or identifier for the template, and it cannot be empty.
     * @type {string}
     * @memberof NotificationTemplatesRequestDto
     */
    'cancel': string;
}
/**
 * 
 * @export
 * @interface NotificationTemplatesResponseDto
 */
export interface NotificationTemplatesResponseDto {
    /**
     * 
     * @type {CreateTemplate}
     * @memberof NotificationTemplatesResponseDto
     */
    'create': CreateTemplate;
    /**
     * 
     * @type {RenewTemplate}
     * @memberof NotificationTemplatesResponseDto
     */
    'renew': RenewTemplate;
    /**
     * 
     * @type {SuspendTemplate}
     * @memberof NotificationTemplatesResponseDto
     */
    'suspend': SuspendTemplate;
    /**
     * 
     * @type {UnsuspendTemplate}
     * @memberof NotificationTemplatesResponseDto
     */
    'unsuspend': UnsuspendTemplate;
    /**
     * 
     * @type {DeleteTemplate}
     * @memberof NotificationTemplatesResponseDto
     */
    'delete': DeleteTemplate;
    /**
     * 
     * @type {UpgradeTemplate}
     * @memberof NotificationTemplatesResponseDto
     */
    'upgrade': UpgradeTemplate;
    /**
     * 
     * @type {DowngradeTemplate}
     * @memberof NotificationTemplatesResponseDto
     */
    'downgrade': DowngradeTemplate;
    /**
     * 
     * @type {UpdateTemplate}
     * @memberof NotificationTemplatesResponseDto
     */
    'update': UpdateTemplate;
    /**
     * 
     * @type {CancelTemplate}
     * @memberof NotificationTemplatesResponseDto
     */
    'cancel': CancelTemplate;
}
/**
 * @type Order
 * Represents the unique identifier for the order linked to this item.
 * @export
 */
export type Order = OrderResponseDto | string;

/**
 * @type Order1
 * The unique identifier of the associated order. If this field is null or not provided, the transaction is considered a deposit to the user\'s balance. Otherwise, it is associated with a specific order.
 * @export
 */
export type Order1 = OrderResponseDto | string;

/**
 * 
 * @export
 * @interface OrderRequestDto
 */
export interface OrderRequestDto {
    /**
     * 
     * @type {User4}
     * @memberof OrderRequestDto
     */
    'user': User4;
    /**
     * Represents an auto-incremented order identifier that is unique within the associated company. If not provided, the numbering will continue automatically from the last value.
     * @type {number}
     * @memberof OrderRequestDto
     */
    'orderNumber'?: number;
    /**
     * Indicates whether the customer has used credits to cover the difference in the order amount when the paid amount was less than the total. If true, the order was partially paid with credits.
     * @type {boolean}
     * @memberof OrderRequestDto
     */
    'useCredits': boolean;
    /**
     * A unique identifier assigned to the client company associated with this order, ensuring the order is linked to the correct client company.
     * @type {string}
     * @memberof OrderRequestDto
     */
    'clientCompany': string;
    /**
     * A unique identifier assigned to the invoice contact associated with this order.
     * @type {string}
     * @memberof OrderRequestDto
     */
    'invoiceContact': string;
    /**
     * The unique identifier for the discount coupon applied to this order. If no coupon is used, this field will be omitted.
     * @type {string}
     * @memberof OrderRequestDto
     */
    'coupon'?: string;
    /**
     * An array of items included in the order. The order must contain at least one item.
     * @type {Array<string>}
     * @memberof OrderRequestDto
     */
    'items': Array<string>;
}
/**
 * 
 * @export
 * @interface OrderResponseDto
 */
export interface OrderResponseDto {
    /**
     * 
     * @type {User4}
     * @memberof OrderResponseDto
     */
    'user': User4;
    /**
     * Represents an auto-incremented order identifier that is unique within the associated company. If not provided, the numbering will continue automatically from the last value.
     * @type {number}
     * @memberof OrderResponseDto
     */
    'orderNumber'?: number;
    /**
     * Indicates whether the customer has used credits to cover the difference in the order amount when the paid amount was less than the total. If true, the order was partially paid with credits.
     * @type {boolean}
     * @memberof OrderResponseDto
     */
    'useCredits': boolean;
    /**
     * A unique identifier for tracking and managing a specific order.
     * @type {string}
     * @memberof OrderResponseDto
     */
    'id'?: string;
    /**
     * 
     * @type {Company10}
     * @memberof OrderResponseDto
     */
    'company': Company10;
    /**
     * 
     * @type {InvoiceContact2}
     * @memberof OrderResponseDto
     */
    'invoiceContact'?: InvoiceContact2;
    /**
     * 
     * @type {ClientCompany1}
     * @memberof OrderResponseDto
     */
    'clientCompany': ClientCompany1;
    /**
     * 
     * @type {Coupon}
     * @memberof OrderResponseDto
     */
    'coupon'?: Coupon;
    /**
     * The current status of the order, indicating its progress or state in the order lifecycle (e.g., pending, completed, canceled). If not provided, it defaults to \'PENDING\'.
     * @type {string}
     * @memberof OrderResponseDto
     */
    'status'?: OrderResponseDtoStatusEnum;
    /**
     * A list of invoice IDs associated with this order. If present, these invoices are linked to the order for billing purposes.
     * @type {Array<OrderResponseDtoInvoicesInner>}
     * @memberof OrderResponseDto
     */
    'invoices'?: Array<OrderResponseDtoInvoicesInner>;
    /**
     * An array of payment details linked to this order, detailing the transactions used to settle the order\'s payment. Each entry includes the transaction ID and the corresponding payment amount.
     * @type {Array<TransactionInfoDto>}
     * @memberof OrderResponseDto
     */
    'transactions'?: Array<TransactionInfoDto>;
    /**
     * An array of items included in the order. The order must contain at least one item.
     * @type {Array<ItemResponseDtoItemBundlesInner>}
     * @memberof OrderResponseDto
     */
    'items': Array<ItemResponseDtoItemBundlesInner>;
    /**
     * 
     * @type {Summary}
     * @memberof OrderResponseDto
     */
    'summary': Summary;
    /**
     * Indicates if the order has been fully paid. A value of true means the payment is completed, while false indicates the payment is pending or not yet made.
     * @type {boolean}
     * @memberof OrderResponseDto
     */
    'paid'?: boolean;
    /**
     * Timestamp indicating when the order was created.
     * @type {string}
     * @memberof OrderResponseDto
     */
    'createdAt'?: string;
    /**
     * Timestamp indicating when the order was last updated.
     * @type {string}
     * @memberof OrderResponseDto
     */
    'updatedAt'?: string;
}

export const OrderResponseDtoStatusEnum = {
    Idle: 'idle',
    Inprogress: 'inprogress',
    Completed: 'completed',
    Canceled: 'canceled',
    Archived: 'archived',
    Refunded: 'refunded'
} as const;

export type OrderResponseDtoStatusEnum = typeof OrderResponseDtoStatusEnum[keyof typeof OrderResponseDtoStatusEnum];

/**
 * @type OrderResponseDtoInvoicesInner
 * @export
 */
export type OrderResponseDtoInvoicesInner = InvoiceResponseDto | string;

/**
 * @type Owner
 * The user entity representing the owner of the company. This field links the company to the individual or entity responsible for its management and operations.
 * @export
 */
export type Owner = UserResponseDto | string;

/**
 * 
 * @export
 * @interface PaginatedResponse
 */
export interface PaginatedResponse {
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedResponse
     */
    'message': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PaginatedResponse
     */
    'data': { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponse
     */
    'currentPage': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponse
     */
    'totalPages': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponse
     */
    'perPage': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponse
     */
    'totalResults': number;
}
/**
 * 
 * @export
 * @interface PaginationQueryDto
 */
export interface PaginationQueryDto {
    /**
     * Current page number
     * @type {number}
     * @memberof PaginationQueryDto
     */
    'currentPage'?: number;
    /**
     * Number of items per page
     * @type {number}
     * @memberof PaginationQueryDto
     */
    'perPage'?: number;
}
/**
 * @type ParentId
 * ParentId / UserId: Must provide at least one of two
 * @export
 */
export type ParentId = CompanyResponseDto | string;

/**
 * @type ParentItem
 * Captures the identifier of the immediately preceding item from which this item derives, in scenarios where it is not the primary item (e.g., during creation or transfer).
 * @export
 */
export type ParentItem = ItemResponseDto | string;

/**
 * 
 * @export
 * @interface PaymentSubscriptionResponseDto
 */
export interface PaymentSubscriptionResponseDto {
    /**
     * Metadata associated with the payment Integration.
     * @type {object}
     * @memberof PaymentSubscriptionResponseDto
     */
    'token': object;
    /**
     * 
     * @type {Integration}
     * @memberof PaymentSubscriptionResponseDto
     */
    'integration': Integration;
}
/**
 * 
 * @export
 * @interface PolicyCriteriaDto
 */
export interface PolicyCriteriaDto {
    /**
     * The minimum number of active products required to meet the criteria.
     * @type {number}
     * @memberof PolicyCriteriaDto
     */
    'activeProductsFrom': number;
    /**
     * The maximum number of active products allowed to meet the criteria.
     * @type {number}
     * @memberof PolicyCriteriaDto
     */
    'activeProductsTo': number;
    /**
     * The minimum turnover required to meet the criteria.
     * @type {number}
     * @memberof PolicyCriteriaDto
     */
    'turnoverFrom': number;
    /**
     * The maximum turnover allowed to meet the criteria.
     * @type {number}
     * @memberof PolicyCriteriaDto
     */
    'turnoverTo': number;
}
/**
 * 
 * @export
 * @interface PolicyPricesRequestDto
 */
export interface PolicyPricesRequestDto {
    /**
     * Price acoording to duration.
     * @type {string}
     * @memberof PolicyPricesRequestDto
     */
    'duration': PolicyPricesRequestDtoDurationEnum;
    /**
     * The created price number.
     * @type {number}
     * @memberof PolicyPricesRequestDto
     */
    'createPrice': number;
    /**
     * Indicates the price number for renew.
     * @type {number}
     * @memberof PolicyPricesRequestDto
     */
    'renewPrice'?: number;
    /**
     * Indicates the price number for one time payment.
     * @type {number}
     * @memberof PolicyPricesRequestDto
     */
    'setupPrice'?: number;
    /**
     * Creates the price number for an offer.
     * @type {number}
     * @memberof PolicyPricesRequestDto
     */
    'offerCreatePrice'?: number;
    /**
     * Creates the price number for a renew offer.
     * @type {number}
     * @memberof PolicyPricesRequestDto
     */
    'offerRenewPrice'?: number;
    /**
     * Creates the price number for a setup offer.
     * @type {number}
     * @memberof PolicyPricesRequestDto
     */
    'offerSetupPrice'?: number;
    /**
     * Text that describes the offer and the languege the text is writen on.
     * @type {Array<MultilangTextDto>}
     * @memberof PolicyPricesRequestDto
     */
    'offerText'?: Array<MultilangTextDto>;
    /**
     * An optional field containing dynamic pricing details based on specific attributes, such as hardware specifications or additional features.
     * @type {Array<DynamicPriceDto>}
     * @memberof PolicyPricesRequestDto
     */
    'dynamicPrices'?: Array<DynamicPriceDto>;
    /**
     * The unique identifier of the price policy assosiated with these prices.
     * @type {string}
     * @memberof PolicyPricesRequestDto
     */
    'pricePolicy': string;
}

export const PolicyPricesRequestDtoDurationEnum = {
    _0: '0',
    _1: '1',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5',
    _6: '6',
    _7: '7',
    _8: '8',
    _9: '9',
    _10: '10',
    _11: '11',
    _12: '12',
    _24: '24',
    _36: '36',
    _48: '48',
    _60: '60',
    _72: '72',
    _84: '84',
    _96: '96',
    _108: '108',
    _120: '120'
} as const;

export type PolicyPricesRequestDtoDurationEnum = typeof PolicyPricesRequestDtoDurationEnum[keyof typeof PolicyPricesRequestDtoDurationEnum];

/**
 * 
 * @export
 * @interface PolicyPricesResponseDto
 */
export interface PolicyPricesResponseDto {
    /**
     * Price acoording to duration.
     * @type {string}
     * @memberof PolicyPricesResponseDto
     */
    'duration': PolicyPricesResponseDtoDurationEnum;
    /**
     * The created price number.
     * @type {number}
     * @memberof PolicyPricesResponseDto
     */
    'createPrice': number;
    /**
     * Indicates the price number for renew.
     * @type {number}
     * @memberof PolicyPricesResponseDto
     */
    'renewPrice'?: number;
    /**
     * Indicates the price number for one time payment.
     * @type {number}
     * @memberof PolicyPricesResponseDto
     */
    'setupPrice'?: number;
    /**
     * Creates the price number for an offer.
     * @type {number}
     * @memberof PolicyPricesResponseDto
     */
    'offerCreatePrice'?: number;
    /**
     * Creates the price number for a renew offer.
     * @type {number}
     * @memberof PolicyPricesResponseDto
     */
    'offerRenewPrice'?: number;
    /**
     * Creates the price number for a setup offer.
     * @type {number}
     * @memberof PolicyPricesResponseDto
     */
    'offerSetupPrice'?: number;
    /**
     * Text that describes the offer and the languege the text is writen on.
     * @type {Array<MultilangTextDto>}
     * @memberof PolicyPricesResponseDto
     */
    'offerText'?: Array<MultilangTextDto>;
    /**
     * An optional field containing dynamic pricing details based on specific attributes, such as hardware specifications or additional features.
     * @type {Array<DynamicPriceDto>}
     * @memberof PolicyPricesResponseDto
     */
    'dynamicPrices'?: Array<DynamicPriceDto>;
    /**
     * 
     * @type {any}
     * @memberof PolicyPricesResponseDto
     */
    'pricePolicy': any;
}

export const PolicyPricesResponseDtoDurationEnum = {
    _0: '0',
    _1: '1',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5',
    _6: '6',
    _7: '7',
    _8: '8',
    _9: '9',
    _10: '10',
    _11: '11',
    _12: '12',
    _24: '24',
    _36: '36',
    _48: '48',
    _60: '60',
    _72: '72',
    _84: '84',
    _96: '96',
    _108: '108',
    _120: '120'
} as const;

export type PolicyPricesResponseDtoDurationEnum = typeof PolicyPricesResponseDtoDurationEnum[keyof typeof PolicyPricesResponseDtoDurationEnum];

/**
 * 
 * @export
 * @interface PolicyRequestDto
 */
export interface PolicyRequestDto {
    /**
     * The title of the price policy, used to identify and describe the policy clearly.
     * @type {string}
     * @memberof PolicyRequestDto
     */
    'title': string;
    /**
     * A detailed description of the price policy, used internally for administrative purposes.
     * @type {string}
     * @memberof PolicyRequestDto
     */
    'description'?: string;
    /**
     * An array of criteria used to determine the automatic application of the policy. If no criteria are defined, the policy must be applied manually by the seller.
     * @type {Array<PolicyCriteriaDto>}
     * @memberof PolicyRequestDto
     */
    'criteria'?: Array<PolicyCriteriaDto>;
}
/**
 * 
 * @export
 * @interface PolicyResponseDto
 */
export interface PolicyResponseDto {
    /**
     * The title of the price policy, used to identify and describe the policy clearly.
     * @type {string}
     * @memberof PolicyResponseDto
     */
    'title': string;
    /**
     * A detailed description of the price policy, used internally for administrative purposes.
     * @type {string}
     * @memberof PolicyResponseDto
     */
    'description'?: string;
    /**
     * An array of criteria used to determine the automatic application of the policy. If no criteria are defined, the policy must be applied manually by the seller.
     * @type {Array<PolicyCriteriaDto>}
     * @memberof PolicyResponseDto
     */
    'criteria'?: Array<PolicyCriteriaDto>;
    /**
     * The unique identifier of the policy.
     * @type {string}
     * @memberof PolicyResponseDto
     */
    'id': string;
    /**
     * 
     * @type {Company2}
     * @memberof PolicyResponseDto
     */
    'company': Company2;
    /**
     * The date when the policy was created.
     * @type {string}
     * @memberof PolicyResponseDto
     */
    'createdAt': string;
    /**
     * The date when the policy was last updated.
     * @type {string}
     * @memberof PolicyResponseDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface PopularTldRequestDto
 */
export interface PopularTldRequestDto {
    /**
     * The priority ranking for the TLD, where a lower number indicates higher importance.
     * @type {number}
     * @memberof PopularTldRequestDto
     */
    'priority': number;
    /**
     * The unique identifier of the TLD (top-level domain) referencing the TLD model.
     * @type {string}
     * @memberof PopularTldRequestDto
     */
    'tld': string;
}
/**
 * 
 * @export
 * @interface PopularTldResponseDto
 */
export interface PopularTldResponseDto {
    /**
     * The priority ranking for the TLD, where a lower number indicates higher importance.
     * @type {number}
     * @memberof PopularTldResponseDto
     */
    'priority': number;
    /**
     * 
     * @type {TLD}
     * @memberof PopularTldResponseDto
     */
    'tld': TLD;
}
/**
 * 
 * @export
 * @interface PremiumPriceCategoryDataDto
 */
export interface PremiumPriceCategoryDataDto {
    /**
     * Some domains are specified by the registry as having a premium price category and as such are more expensive to register, renew and transfer. This is only required for domains that the registry specify have a premium price category associated with
     * @type {string}
     * @memberof PremiumPriceCategoryDataDto
     */
    'priceCategory': PremiumPriceCategoryDataDtoPriceCategoryEnum;
}

export const PremiumPriceCategoryDataDtoPriceCategoryEnum = {
    _2: 'pricecategory 2',
    _3: 'pricecategory 3',
    _4: 'pricecategory 4',
    _5: 'pricecategory 5',
    _6: 'pricecategory 6',
    _7: 'pricecategory 7',
    _8: 'pricecategory 8',
    _9: 'pricecategory 9',
    _10: 'pricecategory 10',
    _11: 'pricecategory 11',
    _12: 'pricecategory 12',
    _13: 'pricecategory 13',
    _14: 'pricecategory 14',
    _15: 'pricecategory 15',
    _16: 'pricecategory 16'
} as const;

export type PremiumPriceCategoryDataDtoPriceCategoryEnum = typeof PremiumPriceCategoryDataDtoPriceCategoryEnum[keyof typeof PremiumPriceCategoryDataDtoPriceCategoryEnum];

/**
 * 
 * @export
 * @interface PremiumPricesRulesDto
 */
export interface PremiumPricesRulesDto {
    /**
     * The percentage of profit earned when selling a premium product.
     * @type {number}
     * @memberof PremiumPricesRulesDto
     */
    'percentage': number;
    /**
     * The minimum profit amount allowed for premium products.
     * @type {number}
     * @memberof PremiumPricesRulesDto
     */
    'minProfit'?: number;
    /**
     * The maximum profit amount allowed for premium products.
     * @type {number}
     * @memberof PremiumPricesRulesDto
     */
    'maxProfit'?: number;
}
/**
 * @type PricePolicy
 * A unique identifier representing the pricing policy assigned to the user.
 * @export
 */
export type PricePolicy = PricePolicyResponseDto | string;

/**
 * 
 * @export
 * @interface PricePolicyDto
 */
export interface PricePolicyDto {
    /**
     * The unique identifier of the company that created and manages this price policy.
     * @type {string}
     * @memberof PricePolicyDto
     */
    'companyId': string;
    /**
     * The specific pricing rules and configuration applied by this price policy.  This defines how the pricing is calculated (e.g., discounts, fixed prices, etc.).
     * @type {string}
     * @memberof PricePolicyDto
     */
    'policy': string;
    /**
     * A collection of price configurations, including duration-based and dynamic pricing options for the product.
     * @type {PricesDto}
     * @memberof PricePolicyDto
     */
    'prices': PricesDto;
}
/**
 * 
 * @export
 * @interface PricePolicyResponseDto
 */
export interface PricePolicyResponseDto {
    /**
     * The title of the price policy. This should be a short, descriptive name that summarizes the policy.
     * @type {string}
     * @memberof PricePolicyResponseDto
     */
    'title': string;
    /**
     * A brief description of the price policy. This can provide additional context or details about the policy.
     * @type {string}
     * @memberof PricePolicyResponseDto
     */
    'description'?: string;
    /**
     * A unique identifier for the price policy, used to reference it within the system.
     * @type {string}
     * @memberof PricePolicyResponseDto
     */
    'id': string;
    /**
     * 
     * @type {Company8}
     * @memberof PricePolicyResponseDto
     */
    'company': Company8;
    /**
     * The date the price policy created.
     * @type {string}
     * @memberof PricePolicyResponseDto
     */
    'createdAt': string;
    /**
     * The date the price policy updated.
     * @type {string}
     * @memberof PricePolicyResponseDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface PricesDto
 */
export interface PricesDto {
    /**
     * Price acoording to duration.
     * @type {string}
     * @memberof PricesDto
     */
    'duration': PricesDtoDurationEnum;
    /**
     * The created price number.
     * @type {number}
     * @memberof PricesDto
     */
    'createPrice': number;
    /**
     * Indicates the price number for renew.
     * @type {number}
     * @memberof PricesDto
     */
    'renewPrice'?: number;
    /**
     * Indicates the price number for one time payment.
     * @type {number}
     * @memberof PricesDto
     */
    'setupPrice'?: number;
    /**
     * Creates the price number for an offer.
     * @type {number}
     * @memberof PricesDto
     */
    'offerCreatePrice'?: number;
    /**
     * Creates the price number for a renew offer.
     * @type {number}
     * @memberof PricesDto
     */
    'offerRenewPrice'?: number;
    /**
     * Creates the price number for a setup offer.
     * @type {number}
     * @memberof PricesDto
     */
    'offerSetupPrice'?: number;
    /**
     * Text that describes the offer and the languege the text is writen on.
     * @type {Array<MultilangTextDto>}
     * @memberof PricesDto
     */
    'offerText'?: Array<MultilangTextDto>;
    /**
     * An optional field containing dynamic pricing details based on specific attributes, such as hardware specifications or additional features.
     * @type {Array<DynamicPriceDto>}
     * @memberof PricesDto
     */
    'dynamicPrices'?: Array<DynamicPriceDto>;
}

export const PricesDtoDurationEnum = {
    _0: '0',
    _1: '1',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5',
    _6: '6',
    _7: '7',
    _8: '8',
    _9: '9',
    _10: '10',
    _11: '11',
    _12: '12',
    _24: '24',
    _36: '36',
    _48: '48',
    _60: '60',
    _72: '72',
    _84: '84',
    _96: '96',
    _108: '108',
    _120: '120'
} as const;

export type PricesDtoDurationEnum = typeof PricesDtoDurationEnum[keyof typeof PricesDtoDurationEnum];

/**
 * 
 * @export
 * @interface ProAdditionalDataDto
 */
export interface ProAdditionalDataDto {
    /**
     * The profession or occupation of the domain holder.
     * @type {string}
     * @memberof ProAdditionalDataDto
     */
    'profession'?: string;
    /**
     * The name of the government certification body or jurisdictional licensing entity recognized by a governmental body.
     * @type {string}
     * @memberof ProAdditionalDataDto
     */
    'authority'?: string;
    /**
     * The website URL of the government certification body or jurisdictional licensing entity.
     * @type {string}
     * @memberof ProAdditionalDataDto
     */
    'authorityWebsite'?: string;
    /**
     * The licence number of the domain holder, if applicable.
     * @type {string}
     * @memberof ProAdditionalDataDto
     */
    'licenceNumber'?: string;
}
/**
 * @type Product
 * The product to which this pricing policy applies. This field contains details about the associated product, including its unique identifier and relevant metadata.
 * @export
 */
export type Product = ProductResponseDto | string;

/**
 * @type Product1
 * The product id the template is associated with
 * @export
 */
export type Product1 = ProductResponseDto | string;

/**
 * The product entity containing all relevant details about the product.
 * @export
 * @interface Product2
 */
export interface Product2 {
    /**
     * The name of the product. This field represents the official name or identifier for the product, and it cannot be empty.
     * @type {any}
     * @memberof Product2
     */
    'name': any;
    /**
     * Key-value pairs representing additional attributes of the product as defined by the seller. These attributes provide extra details about the product\'s configuration or specifications.
     * @type {{ [key: string]: any; }}
     * @memberof Product2
     */
    'attributes'?: { [key: string]: any; };
    /**
     * Indicates whether the product has dynamically calculated prices, such as pricing based on hourly usage or per-usage rates. The default value is false.
     * @type {any}
     * @memberof Product2
     */
    'hasDynamicPrices': any;
    /**
     * Indicates whether the product is activated. An activated product is active and available for use or purchase. The default value is true.
     * @type {any}
     * @memberof Product2
     */
    'activated'?: any;
    /**
     * An array of objects where each object contains the product description and its corresponding language. This enables multilingual support, allowing the product description to be displayed in various languages.
     * @type {any}
     * @memberof Product2
     */
    'description'?: any;
    /**
     * Specifies whether the product requires a domain name for its functionality or activation. This is applicable to products that are dependent on an associated domain. The default value is false.
     * @type {any}
     * @memberof Product2
     */
    'requireDomain'?: any;
    /**
     * The number of days prior to the product\'s expiration date during which the product can be renewed. For instance, a value of 5 allows renewal starting 5 days before the expiration date.
     * @type {any}
     * @memberof Product2
     */
    'preExpirationRenewalPeriod'?: any;
    /**
     * Specifies the duration of the product\'s trial period in days. A value of 0 indicates that no trial is available for this product. The default value is 0.
     * @type {any}
     * @memberof Product2
     */
    'trialDays'?: any;
    /**
     * Specifies the number of days after the product\'s expiration before it will be suspended. A value of 0 indicates immediate suspension upon expiration. The default value is 0.
     * @type {any}
     * @memberof Product2
     */
    'suspendedAfterDays'?: any;
    /**
     * The number of days after which a product is marked as deleted but can still be recovered by the user. A value of 0 means no soft delete period. The default value is 0.
     * @type {any}
     * @memberof Product2
     */
    'softDeleteDays'?: any;
    /**
     * The price charged to the user when restoring a soft-deleted product. A value of 0 indicates that there is no penalty price for restoration. The default value is 0.
     * @type {any}
     * @memberof Product2
     */
    'restorePrice'?: any;
    /**
     * The number of days after which the product is permanently deleted. A value of 0 means the product is deleted immediately. The default value is 0.
     * @type {any}
     * @memberof Product2
     */
    'hardDeleteDays'?: any;
    /**
     * Specifies the method of billing for the product. The type indicates how the product is charged, whether it is billed per hour, per month, as a subscription, or based on a snapshot or prorated basis. The default value is InvoiceTypeEnum.SUBSCRIPTION.
     * @type {any}
     * @memberof Product2
     */
    'billingMethod'?: Product2BillingMethodEnum;
    /**
     * The number of days a client can postpone the deactivation of a product after its expiration. The expiration date remains unchanged, but the product\'s deactivation is delayed for the specified duration.
     * @type {any}
     * @memberof Product2
     */
    'postponeDays'?: any;
    /**
     * The maximum number of times a user is allowed to delay the deactivation of a product within a rolling 365-day period. This feature provides flexibility for the user to extend the active state of their product without altering the original expiration date. The limit ensures fair use and prevents indefinite postponements.
     * @type {any}
     * @memberof Product2
     */
    'postponeTimesPerYear'?: any;
    /**
     * A collection of price configurations, including duration-based and dynamic pricing options for the product.
     * @type {any}
     * @memberof Product2
     */
    'prices': any;
    /**
     * Defines premium pricing policies that are exclusively applicable to domain products. These policies include configurations for user-specific pricing, associated rules, dynamic price calculations, and fixed price details.
     * @type {any}
     * @memberof Product2
     */
    'premiumPricesRules'?: any;
    /**
     * Domain prices hold specific pricing details for a domain name, including additional fees and services such as domain transfer price, lock price, ID shield price, proxy price, soft quarantine fee, and hard quarantine fee. These prices apply to certain manufactured functions associated with domain names.
     * @type {DomainPricesDto}
     * @memberof Product2
     */
    'domainPrices'?: DomainPricesDto;
    /**
     * The stock represents the number of available units left for sale, such as the number of dedicated servers remaining.
     * @type {any}
     * @memberof Product2
     */
    'stock'?: any;
    /**
     * The tags array contains keywords or labels associated with the product for identification purposes. These can help categorize or describe the product, such as \'subscription\' or other relevant terms.
     * @type {any}
     * @memberof Product2
     */
    'tags'?: any;
    /**
     * The icon URL is a URL to an image that represents the product. This can be used to display an icon for the product in the user interface.
     * @type {any}
     * @memberof Product2
     */
    'iconUrl'?: any;
    /**
     * A unique identifier for the product. If an ID is provided, it takes precedence. Otherwise, it defaults to a MongoDB ObjectId as a string. This field is optional and may be used to reference an existing product in the database.
     * @type {any}
     * @memberof Product2
     */
    'id'?: any;
    /**
     * 
     * @type {CompanyId}
     * @memberof Product2
     */
    'company': CompanyId;
    /**
     * A number that indicates the version of the product. Each version represents a specific state of the product, such as updated features, prices, or characteristics. The default value is 1.
     * @type {any}
     * @memberof Product2
     */
    'version'?: any;
    /**
     * Specifies whether the product is categorized as a domain-type product. This distinction is used for products that function as domains. The default value is false.
     * @type {any}
     * @memberof Product2
     */
    'isDomain'?: any;
    /**
     * A boolean that indicates if a version of the product is active. In cases where the product changes, a new version is created with updated prices, features, etc. The value by default is true.
     * @type {any}
     * @memberof Product2
     */
    'activeVersion'?: any;
    /**
     * 
     * @type {ProductIntegration}
     * @memberof Product2
     */
    'integration'?: ProductIntegration;
    /**
     * 
     * @type {ProductCategory}
     * @memberof Product2
     */
    'category'?: ProductCategory;
    /**
     * An array representing all possible upgrade options for the product. These IDs link to products that the current product can be upgraded to.
     * @type {any}
     * @memberof Product2
     */
    'upgradeProducts'?: any;
    /**
     * An array representing all possible downgrade options for the product. These IDs link to products that the current product can be downgraded to.
     * @type {any}
     * @memberof Product2
     */
    'downgradeProducts'?: any;
    /**
     * 
     * @type {Tld}
     * @memberof Product2
     */
    'tld'?: Tld;
    /**
     * An array of the notification templates associated with the product. These templates are used to define the structure and content of notifications sent to users regarding the product.
     * @type {NotificationTemplatesResponseDto}
     * @memberof Product2
     */
    'notificationTemplates'?: NotificationTemplatesResponseDto;
    /**
     * The addon array holds the specific addons that are used only in products without any integration.
     * @type {any}
     * @memberof Product2
     */
    'addons'?: any;
    /**
     * The affiliateIds array contains the affiliates associated with this product.
     * @type {any}
     * @memberof Product2
     */
    'affiliates'?: any;
    /**
     * Indicates whether the product is archived or not.
     * @type {any}
     * @memberof Product2
     */
    'archived': any;
    /**
     * An array that holds all the IDs of the versions of a product available, excluding the current version itself. It represents all previous versions of the product.
     * @type {any}
     * @memberof Product2
     */
    'versions': any;
    /**
     * Defines the prices per price policy for the product or domain. These policies include configurations for user-specific pricing, associated rules, dynamic price calculations, and fixed price details.
     * @type {any}
     * @memberof Product2
     */
    'policyPrices'?: any;
    /**
     * The date the product created.
     * @type {any}
     * @memberof Product2
     */
    'createdAt': any;
    /**
     * The date the product updated.
     * @type {any}
     * @memberof Product2
     */
    'updatedAt': any;
}

export const Product2BillingMethodEnum = {
    Subscription: 'SUBSCRIPTION',
    Snapshot: 'SNAPSHOT',
    Prorata: 'PRORATA'
} as const;

export type Product2BillingMethodEnum = typeof Product2BillingMethodEnum[keyof typeof Product2BillingMethodEnum];

/**
 * @type ProductCategory
 *  A unique identifier for the category of the product associated with the item. It links the item to its respective product category, providing classification and organizational context.
 * @export
 */
export type ProductCategory = ProductCategoryResponseDto | string;

/**
 * 
 * @export
 * @interface ProductCategoryRequestDto
 */
export interface ProductCategoryRequestDto {
    /**
     * Specifies the display names of the product category in various languages. These names are used to identify and present the product category in user interfaces, ensuring localization and clear understanding for users from different regions.
     * @type {Array<MultilangTextDto>}
     * @memberof ProductCategoryRequestDto
     */
    'name': Array<MultilangTextDto>;
    /**
     * Contains the descriptions of the product category in multiple languages. These descriptions provide additional context and details about the product category, making it easier for users across different regions to understand its purpose or functionality.
     * @type {Array<MultilangTextDto>}
     * @memberof ProductCategoryRequestDto
     */
    'description'?: Array<MultilangTextDto>;
    /**
     * Represents the URL of an icon associated with the product category. This icon visually identifies the category, enhancing its recognizability and providing a more intuitive user experience.
     * @type {string}
     * @memberof ProductCategoryRequestDto
     */
    'iconUrl'?: string;
    /**
     * Uniquely identifies the company associated with a product or service, ensuring accurate linkage to its organization within the system.
     * @type {string}
     * @memberof ProductCategoryRequestDto
     */
    'company': string;
}
/**
 * 
 * @export
 * @interface ProductCategoryResponseDto
 */
export interface ProductCategoryResponseDto {
    /**
     * Specifies the display names of the product category in various languages. These names are used to identify and present the product category in user interfaces, ensuring localization and clear understanding for users from different regions.
     * @type {Array<MultilangTextDto>}
     * @memberof ProductCategoryResponseDto
     */
    'name': Array<MultilangTextDto>;
    /**
     * Contains the descriptions of the product category in multiple languages. These descriptions provide additional context and details about the product category, making it easier for users across different regions to understand its purpose or functionality.
     * @type {Array<MultilangTextDto>}
     * @memberof ProductCategoryResponseDto
     */
    'description'?: Array<MultilangTextDto>;
    /**
     * Represents the URL of an icon associated with the product category. This icon visually identifies the category, enhancing its recognizability and providing a more intuitive user experience.
     * @type {string}
     * @memberof ProductCategoryResponseDto
     */
    'iconUrl'?: string;
    /**
     * Represents the unique identifier of the product category, used to distinguish and reference a specific category within the system.
     * @type {string}
     * @memberof ProductCategoryResponseDto
     */
    'id'?: string;
    /**
     * 
     * @type {Company4}
     * @memberof ProductCategoryResponseDto
     */
    'company': Company4;
    /**
     * The date the product category created.
     * @type {string}
     * @memberof ProductCategoryResponseDto
     */
    'createdAt': string;
    /**
     * The date the product category updated.
     * @type {string}
     * @memberof ProductCategoryResponseDto
     */
    'updatedAt': string;
}
/**
 * @type ProductId
 * A unique identifier for the specific product associated with this item.
 * @export
 */
export type ProductId = ProductResponseDto | string;

/**
 * 
 * @export
 * @interface ProductInfoDto
 */
export interface ProductInfoDto {
    /**
     * Configurable attributes that apply at the product level.
     * @type {Array<FieldDto>}
     * @memberof ProductInfoDto
     */
    'productAttributes'?: Array<FieldDto>;
    /**
     * Configurable attributes that apply at the item level.
     * @type {Array<FieldDto>}
     * @memberof ProductInfoDto
     */
    'itemAttributes'?: Array<FieldDto>;
    /**
     * Optional metering units for pay-per-use billing.
     * @type {Array<UnitDto>}
     * @memberof ProductInfoDto
     */
    'payPerUseUnits'?: Array<UnitDto>;
    /**
     * Mapping of field names used in provider responses.
     * @type {{ [key: string]: string; }}
     * @memberof ProductInfoDto
     */
    'responseDataFieldNames'?: { [key: string]: string; };
    /**
     * Integration display title.
     * @type {string}
     * @memberof ProductInfoDto
     */
    'title': string;
    /**
     * Public HTTPS URL for the integration logo.
     * @type {string}
     * @memberof ProductInfoDto
     */
    'logo'?: string;
    /**
     * Short description of the integration.
     * @type {string}
     * @memberof ProductInfoDto
     */
    'description'?: string;
    /**
     * Locales supported by the integration.
     * @type {Array<string>}
     * @memberof ProductInfoDto
     */
    'supportedLanguages': Array<ProductInfoDtoSupportedLanguagesEnum>;
    /**
     * Actions supported by this integration.
     * @type {Array<string>}
     * @memberof ProductInfoDto
     */
    'supportedActions'?: Array<ProductInfoDtoSupportedActionsEnum>;
    /**
     * Platform events the integration can subscribe to.
     * @type {Array<string>}
     * @memberof ProductInfoDto
     */
    'listenEvents'?: Array<ProductInfoDtoListenEventsEnum>;
    /**
     * Roles required for this integration to operate.
     * @type {Array<string>}
     * @memberof ProductInfoDto
     */
    'requiredRoles'?: Array<ProductInfoDtoRequiredRolesEnum>;
    /**
     * Admin UI links, tabs, and actions provided by the integration.
     * @type {AdminPanelDto}
     * @memberof ProductInfoDto
     */
    'adminPanel'?: AdminPanelDto;
    /**
     * Client UI links, tabs, and actions provided by the integration.
     * @type {ClientPanelDto}
     * @memberof ProductInfoDto
     */
    'clientPanel'?: ClientPanelDto;
    /**
     * URL to onboard/configure the integration.
     * @type {string}
     * @memberof ProductInfoDto
     */
    'onboardingUrl'?: string;
    /**
     * Configurable attributes that are used in the setup process.
     * @type {Array<FieldDto>}
     * @memberof ProductInfoDto
     */
    'setupAttributes'?: Array<FieldDto>;
}

export const ProductInfoDtoSupportedLanguagesEnum = {
    Ab: 'AB',
    Aa: 'AA',
    Af: 'AF',
    Ak: 'AK',
    Sq: 'SQ',
    Am: 'AM',
    Ar: 'AR',
    An: 'AN',
    Hy: 'HY',
    As: 'AS',
    Av: 'AV',
    Ae: 'AE',
    Ay: 'AY',
    Az: 'AZ',
    Bm: 'BM',
    Ba: 'BA',
    Eu: 'EU',
    Be: 'BE',
    Bn: 'BN',
    Bi: 'BI',
    Bs: 'BS',
    Br: 'BR',
    Bg: 'BG',
    My: 'MY',
    Ca: 'CA',
    Km: 'KM',
    Ch: 'CH',
    Ce: 'CE',
    Ny: 'NY',
    Zh: 'ZH',
    Cu: 'CU',
    Cv: 'CV',
    Kw: 'KW',
    Co: 'CO',
    Cr: 'CR',
    Hr: 'HR',
    Cs: 'CS',
    Da: 'DA',
    Dv: 'DV',
    Nl: 'NL',
    Dz: 'DZ',
    En: 'EN',
    Eo: 'EO',
    Et: 'ET',
    Ee: 'EE',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Ff: 'FF',
    Gl: 'GL',
    Lg: 'LG',
    Ka: 'KA',
    De: 'DE',
    El: 'EL',
    Gn: 'GN',
    Gu: 'GU',
    Ht: 'HT',
    Ha: 'HA',
    He: 'HE',
    Hz: 'HZ',
    Hi: 'HI',
    Ho: 'HO',
    Hu: 'HU',
    Is: 'IS',
    Io: 'IO',
    Ig: 'IG',
    Id: 'ID',
    Ia: 'IA',
    Ie: 'IE',
    Iu: 'IU',
    Ik: 'IK',
    Ga: 'GA',
    It: 'IT',
    Ja: 'JA',
    Jv: 'JV',
    Kl: 'KL',
    Kn: 'KN',
    Kr: 'KR',
    Ks: 'KS',
    Kk: 'KK',
    Ki: 'KI',
    Rw: 'RW',
    Ky: 'KY',
    Kv: 'KV',
    Kg: 'KG',
    Ko: 'KO',
    Kj: 'KJ',
    Ku: 'KU',
    Lo: 'LO',
    La: 'LA',
    Lv: 'LV',
    Li: 'LI',
    Ln: 'LN',
    Lt: 'LT',
    Lu: 'LU',
    Lb: 'LB',
    Mk: 'MK',
    Mg: 'MG',
    Ms: 'MS',
    Ml: 'ML',
    Mt: 'MT',
    Gv: 'GV',
    Mi: 'MI',
    Mr: 'MR',
    Mh: 'MH',
    Mn: 'MN',
    Na: 'NA',
    Nv: 'NV',
    Nd: 'ND',
    Nr: 'NR',
    Ng: 'NG',
    Ne: 'NE',
    Se: 'SE',
    No: 'NO',
    Nb: 'NB',
    Nn: 'NN',
    Ii: 'II',
    Oc: 'OC',
    Oj: 'OJ',
    Or: 'OR',
    Om: 'OM',
    Os: 'OS',
    Pi: 'PI',
    Ps: 'PS',
    Fa: 'FA',
    Pl: 'PL',
    Pt: 'PT',
    Pa: 'PA',
    Qu: 'QU',
    Ro: 'RO',
    Rm: 'RM',
    Rn: 'RN',
    Ru: 'RU',
    Sm: 'SM',
    Sg: 'SG',
    Sa: 'SA',
    Sc: 'SC',
    Gd: 'GD',
    Sr: 'SR',
    Sn: 'SN',
    Ii2: 'II',
    Sd: 'SD',
    Si: 'SI',
    Sk: 'SK',
    Sl: 'SL',
    So: 'SO',
    St: 'ST',
    Es: 'ES',
    Su: 'SU',
    Sw: 'SW',
    Ss: 'SS',
    Sv: 'SV',
    Tl: 'TL',
    Ty: 'TY',
    Tg: 'TG',
    Ta: 'TA',
    Tt: 'TT',
    Te: 'TE',
    Th: 'TH',
    Bo: 'BO',
    Ti: 'TI',
    To: 'TO',
    Ts: 'TS',
    Tn: 'TN',
    Tr: 'TR',
    Tk: 'TK',
    Tw: 'TW',
    Ug: 'UG',
    Uk: 'UK',
    Ur: 'UR',
    Uz: 'UZ',
    Ve: 'VE',
    Vi: 'VI',
    Vo: 'VO',
    Wa: 'WA',
    Cy: 'CY',
    Fy: 'FY',
    Wo: 'WO',
    Xh: 'XH',
    Yi: 'YI',
    Yo: 'YO',
    Za: 'ZA',
    Zu: 'ZU'
} as const;

export type ProductInfoDtoSupportedLanguagesEnum = typeof ProductInfoDtoSupportedLanguagesEnum[keyof typeof ProductInfoDtoSupportedLanguagesEnum];
export const ProductInfoDtoSupportedActionsEnum = {
    Create: 'create',
    Renew: 'renew',
    Upgrade: 'upgrade',
    Downgrade: 'downgrade',
    Transfer: 'transfer',
    Trade: 'trade',
    Suspend: 'suspend',
    Unsuspend: 'unsuspend',
    Delete: 'delete'
} as const;

export type ProductInfoDtoSupportedActionsEnum = typeof ProductInfoDtoSupportedActionsEnum[keyof typeof ProductInfoDtoSupportedActionsEnum];
export const ProductInfoDtoListenEventsEnum = {
    UserCreated: 'user/created',
    UserUpdated: 'user/updated',
    UserDeleted: 'user/deleted',
    UserBanned: 'user/banned',
    UserUnbanned: 'user/unbanned',
    UserCompanyAccessAdded: 'user/company/access/added',
    UserCompanyAccessRemoved: 'user/company/access/removed',
    UserLocked: 'user/locked',
    UserCreditBalanceUpdated: 'user/credit-balance/updated',
    UserUnlocked: 'user/unlocked',
    UserPasswordUpdated: 'user/password/updated',
    UserEmailUpdated: 'user/email/updated',
    UserCurrencyUpdated: 'user/currency/updated',
    UserInvoiceContactUpdated: 'user/invoice-contact/updated',
    UserPolicyUpdated: 'user/policy/updated',
    UserLanguagesUpdated: 'user/languages/updated',
    UserCustomPricePoliciesUpdated: 'user/custom-price-policies/updated',
    UserCustomAddonPricePoliciesUpdated: 'user/custom-addon-price-policies/updated',
    UserCustomAffiliateAdded: 'user/custom-affiliate/added',
    UserCustomAffiliateRemoved: 'user/custom-affiliate/removed',
    UserInvoiceIntervalUpdated: 'user/invoice-interval/updated',
    UserAdditionalNotificationEmailRemoved: 'user/additional-notification-email/removed',
    UserAdditionalNotificationEmailAdded: 'user/additional-notification-email/added',
    UserCommentAdded: 'user/comment/added',
    UserCommentRemoved: 'user/comment/removed',
    UserCommentUpdated: 'user/comment/updated',
    UserTagsUpdated: 'user/tags/updated',
    UserSettingAdded: 'user/setting/added',
    UserSettingRemoved: 'user/setting/removed',
    UserSettingUpdated: 'user/setting/updated',
    UserStartSelling: 'user/start-selling',
    UserRolesUpdated: 'user/roles/updated',
    UserRolesAdded: 'user/roles/added',
    UserRolesDeleted: 'user/roles/deleted',
    MessageCreated: 'message/created',
    MessageUpdated: 'message/updated',
    MessageDeleted: 'message/deleted',
    NotificationSent: 'notification/sent',
    PolicyCreated: 'policy/created',
    PolicyUpdated: 'policy/updated',
    PolicyDeleted: 'policy/deleted',
    ProductCategoryCreated: 'product-category/created',
    ProductCategoryUpdated: 'product-category/updated',
    ProductCategoryDeleted: 'product-category/deleted',
    InvoiceContactCreated: 'invoice-contact/created',
    InvoiceContactUpdated: 'invoice-contact/updated',
    InvoiceContactDeleted: 'invoice-contact/deleted',
    InvoiceCreated: 'invoice/created',
    InvoiceUpdated: 'invoice/updated',
    InvoiceDeleted: 'invoice/deleted',
    CurrencyCreated: 'currency/created',
    CurrencyUpdated: 'currency/updated',
    CurrencyDeleted: 'currency/deleted',
    AffiliateCreated: 'affiliate/created',
    AffiliateUpdated: 'affiliate/updated',
    AffiliateDeleted: 'affiliate/deleted',
    CompanyCreated: 'company/created',
    CompanyUpdated: 'company/updated',
    CompanyDeleted: 'company/deleted',
    OrganizationIntegrationAttached: 'organization/integration/attached',
    OrganizationIntegrationDetached: 'organization/integration/detached',
    TldCreated: 'tld/created',
    TldUpdated: 'tld/updated',
    TldDeleted: 'tld/deleted',
    IntegrationCreated: 'integration/created',
    IntegrationUpdated: 'integration/updated',
    IntegrationDeleted: 'integration/deleted',
    IntegrationInstalled: 'integration/installed',
    IntegrationUninstalled: 'integration/uninstalled',
    IntegrationActivated: 'integration/activated',
    IntegrationDeactivated: 'integration/deactivated',
    IntegrationMaintenanceStarted: 'integration/maintenance-started',
    IntegrationMaintenanceFinished: 'integration/maintenance-finished',
    DomainContactCreated: 'domain-contact/created',
    DomainContactUpdated: 'domain-contact/updated',
    DomainContactDeleted: 'domain-contact/deleted',
    DomainCategoryCreated: 'domain-category/created',
    DomainCategoryUpdated: 'domain-category/updated',
    DomainCategoryDeleted: 'domain-category/deleted',
    AddonCreated: 'addon/created',
    AddonUpdated: 'addon/updated',
    AddonDeleted: 'addon/deleted',
    TransactionCreated: 'transaction/created',
    TransactionCanceled: 'transaction/canceled',
    TransactionFailed: 'transaction/failed',
    TransactionSubscribed: 'transaction/subscribed',
    TransactionUnsubscribed: 'transaction/unsubscribed',
    TransactionUpdated: 'transaction/updated',
    TransactionDeleted: 'transaction/deleted',
    TransactionCompleted: 'transaction/completed',
    TransactionRefunded: 'transaction/refunded',
    TemplateCreated: 'template/created',
    TemplateUpdated: 'template/updated',
    TemplateDeleted: 'template/deleted',
    CouponCreated: 'coupon/created',
    CouponUpdated: 'coupon/updated',
    CouponDeleted: 'coupon/deleted',
    TemplateIntegrationCreated: 'template-integration/created',
    TemplateIntegrationUpdated: 'template-integration/updated',
    TemplateIntegrationDeleted: 'template-integration/deleted',
    OrderCreated: 'order/created',
    OrderStatusInProgress: 'order/status/in-progress',
    OrderStatusCompleted: 'order/status/completed',
    OrderStatusCanceled: 'order/status/canceled',
    OrderStatusPending: 'order/status/pending',
    OrderStatusArchived: 'order/status/archived',
    OrderInsufficientBalance: 'order/insufficient-balance',
    OrderItemDetached: 'order/item-detached',
    OrderInvoiceContactChanged: 'order/invoice-contact-changed',
    OrderUpdated: 'order/updated',
    OrderDeleted: 'order/deleted',
    SettingCreated: 'setting/created',
    SettingUpdated: 'setting/updated',
    SettingDeleted: 'setting/deleted',
    IssueCreated: 'issue/created',
    IssueUpdated: 'issue/updated',
    IssueDeleted: 'issue/deleted',
    TaskCreated: 'task/created',
    TaskUpdated: 'task/updated',
    TaskDeleted: 'task/deleted',
    TaskCanceled: 'task/canceled',
    TaskInProgress: 'task/in-progress',
    TaskCompleted: 'task/completed',
    TaskPercentageUpdated: 'task/percentage/updated',
    ProductCreated: 'product/created',
    ProductUpdated: 'product/updated',
    ProductDeleted: 'product/deleted',
    ProductAutoRenewUpdated: 'product/auto-renew/updated',
    ProductEnabled: 'product/enabled',
    ProductDisabled: 'product/disabled',
    ProductVersionCreated: 'product/version-created',
    IpGroupCreated: 'ip-group/created',
    IpGroupUpdated: 'ip-group/updated',
    IpGroupDeleted: 'ip-group/deleted',
    IpCreated: 'ip/created',
    IpUpdated: 'ip/updated',
    IpDeleted: 'ip/deleted',
    DomainNameCreated: 'domain-name/created',
    DomainNameUpdated: 'domain-name/updated',
    DomainNameDeleted: 'domain-name/deleted',
    DomainNameLocked: 'domain-name/locked',
    DomainNameUnlocked: 'domain-name/unlocked',
    DomainNameIdshieldActivated: 'domain-name/idshield-activated',
    DomainNameIdshieldDeactivated: 'domain-name/idshield-deactivated',
    DomainNameBundleAdded: 'domain-name/bundle-added',
    DomainNameBundleRemoved: 'domain-name/bundle-removed',
    DomainNameRegistrantUpdated: 'domain-name/registrant-updated',
    DomainNameAdminUpdated: 'domain-name/admin-updated',
    DomainNameTechUpdated: 'domain-name/tech-updated',
    DomainNameBillingUpdated: 'domain-name/billing-updated',
    DomainNameAdditionalUpdated: 'domain-name/additional-updated',
    ItemCreated: 'item/created',
    ItemUpdated: 'item/updated',
    ItemDeleted: 'item/deleted',
    ItemRenewed: 'item/renewed',
    ItemUpgraded: 'item/upgraded',
    ItemDowngraded: 'item/downgraded',
    ItemIpAttached: 'item/ip-attached',
    ItemIpDetached: 'item/ip-detached',
    ItemDetachedFromOrder: 'item/detached-from-order',
    ItemPostponed: 'item/postponed',
    ItemTransferredIn: 'item/transferred-in',
    ItemCanceled: 'item/canceled',
    ItemSuspended: 'item/suspended',
    ItemUnsuspended: 'item/unsuspended',
    ItemAffiliateAdded: 'item/affiliate/added',
    ItemBundleAttached: 'item/bundle/attached',
    ItemBundleDetached: 'item/bundle/detached',
    ItemActivated: 'item/activated',
    ItemSetInactive: 'item/set-inactive',
    ItemProcessed: 'item/processed',
    OrderPaid: 'order/paid',
    Test: 'test',
    DeadLettering: 'dead-lettering',
    CoreQueue: 'core-queue'
} as const;

export type ProductInfoDtoListenEventsEnum = typeof ProductInfoDtoListenEventsEnum[keyof typeof ProductInfoDtoListenEventsEnum];
export const ProductInfoDtoRequiredRolesEnum = {
    SimpleUser: 'SIMPLE_USER',
    FullAccess: 'FULL_ACCESS',
    SuperAdmin: 'SUPER_ADMIN',
    OrderRead: 'ORDER_READ',
    OrderWrite: 'ORDER_WRITE',
    AddonRead: 'ADDON_READ',
    AddonWrite: 'ADDON_WRITE',
    AffiliateRead: 'AFFILIATE_READ',
    AffiliateWrite: 'AFFILIATE_WRITE',
    CompanyRead: 'COMPANY_READ',
    CompanyWrite: 'COMPANY_WRITE',
    TemplateRead: 'TEMPLATE_READ',
    TemplateWrite: 'TEMPLATE_WRITE',
    CouponRead: 'COUPON_READ',
    CouponWrite: 'COUPON_WRITE',
    DomainCategoryRead: 'DOMAIN_CATEGORY_READ',
    DomainCategoryWrite: 'DOMAIN_CATEGORY_WRITE',
    DomainContactRead: 'DOMAIN_CONTACT_READ',
    DomainContactWrite: 'DOMAIN_CONTACT_WRITE',
    DomainNameRead: 'DOMAIN_NAME_READ',
    DomainNameWrite: 'DOMAIN_NAME_WRITE',
    InvoiceContactRead: 'INVOICE_CONTACT_READ',
    InvoiceContactWrite: 'INVOICE_CONTACT_WRITE',
    InvoiceRead: 'INVOICE_READ',
    InvoiceWrite: 'INVOICE_WRITE',
    IpGroupsRead: 'IP_GROUPS_READ',
    IpGroupsWrite: 'IP_GROUPS_WRITE',
    IpsRead: 'IPS_READ',
    IpsWrite: 'IPS_WRITE',
    ItemsRead: 'ITEMS_READ',
    ItemsWrite: 'ITEMS_WRITE',
    OrdersRead: 'ORDERS_READ',
    OrdersWrite: 'ORDERS_WRITE',
    TransactionsRead: 'TRANSACTIONS_READ',
    TransactionsWrite: 'TRANSACTIONS_WRITE',
    PoliciesRead: 'POLICIES_READ',
    PoliciesWrite: 'POLICIES_WRITE',
    ProductCategoriesRead: 'PRODUCT_CATEGORIES_READ',
    ProductCategoriesWrite: 'PRODUCT_CATEGORIES_WRITE',
    ProductsRead: 'PRODUCTS_READ',
    ProductsWrite: 'PRODUCTS_WRITE',
    SettingsRead: 'SETTINGS_READ',
    SettingsWrite: 'SETTINGS_WRITE',
    IntegrationsRead: 'INTEGRATIONS_READ',
    IntegrationsWrite: 'INTEGRATIONS_WRITE',
    TldsRead: 'TLDS_READ',
    TldsWrite: 'TLDS_WRITE',
    UsersRead: 'USERS_READ',
    UsersWrite: 'USERS_WRITE',
    IssuesWrite: 'ISSUES_WRITE',
    IssuesRead: 'ISSUES_READ',
    ActionLogsRead: 'ACTION_LOGS_READ'
} as const;

export type ProductInfoDtoRequiredRolesEnum = typeof ProductInfoDtoRequiredRolesEnum[keyof typeof ProductInfoDtoRequiredRolesEnum];

/**
 * @type ProductIntegration
 * Represents the integration associated with this product. This field links the product to its corresponding integration.
 * @export
 */
export type ProductIntegration = IntegrationResponseDto | string;

/**
 * 
 * @export
 * @interface ProductRequestDto
 */
export interface ProductRequestDto {
    /**
     * The name of the product. This field represents the official name or identifier for the product, and it cannot be empty.
     * @type {string}
     * @memberof ProductRequestDto
     */
    'name': string;
    /**
     * Key-value pairs representing additional attributes of the product as defined by the seller. These attributes provide extra details about the product\'s configuration or specifications.
     * @type {{ [key: string]: any; }}
     * @memberof ProductRequestDto
     */
    'attributes'?: { [key: string]: any; };
    /**
     * Indicates whether the product has dynamically calculated prices, such as pricing based on hourly usage or per-usage rates. The default value is false.
     * @type {boolean}
     * @memberof ProductRequestDto
     */
    'hasDynamicPrices': boolean;
    /**
     * Indicates whether the product is activated. An activated product is active and available for use or purchase. The default value is true.
     * @type {boolean}
     * @memberof ProductRequestDto
     */
    'activated'?: boolean;
    /**
     * An array of objects where each object contains the product description and its corresponding language. This enables multilingual support, allowing the product description to be displayed in various languages.
     * @type {Array<MultilangTextDto>}
     * @memberof ProductRequestDto
     */
    'description'?: Array<MultilangTextDto>;
    /**
     * Specifies whether the product requires a domain name for its functionality or activation. This is applicable to products that are dependent on an associated domain. The default value is false.
     * @type {boolean}
     * @memberof ProductRequestDto
     */
    'requireDomain'?: boolean;
    /**
     * The number of days prior to the product\'s expiration date during which the product can be renewed. For instance, a value of 5 allows renewal starting 5 days before the expiration date.
     * @type {number}
     * @memberof ProductRequestDto
     */
    'preExpirationRenewalPeriod'?: number;
    /**
     * Specifies the duration of the product\'s trial period in days. A value of 0 indicates that no trial is available for this product. The default value is 0.
     * @type {number}
     * @memberof ProductRequestDto
     */
    'trialDays'?: number;
    /**
     * Specifies the number of days after the product\'s expiration before it will be suspended. A value of 0 indicates immediate suspension upon expiration. The default value is 0.
     * @type {number}
     * @memberof ProductRequestDto
     */
    'suspendedAfterDays'?: number;
    /**
     * The number of days after which a product is marked as deleted but can still be recovered by the user. A value of 0 means no soft delete period. The default value is 0.
     * @type {number}
     * @memberof ProductRequestDto
     */
    'softDeleteDays'?: number;
    /**
     * The price charged to the user when restoring a soft-deleted product. A value of 0 indicates that there is no penalty price for restoration. The default value is 0.
     * @type {number}
     * @memberof ProductRequestDto
     */
    'restorePrice'?: number;
    /**
     * The number of days after which the product is permanently deleted. A value of 0 means the product is deleted immediately. The default value is 0.
     * @type {number}
     * @memberof ProductRequestDto
     */
    'hardDeleteDays'?: number;
    /**
     * Specifies the method of billing for the product. The type indicates how the product is charged, whether it is billed per hour, per month, as a subscription, or based on a snapshot or prorated basis. The default value is InvoiceTypeEnum.SUBSCRIPTION.
     * @type {string}
     * @memberof ProductRequestDto
     */
    'billingMethod'?: ProductRequestDtoBillingMethodEnum;
    /**
     * The number of days a client can postpone the deactivation of a product after its expiration. The expiration date remains unchanged, but the product\'s deactivation is delayed for the specified duration.
     * @type {number}
     * @memberof ProductRequestDto
     */
    'postponeDays'?: number;
    /**
     * The maximum number of times a user is allowed to delay the deactivation of a product within a rolling 365-day period. This feature provides flexibility for the user to extend the active state of their product without altering the original expiration date. The limit ensures fair use and prevents indefinite postponements.
     * @type {number}
     * @memberof ProductRequestDto
     */
    'postponeTimesPerYear'?: number;
    /**
     * A collection of price configurations, including duration-based and dynamic pricing options for the product.
     * @type {Array<PricesDto>}
     * @memberof ProductRequestDto
     */
    'prices': Array<PricesDto>;
    /**
     * Defines premium pricing policies that are exclusively applicable to domain products. These policies include configurations for user-specific pricing, associated rules, dynamic price calculations, and fixed price details.
     * @type {Array<PremiumPricesRulesDto>}
     * @memberof ProductRequestDto
     */
    'premiumPricesRules'?: Array<PremiumPricesRulesDto>;
    /**
     * Domain prices hold specific pricing details for a domain name, including additional fees and services such as domain transfer price, lock price, ID shield price, proxy price, soft quarantine fee, and hard quarantine fee. These prices apply to certain manufactured functions associated with domain names.
     * @type {DomainPricesDto}
     * @memberof ProductRequestDto
     */
    'domainPrices'?: DomainPricesDto;
    /**
     * The stock represents the number of available units left for sale, such as the number of dedicated servers remaining.
     * @type {number}
     * @memberof ProductRequestDto
     */
    'stock'?: number;
    /**
     * The tags array contains keywords or labels associated with the product for identification purposes. These can help categorize or describe the product, such as \'subscription\' or other relevant terms.
     * @type {Array<string>}
     * @memberof ProductRequestDto
     */
    'tags'?: Array<string>;
    /**
     * The icon URL is a URL to an image that represents the product. This can be used to display an icon for the product in the user interface.
     * @type {string}
     * @memberof ProductRequestDto
     */
    'iconUrl'?: string;
    /**
     * The ID of the integration responsible for managing the product. This ID links the product with its corresponding integration for centralized management and interaction.
     * @type {string}
     * @memberof ProductRequestDto
     */
    'integration'?: string;
    /**
     * The unique identifier of the category to which the product belongs. This helps in organizing and grouping products under a specific category.
     * @type {string}
     * @memberof ProductRequestDto
     */
    'category'?: string;
    /**
     * An array of unique identifiers representing all possible upgrade options for the product. These IDs link to products that the current product can be upgraded to.
     * @type {Array<string>}
     * @memberof ProductRequestDto
     */
    'upgradeProducts'?: Array<string>;
    /**
     * An array of unique identifiers representing all possible downgrade options for the product. These IDs link to products that the current product can be downgraded to.
     * @type {Array<string>}
     * @memberof ProductRequestDto
     */
    'downgradeProducts'?: Array<string>;
    /**
     * An object that maps product actions to specific notification template IDs. Each key represents a mandatory action (create, renew, suspend, unsuspend, delete), and its value is the ID of the template to be used for that action.
     * @type {NotificationTemplatesRequestDto}
     * @memberof ProductRequestDto
     */
    'notificationTemplates'?: NotificationTemplatesRequestDto;
    /**
     * The addonIds array holds the unique identifiers of the specific addons that are used only in products without any integration.
     * @type {Array<string>}
     * @memberof ProductRequestDto
     */
    'addons'?: Array<string>;
    /**
     * The affiliateIds array contains the unique identifiers of the affiliates associated with this product.
     * @type {Array<string>}
     * @memberof ProductRequestDto
     */
    'affiliates'?: Array<string>;
    /**
     * Defines the prices per price policy for the product or domain. These policies include configurations for user-specific pricing, associated rules, dynamic price calculations, and fixed price details.
     * @type {Array<PolicyPricesRequestDto>}
     * @memberof ProductRequestDto
     */
    'policyPrices'?: Array<PolicyPricesRequestDto>;
    /**
     * The tld of the top-level domain (TLD) selected. It represents the TLD to which all associated properties and configurations.
     * @type {string}
     * @memberof ProductRequestDto
     */
    'tld'?: string;
}

export const ProductRequestDtoBillingMethodEnum = {
    Subscription: 'SUBSCRIPTION',
    Snapshot: 'SNAPSHOT',
    Prorata: 'PRORATA'
} as const;

export type ProductRequestDtoBillingMethodEnum = typeof ProductRequestDtoBillingMethodEnum[keyof typeof ProductRequestDtoBillingMethodEnum];

/**
 * 
 * @export
 * @interface ProductResponseDto
 */
export interface ProductResponseDto {
    /**
     * The name of the product. This field represents the official name or identifier for the product, and it cannot be empty.
     * @type {string}
     * @memberof ProductResponseDto
     */
    'name': string;
    /**
     * Key-value pairs representing additional attributes of the product as defined by the seller. These attributes provide extra details about the product\'s configuration or specifications.
     * @type {{ [key: string]: any; }}
     * @memberof ProductResponseDto
     */
    'attributes'?: { [key: string]: any; };
    /**
     * Indicates whether the product has dynamically calculated prices, such as pricing based on hourly usage or per-usage rates. The default value is false.
     * @type {boolean}
     * @memberof ProductResponseDto
     */
    'hasDynamicPrices': boolean;
    /**
     * Indicates whether the product is activated. An activated product is active and available for use or purchase. The default value is true.
     * @type {boolean}
     * @memberof ProductResponseDto
     */
    'activated'?: boolean;
    /**
     * An array of objects where each object contains the product description and its corresponding language. This enables multilingual support, allowing the product description to be displayed in various languages.
     * @type {Array<MultilangTextDto>}
     * @memberof ProductResponseDto
     */
    'description'?: Array<MultilangTextDto>;
    /**
     * Specifies whether the product requires a domain name for its functionality or activation. This is applicable to products that are dependent on an associated domain. The default value is false.
     * @type {boolean}
     * @memberof ProductResponseDto
     */
    'requireDomain'?: boolean;
    /**
     * The number of days prior to the product\'s expiration date during which the product can be renewed. For instance, a value of 5 allows renewal starting 5 days before the expiration date.
     * @type {number}
     * @memberof ProductResponseDto
     */
    'preExpirationRenewalPeriod'?: number;
    /**
     * Specifies the duration of the product\'s trial period in days. A value of 0 indicates that no trial is available for this product. The default value is 0.
     * @type {number}
     * @memberof ProductResponseDto
     */
    'trialDays'?: number;
    /**
     * Specifies the number of days after the product\'s expiration before it will be suspended. A value of 0 indicates immediate suspension upon expiration. The default value is 0.
     * @type {number}
     * @memberof ProductResponseDto
     */
    'suspendedAfterDays'?: number;
    /**
     * The number of days after which a product is marked as deleted but can still be recovered by the user. A value of 0 means no soft delete period. The default value is 0.
     * @type {number}
     * @memberof ProductResponseDto
     */
    'softDeleteDays'?: number;
    /**
     * The price charged to the user when restoring a soft-deleted product. A value of 0 indicates that there is no penalty price for restoration. The default value is 0.
     * @type {number}
     * @memberof ProductResponseDto
     */
    'restorePrice'?: number;
    /**
     * The number of days after which the product is permanently deleted. A value of 0 means the product is deleted immediately. The default value is 0.
     * @type {number}
     * @memberof ProductResponseDto
     */
    'hardDeleteDays'?: number;
    /**
     * Specifies the method of billing for the product. The type indicates how the product is charged, whether it is billed per hour, per month, as a subscription, or based on a snapshot or prorated basis. The default value is InvoiceTypeEnum.SUBSCRIPTION.
     * @type {string}
     * @memberof ProductResponseDto
     */
    'billingMethod'?: ProductResponseDtoBillingMethodEnum;
    /**
     * The number of days a client can postpone the deactivation of a product after its expiration. The expiration date remains unchanged, but the product\'s deactivation is delayed for the specified duration.
     * @type {number}
     * @memberof ProductResponseDto
     */
    'postponeDays'?: number;
    /**
     * The maximum number of times a user is allowed to delay the deactivation of a product within a rolling 365-day period. This feature provides flexibility for the user to extend the active state of their product without altering the original expiration date. The limit ensures fair use and prevents indefinite postponements.
     * @type {number}
     * @memberof ProductResponseDto
     */
    'postponeTimesPerYear'?: number;
    /**
     * A collection of price configurations, including duration-based and dynamic pricing options for the product.
     * @type {Array<PricesDto>}
     * @memberof ProductResponseDto
     */
    'prices': Array<PricesDto>;
    /**
     * Defines premium pricing policies that are exclusively applicable to domain products. These policies include configurations for user-specific pricing, associated rules, dynamic price calculations, and fixed price details.
     * @type {Array<PremiumPricesRulesDto>}
     * @memberof ProductResponseDto
     */
    'premiumPricesRules'?: Array<PremiumPricesRulesDto>;
    /**
     * Domain prices hold specific pricing details for a domain name, including additional fees and services such as domain transfer price, lock price, ID shield price, proxy price, soft quarantine fee, and hard quarantine fee. These prices apply to certain manufactured functions associated with domain names.
     * @type {DomainPricesDto}
     * @memberof ProductResponseDto
     */
    'domainPrices'?: DomainPricesDto;
    /**
     * The stock represents the number of available units left for sale, such as the number of dedicated servers remaining.
     * @type {number}
     * @memberof ProductResponseDto
     */
    'stock'?: number;
    /**
     * The tags array contains keywords or labels associated with the product for identification purposes. These can help categorize or describe the product, such as \'subscription\' or other relevant terms.
     * @type {Array<string>}
     * @memberof ProductResponseDto
     */
    'tags'?: Array<string>;
    /**
     * The icon URL is a URL to an image that represents the product. This can be used to display an icon for the product in the user interface.
     * @type {string}
     * @memberof ProductResponseDto
     */
    'iconUrl'?: string;
    /**
     * A unique identifier for the product. If an ID is provided, it takes precedence. Otherwise, it defaults to a MongoDB ObjectId as a string. This field is optional and may be used to reference an existing product in the database.
     * @type {string}
     * @memberof ProductResponseDto
     */
    'id'?: string;
    /**
     * 
     * @type {CompanyId}
     * @memberof ProductResponseDto
     */
    'company': CompanyId;
    /**
     * A number that indicates the version of the product. Each version represents a specific state of the product, such as updated features, prices, or characteristics. The default value is 1.
     * @type {number}
     * @memberof ProductResponseDto
     */
    'version'?: number;
    /**
     * Specifies whether the product is categorized as a domain-type product. This distinction is used for products that function as domains. The default value is false.
     * @type {boolean}
     * @memberof ProductResponseDto
     */
    'isDomain'?: boolean;
    /**
     * A boolean that indicates if a version of the product is active. In cases where the product changes, a new version is created with updated prices, features, etc. The value by default is true.
     * @type {boolean}
     * @memberof ProductResponseDto
     */
    'activeVersion'?: boolean;
    /**
     * 
     * @type {ProductIntegration}
     * @memberof ProductResponseDto
     */
    'integration'?: ProductIntegration;
    /**
     * 
     * @type {ProductCategory}
     * @memberof ProductResponseDto
     */
    'category'?: ProductCategory;
    /**
     * An array representing all possible upgrade options for the product. These IDs link to products that the current product can be upgraded to.
     * @type {Array<ProductVersionDtoProductInner>}
     * @memberof ProductResponseDto
     */
    'upgradeProducts'?: Array<ProductVersionDtoProductInner>;
    /**
     * An array representing all possible downgrade options for the product. These IDs link to products that the current product can be downgraded to.
     * @type {Array<ProductVersionDtoProductInner>}
     * @memberof ProductResponseDto
     */
    'downgradeProducts'?: Array<ProductVersionDtoProductInner>;
    /**
     * 
     * @type {Tld}
     * @memberof ProductResponseDto
     */
    'tld'?: Tld;
    /**
     * An array of the notification templates associated with the product. These templates are used to define the structure and content of notifications sent to users regarding the product.
     * @type {NotificationTemplatesResponseDto}
     * @memberof ProductResponseDto
     */
    'notificationTemplates'?: NotificationTemplatesResponseDto;
    /**
     * The addon array holds the specific addons that are used only in products without any integration.
     * @type {Array<ProductResponseDtoAddonsInner>}
     * @memberof ProductResponseDto
     */
    'addons'?: Array<ProductResponseDtoAddonsInner>;
    /**
     * The affiliateIds array contains the affiliates associated with this product.
     * @type {Array<UserResponseDtoCustomAffiliatesInner>}
     * @memberof ProductResponseDto
     */
    'affiliates'?: Array<UserResponseDtoCustomAffiliatesInner>;
    /**
     * Indicates whether the product is archived or not.
     * @type {boolean}
     * @memberof ProductResponseDto
     */
    'archived': boolean;
    /**
     * An array that holds all the IDs of the versions of a product available, excluding the current version itself. It represents all previous versions of the product.
     * @type {Array<ProductVersionDto>}
     * @memberof ProductResponseDto
     */
    'versions': Array<ProductVersionDto>;
    /**
     * Defines the prices per price policy for the product or domain. These policies include configurations for user-specific pricing, associated rules, dynamic price calculations, and fixed price details.
     * @type {Array<PolicyPricesResponseDto>}
     * @memberof ProductResponseDto
     */
    'policyPrices'?: Array<PolicyPricesResponseDto>;
    /**
     * The date the product created.
     * @type {string}
     * @memberof ProductResponseDto
     */
    'createdAt': string;
    /**
     * The date the product updated.
     * @type {string}
     * @memberof ProductResponseDto
     */
    'updatedAt': string;
}

export const ProductResponseDtoBillingMethodEnum = {
    Subscription: 'SUBSCRIPTION',
    Snapshot: 'SNAPSHOT',
    Prorata: 'PRORATA'
} as const;

export type ProductResponseDtoBillingMethodEnum = typeof ProductResponseDtoBillingMethodEnum[keyof typeof ProductResponseDtoBillingMethodEnum];

/**
 * @type ProductResponseDtoAddonsInner
 * @export
 */
export type ProductResponseDtoAddonsInner = AddonResponseDto | string;

/**
 * 
 * @export
 * @interface ProductUpdateRequestDto
 */
export interface ProductUpdateRequestDto {
    /**
     * The name of the product. This field represents the official name or identifier for the product, and it cannot be empty.
     * @type {string}
     * @memberof ProductUpdateRequestDto
     */
    'name': string;
    /**
     * Key-value pairs representing additional attributes of the product as defined by the seller. These attributes provide extra details about the product\'s configuration or specifications.
     * @type {{ [key: string]: any; }}
     * @memberof ProductUpdateRequestDto
     */
    'attributes': { [key: string]: any; };
    /**
     * Indicates whether the product has dynamically calculated prices, such as pricing based on hourly usage or per-usage rates. The default value is false.
     * @type {boolean}
     * @memberof ProductUpdateRequestDto
     */
    'hasDynamicPrices': boolean;
    /**
     * An array of objects where each object contains the product description and its corresponding language. This enables multilingual support, allowing the product description to be displayed in various languages.
     * @type {Array<MultilangTextDto>}
     * @memberof ProductUpdateRequestDto
     */
    'description': Array<MultilangTextDto>;
    /**
     * The number of days prior to the product\'s expiration date during which the product can be renewed. For instance, a value of 5 allows renewal starting 5 days before the expiration date.
     * @type {number}
     * @memberof ProductUpdateRequestDto
     */
    'preExpirationRenewalPeriod': number;
    /**
     * Specifies the duration of the product\'s trial period in days. A value of 0 indicates that no trial is available for this product. The default value is 0.
     * @type {number}
     * @memberof ProductUpdateRequestDto
     */
    'trialDays': number;
    /**
     * Specifies the number of days after the product\'s expiration before it will be suspended. A value of 0 indicates immediate suspension upon expiration. The default value is 0.
     * @type {number}
     * @memberof ProductUpdateRequestDto
     */
    'suspendedAfterDays': number;
    /**
     * The number of days after which a product is marked as deleted but can still be recovered by the user. A value of 0 means no soft delete period. The default value is 0.
     * @type {number}
     * @memberof ProductUpdateRequestDto
     */
    'softDeleteDays': number;
    /**
     * The price charged to the user when restoring a soft-deleted product. A value of 0 indicates that there is no penalty price for restoration. The default value is 0.
     * @type {number}
     * @memberof ProductUpdateRequestDto
     */
    'restorePrice': number;
    /**
     * The number of days after which the product is permanently deleted. A value of 0 means the product is deleted immediately. The default value is 0.
     * @type {number}
     * @memberof ProductUpdateRequestDto
     */
    'hardDeleteDays': number;
    /**
     * Specifies the method of billing for the product. The type indicates how the product is charged, whether it is billed per hour, per month, as a subscription, or based on a snapshot or prorated basis. The default value is InvoiceTypeEnum.SUBSCRIPTION.
     * @type {string}
     * @memberof ProductUpdateRequestDto
     */
    'billingMethod': ProductUpdateRequestDtoBillingMethodEnum;
    /**
     * The number of days a client can postpone the deactivation of a product after its expiration. The expiration date remains unchanged, but the product\'s deactivation is delayed for the specified duration.
     * @type {number}
     * @memberof ProductUpdateRequestDto
     */
    'postponeDays': number;
    /**
     * The maximum number of times a user is allowed to delay the deactivation of a product within a rolling 365-day period. This feature provides flexibility for the user to extend the active state of their product without altering the original expiration date. The limit ensures fair use and prevents indefinite postponements.
     * @type {number}
     * @memberof ProductUpdateRequestDto
     */
    'postponeTimesPerYear': number;
    /**
     * A collection of price configurations, including duration-based and dynamic pricing options for the product.
     * @type {Array<PricesDto>}
     * @memberof ProductUpdateRequestDto
     */
    'prices': Array<PricesDto>;
    /**
     * Defines premium pricing policies that are exclusively applicable to domain products. These policies include configurations for user-specific pricing, associated rules, dynamic price calculations, and fixed price details.
     * @type {Array<PremiumPricesRulesDto>}
     * @memberof ProductUpdateRequestDto
     */
    'premiumPricesRules': Array<PremiumPricesRulesDto>;
    /**
     * Domain prices hold specific pricing details for a domain name, including additional fees and services such as domain transfer price, lock price, ID shield price, proxy price, soft quarantine fee, and hard quarantine fee. These prices apply to certain manufactured functions associated with domain names.
     * @type {DomainPricesDto}
     * @memberof ProductUpdateRequestDto
     */
    'domainPrices': DomainPricesDto;
    /**
     * The stock represents the number of available units left for sale, such as the number of dedicated servers remaining.
     * @type {number}
     * @memberof ProductUpdateRequestDto
     */
    'stock': number;
    /**
     * The tags array contains keywords or labels associated with the product for identification purposes. These can help categorize or describe the product, such as \'subscription\' or other relevant terms.
     * @type {Array<string>}
     * @memberof ProductUpdateRequestDto
     */
    'tags': Array<string>;
    /**
     * The icon URL is a URL to an image that represents the product. This can be used to display an icon for the product in the user interface.
     * @type {string}
     * @memberof ProductUpdateRequestDto
     */
    'iconUrl': string;
    /**
     * The unique identifier of the category to which the product belongs. This helps in organizing and grouping products under a specific category.
     * @type {string}
     * @memberof ProductUpdateRequestDto
     */
    'category': string;
    /**
     * An array of unique identifiers representing all possible upgrade options for the product. These IDs link to products that the current product can be upgraded to.
     * @type {Array<string>}
     * @memberof ProductUpdateRequestDto
     */
    'upgradeProducts': Array<string>;
    /**
     * An array of unique identifiers representing all possible downgrade options for the product. These IDs link to products that the current product can be downgraded to.
     * @type {Array<string>}
     * @memberof ProductUpdateRequestDto
     */
    'downgradeProducts': Array<string>;
    /**
     * An object that maps product actions to specific notification template IDs. Each key represents a mandatory action (create, renew, suspend, unsuspend, delete), and its value is the ID of the template to be used for that action.
     * @type {NotificationTemplatesRequestDto}
     * @memberof ProductUpdateRequestDto
     */
    'notificationTemplates': NotificationTemplatesRequestDto;
    /**
     * The addonIds array holds the unique identifiers of the specific addons that are used only in products without any integration.
     * @type {Array<string>}
     * @memberof ProductUpdateRequestDto
     */
    'addons': Array<string>;
    /**
     * The affiliateIds array contains the unique identifiers of the affiliates associated with this product.
     * @type {Array<string>}
     * @memberof ProductUpdateRequestDto
     */
    'affiliates': Array<string>;
    /**
     * Defines the prices per price policy for the product or domain. These policies include configurations for user-specific pricing, associated rules, dynamic price calculations, and fixed price details.
     * @type {Array<PolicyPricesRequestDto>}
     * @memberof ProductUpdateRequestDto
     */
    'policyPrices': Array<PolicyPricesRequestDto>;
}

export const ProductUpdateRequestDtoBillingMethodEnum = {
    Subscription: 'SUBSCRIPTION',
    Snapshot: 'SNAPSHOT',
    Prorata: 'PRORATA'
} as const;

export type ProductUpdateRequestDtoBillingMethodEnum = typeof ProductUpdateRequestDtoBillingMethodEnum[keyof typeof ProductUpdateRequestDtoBillingMethodEnum];

/**
 * 
 * @export
 * @interface ProductVersionDto
 */
export interface ProductVersionDto {
    /**
     * A number that indicates the version of the product. Each version represents a specific state of the product, such as updated features, prices, or characteristics. The default value is 1.
     * @type {number}
     * @memberof ProductVersionDto
     */
    'version'?: number;
    /**
     * An array that holds all the IDs of the versions of a product available, excluding the current version itself. It represents all previous versions of the product.
     * @type {Array<ProductVersionDtoProductInner>}
     * @memberof ProductVersionDto
     */
    'product': Array<ProductVersionDtoProductInner>;
}
/**
 * @type ProductVersionDtoProductInner
 * @export
 */
export type ProductVersionDtoProductInner = ProductResponseDto | string;

/**
 * 
 * @export
 * @interface ProxyServiceDataDto
 */
export interface ProxyServiceDataDto {
    /**
     * Indicates whether the domain should be registered through a proxy owner.
     * @type {boolean}
     * @memberof ProxyServiceDataDto
     */
    'useProxyService': boolean;
}
/**
 * 
 * @export
 * @interface PublicIntegrationInfoDto
 */
export interface PublicIntegrationInfoDto {
    /**
     * The title of the integration.
     * @type {string}
     * @memberof PublicIntegrationInfoDto
     */
    'title': string;
    /**
     * The logo URL of the integration.
     * @type {string}
     * @memberof PublicIntegrationInfoDto
     */
    'logo': string;
    /**
     * The description of the integration.
     * @type {string}
     * @memberof PublicIntegrationInfoDto
     */
    'description': string;
    /**
     * Supported languages for the integration.
     * @type {Array<string>}
     * @memberof PublicIntegrationInfoDto
     */
    'supportedLanguages': Array<string>;
    /**
     * Roles required for the integration.
     * @type {Array<string>}
     * @memberof PublicIntegrationInfoDto
     */
    'requiredRoles': Array<PublicIntegrationInfoDtoRequiredRolesEnum>;
    /**
     * The type of notification supported by the integration.
     * @type {string}
     * @memberof PublicIntegrationInfoDto
     */
    'notificationType': PublicIntegrationInfoDtoNotificationTypeEnum;
}

export const PublicIntegrationInfoDtoRequiredRolesEnum = {
    SimpleUser: 'SIMPLE_USER',
    FullAccess: 'FULL_ACCESS',
    SuperAdmin: 'SUPER_ADMIN',
    OrderRead: 'ORDER_READ',
    OrderWrite: 'ORDER_WRITE',
    AddonRead: 'ADDON_READ',
    AddonWrite: 'ADDON_WRITE',
    AffiliateRead: 'AFFILIATE_READ',
    AffiliateWrite: 'AFFILIATE_WRITE',
    CompanyRead: 'COMPANY_READ',
    CompanyWrite: 'COMPANY_WRITE',
    TemplateRead: 'TEMPLATE_READ',
    TemplateWrite: 'TEMPLATE_WRITE',
    CouponRead: 'COUPON_READ',
    CouponWrite: 'COUPON_WRITE',
    DomainCategoryRead: 'DOMAIN_CATEGORY_READ',
    DomainCategoryWrite: 'DOMAIN_CATEGORY_WRITE',
    DomainContactRead: 'DOMAIN_CONTACT_READ',
    DomainContactWrite: 'DOMAIN_CONTACT_WRITE',
    DomainNameRead: 'DOMAIN_NAME_READ',
    DomainNameWrite: 'DOMAIN_NAME_WRITE',
    InvoiceContactRead: 'INVOICE_CONTACT_READ',
    InvoiceContactWrite: 'INVOICE_CONTACT_WRITE',
    InvoiceRead: 'INVOICE_READ',
    InvoiceWrite: 'INVOICE_WRITE',
    IpGroupsRead: 'IP_GROUPS_READ',
    IpGroupsWrite: 'IP_GROUPS_WRITE',
    IpsRead: 'IPS_READ',
    IpsWrite: 'IPS_WRITE',
    ItemsRead: 'ITEMS_READ',
    ItemsWrite: 'ITEMS_WRITE',
    OrdersRead: 'ORDERS_READ',
    OrdersWrite: 'ORDERS_WRITE',
    TransactionsRead: 'TRANSACTIONS_READ',
    TransactionsWrite: 'TRANSACTIONS_WRITE',
    PoliciesRead: 'POLICIES_READ',
    PoliciesWrite: 'POLICIES_WRITE',
    ProductCategoriesRead: 'PRODUCT_CATEGORIES_READ',
    ProductCategoriesWrite: 'PRODUCT_CATEGORIES_WRITE',
    ProductsRead: 'PRODUCTS_READ',
    ProductsWrite: 'PRODUCTS_WRITE',
    SettingsRead: 'SETTINGS_READ',
    SettingsWrite: 'SETTINGS_WRITE',
    IntegrationsRead: 'INTEGRATIONS_READ',
    IntegrationsWrite: 'INTEGRATIONS_WRITE',
    TldsRead: 'TLDS_READ',
    TldsWrite: 'TLDS_WRITE',
    UsersRead: 'USERS_READ',
    UsersWrite: 'USERS_WRITE',
    IssuesWrite: 'ISSUES_WRITE',
    IssuesRead: 'ISSUES_READ',
    ActionLogsRead: 'ACTION_LOGS_READ'
} as const;

export type PublicIntegrationInfoDtoRequiredRolesEnum = typeof PublicIntegrationInfoDtoRequiredRolesEnum[keyof typeof PublicIntegrationInfoDtoRequiredRolesEnum];
export const PublicIntegrationInfoDtoNotificationTypeEnum = {
    Email: 'email',
    Sms: 'sms',
    Push: 'push'
} as const;

export type PublicIntegrationInfoDtoNotificationTypeEnum = typeof PublicIntegrationInfoDtoNotificationTypeEnum[keyof typeof PublicIntegrationInfoDtoNotificationTypeEnum];

/**
 * 
 * @export
 * @interface PushPayloadDto
 */
export interface PushPayloadDto {
    /**
     * The title of the push message
     * @type {string}
     * @memberof PushPayloadDto
     */
    'title': string;
    /**
     * The subtitle of the push message
     * @type {string}
     * @memberof PushPayloadDto
     */
    'subtitle': string;
    /**
     * The content of the push message
     * @type {string}
     * @memberof PushPayloadDto
     */
    'body': string;
}
/**
 * 
 * @export
 * @interface RefreshSecret200Response
 */
export interface RefreshSecret200Response {
    /**
     * The HTTP status code indicating the result of the operation.
     * @type {any}
     * @memberof RefreshSecret200Response
     */
    'code': any;
    /**
     * A human-readable message providing more details about the response.
     * @type {any}
     * @memberof RefreshSecret200Response
     */
    'message': any;
    /**
     * 
     * @type {string}
     * @memberof RefreshSecret200Response
     */
    'data': string;
}
/**
 * 
 * @export
 * @interface RefundRequestDto
 */
export interface RefundRequestDto {
    /**
     * An array of items and prices to be refunded.
     * @type {Array<Array<string>>}
     * @memberof RefundRequestDto
     */
    'refundItems': Array<Array<string>>;
    /**
     * A comment to be added to the refund request.
     * @type {string}
     * @memberof RefundRequestDto
     */
    'comment': string;
}
/**
 * 
 * @export
 * @interface RegistryContactsDto
 */
export interface RegistryContactsDto {
    /**
     * The unique identifier for the domain\'s registrant (the owner of the domain).
     * @type {string}
     * @memberof RegistryContactsDto
     */
    'registrantCode': string;
    /**
     * The unique identifier for the domain\'s administrative contact, responsible for managing the domain.
     * @type {string}
     * @memberof RegistryContactsDto
     */
    'adminCode': string;
    /**
     * The unique identifier for the domain\'s technical contact, responsible for technical configuration and support.
     * @type {string}
     * @memberof RegistryContactsDto
     */
    'techCode': string;
    /**
     * The unique identifier for the domain\'s billing contact, responsible for managing payments and invoices.
     * @type {string}
     * @memberof RegistryContactsDto
     */
    'billingCode': string;
}
/**
 * @type RenewTemplate
 * The template for renewing a product. This field represents the official name or identifier for the template, and it cannot be empty.
 * @export
 */
export type RenewTemplate = TemplateResponseDto | string;

/**
 * 
 * @export
 * @interface SelectedNotificationIntegrationsDto
 */
export interface SelectedNotificationIntegrationsDto {
    /**
     * The unique identifier of the email notification integration to be used for sending email alerts.
     * @type {string}
     * @memberof SelectedNotificationIntegrationsDto
     */
    'emailNotification': string;
    /**
     * The unique identifier of the SMS notification integration to be used for sending text messages.
     * @type {string}
     * @memberof SelectedNotificationIntegrationsDto
     */
    'smsNotification'?: string;
    /**
     * The unique identifier of the push notification integration to be used for sending real-time notifications.
     * @type {string}
     * @memberof SelectedNotificationIntegrationsDto
     */
    'pushNotification'?: string;
}
/**
 * 
 * @export
 * @interface SetCompanyCreditBalanceRequest
 */
export interface SetCompanyCreditBalanceRequest {
    /**
     * 
     * @type {number}
     * @memberof SetCompanyCreditBalanceRequest
     */
    'creditBalance'?: number;
}
/**
 * @type Settings
 * Admin panel settings page configuration.
 * @export
 */
export type Settings = SettingsWithTabsDto | SettingsWithUrlDto;

/**
 * 
 * @export
 * @interface SettingsDto
 */
export interface SettingsDto {
    /**
     * Label of the settings page.
     * @type {string}
     * @memberof SettingsDto
     */
    'label': string;
    /**
     * Icon of the settings page.
     * @type {string}
     * @memberof SettingsDto
     */
    'icon': string;
    /**
     * Description of the settings page.
     * @type {string}
     * @memberof SettingsDto
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface SettingsWithTabsDto
 */
export interface SettingsWithTabsDto {
    /**
     * Tabs shown on the settings page.
     * @type {Array<TabDto>}
     * @memberof SettingsWithTabsDto
     */
    'tabs': Array<TabDto>;
    /**
     * Label of the settings page.
     * @type {string}
     * @memberof SettingsWithTabsDto
     */
    'label': string;
    /**
     * Icon of the settings page.
     * @type {string}
     * @memberof SettingsWithTabsDto
     */
    'icon': string;
    /**
     * Description of the settings page.
     * @type {string}
     * @memberof SettingsWithTabsDto
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface SettingsWithUrlDto
 */
export interface SettingsWithUrlDto {
    /**
     * 
     * @type {string}
     * @memberof SettingsWithUrlDto
     */
    'url': string;
    /**
     * Label of the settings page.
     * @type {string}
     * @memberof SettingsWithUrlDto
     */
    'label': string;
    /**
     * Icon of the settings page.
     * @type {string}
     * @memberof SettingsWithUrlDto
     */
    'icon': string;
    /**
     * Description of the settings page.
     * @type {string}
     * @memberof SettingsWithUrlDto
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface SingleResponseDto
 */
export interface SingleResponseDto {
    /**
     * The HTTP status code indicating the result of the operation.
     * @type {number}
     * @memberof SingleResponseDto
     */
    'code': number;
    /**
     * A human-readable message providing more details about the response.
     * @type {string}
     * @memberof SingleResponseDto
     */
    'message': string;
    /**
     * The data payload containing the response details.
     * @type {{ [key: string]: any; }}
     * @memberof SingleResponseDto
     */
    'data': { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface SmsPayloadDto
 */
export interface SmsPayloadDto {
    /**
     * The SMS message content
     * @type {string}
     * @memberof SmsPayloadDto
     */
    'body': string;
}
/**
 * Provides a summary of the total costs associated with the order.
 * @export
 * @interface Summary
 */
export interface Summary {
    /**
     * Price acoording to duration.
     * @type {any}
     * @memberof Summary
     */
    'duration': SummaryDurationEnum;
    /**
     * The created price number.
     * @type {any}
     * @memberof Summary
     */
    'createPrice': any;
    /**
     * Indicates the price number for renew.
     * @type {any}
     * @memberof Summary
     */
    'renewPrice'?: any;
    /**
     * Indicates the price number for one time payment.
     * @type {any}
     * @memberof Summary
     */
    'setupPrice'?: any;
    /**
     * Creates the price number for an offer.
     * @type {any}
     * @memberof Summary
     */
    'offerCreatePrice'?: any;
    /**
     * Creates the price number for a renew offer.
     * @type {any}
     * @memberof Summary
     */
    'offerRenewPrice'?: any;
    /**
     * Creates the price number for a setup offer.
     * @type {any}
     * @memberof Summary
     */
    'offerSetupPrice'?: any;
    /**
     * Text that describes the offer and the languege the text is writen on.
     * @type {any}
     * @memberof Summary
     */
    'offerText'?: any;
    /**
     * An optional field containing dynamic pricing details based on specific attributes, such as hardware specifications or additional features.
     * @type {any}
     * @memberof Summary
     */
    'dynamicPrices'?: any;
}

export const SummaryDurationEnum = {
    _0: '0',
    _1: '1',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5',
    _6: '6',
    _7: '7',
    _8: '8',
    _9: '9',
    _10: '10',
    _11: '11',
    _12: '12',
    _24: '24',
    _36: '36',
    _48: '48',
    _60: '60',
    _72: '72',
    _84: '84',
    _96: '96',
    _108: '108',
    _120: '120'
} as const;

export type SummaryDurationEnum = typeof SummaryDurationEnum[keyof typeof SummaryDurationEnum];

/**
 * 
 * @export
 * @interface SunriseDataDto
 */
export interface SunriseDataDto {
    /**
     * A Signed Mark Data (SMD) file is a token demonstrating that minimum eligibility requirements for Sunrise have been verified by the Clearinghouse. The SMD can be used by the Trademark holder to apply for a Domain Name during the sunrise period.
     * @type {string}
     * @memberof SunriseDataDto
     */
    'smdFile': string;
}
/**
 * @type SuspendTemplate
 * The template for suspending a product. This field represents the official name or identifier for the template, and it cannot be empty.
 * @export
 */
export type SuspendTemplate = TemplateResponseDto | string;

/**
 * @type TLD
 * The detailed top-level domain (TLD) information, including its properties and associated metadata.
 * @export
 */
export type TLD = TldResponseDto | string;

/**
 * 
 * @export
 * @interface TabDto
 */
export interface TabDto {
    /**
     * Text label for the tab.
     * @type {string}
     * @memberof TabDto
     */
    'label': string;
    /**
     * URL associated with the tab.
     * @type {string}
     * @memberof TabDto
     */
    'url': string;
}
/**
 * Tab structure for Admin panel sections.
 * @export
 * @interface Tabs
 */
export interface Tabs {
    /**
     * 
     * @type {AdminPanelTabsDto}
     * @memberof Tabs
     */
    'tabs'?: AdminPanelTabsDto;
}
/**
 * Tab structure for Client panel.
 * @export
 * @interface Tabs1
 */
export interface Tabs1 {
    /**
     * 
     * @type {ClientPanelTabsDto}
     * @memberof Tabs1
     */
    'tabs'?: ClientPanelTabsDto;
}
/**
 * @type TemplateData
 * An array tha cantains necessary data for the templates.
 * @export
 */
export type TemplateData = EmailPayloadDto | PushPayloadDto | SmsPayloadDto;

/**
 * 
 * @export
 * @interface TemplateRequestDto
 */
export interface TemplateRequestDto {
    /**
     * The title of the template.
     * @type {string}
     * @memberof TemplateRequestDto
     */
    'title': string;
    /**
     * The notification type of the template.
     * @type {string}
     * @memberof TemplateRequestDto
     */
    'notificationType': TemplateRequestDtoNotificationTypeEnum;
    /**
     * 
     * @type {TemplateData}
     * @memberof TemplateRequestDto
     */
    'data': TemplateData;
    /**
     * The event associated with the template.
     * @type {string}
     * @memberof TemplateRequestDto
     */
    'event'?: TemplateRequestDtoEventEnum;
    /**
     * The integration id of the template
     * @type {string}
     * @memberof TemplateRequestDto
     */
    'integration': string;
    /**
     * The product id the template is associated with
     * @type {string}
     * @memberof TemplateRequestDto
     */
    'product'?: string;
}

export const TemplateRequestDtoNotificationTypeEnum = {
    Email: 'email',
    Chat: 'chat',
    Push: 'push',
    Sms: 'sms'
} as const;

export type TemplateRequestDtoNotificationTypeEnum = typeof TemplateRequestDtoNotificationTypeEnum[keyof typeof TemplateRequestDtoNotificationTypeEnum];
export const TemplateRequestDtoEventEnum = {
    UserCreated: 'user/created',
    UserUpdated: 'user/updated',
    UserDeleted: 'user/deleted',
    UserBanned: 'user/banned',
    UserUnbanned: 'user/unbanned',
    UserCompanyAccessAdded: 'user/company/access/added',
    UserCompanyAccessRemoved: 'user/company/access/removed',
    UserLocked: 'user/locked',
    UserCreditBalanceUpdated: 'user/credit-balance/updated',
    UserUnlocked: 'user/unlocked',
    UserPasswordUpdated: 'user/password/updated',
    UserEmailUpdated: 'user/email/updated',
    UserCurrencyUpdated: 'user/currency/updated',
    UserInvoiceContactUpdated: 'user/invoice-contact/updated',
    UserPolicyUpdated: 'user/policy/updated',
    UserLanguagesUpdated: 'user/languages/updated',
    UserCustomPricePoliciesUpdated: 'user/custom-price-policies/updated',
    UserCustomAddonPricePoliciesUpdated: 'user/custom-addon-price-policies/updated',
    UserCustomAffiliateAdded: 'user/custom-affiliate/added',
    UserCustomAffiliateRemoved: 'user/custom-affiliate/removed',
    UserInvoiceIntervalUpdated: 'user/invoice-interval/updated',
    UserAdditionalNotificationEmailRemoved: 'user/additional-notification-email/removed',
    UserAdditionalNotificationEmailAdded: 'user/additional-notification-email/added',
    UserCommentAdded: 'user/comment/added',
    UserCommentRemoved: 'user/comment/removed',
    UserCommentUpdated: 'user/comment/updated',
    UserTagsUpdated: 'user/tags/updated',
    UserSettingAdded: 'user/setting/added',
    UserSettingRemoved: 'user/setting/removed',
    UserSettingUpdated: 'user/setting/updated',
    UserStartSelling: 'user/start-selling',
    UserRolesUpdated: 'user/roles/updated',
    UserRolesAdded: 'user/roles/added',
    UserRolesDeleted: 'user/roles/deleted',
    MessageCreated: 'message/created',
    MessageUpdated: 'message/updated',
    MessageDeleted: 'message/deleted',
    NotificationSent: 'notification/sent',
    PolicyCreated: 'policy/created',
    PolicyUpdated: 'policy/updated',
    PolicyDeleted: 'policy/deleted',
    ProductCategoryCreated: 'product-category/created',
    ProductCategoryUpdated: 'product-category/updated',
    ProductCategoryDeleted: 'product-category/deleted',
    InvoiceContactCreated: 'invoice-contact/created',
    InvoiceContactUpdated: 'invoice-contact/updated',
    InvoiceContactDeleted: 'invoice-contact/deleted',
    InvoiceCreated: 'invoice/created',
    InvoiceUpdated: 'invoice/updated',
    InvoiceDeleted: 'invoice/deleted',
    CurrencyCreated: 'currency/created',
    CurrencyUpdated: 'currency/updated',
    CurrencyDeleted: 'currency/deleted',
    AffiliateCreated: 'affiliate/created',
    AffiliateUpdated: 'affiliate/updated',
    AffiliateDeleted: 'affiliate/deleted',
    CompanyCreated: 'company/created',
    CompanyUpdated: 'company/updated',
    CompanyDeleted: 'company/deleted',
    OrganizationIntegrationAttached: 'organization/integration/attached',
    OrganizationIntegrationDetached: 'organization/integration/detached',
    TldCreated: 'tld/created',
    TldUpdated: 'tld/updated',
    TldDeleted: 'tld/deleted',
    IntegrationCreated: 'integration/created',
    IntegrationUpdated: 'integration/updated',
    IntegrationDeleted: 'integration/deleted',
    IntegrationInstalled: 'integration/installed',
    IntegrationUninstalled: 'integration/uninstalled',
    IntegrationActivated: 'integration/activated',
    IntegrationDeactivated: 'integration/deactivated',
    IntegrationMaintenanceStarted: 'integration/maintenance-started',
    IntegrationMaintenanceFinished: 'integration/maintenance-finished',
    DomainContactCreated: 'domain-contact/created',
    DomainContactUpdated: 'domain-contact/updated',
    DomainContactDeleted: 'domain-contact/deleted',
    DomainCategoryCreated: 'domain-category/created',
    DomainCategoryUpdated: 'domain-category/updated',
    DomainCategoryDeleted: 'domain-category/deleted',
    AddonCreated: 'addon/created',
    AddonUpdated: 'addon/updated',
    AddonDeleted: 'addon/deleted',
    TransactionCreated: 'transaction/created',
    TransactionCanceled: 'transaction/canceled',
    TransactionFailed: 'transaction/failed',
    TransactionSubscribed: 'transaction/subscribed',
    TransactionUnsubscribed: 'transaction/unsubscribed',
    TransactionUpdated: 'transaction/updated',
    TransactionDeleted: 'transaction/deleted',
    TransactionCompleted: 'transaction/completed',
    TransactionRefunded: 'transaction/refunded',
    TemplateCreated: 'template/created',
    TemplateUpdated: 'template/updated',
    TemplateDeleted: 'template/deleted',
    CouponCreated: 'coupon/created',
    CouponUpdated: 'coupon/updated',
    CouponDeleted: 'coupon/deleted',
    TemplateIntegrationCreated: 'template-integration/created',
    TemplateIntegrationUpdated: 'template-integration/updated',
    TemplateIntegrationDeleted: 'template-integration/deleted',
    OrderCreated: 'order/created',
    OrderStatusInProgress: 'order/status/in-progress',
    OrderStatusCompleted: 'order/status/completed',
    OrderStatusCanceled: 'order/status/canceled',
    OrderStatusPending: 'order/status/pending',
    OrderStatusArchived: 'order/status/archived',
    OrderInsufficientBalance: 'order/insufficient-balance',
    OrderItemDetached: 'order/item-detached',
    OrderInvoiceContactChanged: 'order/invoice-contact-changed',
    OrderUpdated: 'order/updated',
    OrderDeleted: 'order/deleted',
    SettingCreated: 'setting/created',
    SettingUpdated: 'setting/updated',
    SettingDeleted: 'setting/deleted',
    IssueCreated: 'issue/created',
    IssueUpdated: 'issue/updated',
    IssueDeleted: 'issue/deleted',
    TaskCreated: 'task/created',
    TaskUpdated: 'task/updated',
    TaskDeleted: 'task/deleted',
    TaskCanceled: 'task/canceled',
    TaskInProgress: 'task/in-progress',
    TaskCompleted: 'task/completed',
    TaskPercentageUpdated: 'task/percentage/updated',
    ProductCreated: 'product/created',
    ProductUpdated: 'product/updated',
    ProductDeleted: 'product/deleted',
    ProductAutoRenewUpdated: 'product/auto-renew/updated',
    ProductEnabled: 'product/enabled',
    ProductDisabled: 'product/disabled',
    ProductVersionCreated: 'product/version-created',
    IpGroupCreated: 'ip-group/created',
    IpGroupUpdated: 'ip-group/updated',
    IpGroupDeleted: 'ip-group/deleted',
    IpCreated: 'ip/created',
    IpUpdated: 'ip/updated',
    IpDeleted: 'ip/deleted',
    DomainNameCreated: 'domain-name/created',
    DomainNameUpdated: 'domain-name/updated',
    DomainNameDeleted: 'domain-name/deleted',
    DomainNameLocked: 'domain-name/locked',
    DomainNameUnlocked: 'domain-name/unlocked',
    DomainNameIdshieldActivated: 'domain-name/idshield-activated',
    DomainNameIdshieldDeactivated: 'domain-name/idshield-deactivated',
    DomainNameBundleAdded: 'domain-name/bundle-added',
    DomainNameBundleRemoved: 'domain-name/bundle-removed',
    DomainNameRegistrantUpdated: 'domain-name/registrant-updated',
    DomainNameAdminUpdated: 'domain-name/admin-updated',
    DomainNameTechUpdated: 'domain-name/tech-updated',
    DomainNameBillingUpdated: 'domain-name/billing-updated',
    DomainNameAdditionalUpdated: 'domain-name/additional-updated',
    ItemCreated: 'item/created',
    ItemUpdated: 'item/updated',
    ItemDeleted: 'item/deleted',
    ItemRenewed: 'item/renewed',
    ItemUpgraded: 'item/upgraded',
    ItemDowngraded: 'item/downgraded',
    ItemIpAttached: 'item/ip-attached',
    ItemIpDetached: 'item/ip-detached',
    ItemDetachedFromOrder: 'item/detached-from-order',
    ItemPostponed: 'item/postponed',
    ItemTransferredIn: 'item/transferred-in',
    ItemCanceled: 'item/canceled',
    ItemSuspended: 'item/suspended',
    ItemUnsuspended: 'item/unsuspended',
    ItemAffiliateAdded: 'item/affiliate/added',
    ItemBundleAttached: 'item/bundle/attached',
    ItemBundleDetached: 'item/bundle/detached',
    ItemActivated: 'item/activated',
    ItemSetInactive: 'item/set-inactive',
    ItemProcessed: 'item/processed',
    OrderPaid: 'order/paid',
    Test: 'test',
    DeadLettering: 'dead-lettering',
    CoreQueue: 'core-queue'
} as const;

export type TemplateRequestDtoEventEnum = typeof TemplateRequestDtoEventEnum[keyof typeof TemplateRequestDtoEventEnum];

/**
 * 
 * @export
 * @interface TemplateResponseDto
 */
export interface TemplateResponseDto {
    /**
     * The title of the template.
     * @type {string}
     * @memberof TemplateResponseDto
     */
    'title': string;
    /**
     * The notification type of the template.
     * @type {string}
     * @memberof TemplateResponseDto
     */
    'notificationType': TemplateResponseDtoNotificationTypeEnum;
    /**
     * 
     * @type {TemplateData}
     * @memberof TemplateResponseDto
     */
    'data': TemplateData;
    /**
     * The event associated with the template.
     * @type {string}
     * @memberof TemplateResponseDto
     */
    'event'?: TemplateResponseDtoEventEnum;
    /**
     * The unique identifier of the template.
     * @type {string}
     * @memberof TemplateResponseDto
     */
    'id': string;
    /**
     * 
     * @type {Company5}
     * @memberof TemplateResponseDto
     */
    'company': Company5;
    /**
     * 
     * @type {Integration1}
     * @memberof TemplateResponseDto
     */
    'integration': Integration1;
    /**
     * 
     * @type {Product1}
     * @memberof TemplateResponseDto
     */
    'product'?: Product1;
    /**
     * Indicates if the template is deletable or not.
     * @type {boolean}
     * @memberof TemplateResponseDto
     */
    'deletable': boolean;
    /**
     * The date when the template was created.
     * @type {string}
     * @memberof TemplateResponseDto
     */
    'createdAt': string;
    /**
     * The date when the template was updated.
     * @type {string}
     * @memberof TemplateResponseDto
     */
    'updatedAt': string;
}

export const TemplateResponseDtoNotificationTypeEnum = {
    Email: 'email',
    Chat: 'chat',
    Push: 'push',
    Sms: 'sms'
} as const;

export type TemplateResponseDtoNotificationTypeEnum = typeof TemplateResponseDtoNotificationTypeEnum[keyof typeof TemplateResponseDtoNotificationTypeEnum];
export const TemplateResponseDtoEventEnum = {
    UserCreated: 'user/created',
    UserUpdated: 'user/updated',
    UserDeleted: 'user/deleted',
    UserBanned: 'user/banned',
    UserUnbanned: 'user/unbanned',
    UserCompanyAccessAdded: 'user/company/access/added',
    UserCompanyAccessRemoved: 'user/company/access/removed',
    UserLocked: 'user/locked',
    UserCreditBalanceUpdated: 'user/credit-balance/updated',
    UserUnlocked: 'user/unlocked',
    UserPasswordUpdated: 'user/password/updated',
    UserEmailUpdated: 'user/email/updated',
    UserCurrencyUpdated: 'user/currency/updated',
    UserInvoiceContactUpdated: 'user/invoice-contact/updated',
    UserPolicyUpdated: 'user/policy/updated',
    UserLanguagesUpdated: 'user/languages/updated',
    UserCustomPricePoliciesUpdated: 'user/custom-price-policies/updated',
    UserCustomAddonPricePoliciesUpdated: 'user/custom-addon-price-policies/updated',
    UserCustomAffiliateAdded: 'user/custom-affiliate/added',
    UserCustomAffiliateRemoved: 'user/custom-affiliate/removed',
    UserInvoiceIntervalUpdated: 'user/invoice-interval/updated',
    UserAdditionalNotificationEmailRemoved: 'user/additional-notification-email/removed',
    UserAdditionalNotificationEmailAdded: 'user/additional-notification-email/added',
    UserCommentAdded: 'user/comment/added',
    UserCommentRemoved: 'user/comment/removed',
    UserCommentUpdated: 'user/comment/updated',
    UserTagsUpdated: 'user/tags/updated',
    UserSettingAdded: 'user/setting/added',
    UserSettingRemoved: 'user/setting/removed',
    UserSettingUpdated: 'user/setting/updated',
    UserStartSelling: 'user/start-selling',
    UserRolesUpdated: 'user/roles/updated',
    UserRolesAdded: 'user/roles/added',
    UserRolesDeleted: 'user/roles/deleted',
    MessageCreated: 'message/created',
    MessageUpdated: 'message/updated',
    MessageDeleted: 'message/deleted',
    NotificationSent: 'notification/sent',
    PolicyCreated: 'policy/created',
    PolicyUpdated: 'policy/updated',
    PolicyDeleted: 'policy/deleted',
    ProductCategoryCreated: 'product-category/created',
    ProductCategoryUpdated: 'product-category/updated',
    ProductCategoryDeleted: 'product-category/deleted',
    InvoiceContactCreated: 'invoice-contact/created',
    InvoiceContactUpdated: 'invoice-contact/updated',
    InvoiceContactDeleted: 'invoice-contact/deleted',
    InvoiceCreated: 'invoice/created',
    InvoiceUpdated: 'invoice/updated',
    InvoiceDeleted: 'invoice/deleted',
    CurrencyCreated: 'currency/created',
    CurrencyUpdated: 'currency/updated',
    CurrencyDeleted: 'currency/deleted',
    AffiliateCreated: 'affiliate/created',
    AffiliateUpdated: 'affiliate/updated',
    AffiliateDeleted: 'affiliate/deleted',
    CompanyCreated: 'company/created',
    CompanyUpdated: 'company/updated',
    CompanyDeleted: 'company/deleted',
    OrganizationIntegrationAttached: 'organization/integration/attached',
    OrganizationIntegrationDetached: 'organization/integration/detached',
    TldCreated: 'tld/created',
    TldUpdated: 'tld/updated',
    TldDeleted: 'tld/deleted',
    IntegrationCreated: 'integration/created',
    IntegrationUpdated: 'integration/updated',
    IntegrationDeleted: 'integration/deleted',
    IntegrationInstalled: 'integration/installed',
    IntegrationUninstalled: 'integration/uninstalled',
    IntegrationActivated: 'integration/activated',
    IntegrationDeactivated: 'integration/deactivated',
    IntegrationMaintenanceStarted: 'integration/maintenance-started',
    IntegrationMaintenanceFinished: 'integration/maintenance-finished',
    DomainContactCreated: 'domain-contact/created',
    DomainContactUpdated: 'domain-contact/updated',
    DomainContactDeleted: 'domain-contact/deleted',
    DomainCategoryCreated: 'domain-category/created',
    DomainCategoryUpdated: 'domain-category/updated',
    DomainCategoryDeleted: 'domain-category/deleted',
    AddonCreated: 'addon/created',
    AddonUpdated: 'addon/updated',
    AddonDeleted: 'addon/deleted',
    TransactionCreated: 'transaction/created',
    TransactionCanceled: 'transaction/canceled',
    TransactionFailed: 'transaction/failed',
    TransactionSubscribed: 'transaction/subscribed',
    TransactionUnsubscribed: 'transaction/unsubscribed',
    TransactionUpdated: 'transaction/updated',
    TransactionDeleted: 'transaction/deleted',
    TransactionCompleted: 'transaction/completed',
    TransactionRefunded: 'transaction/refunded',
    TemplateCreated: 'template/created',
    TemplateUpdated: 'template/updated',
    TemplateDeleted: 'template/deleted',
    CouponCreated: 'coupon/created',
    CouponUpdated: 'coupon/updated',
    CouponDeleted: 'coupon/deleted',
    TemplateIntegrationCreated: 'template-integration/created',
    TemplateIntegrationUpdated: 'template-integration/updated',
    TemplateIntegrationDeleted: 'template-integration/deleted',
    OrderCreated: 'order/created',
    OrderStatusInProgress: 'order/status/in-progress',
    OrderStatusCompleted: 'order/status/completed',
    OrderStatusCanceled: 'order/status/canceled',
    OrderStatusPending: 'order/status/pending',
    OrderStatusArchived: 'order/status/archived',
    OrderInsufficientBalance: 'order/insufficient-balance',
    OrderItemDetached: 'order/item-detached',
    OrderInvoiceContactChanged: 'order/invoice-contact-changed',
    OrderUpdated: 'order/updated',
    OrderDeleted: 'order/deleted',
    SettingCreated: 'setting/created',
    SettingUpdated: 'setting/updated',
    SettingDeleted: 'setting/deleted',
    IssueCreated: 'issue/created',
    IssueUpdated: 'issue/updated',
    IssueDeleted: 'issue/deleted',
    TaskCreated: 'task/created',
    TaskUpdated: 'task/updated',
    TaskDeleted: 'task/deleted',
    TaskCanceled: 'task/canceled',
    TaskInProgress: 'task/in-progress',
    TaskCompleted: 'task/completed',
    TaskPercentageUpdated: 'task/percentage/updated',
    ProductCreated: 'product/created',
    ProductUpdated: 'product/updated',
    ProductDeleted: 'product/deleted',
    ProductAutoRenewUpdated: 'product/auto-renew/updated',
    ProductEnabled: 'product/enabled',
    ProductDisabled: 'product/disabled',
    ProductVersionCreated: 'product/version-created',
    IpGroupCreated: 'ip-group/created',
    IpGroupUpdated: 'ip-group/updated',
    IpGroupDeleted: 'ip-group/deleted',
    IpCreated: 'ip/created',
    IpUpdated: 'ip/updated',
    IpDeleted: 'ip/deleted',
    DomainNameCreated: 'domain-name/created',
    DomainNameUpdated: 'domain-name/updated',
    DomainNameDeleted: 'domain-name/deleted',
    DomainNameLocked: 'domain-name/locked',
    DomainNameUnlocked: 'domain-name/unlocked',
    DomainNameIdshieldActivated: 'domain-name/idshield-activated',
    DomainNameIdshieldDeactivated: 'domain-name/idshield-deactivated',
    DomainNameBundleAdded: 'domain-name/bundle-added',
    DomainNameBundleRemoved: 'domain-name/bundle-removed',
    DomainNameRegistrantUpdated: 'domain-name/registrant-updated',
    DomainNameAdminUpdated: 'domain-name/admin-updated',
    DomainNameTechUpdated: 'domain-name/tech-updated',
    DomainNameBillingUpdated: 'domain-name/billing-updated',
    DomainNameAdditionalUpdated: 'domain-name/additional-updated',
    ItemCreated: 'item/created',
    ItemUpdated: 'item/updated',
    ItemDeleted: 'item/deleted',
    ItemRenewed: 'item/renewed',
    ItemUpgraded: 'item/upgraded',
    ItemDowngraded: 'item/downgraded',
    ItemIpAttached: 'item/ip-attached',
    ItemIpDetached: 'item/ip-detached',
    ItemDetachedFromOrder: 'item/detached-from-order',
    ItemPostponed: 'item/postponed',
    ItemTransferredIn: 'item/transferred-in',
    ItemCanceled: 'item/canceled',
    ItemSuspended: 'item/suspended',
    ItemUnsuspended: 'item/unsuspended',
    ItemAffiliateAdded: 'item/affiliate/added',
    ItemBundleAttached: 'item/bundle/attached',
    ItemBundleDetached: 'item/bundle/detached',
    ItemActivated: 'item/activated',
    ItemSetInactive: 'item/set-inactive',
    ItemProcessed: 'item/processed',
    OrderPaid: 'order/paid',
    Test: 'test',
    DeadLettering: 'dead-lettering',
    CoreQueue: 'core-queue'
} as const;

export type TemplateResponseDtoEventEnum = typeof TemplateResponseDtoEventEnum[keyof typeof TemplateResponseDtoEventEnum];

/**
 * @type Tld
 * The tld of the top-level domain (TLD) selected. It represents the TLD to which all associated properties and configurations.
 * @export
 */
export type Tld = TldResponseDto | string;

/**
 * @type Tld1
 * The unique identifier of the top-level domain (TLD) associated with the domain name, representing the domain\'s extension.
 * @export
 */
export type Tld1 = TldResponseDto | string;

/**
 * 
 * @export
 * @interface TldRequestDto
 */
export interface TldRequestDto {
    /**
     * The Top-Level Domain (TLD) as a string, representing the domain\'s extension.
     * @type {string}
     * @memberof TldRequestDto
     */
    'tld': string;
    /**
     * The minimum number of characters allowed for the second-level domain (SLD).
     * @type {number}
     * @memberof TldRequestDto
     */
    'minLength': number;
    /**
     * The maximum number of characters allowed for the second-level domain (SLD).
     * @type {number}
     * @memberof TldRequestDto
     */
    'maxLength': number;
    /**
     * The duration (in days) a TLD remains in a soft quarantine state, during which it can be renewed with minimal or no penalty.
     * @type {number}
     * @memberof TldRequestDto
     */
    'softQuarantineDays': number;
    /**
     * The duration (in days) a TLD remains in a hard quarantine state, during which it can be renewed with a high penalty. Defaults to 0 if not applicable.
     * @type {number}
     * @memberof TldRequestDto
     */
    'hardQuarantineDays': number;
    /**
     * The number of days before the registry\'s expiration date when the domain can be renewed.
     * @type {number}
     * @memberof TldRequestDto
     */
    'renewalDateOffset': number;
    /**
     * The number of days subtracted from the registry\'s expiration date to determine the domain\'s effective expiration date. For example, if the registry\'s expiration date is January 30 and the offset is 1, the domain will expire on January 29.
     * @type {number}
     * @memberof TldRequestDto
     */
    'expirationDateOffset': number;
    /**
     * The number of hours the authorization code remains valid after it is generated.
     * @type {number}
     * @memberof TldRequestDto
     */
    'authorizationCodeValidityHours': number;
    /**
     * A list of country codes specifying the countries where the registrant must reside to meet registration requirements.
     * @type {Array<string>}
     * @memberof TldRequestDto
     */
    'registrantContactCountryPresence'?: Array<TldRequestDtoRegistrantContactCountryPresenceEnum>;
    /**
     * A list of country codes specifying the countries where the admin must reside to meet registration requirements.
     * @type {Array<string>}
     * @memberof TldRequestDto
     */
    'adminContactCountryPresence'?: Array<TldRequestDtoAdminContactCountryPresenceEnum>;
    /**
     * A list of country codes specifying the countries where the tech contact must reside to meet registration requirements.
     * @type {Array<string>}
     * @memberof TldRequestDto
     */
    'techContactCountryPresence'?: Array<TldRequestDtoTechContactCountryPresenceEnum>;
    /**
     * A list of country codes specifying the countries where the billing contact must reside to meet registration requirements.
     * @type {Array<string>}
     * @memberof TldRequestDto
     */
    'billingContactCountryPresence'?: Array<TldRequestDtoBillingContactCountryPresenceEnum>;
    /**
     * Indicates whether the domain can be restored during the pending delete period before it is permanently deleted.
     * @type {boolean}
     * @memberof TldRequestDto
     */
    'restoreDuringPendingDelete': boolean;
    /**
     * Indicates whether the domain can be deleted before its expiration date.
     * @type {boolean}
     * @memberof TldRequestDto
     */
    'allowsDelete': boolean;
    /**
     * Indicates whether the domain name can be recalled after a delete action.
     * @type {boolean}
     * @memberof TldRequestDto
     */
    'allowsRecall'?: boolean;
    /**
     * The number of days required to complete the deletion process of the domain name.
     * @type {number}
     * @memberof TldRequestDto
     */
    'daysToCompleteDelete'?: number;
    /**
     * The maximum number of days allowed for recalling the product after purchase. The trial period for the product should not exceed this value.
     * @type {number}
     * @memberof TldRequestDto
     */
    'recallDays'?: number;
    /**
     * Indicates whether the domain supports DNSSEC (Domain Name System Security Extensions).
     * @type {boolean}
     * @memberof TldRequestDto
     */
    'supportsDNSSEC': boolean;
    /**
     * Indicates whether the domain supports Internationalized Domain Names (IDN), allowing non-ASCII characters in domain names.
     * @type {boolean}
     * @memberof TldRequestDto
     */
    'supportsIDN'?: boolean;
    /**
     * Indicates whether the domain allows accepting or canceling a transfer out request during the transfer process.
     * @type {boolean}
     * @memberof TldRequestDto
     */
    'allowsAcceptOrCancelTransferOut': boolean;
    /**
     * Indicates whether email verification is required after a domain registration.
     * @type {boolean}
     * @memberof TldRequestDto
     */
    'registrantEmailAddressVerification': boolean;
    /**
     * Indicates whether active DNS zones are required before completing the domain registration process.
     * @type {boolean}
     * @memberof TldRequestDto
     */
    'activeDNSZonesRequired'?: boolean;
    /**
     * Indicates whether the domain will be deleted if its DNS zones become inactive during the registration period.
     * @type {boolean}
     * @memberof TldRequestDto
     */
    'deletesIfDnsZonesAreInactive': boolean;
    /**
     * Indicates whether the EPP code should be sent to the domain owner via email when they request a transfer to a different registrar.
     * @type {boolean}
     * @memberof TldRequestDto
     */
    'sendEppCodeToOwner'?: boolean;
    /**
     * Indicates how renewal and expiration dates are handled when transferring to a different registrar.
     * @type {string}
     * @memberof TldRequestDto
     */
    'renewalHandlingAfterTransfer': TldRequestDtoRenewalHandlingAfterTransferEnum;
    /**
     * A list of supported durations for domain registrations. The user can only select from these durations when creating a domain name product, as specified by the TLD.
     * @type {Array<string>}
     * @memberof TldRequestDto
     */
    'supportedDurations': Array<TldRequestDtoSupportedDurationsEnum>;
    /**
     * Indicates if the TLD has a fee for the soft quarantine status or not. This determines if a renewal fee must be set during this period.
     * @type {boolean}
     * @memberof TldRequestDto
     */
    'hasSoftQuarantineFee': boolean;
    /**
     * Indicates if the TLD has a fee for the hard quarantine status. This determines if a renewal fee must be set during this period.
     * @type {boolean}
     * @memberof TldRequestDto
     */
    'hasHardQuarantineFee': boolean;
    /**
     * Indicates whether the TLD can be transferred to a different registrar even after it has expired.
     * @type {boolean}
     * @memberof TldRequestDto
     */
    'transferWhileExpired': boolean;
    /**
     * Specifies which additional data needs to be requested from the user for domains under this TLD.
     * @type {string}
     * @memberof TldRequestDto
     */
    'domainAdditionalData'?: TldRequestDtoDomainAdditionalDataEnum;
    /**
     * Specifies which additional data needs to be requested from the user for contacts associated with this TLD.
     * @type {string}
     * @memberof TldRequestDto
     */
    'contactAdditionalData'?: TldRequestDtoContactAdditionalDataEnum;
    /**
     * An array of unique identifiers representing the categories to which this TLD belongs.
     * @type {Array<string>}
     * @memberof TldRequestDto
     */
    'categories': Array<string>;
}

export const TldRequestDtoRegistrantContactCountryPresenceEnum = {
    Af: 'AF',
    Al: 'AL',
    Dz: 'DZ',
    As: 'AS',
    Ad: 'AD',
    Ao: 'AO',
    Ai: 'AI',
    Aq: 'AQ',
    Ag: 'AG',
    Ar: 'AR',
    Am: 'AM',
    Aw: 'AW',
    Au: 'AU',
    At: 'AT',
    Az: 'AZ',
    Bs: 'BS',
    Bh: 'BH',
    Bd: 'BD',
    Bb: 'BB',
    By: 'BY',
    Be: 'BE',
    Bz: 'BZ',
    Bj: 'BJ',
    Bm: 'BM',
    Bt: 'BT',
    Bo: 'BO',
    Bq: 'BQ',
    Ba: 'BA',
    Bw: 'BW',
    Bv: 'BV',
    Br: 'BR',
    Io: 'IO',
    Bn: 'BN',
    Bg: 'BG',
    Bf: 'BF',
    Bi: 'BI',
    Kh: 'KH',
    Cm: 'CM',
    Ca: 'CA',
    Cv: 'CV',
    Ky: 'KY',
    Cf: 'CF',
    Td: 'TD',
    Cl: 'CL',
    Cn: 'CN',
    Cx: 'CX',
    Cc: 'CC',
    Co: 'CO',
    Km: 'KM',
    Cg: 'CG',
    Cd: 'CD',
    Ck: 'CK',
    Cr: 'CR',
    Ci: 'CI',
    Hr: 'HR',
    Cu: 'CU',
    Cw: 'CW',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Dj: 'DJ',
    Dm: 'DM',
    Do: 'DO',
    Ec: 'EC',
    Eg: 'EG',
    Sv: 'SV',
    Gq: 'GQ',
    Er: 'ER',
    Ee: 'EE',
    Et: 'ET',
    Fk: 'FK',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Gf: 'GF',
    Pf: 'PF',
    Tf: 'TF',
    Ga: 'GA',
    Gm: 'GM',
    Ge: 'GE',
    De: 'DE',
    Gh: 'GH',
    Gi: 'GI',
    Gr: 'GR',
    Gl: 'GL',
    Gd: 'GD',
    Gp: 'GP',
    Gu: 'GU',
    Gt: 'GT',
    Gg: 'GG',
    Gn: 'GN',
    Gw: 'GW',
    Gy: 'GY',
    Ht: 'HT',
    Hm: 'HM',
    Va: 'VA',
    Hn: 'HN',
    Hk: 'HK',
    Hu: 'HU',
    Is: 'IS',
    In: 'IN',
    Id: 'ID',
    Ir: 'IR',
    Iq: 'IQ',
    Ie: 'IE',
    Im: 'IM',
    Il: 'IL',
    It: 'IT',
    Jm: 'JM',
    Jp: 'JP',
    Je: 'JE',
    Jo: 'JO',
    Kz: 'KZ',
    Ke: 'KE',
    Ki: 'KI',
    Kp: 'KP',
    Kr: 'KR',
    Kw: 'KW',
    Kg: 'KG',
    La: 'LA',
    Lv: 'LV',
    Lb: 'LB',
    Ls: 'LS',
    Lr: 'LR',
    Ly: 'LY',
    Li: 'LI',
    Lt: 'LT',
    Lu: 'LU',
    Mo: 'MO',
    Mk: 'MK',
    Mg: 'MG',
    Mw: 'MW',
    My: 'MY',
    Mv: 'MV',
    Ml: 'ML',
    Mt: 'MT',
    Mh: 'MH',
    Mq: 'MQ',
    Mr: 'MR',
    Mu: 'MU',
    Tn: 'TN',
    Tr: 'TR',
    Tm: 'TM',
    Tc: 'TC',
    Tv: 'TV',
    Ug: 'UG',
    Ua: 'UA',
    Ae: 'AE',
    Gb: 'GB',
    Us: 'US',
    Um: 'UM',
    Uy: 'UY',
    Uz: 'UZ',
    Vu: 'VU',
    Ve: 'VE',
    Vn: 'VN',
    Vg: 'VG',
    Vi: 'VI',
    Wf: 'WF',
    Eh: 'EH',
    Ye: 'YE',
    Zm: 'ZM',
    Zw: 'ZW',
    Yt: 'YT',
    Mx: 'MX',
    Fm: 'FM',
    Md: 'MD',
    Mc: 'MC',
    Mn: 'MN',
    Me: 'ME',
    Ms: 'MS',
    Ma: 'MA',
    Mz: 'MZ',
    Mm: 'MM',
    Na: 'NA',
    Nr: 'NR',
    Np: 'NP',
    Nl: 'NL',
    Nc: 'NC',
    Nz: 'NZ',
    Ni: 'NI',
    Ne: 'NE',
    Ng: 'NG',
    Nu: 'NU',
    Nf: 'NF',
    Mp: 'MP',
    No: 'NO',
    Om: 'OM',
    Pk: 'PK',
    Pw: 'PW',
    Ps: 'PS',
    Pa: 'PA',
    Pg: 'PG',
    Py: 'PY',
    Pe: 'PE',
    Ph: 'PH',
    Pn: 'PN',
    Pl: 'PL',
    Pt: 'PT',
    Pr: 'PR',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Ru: 'RU',
    Rw: 'RW',
    Bl: 'BL',
    Sh: 'SH',
    Kn: 'KN',
    Lc: 'LC',
    Mf: 'MF',
    Pm: 'PM',
    Vc: 'VC',
    Ws: 'WS',
    Sm: 'SM',
    St: 'ST',
    Sa: 'SA',
    Sn: 'SN',
    Rs: 'RS',
    Sc: 'SC',
    Sl: 'SL',
    Sg: 'SG',
    Sx: 'SX',
    Sk: 'SK',
    Si: 'SI',
    Sb: 'SB',
    So: 'SO',
    Za: 'ZA',
    Gs: 'GS',
    Ss: 'SS',
    Es: 'ES',
    Lk: 'LK',
    Sd: 'SD',
    Sr: 'SR',
    Sj: 'SJ',
    Sz: 'SZ',
    Se: 'SE',
    Ch: 'CH',
    Sy: 'SY',
    Tw: 'TW',
    Tj: 'TJ',
    Tz: 'TZ',
    Th: 'TH',
    Tl: 'TL',
    Tg: 'TG',
    Tk: 'TK',
    To: 'TO',
    Tt: 'TT'
} as const;

export type TldRequestDtoRegistrantContactCountryPresenceEnum = typeof TldRequestDtoRegistrantContactCountryPresenceEnum[keyof typeof TldRequestDtoRegistrantContactCountryPresenceEnum];
export const TldRequestDtoAdminContactCountryPresenceEnum = {
    Af: 'AF',
    Al: 'AL',
    Dz: 'DZ',
    As: 'AS',
    Ad: 'AD',
    Ao: 'AO',
    Ai: 'AI',
    Aq: 'AQ',
    Ag: 'AG',
    Ar: 'AR',
    Am: 'AM',
    Aw: 'AW',
    Au: 'AU',
    At: 'AT',
    Az: 'AZ',
    Bs: 'BS',
    Bh: 'BH',
    Bd: 'BD',
    Bb: 'BB',
    By: 'BY',
    Be: 'BE',
    Bz: 'BZ',
    Bj: 'BJ',
    Bm: 'BM',
    Bt: 'BT',
    Bo: 'BO',
    Bq: 'BQ',
    Ba: 'BA',
    Bw: 'BW',
    Bv: 'BV',
    Br: 'BR',
    Io: 'IO',
    Bn: 'BN',
    Bg: 'BG',
    Bf: 'BF',
    Bi: 'BI',
    Kh: 'KH',
    Cm: 'CM',
    Ca: 'CA',
    Cv: 'CV',
    Ky: 'KY',
    Cf: 'CF',
    Td: 'TD',
    Cl: 'CL',
    Cn: 'CN',
    Cx: 'CX',
    Cc: 'CC',
    Co: 'CO',
    Km: 'KM',
    Cg: 'CG',
    Cd: 'CD',
    Ck: 'CK',
    Cr: 'CR',
    Ci: 'CI',
    Hr: 'HR',
    Cu: 'CU',
    Cw: 'CW',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Dj: 'DJ',
    Dm: 'DM',
    Do: 'DO',
    Ec: 'EC',
    Eg: 'EG',
    Sv: 'SV',
    Gq: 'GQ',
    Er: 'ER',
    Ee: 'EE',
    Et: 'ET',
    Fk: 'FK',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Gf: 'GF',
    Pf: 'PF',
    Tf: 'TF',
    Ga: 'GA',
    Gm: 'GM',
    Ge: 'GE',
    De: 'DE',
    Gh: 'GH',
    Gi: 'GI',
    Gr: 'GR',
    Gl: 'GL',
    Gd: 'GD',
    Gp: 'GP',
    Gu: 'GU',
    Gt: 'GT',
    Gg: 'GG',
    Gn: 'GN',
    Gw: 'GW',
    Gy: 'GY',
    Ht: 'HT',
    Hm: 'HM',
    Va: 'VA',
    Hn: 'HN',
    Hk: 'HK',
    Hu: 'HU',
    Is: 'IS',
    In: 'IN',
    Id: 'ID',
    Ir: 'IR',
    Iq: 'IQ',
    Ie: 'IE',
    Im: 'IM',
    Il: 'IL',
    It: 'IT',
    Jm: 'JM',
    Jp: 'JP',
    Je: 'JE',
    Jo: 'JO',
    Kz: 'KZ',
    Ke: 'KE',
    Ki: 'KI',
    Kp: 'KP',
    Kr: 'KR',
    Kw: 'KW',
    Kg: 'KG',
    La: 'LA',
    Lv: 'LV',
    Lb: 'LB',
    Ls: 'LS',
    Lr: 'LR',
    Ly: 'LY',
    Li: 'LI',
    Lt: 'LT',
    Lu: 'LU',
    Mo: 'MO',
    Mk: 'MK',
    Mg: 'MG',
    Mw: 'MW',
    My: 'MY',
    Mv: 'MV',
    Ml: 'ML',
    Mt: 'MT',
    Mh: 'MH',
    Mq: 'MQ',
    Mr: 'MR',
    Mu: 'MU',
    Tn: 'TN',
    Tr: 'TR',
    Tm: 'TM',
    Tc: 'TC',
    Tv: 'TV',
    Ug: 'UG',
    Ua: 'UA',
    Ae: 'AE',
    Gb: 'GB',
    Us: 'US',
    Um: 'UM',
    Uy: 'UY',
    Uz: 'UZ',
    Vu: 'VU',
    Ve: 'VE',
    Vn: 'VN',
    Vg: 'VG',
    Vi: 'VI',
    Wf: 'WF',
    Eh: 'EH',
    Ye: 'YE',
    Zm: 'ZM',
    Zw: 'ZW',
    Yt: 'YT',
    Mx: 'MX',
    Fm: 'FM',
    Md: 'MD',
    Mc: 'MC',
    Mn: 'MN',
    Me: 'ME',
    Ms: 'MS',
    Ma: 'MA',
    Mz: 'MZ',
    Mm: 'MM',
    Na: 'NA',
    Nr: 'NR',
    Np: 'NP',
    Nl: 'NL',
    Nc: 'NC',
    Nz: 'NZ',
    Ni: 'NI',
    Ne: 'NE',
    Ng: 'NG',
    Nu: 'NU',
    Nf: 'NF',
    Mp: 'MP',
    No: 'NO',
    Om: 'OM',
    Pk: 'PK',
    Pw: 'PW',
    Ps: 'PS',
    Pa: 'PA',
    Pg: 'PG',
    Py: 'PY',
    Pe: 'PE',
    Ph: 'PH',
    Pn: 'PN',
    Pl: 'PL',
    Pt: 'PT',
    Pr: 'PR',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Ru: 'RU',
    Rw: 'RW',
    Bl: 'BL',
    Sh: 'SH',
    Kn: 'KN',
    Lc: 'LC',
    Mf: 'MF',
    Pm: 'PM',
    Vc: 'VC',
    Ws: 'WS',
    Sm: 'SM',
    St: 'ST',
    Sa: 'SA',
    Sn: 'SN',
    Rs: 'RS',
    Sc: 'SC',
    Sl: 'SL',
    Sg: 'SG',
    Sx: 'SX',
    Sk: 'SK',
    Si: 'SI',
    Sb: 'SB',
    So: 'SO',
    Za: 'ZA',
    Gs: 'GS',
    Ss: 'SS',
    Es: 'ES',
    Lk: 'LK',
    Sd: 'SD',
    Sr: 'SR',
    Sj: 'SJ',
    Sz: 'SZ',
    Se: 'SE',
    Ch: 'CH',
    Sy: 'SY',
    Tw: 'TW',
    Tj: 'TJ',
    Tz: 'TZ',
    Th: 'TH',
    Tl: 'TL',
    Tg: 'TG',
    Tk: 'TK',
    To: 'TO',
    Tt: 'TT'
} as const;

export type TldRequestDtoAdminContactCountryPresenceEnum = typeof TldRequestDtoAdminContactCountryPresenceEnum[keyof typeof TldRequestDtoAdminContactCountryPresenceEnum];
export const TldRequestDtoTechContactCountryPresenceEnum = {
    Af: 'AF',
    Al: 'AL',
    Dz: 'DZ',
    As: 'AS',
    Ad: 'AD',
    Ao: 'AO',
    Ai: 'AI',
    Aq: 'AQ',
    Ag: 'AG',
    Ar: 'AR',
    Am: 'AM',
    Aw: 'AW',
    Au: 'AU',
    At: 'AT',
    Az: 'AZ',
    Bs: 'BS',
    Bh: 'BH',
    Bd: 'BD',
    Bb: 'BB',
    By: 'BY',
    Be: 'BE',
    Bz: 'BZ',
    Bj: 'BJ',
    Bm: 'BM',
    Bt: 'BT',
    Bo: 'BO',
    Bq: 'BQ',
    Ba: 'BA',
    Bw: 'BW',
    Bv: 'BV',
    Br: 'BR',
    Io: 'IO',
    Bn: 'BN',
    Bg: 'BG',
    Bf: 'BF',
    Bi: 'BI',
    Kh: 'KH',
    Cm: 'CM',
    Ca: 'CA',
    Cv: 'CV',
    Ky: 'KY',
    Cf: 'CF',
    Td: 'TD',
    Cl: 'CL',
    Cn: 'CN',
    Cx: 'CX',
    Cc: 'CC',
    Co: 'CO',
    Km: 'KM',
    Cg: 'CG',
    Cd: 'CD',
    Ck: 'CK',
    Cr: 'CR',
    Ci: 'CI',
    Hr: 'HR',
    Cu: 'CU',
    Cw: 'CW',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Dj: 'DJ',
    Dm: 'DM',
    Do: 'DO',
    Ec: 'EC',
    Eg: 'EG',
    Sv: 'SV',
    Gq: 'GQ',
    Er: 'ER',
    Ee: 'EE',
    Et: 'ET',
    Fk: 'FK',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Gf: 'GF',
    Pf: 'PF',
    Tf: 'TF',
    Ga: 'GA',
    Gm: 'GM',
    Ge: 'GE',
    De: 'DE',
    Gh: 'GH',
    Gi: 'GI',
    Gr: 'GR',
    Gl: 'GL',
    Gd: 'GD',
    Gp: 'GP',
    Gu: 'GU',
    Gt: 'GT',
    Gg: 'GG',
    Gn: 'GN',
    Gw: 'GW',
    Gy: 'GY',
    Ht: 'HT',
    Hm: 'HM',
    Va: 'VA',
    Hn: 'HN',
    Hk: 'HK',
    Hu: 'HU',
    Is: 'IS',
    In: 'IN',
    Id: 'ID',
    Ir: 'IR',
    Iq: 'IQ',
    Ie: 'IE',
    Im: 'IM',
    Il: 'IL',
    It: 'IT',
    Jm: 'JM',
    Jp: 'JP',
    Je: 'JE',
    Jo: 'JO',
    Kz: 'KZ',
    Ke: 'KE',
    Ki: 'KI',
    Kp: 'KP',
    Kr: 'KR',
    Kw: 'KW',
    Kg: 'KG',
    La: 'LA',
    Lv: 'LV',
    Lb: 'LB',
    Ls: 'LS',
    Lr: 'LR',
    Ly: 'LY',
    Li: 'LI',
    Lt: 'LT',
    Lu: 'LU',
    Mo: 'MO',
    Mk: 'MK',
    Mg: 'MG',
    Mw: 'MW',
    My: 'MY',
    Mv: 'MV',
    Ml: 'ML',
    Mt: 'MT',
    Mh: 'MH',
    Mq: 'MQ',
    Mr: 'MR',
    Mu: 'MU',
    Tn: 'TN',
    Tr: 'TR',
    Tm: 'TM',
    Tc: 'TC',
    Tv: 'TV',
    Ug: 'UG',
    Ua: 'UA',
    Ae: 'AE',
    Gb: 'GB',
    Us: 'US',
    Um: 'UM',
    Uy: 'UY',
    Uz: 'UZ',
    Vu: 'VU',
    Ve: 'VE',
    Vn: 'VN',
    Vg: 'VG',
    Vi: 'VI',
    Wf: 'WF',
    Eh: 'EH',
    Ye: 'YE',
    Zm: 'ZM',
    Zw: 'ZW',
    Yt: 'YT',
    Mx: 'MX',
    Fm: 'FM',
    Md: 'MD',
    Mc: 'MC',
    Mn: 'MN',
    Me: 'ME',
    Ms: 'MS',
    Ma: 'MA',
    Mz: 'MZ',
    Mm: 'MM',
    Na: 'NA',
    Nr: 'NR',
    Np: 'NP',
    Nl: 'NL',
    Nc: 'NC',
    Nz: 'NZ',
    Ni: 'NI',
    Ne: 'NE',
    Ng: 'NG',
    Nu: 'NU',
    Nf: 'NF',
    Mp: 'MP',
    No: 'NO',
    Om: 'OM',
    Pk: 'PK',
    Pw: 'PW',
    Ps: 'PS',
    Pa: 'PA',
    Pg: 'PG',
    Py: 'PY',
    Pe: 'PE',
    Ph: 'PH',
    Pn: 'PN',
    Pl: 'PL',
    Pt: 'PT',
    Pr: 'PR',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Ru: 'RU',
    Rw: 'RW',
    Bl: 'BL',
    Sh: 'SH',
    Kn: 'KN',
    Lc: 'LC',
    Mf: 'MF',
    Pm: 'PM',
    Vc: 'VC',
    Ws: 'WS',
    Sm: 'SM',
    St: 'ST',
    Sa: 'SA',
    Sn: 'SN',
    Rs: 'RS',
    Sc: 'SC',
    Sl: 'SL',
    Sg: 'SG',
    Sx: 'SX',
    Sk: 'SK',
    Si: 'SI',
    Sb: 'SB',
    So: 'SO',
    Za: 'ZA',
    Gs: 'GS',
    Ss: 'SS',
    Es: 'ES',
    Lk: 'LK',
    Sd: 'SD',
    Sr: 'SR',
    Sj: 'SJ',
    Sz: 'SZ',
    Se: 'SE',
    Ch: 'CH',
    Sy: 'SY',
    Tw: 'TW',
    Tj: 'TJ',
    Tz: 'TZ',
    Th: 'TH',
    Tl: 'TL',
    Tg: 'TG',
    Tk: 'TK',
    To: 'TO',
    Tt: 'TT'
} as const;

export type TldRequestDtoTechContactCountryPresenceEnum = typeof TldRequestDtoTechContactCountryPresenceEnum[keyof typeof TldRequestDtoTechContactCountryPresenceEnum];
export const TldRequestDtoBillingContactCountryPresenceEnum = {
    Af: 'AF',
    Al: 'AL',
    Dz: 'DZ',
    As: 'AS',
    Ad: 'AD',
    Ao: 'AO',
    Ai: 'AI',
    Aq: 'AQ',
    Ag: 'AG',
    Ar: 'AR',
    Am: 'AM',
    Aw: 'AW',
    Au: 'AU',
    At: 'AT',
    Az: 'AZ',
    Bs: 'BS',
    Bh: 'BH',
    Bd: 'BD',
    Bb: 'BB',
    By: 'BY',
    Be: 'BE',
    Bz: 'BZ',
    Bj: 'BJ',
    Bm: 'BM',
    Bt: 'BT',
    Bo: 'BO',
    Bq: 'BQ',
    Ba: 'BA',
    Bw: 'BW',
    Bv: 'BV',
    Br: 'BR',
    Io: 'IO',
    Bn: 'BN',
    Bg: 'BG',
    Bf: 'BF',
    Bi: 'BI',
    Kh: 'KH',
    Cm: 'CM',
    Ca: 'CA',
    Cv: 'CV',
    Ky: 'KY',
    Cf: 'CF',
    Td: 'TD',
    Cl: 'CL',
    Cn: 'CN',
    Cx: 'CX',
    Cc: 'CC',
    Co: 'CO',
    Km: 'KM',
    Cg: 'CG',
    Cd: 'CD',
    Ck: 'CK',
    Cr: 'CR',
    Ci: 'CI',
    Hr: 'HR',
    Cu: 'CU',
    Cw: 'CW',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Dj: 'DJ',
    Dm: 'DM',
    Do: 'DO',
    Ec: 'EC',
    Eg: 'EG',
    Sv: 'SV',
    Gq: 'GQ',
    Er: 'ER',
    Ee: 'EE',
    Et: 'ET',
    Fk: 'FK',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Gf: 'GF',
    Pf: 'PF',
    Tf: 'TF',
    Ga: 'GA',
    Gm: 'GM',
    Ge: 'GE',
    De: 'DE',
    Gh: 'GH',
    Gi: 'GI',
    Gr: 'GR',
    Gl: 'GL',
    Gd: 'GD',
    Gp: 'GP',
    Gu: 'GU',
    Gt: 'GT',
    Gg: 'GG',
    Gn: 'GN',
    Gw: 'GW',
    Gy: 'GY',
    Ht: 'HT',
    Hm: 'HM',
    Va: 'VA',
    Hn: 'HN',
    Hk: 'HK',
    Hu: 'HU',
    Is: 'IS',
    In: 'IN',
    Id: 'ID',
    Ir: 'IR',
    Iq: 'IQ',
    Ie: 'IE',
    Im: 'IM',
    Il: 'IL',
    It: 'IT',
    Jm: 'JM',
    Jp: 'JP',
    Je: 'JE',
    Jo: 'JO',
    Kz: 'KZ',
    Ke: 'KE',
    Ki: 'KI',
    Kp: 'KP',
    Kr: 'KR',
    Kw: 'KW',
    Kg: 'KG',
    La: 'LA',
    Lv: 'LV',
    Lb: 'LB',
    Ls: 'LS',
    Lr: 'LR',
    Ly: 'LY',
    Li: 'LI',
    Lt: 'LT',
    Lu: 'LU',
    Mo: 'MO',
    Mk: 'MK',
    Mg: 'MG',
    Mw: 'MW',
    My: 'MY',
    Mv: 'MV',
    Ml: 'ML',
    Mt: 'MT',
    Mh: 'MH',
    Mq: 'MQ',
    Mr: 'MR',
    Mu: 'MU',
    Tn: 'TN',
    Tr: 'TR',
    Tm: 'TM',
    Tc: 'TC',
    Tv: 'TV',
    Ug: 'UG',
    Ua: 'UA',
    Ae: 'AE',
    Gb: 'GB',
    Us: 'US',
    Um: 'UM',
    Uy: 'UY',
    Uz: 'UZ',
    Vu: 'VU',
    Ve: 'VE',
    Vn: 'VN',
    Vg: 'VG',
    Vi: 'VI',
    Wf: 'WF',
    Eh: 'EH',
    Ye: 'YE',
    Zm: 'ZM',
    Zw: 'ZW',
    Yt: 'YT',
    Mx: 'MX',
    Fm: 'FM',
    Md: 'MD',
    Mc: 'MC',
    Mn: 'MN',
    Me: 'ME',
    Ms: 'MS',
    Ma: 'MA',
    Mz: 'MZ',
    Mm: 'MM',
    Na: 'NA',
    Nr: 'NR',
    Np: 'NP',
    Nl: 'NL',
    Nc: 'NC',
    Nz: 'NZ',
    Ni: 'NI',
    Ne: 'NE',
    Ng: 'NG',
    Nu: 'NU',
    Nf: 'NF',
    Mp: 'MP',
    No: 'NO',
    Om: 'OM',
    Pk: 'PK',
    Pw: 'PW',
    Ps: 'PS',
    Pa: 'PA',
    Pg: 'PG',
    Py: 'PY',
    Pe: 'PE',
    Ph: 'PH',
    Pn: 'PN',
    Pl: 'PL',
    Pt: 'PT',
    Pr: 'PR',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Ru: 'RU',
    Rw: 'RW',
    Bl: 'BL',
    Sh: 'SH',
    Kn: 'KN',
    Lc: 'LC',
    Mf: 'MF',
    Pm: 'PM',
    Vc: 'VC',
    Ws: 'WS',
    Sm: 'SM',
    St: 'ST',
    Sa: 'SA',
    Sn: 'SN',
    Rs: 'RS',
    Sc: 'SC',
    Sl: 'SL',
    Sg: 'SG',
    Sx: 'SX',
    Sk: 'SK',
    Si: 'SI',
    Sb: 'SB',
    So: 'SO',
    Za: 'ZA',
    Gs: 'GS',
    Ss: 'SS',
    Es: 'ES',
    Lk: 'LK',
    Sd: 'SD',
    Sr: 'SR',
    Sj: 'SJ',
    Sz: 'SZ',
    Se: 'SE',
    Ch: 'CH',
    Sy: 'SY',
    Tw: 'TW',
    Tj: 'TJ',
    Tz: 'TZ',
    Th: 'TH',
    Tl: 'TL',
    Tg: 'TG',
    Tk: 'TK',
    To: 'TO',
    Tt: 'TT'
} as const;

export type TldRequestDtoBillingContactCountryPresenceEnum = typeof TldRequestDtoBillingContactCountryPresenceEnum[keyof typeof TldRequestDtoBillingContactCountryPresenceEnum];
export const TldRequestDtoRenewalHandlingAfterTransferEnum = {
    Unchanged: 'UNCHANGED',
    Extends: 'EXTENDS',
    Restarts: 'RESTARTS'
} as const;

export type TldRequestDtoRenewalHandlingAfterTransferEnum = typeof TldRequestDtoRenewalHandlingAfterTransferEnum[keyof typeof TldRequestDtoRenewalHandlingAfterTransferEnum];
export const TldRequestDtoSupportedDurationsEnum = {
    _0: '0',
    _1: '1',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5',
    _6: '6',
    _7: '7',
    _8: '8',
    _9: '9',
    _10: '10',
    _11: '11',
    _12: '12',
    _24: '24',
    _36: '36',
    _48: '48',
    _60: '60',
    _72: '72',
    _84: '84',
    _96: '96',
    _108: '108',
    _120: '120'
} as const;

export type TldRequestDtoSupportedDurationsEnum = typeof TldRequestDtoSupportedDurationsEnum[keyof typeof TldRequestDtoSupportedDurationsEnum];
export const TldRequestDtoDomainAdditionalDataEnum = {
    CatParameter: 'CAT_PARAMETER',
    ChallengeParameter: 'CHALLENGE_PARAMETER',
    ClaimsToken: 'CLAIMS_TOKEN',
    DonutsPriceCategory: 'DONUTS_PRICE_CATEGORY',
    IntentedUse: 'INTENTED_USE',
    PremiumPriceCategory: 'PREMIUM_PRICE_CATEGORY',
    ProxyService: 'PROXY_SERVICE',
    Sunrise: 'SUNRISE',
    UkDirect: 'UK_DIRECT',
    XxxMember: 'XXX_MEMBER'
} as const;

export type TldRequestDtoDomainAdditionalDataEnum = typeof TldRequestDtoDomainAdditionalDataEnum[keyof typeof TldRequestDtoDomainAdditionalDataEnum];
export const TldRequestDtoContactAdditionalDataEnum = {
    Afnic: 'AFNIC',
    Cat: 'CAT',
    De: 'DE',
    Es: 'ES',
    Eu: 'EU',
    It: 'IT',
    Lv: 'LV',
    Nl: 'NL',
    Pro: 'PRO',
    Uk: 'UK',
    Us: 'US'
} as const;

export type TldRequestDtoContactAdditionalDataEnum = typeof TldRequestDtoContactAdditionalDataEnum[keyof typeof TldRequestDtoContactAdditionalDataEnum];

/**
 * 
 * @export
 * @interface TldResponseDto
 */
export interface TldResponseDto {
    /**
     * The Top-Level Domain (TLD) as a string, representing the domain\'s extension.
     * @type {string}
     * @memberof TldResponseDto
     */
    'tld': string;
    /**
     * The minimum number of characters allowed for the second-level domain (SLD).
     * @type {number}
     * @memberof TldResponseDto
     */
    'minLength': number;
    /**
     * The maximum number of characters allowed for the second-level domain (SLD).
     * @type {number}
     * @memberof TldResponseDto
     */
    'maxLength': number;
    /**
     * The duration (in days) a TLD remains in a soft quarantine state, during which it can be renewed with minimal or no penalty.
     * @type {number}
     * @memberof TldResponseDto
     */
    'softQuarantineDays': number;
    /**
     * The duration (in days) a TLD remains in a hard quarantine state, during which it can be renewed with a high penalty. Defaults to 0 if not applicable.
     * @type {number}
     * @memberof TldResponseDto
     */
    'hardQuarantineDays': number;
    /**
     * The number of days before the registry\'s expiration date when the domain can be renewed.
     * @type {number}
     * @memberof TldResponseDto
     */
    'renewalDateOffset': number;
    /**
     * The number of days subtracted from the registry\'s expiration date to determine the domain\'s effective expiration date. For example, if the registry\'s expiration date is January 30 and the offset is 1, the domain will expire on January 29.
     * @type {number}
     * @memberof TldResponseDto
     */
    'expirationDateOffset': number;
    /**
     * The number of hours the authorization code remains valid after it is generated.
     * @type {number}
     * @memberof TldResponseDto
     */
    'authorizationCodeValidityHours': number;
    /**
     * A list of country codes specifying the countries where the registrant must reside to meet registration requirements.
     * @type {Array<string>}
     * @memberof TldResponseDto
     */
    'registrantContactCountryPresence'?: Array<TldResponseDtoRegistrantContactCountryPresenceEnum>;
    /**
     * A list of country codes specifying the countries where the admin must reside to meet registration requirements.
     * @type {Array<string>}
     * @memberof TldResponseDto
     */
    'adminContactCountryPresence'?: Array<TldResponseDtoAdminContactCountryPresenceEnum>;
    /**
     * A list of country codes specifying the countries where the tech contact must reside to meet registration requirements.
     * @type {Array<string>}
     * @memberof TldResponseDto
     */
    'techContactCountryPresence'?: Array<TldResponseDtoTechContactCountryPresenceEnum>;
    /**
     * A list of country codes specifying the countries where the billing contact must reside to meet registration requirements.
     * @type {Array<string>}
     * @memberof TldResponseDto
     */
    'billingContactCountryPresence'?: Array<TldResponseDtoBillingContactCountryPresenceEnum>;
    /**
     * Indicates whether the domain can be restored during the pending delete period before it is permanently deleted.
     * @type {boolean}
     * @memberof TldResponseDto
     */
    'restoreDuringPendingDelete': boolean;
    /**
     * Indicates whether the domain can be deleted before its expiration date.
     * @type {boolean}
     * @memberof TldResponseDto
     */
    'allowsDelete': boolean;
    /**
     * Indicates whether the domain name can be recalled after a delete action.
     * @type {boolean}
     * @memberof TldResponseDto
     */
    'allowsRecall'?: boolean;
    /**
     * The number of days required to complete the deletion process of the domain name.
     * @type {number}
     * @memberof TldResponseDto
     */
    'daysToCompleteDelete'?: number;
    /**
     * The maximum number of days allowed for recalling the product after purchase. The trial period for the product should not exceed this value.
     * @type {number}
     * @memberof TldResponseDto
     */
    'recallDays'?: number;
    /**
     * Indicates whether the domain supports DNSSEC (Domain Name System Security Extensions).
     * @type {boolean}
     * @memberof TldResponseDto
     */
    'supportsDNSSEC': boolean;
    /**
     * Indicates whether the domain supports Internationalized Domain Names (IDN), allowing non-ASCII characters in domain names.
     * @type {boolean}
     * @memberof TldResponseDto
     */
    'supportsIDN'?: boolean;
    /**
     * Indicates whether the domain allows accepting or canceling a transfer out request during the transfer process.
     * @type {boolean}
     * @memberof TldResponseDto
     */
    'allowsAcceptOrCancelTransferOut': boolean;
    /**
     * Indicates whether email verification is required after a domain registration.
     * @type {boolean}
     * @memberof TldResponseDto
     */
    'registrantEmailAddressVerification': boolean;
    /**
     * Indicates whether active DNS zones are required before completing the domain registration process.
     * @type {boolean}
     * @memberof TldResponseDto
     */
    'activeDNSZonesRequired'?: boolean;
    /**
     * Indicates whether the domain will be deleted if its DNS zones become inactive during the registration period.
     * @type {boolean}
     * @memberof TldResponseDto
     */
    'deletesIfDnsZonesAreInactive': boolean;
    /**
     * Indicates whether the EPP code should be sent to the domain owner via email when they request a transfer to a different registrar.
     * @type {boolean}
     * @memberof TldResponseDto
     */
    'sendEppCodeToOwner'?: boolean;
    /**
     * Indicates how renewal and expiration dates are handled when transferring to a different registrar.
     * @type {string}
     * @memberof TldResponseDto
     */
    'renewalHandlingAfterTransfer': TldResponseDtoRenewalHandlingAfterTransferEnum;
    /**
     * A list of supported durations for domain registrations. The user can only select from these durations when creating a domain name product, as specified by the TLD.
     * @type {Array<string>}
     * @memberof TldResponseDto
     */
    'supportedDurations': Array<TldResponseDtoSupportedDurationsEnum>;
    /**
     * Indicates if the TLD has a fee for the soft quarantine status or not. This determines if a renewal fee must be set during this period.
     * @type {boolean}
     * @memberof TldResponseDto
     */
    'hasSoftQuarantineFee': boolean;
    /**
     * Indicates if the TLD has a fee for the hard quarantine status. This determines if a renewal fee must be set during this period.
     * @type {boolean}
     * @memberof TldResponseDto
     */
    'hasHardQuarantineFee': boolean;
    /**
     * Indicates whether the TLD can be transferred to a different registrar even after it has expired.
     * @type {boolean}
     * @memberof TldResponseDto
     */
    'transferWhileExpired': boolean;
    /**
     * Specifies which additional data needs to be requested from the user for domains under this TLD.
     * @type {string}
     * @memberof TldResponseDto
     */
    'domainAdditionalData'?: TldResponseDtoDomainAdditionalDataEnum;
    /**
     * Specifies which additional data needs to be requested from the user for contacts associated with this TLD.
     * @type {string}
     * @memberof TldResponseDto
     */
    'contactAdditionalData'?: TldResponseDtoContactAdditionalDataEnum;
    /**
     * The unique identifier for the tld.
     * @type {string}
     * @memberof TldResponseDto
     */
    'id': string;
    /**
     * An array representing the categories to which this TLD belongs.
     * @type {Array<TldResponseDtoCategoriesInner>}
     * @memberof TldResponseDto
     */
    'categories': Array<TldResponseDtoCategoriesInner>;
    /**
     * The date and time when the tld was created.
     * @type {string}
     * @memberof TldResponseDto
     */
    'createdAt': string;
    /**
     * The date and time when the tld was created.
     * @type {string}
     * @memberof TldResponseDto
     */
    'updatedAt': string;
}

export const TldResponseDtoRegistrantContactCountryPresenceEnum = {
    Af: 'AF',
    Al: 'AL',
    Dz: 'DZ',
    As: 'AS',
    Ad: 'AD',
    Ao: 'AO',
    Ai: 'AI',
    Aq: 'AQ',
    Ag: 'AG',
    Ar: 'AR',
    Am: 'AM',
    Aw: 'AW',
    Au: 'AU',
    At: 'AT',
    Az: 'AZ',
    Bs: 'BS',
    Bh: 'BH',
    Bd: 'BD',
    Bb: 'BB',
    By: 'BY',
    Be: 'BE',
    Bz: 'BZ',
    Bj: 'BJ',
    Bm: 'BM',
    Bt: 'BT',
    Bo: 'BO',
    Bq: 'BQ',
    Ba: 'BA',
    Bw: 'BW',
    Bv: 'BV',
    Br: 'BR',
    Io: 'IO',
    Bn: 'BN',
    Bg: 'BG',
    Bf: 'BF',
    Bi: 'BI',
    Kh: 'KH',
    Cm: 'CM',
    Ca: 'CA',
    Cv: 'CV',
    Ky: 'KY',
    Cf: 'CF',
    Td: 'TD',
    Cl: 'CL',
    Cn: 'CN',
    Cx: 'CX',
    Cc: 'CC',
    Co: 'CO',
    Km: 'KM',
    Cg: 'CG',
    Cd: 'CD',
    Ck: 'CK',
    Cr: 'CR',
    Ci: 'CI',
    Hr: 'HR',
    Cu: 'CU',
    Cw: 'CW',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Dj: 'DJ',
    Dm: 'DM',
    Do: 'DO',
    Ec: 'EC',
    Eg: 'EG',
    Sv: 'SV',
    Gq: 'GQ',
    Er: 'ER',
    Ee: 'EE',
    Et: 'ET',
    Fk: 'FK',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Gf: 'GF',
    Pf: 'PF',
    Tf: 'TF',
    Ga: 'GA',
    Gm: 'GM',
    Ge: 'GE',
    De: 'DE',
    Gh: 'GH',
    Gi: 'GI',
    Gr: 'GR',
    Gl: 'GL',
    Gd: 'GD',
    Gp: 'GP',
    Gu: 'GU',
    Gt: 'GT',
    Gg: 'GG',
    Gn: 'GN',
    Gw: 'GW',
    Gy: 'GY',
    Ht: 'HT',
    Hm: 'HM',
    Va: 'VA',
    Hn: 'HN',
    Hk: 'HK',
    Hu: 'HU',
    Is: 'IS',
    In: 'IN',
    Id: 'ID',
    Ir: 'IR',
    Iq: 'IQ',
    Ie: 'IE',
    Im: 'IM',
    Il: 'IL',
    It: 'IT',
    Jm: 'JM',
    Jp: 'JP',
    Je: 'JE',
    Jo: 'JO',
    Kz: 'KZ',
    Ke: 'KE',
    Ki: 'KI',
    Kp: 'KP',
    Kr: 'KR',
    Kw: 'KW',
    Kg: 'KG',
    La: 'LA',
    Lv: 'LV',
    Lb: 'LB',
    Ls: 'LS',
    Lr: 'LR',
    Ly: 'LY',
    Li: 'LI',
    Lt: 'LT',
    Lu: 'LU',
    Mo: 'MO',
    Mk: 'MK',
    Mg: 'MG',
    Mw: 'MW',
    My: 'MY',
    Mv: 'MV',
    Ml: 'ML',
    Mt: 'MT',
    Mh: 'MH',
    Mq: 'MQ',
    Mr: 'MR',
    Mu: 'MU',
    Tn: 'TN',
    Tr: 'TR',
    Tm: 'TM',
    Tc: 'TC',
    Tv: 'TV',
    Ug: 'UG',
    Ua: 'UA',
    Ae: 'AE',
    Gb: 'GB',
    Us: 'US',
    Um: 'UM',
    Uy: 'UY',
    Uz: 'UZ',
    Vu: 'VU',
    Ve: 'VE',
    Vn: 'VN',
    Vg: 'VG',
    Vi: 'VI',
    Wf: 'WF',
    Eh: 'EH',
    Ye: 'YE',
    Zm: 'ZM',
    Zw: 'ZW',
    Yt: 'YT',
    Mx: 'MX',
    Fm: 'FM',
    Md: 'MD',
    Mc: 'MC',
    Mn: 'MN',
    Me: 'ME',
    Ms: 'MS',
    Ma: 'MA',
    Mz: 'MZ',
    Mm: 'MM',
    Na: 'NA',
    Nr: 'NR',
    Np: 'NP',
    Nl: 'NL',
    Nc: 'NC',
    Nz: 'NZ',
    Ni: 'NI',
    Ne: 'NE',
    Ng: 'NG',
    Nu: 'NU',
    Nf: 'NF',
    Mp: 'MP',
    No: 'NO',
    Om: 'OM',
    Pk: 'PK',
    Pw: 'PW',
    Ps: 'PS',
    Pa: 'PA',
    Pg: 'PG',
    Py: 'PY',
    Pe: 'PE',
    Ph: 'PH',
    Pn: 'PN',
    Pl: 'PL',
    Pt: 'PT',
    Pr: 'PR',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Ru: 'RU',
    Rw: 'RW',
    Bl: 'BL',
    Sh: 'SH',
    Kn: 'KN',
    Lc: 'LC',
    Mf: 'MF',
    Pm: 'PM',
    Vc: 'VC',
    Ws: 'WS',
    Sm: 'SM',
    St: 'ST',
    Sa: 'SA',
    Sn: 'SN',
    Rs: 'RS',
    Sc: 'SC',
    Sl: 'SL',
    Sg: 'SG',
    Sx: 'SX',
    Sk: 'SK',
    Si: 'SI',
    Sb: 'SB',
    So: 'SO',
    Za: 'ZA',
    Gs: 'GS',
    Ss: 'SS',
    Es: 'ES',
    Lk: 'LK',
    Sd: 'SD',
    Sr: 'SR',
    Sj: 'SJ',
    Sz: 'SZ',
    Se: 'SE',
    Ch: 'CH',
    Sy: 'SY',
    Tw: 'TW',
    Tj: 'TJ',
    Tz: 'TZ',
    Th: 'TH',
    Tl: 'TL',
    Tg: 'TG',
    Tk: 'TK',
    To: 'TO',
    Tt: 'TT'
} as const;

export type TldResponseDtoRegistrantContactCountryPresenceEnum = typeof TldResponseDtoRegistrantContactCountryPresenceEnum[keyof typeof TldResponseDtoRegistrantContactCountryPresenceEnum];
export const TldResponseDtoAdminContactCountryPresenceEnum = {
    Af: 'AF',
    Al: 'AL',
    Dz: 'DZ',
    As: 'AS',
    Ad: 'AD',
    Ao: 'AO',
    Ai: 'AI',
    Aq: 'AQ',
    Ag: 'AG',
    Ar: 'AR',
    Am: 'AM',
    Aw: 'AW',
    Au: 'AU',
    At: 'AT',
    Az: 'AZ',
    Bs: 'BS',
    Bh: 'BH',
    Bd: 'BD',
    Bb: 'BB',
    By: 'BY',
    Be: 'BE',
    Bz: 'BZ',
    Bj: 'BJ',
    Bm: 'BM',
    Bt: 'BT',
    Bo: 'BO',
    Bq: 'BQ',
    Ba: 'BA',
    Bw: 'BW',
    Bv: 'BV',
    Br: 'BR',
    Io: 'IO',
    Bn: 'BN',
    Bg: 'BG',
    Bf: 'BF',
    Bi: 'BI',
    Kh: 'KH',
    Cm: 'CM',
    Ca: 'CA',
    Cv: 'CV',
    Ky: 'KY',
    Cf: 'CF',
    Td: 'TD',
    Cl: 'CL',
    Cn: 'CN',
    Cx: 'CX',
    Cc: 'CC',
    Co: 'CO',
    Km: 'KM',
    Cg: 'CG',
    Cd: 'CD',
    Ck: 'CK',
    Cr: 'CR',
    Ci: 'CI',
    Hr: 'HR',
    Cu: 'CU',
    Cw: 'CW',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Dj: 'DJ',
    Dm: 'DM',
    Do: 'DO',
    Ec: 'EC',
    Eg: 'EG',
    Sv: 'SV',
    Gq: 'GQ',
    Er: 'ER',
    Ee: 'EE',
    Et: 'ET',
    Fk: 'FK',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Gf: 'GF',
    Pf: 'PF',
    Tf: 'TF',
    Ga: 'GA',
    Gm: 'GM',
    Ge: 'GE',
    De: 'DE',
    Gh: 'GH',
    Gi: 'GI',
    Gr: 'GR',
    Gl: 'GL',
    Gd: 'GD',
    Gp: 'GP',
    Gu: 'GU',
    Gt: 'GT',
    Gg: 'GG',
    Gn: 'GN',
    Gw: 'GW',
    Gy: 'GY',
    Ht: 'HT',
    Hm: 'HM',
    Va: 'VA',
    Hn: 'HN',
    Hk: 'HK',
    Hu: 'HU',
    Is: 'IS',
    In: 'IN',
    Id: 'ID',
    Ir: 'IR',
    Iq: 'IQ',
    Ie: 'IE',
    Im: 'IM',
    Il: 'IL',
    It: 'IT',
    Jm: 'JM',
    Jp: 'JP',
    Je: 'JE',
    Jo: 'JO',
    Kz: 'KZ',
    Ke: 'KE',
    Ki: 'KI',
    Kp: 'KP',
    Kr: 'KR',
    Kw: 'KW',
    Kg: 'KG',
    La: 'LA',
    Lv: 'LV',
    Lb: 'LB',
    Ls: 'LS',
    Lr: 'LR',
    Ly: 'LY',
    Li: 'LI',
    Lt: 'LT',
    Lu: 'LU',
    Mo: 'MO',
    Mk: 'MK',
    Mg: 'MG',
    Mw: 'MW',
    My: 'MY',
    Mv: 'MV',
    Ml: 'ML',
    Mt: 'MT',
    Mh: 'MH',
    Mq: 'MQ',
    Mr: 'MR',
    Mu: 'MU',
    Tn: 'TN',
    Tr: 'TR',
    Tm: 'TM',
    Tc: 'TC',
    Tv: 'TV',
    Ug: 'UG',
    Ua: 'UA',
    Ae: 'AE',
    Gb: 'GB',
    Us: 'US',
    Um: 'UM',
    Uy: 'UY',
    Uz: 'UZ',
    Vu: 'VU',
    Ve: 'VE',
    Vn: 'VN',
    Vg: 'VG',
    Vi: 'VI',
    Wf: 'WF',
    Eh: 'EH',
    Ye: 'YE',
    Zm: 'ZM',
    Zw: 'ZW',
    Yt: 'YT',
    Mx: 'MX',
    Fm: 'FM',
    Md: 'MD',
    Mc: 'MC',
    Mn: 'MN',
    Me: 'ME',
    Ms: 'MS',
    Ma: 'MA',
    Mz: 'MZ',
    Mm: 'MM',
    Na: 'NA',
    Nr: 'NR',
    Np: 'NP',
    Nl: 'NL',
    Nc: 'NC',
    Nz: 'NZ',
    Ni: 'NI',
    Ne: 'NE',
    Ng: 'NG',
    Nu: 'NU',
    Nf: 'NF',
    Mp: 'MP',
    No: 'NO',
    Om: 'OM',
    Pk: 'PK',
    Pw: 'PW',
    Ps: 'PS',
    Pa: 'PA',
    Pg: 'PG',
    Py: 'PY',
    Pe: 'PE',
    Ph: 'PH',
    Pn: 'PN',
    Pl: 'PL',
    Pt: 'PT',
    Pr: 'PR',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Ru: 'RU',
    Rw: 'RW',
    Bl: 'BL',
    Sh: 'SH',
    Kn: 'KN',
    Lc: 'LC',
    Mf: 'MF',
    Pm: 'PM',
    Vc: 'VC',
    Ws: 'WS',
    Sm: 'SM',
    St: 'ST',
    Sa: 'SA',
    Sn: 'SN',
    Rs: 'RS',
    Sc: 'SC',
    Sl: 'SL',
    Sg: 'SG',
    Sx: 'SX',
    Sk: 'SK',
    Si: 'SI',
    Sb: 'SB',
    So: 'SO',
    Za: 'ZA',
    Gs: 'GS',
    Ss: 'SS',
    Es: 'ES',
    Lk: 'LK',
    Sd: 'SD',
    Sr: 'SR',
    Sj: 'SJ',
    Sz: 'SZ',
    Se: 'SE',
    Ch: 'CH',
    Sy: 'SY',
    Tw: 'TW',
    Tj: 'TJ',
    Tz: 'TZ',
    Th: 'TH',
    Tl: 'TL',
    Tg: 'TG',
    Tk: 'TK',
    To: 'TO',
    Tt: 'TT'
} as const;

export type TldResponseDtoAdminContactCountryPresenceEnum = typeof TldResponseDtoAdminContactCountryPresenceEnum[keyof typeof TldResponseDtoAdminContactCountryPresenceEnum];
export const TldResponseDtoTechContactCountryPresenceEnum = {
    Af: 'AF',
    Al: 'AL',
    Dz: 'DZ',
    As: 'AS',
    Ad: 'AD',
    Ao: 'AO',
    Ai: 'AI',
    Aq: 'AQ',
    Ag: 'AG',
    Ar: 'AR',
    Am: 'AM',
    Aw: 'AW',
    Au: 'AU',
    At: 'AT',
    Az: 'AZ',
    Bs: 'BS',
    Bh: 'BH',
    Bd: 'BD',
    Bb: 'BB',
    By: 'BY',
    Be: 'BE',
    Bz: 'BZ',
    Bj: 'BJ',
    Bm: 'BM',
    Bt: 'BT',
    Bo: 'BO',
    Bq: 'BQ',
    Ba: 'BA',
    Bw: 'BW',
    Bv: 'BV',
    Br: 'BR',
    Io: 'IO',
    Bn: 'BN',
    Bg: 'BG',
    Bf: 'BF',
    Bi: 'BI',
    Kh: 'KH',
    Cm: 'CM',
    Ca: 'CA',
    Cv: 'CV',
    Ky: 'KY',
    Cf: 'CF',
    Td: 'TD',
    Cl: 'CL',
    Cn: 'CN',
    Cx: 'CX',
    Cc: 'CC',
    Co: 'CO',
    Km: 'KM',
    Cg: 'CG',
    Cd: 'CD',
    Ck: 'CK',
    Cr: 'CR',
    Ci: 'CI',
    Hr: 'HR',
    Cu: 'CU',
    Cw: 'CW',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Dj: 'DJ',
    Dm: 'DM',
    Do: 'DO',
    Ec: 'EC',
    Eg: 'EG',
    Sv: 'SV',
    Gq: 'GQ',
    Er: 'ER',
    Ee: 'EE',
    Et: 'ET',
    Fk: 'FK',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Gf: 'GF',
    Pf: 'PF',
    Tf: 'TF',
    Ga: 'GA',
    Gm: 'GM',
    Ge: 'GE',
    De: 'DE',
    Gh: 'GH',
    Gi: 'GI',
    Gr: 'GR',
    Gl: 'GL',
    Gd: 'GD',
    Gp: 'GP',
    Gu: 'GU',
    Gt: 'GT',
    Gg: 'GG',
    Gn: 'GN',
    Gw: 'GW',
    Gy: 'GY',
    Ht: 'HT',
    Hm: 'HM',
    Va: 'VA',
    Hn: 'HN',
    Hk: 'HK',
    Hu: 'HU',
    Is: 'IS',
    In: 'IN',
    Id: 'ID',
    Ir: 'IR',
    Iq: 'IQ',
    Ie: 'IE',
    Im: 'IM',
    Il: 'IL',
    It: 'IT',
    Jm: 'JM',
    Jp: 'JP',
    Je: 'JE',
    Jo: 'JO',
    Kz: 'KZ',
    Ke: 'KE',
    Ki: 'KI',
    Kp: 'KP',
    Kr: 'KR',
    Kw: 'KW',
    Kg: 'KG',
    La: 'LA',
    Lv: 'LV',
    Lb: 'LB',
    Ls: 'LS',
    Lr: 'LR',
    Ly: 'LY',
    Li: 'LI',
    Lt: 'LT',
    Lu: 'LU',
    Mo: 'MO',
    Mk: 'MK',
    Mg: 'MG',
    Mw: 'MW',
    My: 'MY',
    Mv: 'MV',
    Ml: 'ML',
    Mt: 'MT',
    Mh: 'MH',
    Mq: 'MQ',
    Mr: 'MR',
    Mu: 'MU',
    Tn: 'TN',
    Tr: 'TR',
    Tm: 'TM',
    Tc: 'TC',
    Tv: 'TV',
    Ug: 'UG',
    Ua: 'UA',
    Ae: 'AE',
    Gb: 'GB',
    Us: 'US',
    Um: 'UM',
    Uy: 'UY',
    Uz: 'UZ',
    Vu: 'VU',
    Ve: 'VE',
    Vn: 'VN',
    Vg: 'VG',
    Vi: 'VI',
    Wf: 'WF',
    Eh: 'EH',
    Ye: 'YE',
    Zm: 'ZM',
    Zw: 'ZW',
    Yt: 'YT',
    Mx: 'MX',
    Fm: 'FM',
    Md: 'MD',
    Mc: 'MC',
    Mn: 'MN',
    Me: 'ME',
    Ms: 'MS',
    Ma: 'MA',
    Mz: 'MZ',
    Mm: 'MM',
    Na: 'NA',
    Nr: 'NR',
    Np: 'NP',
    Nl: 'NL',
    Nc: 'NC',
    Nz: 'NZ',
    Ni: 'NI',
    Ne: 'NE',
    Ng: 'NG',
    Nu: 'NU',
    Nf: 'NF',
    Mp: 'MP',
    No: 'NO',
    Om: 'OM',
    Pk: 'PK',
    Pw: 'PW',
    Ps: 'PS',
    Pa: 'PA',
    Pg: 'PG',
    Py: 'PY',
    Pe: 'PE',
    Ph: 'PH',
    Pn: 'PN',
    Pl: 'PL',
    Pt: 'PT',
    Pr: 'PR',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Ru: 'RU',
    Rw: 'RW',
    Bl: 'BL',
    Sh: 'SH',
    Kn: 'KN',
    Lc: 'LC',
    Mf: 'MF',
    Pm: 'PM',
    Vc: 'VC',
    Ws: 'WS',
    Sm: 'SM',
    St: 'ST',
    Sa: 'SA',
    Sn: 'SN',
    Rs: 'RS',
    Sc: 'SC',
    Sl: 'SL',
    Sg: 'SG',
    Sx: 'SX',
    Sk: 'SK',
    Si: 'SI',
    Sb: 'SB',
    So: 'SO',
    Za: 'ZA',
    Gs: 'GS',
    Ss: 'SS',
    Es: 'ES',
    Lk: 'LK',
    Sd: 'SD',
    Sr: 'SR',
    Sj: 'SJ',
    Sz: 'SZ',
    Se: 'SE',
    Ch: 'CH',
    Sy: 'SY',
    Tw: 'TW',
    Tj: 'TJ',
    Tz: 'TZ',
    Th: 'TH',
    Tl: 'TL',
    Tg: 'TG',
    Tk: 'TK',
    To: 'TO',
    Tt: 'TT'
} as const;

export type TldResponseDtoTechContactCountryPresenceEnum = typeof TldResponseDtoTechContactCountryPresenceEnum[keyof typeof TldResponseDtoTechContactCountryPresenceEnum];
export const TldResponseDtoBillingContactCountryPresenceEnum = {
    Af: 'AF',
    Al: 'AL',
    Dz: 'DZ',
    As: 'AS',
    Ad: 'AD',
    Ao: 'AO',
    Ai: 'AI',
    Aq: 'AQ',
    Ag: 'AG',
    Ar: 'AR',
    Am: 'AM',
    Aw: 'AW',
    Au: 'AU',
    At: 'AT',
    Az: 'AZ',
    Bs: 'BS',
    Bh: 'BH',
    Bd: 'BD',
    Bb: 'BB',
    By: 'BY',
    Be: 'BE',
    Bz: 'BZ',
    Bj: 'BJ',
    Bm: 'BM',
    Bt: 'BT',
    Bo: 'BO',
    Bq: 'BQ',
    Ba: 'BA',
    Bw: 'BW',
    Bv: 'BV',
    Br: 'BR',
    Io: 'IO',
    Bn: 'BN',
    Bg: 'BG',
    Bf: 'BF',
    Bi: 'BI',
    Kh: 'KH',
    Cm: 'CM',
    Ca: 'CA',
    Cv: 'CV',
    Ky: 'KY',
    Cf: 'CF',
    Td: 'TD',
    Cl: 'CL',
    Cn: 'CN',
    Cx: 'CX',
    Cc: 'CC',
    Co: 'CO',
    Km: 'KM',
    Cg: 'CG',
    Cd: 'CD',
    Ck: 'CK',
    Cr: 'CR',
    Ci: 'CI',
    Hr: 'HR',
    Cu: 'CU',
    Cw: 'CW',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Dj: 'DJ',
    Dm: 'DM',
    Do: 'DO',
    Ec: 'EC',
    Eg: 'EG',
    Sv: 'SV',
    Gq: 'GQ',
    Er: 'ER',
    Ee: 'EE',
    Et: 'ET',
    Fk: 'FK',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Gf: 'GF',
    Pf: 'PF',
    Tf: 'TF',
    Ga: 'GA',
    Gm: 'GM',
    Ge: 'GE',
    De: 'DE',
    Gh: 'GH',
    Gi: 'GI',
    Gr: 'GR',
    Gl: 'GL',
    Gd: 'GD',
    Gp: 'GP',
    Gu: 'GU',
    Gt: 'GT',
    Gg: 'GG',
    Gn: 'GN',
    Gw: 'GW',
    Gy: 'GY',
    Ht: 'HT',
    Hm: 'HM',
    Va: 'VA',
    Hn: 'HN',
    Hk: 'HK',
    Hu: 'HU',
    Is: 'IS',
    In: 'IN',
    Id: 'ID',
    Ir: 'IR',
    Iq: 'IQ',
    Ie: 'IE',
    Im: 'IM',
    Il: 'IL',
    It: 'IT',
    Jm: 'JM',
    Jp: 'JP',
    Je: 'JE',
    Jo: 'JO',
    Kz: 'KZ',
    Ke: 'KE',
    Ki: 'KI',
    Kp: 'KP',
    Kr: 'KR',
    Kw: 'KW',
    Kg: 'KG',
    La: 'LA',
    Lv: 'LV',
    Lb: 'LB',
    Ls: 'LS',
    Lr: 'LR',
    Ly: 'LY',
    Li: 'LI',
    Lt: 'LT',
    Lu: 'LU',
    Mo: 'MO',
    Mk: 'MK',
    Mg: 'MG',
    Mw: 'MW',
    My: 'MY',
    Mv: 'MV',
    Ml: 'ML',
    Mt: 'MT',
    Mh: 'MH',
    Mq: 'MQ',
    Mr: 'MR',
    Mu: 'MU',
    Tn: 'TN',
    Tr: 'TR',
    Tm: 'TM',
    Tc: 'TC',
    Tv: 'TV',
    Ug: 'UG',
    Ua: 'UA',
    Ae: 'AE',
    Gb: 'GB',
    Us: 'US',
    Um: 'UM',
    Uy: 'UY',
    Uz: 'UZ',
    Vu: 'VU',
    Ve: 'VE',
    Vn: 'VN',
    Vg: 'VG',
    Vi: 'VI',
    Wf: 'WF',
    Eh: 'EH',
    Ye: 'YE',
    Zm: 'ZM',
    Zw: 'ZW',
    Yt: 'YT',
    Mx: 'MX',
    Fm: 'FM',
    Md: 'MD',
    Mc: 'MC',
    Mn: 'MN',
    Me: 'ME',
    Ms: 'MS',
    Ma: 'MA',
    Mz: 'MZ',
    Mm: 'MM',
    Na: 'NA',
    Nr: 'NR',
    Np: 'NP',
    Nl: 'NL',
    Nc: 'NC',
    Nz: 'NZ',
    Ni: 'NI',
    Ne: 'NE',
    Ng: 'NG',
    Nu: 'NU',
    Nf: 'NF',
    Mp: 'MP',
    No: 'NO',
    Om: 'OM',
    Pk: 'PK',
    Pw: 'PW',
    Ps: 'PS',
    Pa: 'PA',
    Pg: 'PG',
    Py: 'PY',
    Pe: 'PE',
    Ph: 'PH',
    Pn: 'PN',
    Pl: 'PL',
    Pt: 'PT',
    Pr: 'PR',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Ru: 'RU',
    Rw: 'RW',
    Bl: 'BL',
    Sh: 'SH',
    Kn: 'KN',
    Lc: 'LC',
    Mf: 'MF',
    Pm: 'PM',
    Vc: 'VC',
    Ws: 'WS',
    Sm: 'SM',
    St: 'ST',
    Sa: 'SA',
    Sn: 'SN',
    Rs: 'RS',
    Sc: 'SC',
    Sl: 'SL',
    Sg: 'SG',
    Sx: 'SX',
    Sk: 'SK',
    Si: 'SI',
    Sb: 'SB',
    So: 'SO',
    Za: 'ZA',
    Gs: 'GS',
    Ss: 'SS',
    Es: 'ES',
    Lk: 'LK',
    Sd: 'SD',
    Sr: 'SR',
    Sj: 'SJ',
    Sz: 'SZ',
    Se: 'SE',
    Ch: 'CH',
    Sy: 'SY',
    Tw: 'TW',
    Tj: 'TJ',
    Tz: 'TZ',
    Th: 'TH',
    Tl: 'TL',
    Tg: 'TG',
    Tk: 'TK',
    To: 'TO',
    Tt: 'TT'
} as const;

export type TldResponseDtoBillingContactCountryPresenceEnum = typeof TldResponseDtoBillingContactCountryPresenceEnum[keyof typeof TldResponseDtoBillingContactCountryPresenceEnum];
export const TldResponseDtoRenewalHandlingAfterTransferEnum = {
    Unchanged: 'UNCHANGED',
    Extends: 'EXTENDS',
    Restarts: 'RESTARTS'
} as const;

export type TldResponseDtoRenewalHandlingAfterTransferEnum = typeof TldResponseDtoRenewalHandlingAfterTransferEnum[keyof typeof TldResponseDtoRenewalHandlingAfterTransferEnum];
export const TldResponseDtoSupportedDurationsEnum = {
    _0: '0',
    _1: '1',
    _2: '2',
    _3: '3',
    _4: '4',
    _5: '5',
    _6: '6',
    _7: '7',
    _8: '8',
    _9: '9',
    _10: '10',
    _11: '11',
    _12: '12',
    _24: '24',
    _36: '36',
    _48: '48',
    _60: '60',
    _72: '72',
    _84: '84',
    _96: '96',
    _108: '108',
    _120: '120'
} as const;

export type TldResponseDtoSupportedDurationsEnum = typeof TldResponseDtoSupportedDurationsEnum[keyof typeof TldResponseDtoSupportedDurationsEnum];
export const TldResponseDtoDomainAdditionalDataEnum = {
    CatParameter: 'CAT_PARAMETER',
    ChallengeParameter: 'CHALLENGE_PARAMETER',
    ClaimsToken: 'CLAIMS_TOKEN',
    DonutsPriceCategory: 'DONUTS_PRICE_CATEGORY',
    IntentedUse: 'INTENTED_USE',
    PremiumPriceCategory: 'PREMIUM_PRICE_CATEGORY',
    ProxyService: 'PROXY_SERVICE',
    Sunrise: 'SUNRISE',
    UkDirect: 'UK_DIRECT',
    XxxMember: 'XXX_MEMBER'
} as const;

export type TldResponseDtoDomainAdditionalDataEnum = typeof TldResponseDtoDomainAdditionalDataEnum[keyof typeof TldResponseDtoDomainAdditionalDataEnum];
export const TldResponseDtoContactAdditionalDataEnum = {
    Afnic: 'AFNIC',
    Cat: 'CAT',
    De: 'DE',
    Es: 'ES',
    Eu: 'EU',
    It: 'IT',
    Lv: 'LV',
    Nl: 'NL',
    Pro: 'PRO',
    Uk: 'UK',
    Us: 'US'
} as const;

export type TldResponseDtoContactAdditionalDataEnum = typeof TldResponseDtoContactAdditionalDataEnum[keyof typeof TldResponseDtoContactAdditionalDataEnum];

/**
 * @type TldResponseDtoCategoriesInner
 * @export
 */
export type TldResponseDtoCategoriesInner = DomainCategoryResponseDto | string;

/**
 * @type TransactionId
 * A unique identifier assigned to the transaction to ensure precise reference within the system.
 * @export
 */
export type TransactionId = TransactionResponseDto | string;

/**
 * 
 * @export
 * @interface TransactionInfoDto
 */
export interface TransactionInfoDto {
    /**
     * 
     * @type {TransactionId}
     * @memberof TransactionInfoDto
     */
    'transaction': TransactionId;
    /**
     * The total amount of the transaction, in the order currency.
     * @type {number}
     * @memberof TransactionInfoDto
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface TransactionRedirectUrlResponseDto
 */
export interface TransactionRedirectUrlResponseDto {
    /**
     * The URL to which the payment is redirected.
     * @type {string}
     * @memberof TransactionRedirectUrlResponseDto
     */
    'redirectUrl': string;
    /**
     * The date when the redirect URL was created.
     * @type {string}
     * @memberof TransactionRedirectUrlResponseDto
     */
    'createdAt'?: string;
    /**
     * The date when the redirect URL was last updated.
     * @type {string}
     * @memberof TransactionRedirectUrlResponseDto
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface TransactionRequestDto
 */
export interface TransactionRequestDto {
    /**
     * The type of balance associated with the transaction. This field indicates whether the transaction is related to the users credit or discount balance.
     * @type {string}
     * @memberof TransactionRequestDto
     */
    'balanceType': TransactionRequestDtoBalanceTypeEnum;
    /**
     * Specifies the nature of the transaction, indicating whether it is a deposit (adding funds), a withdrawal (removing funds).
     * @type {string}
     * @memberof TransactionRequestDto
     */
    'type': TransactionRequestDtoTypeEnum;
    /**
     * The full name of the user associated with the transaction.
     * @type {string}
     * @memberof TransactionRequestDto
     */
    'fullName'?: string;
    /**
     * The name of the company associated with this transaction.
     * @type {string}
     * @memberof TransactionRequestDto
     */
    'companyName'?: string;
    /**
     * A descriptive title for the integration associated with the transaction.
     * @type {string}
     * @memberof TransactionRequestDto
     */
    'integrationTitle'?: string;
    /**
     * The current status of the transaction.  This field indicates the progress and state of the transaction, such as whether it is pending, processing, successful, or failed.
     * @type {string}
     * @memberof TransactionRequestDto
     */
    'status': TransactionRequestDtoStatusEnum;
    /**
     * The total amount of the transaction. This value represents the monetary amount that will be added to or subtracted from the user\'s balance.
     * @type {number}
     * @memberof TransactionRequestDto
     */
    'amount': number;
    /**
     * The payment method used for the transaction. This field indicates how the customer paid for the transaction and is required.
     * @type {string}
     * @memberof TransactionRequestDto
     */
    'paymentMethod': string;
    /**
     * An internal note related to the transaction. This field is optional and is not visible to the customer, but can be used for bookkeeping or additional context.
     * @type {string}
     * @memberof TransactionRequestDto
     */
    'comment'?: string;
    /**
     * Additional data related to the transaction. This field is optional and is not visible to the customer. It can store metadata or extra details for internal use.
     * @type {object}
     * @memberof TransactionRequestDto
     */
    'payload'?: object;
    /**
     * The date and time when the transaction occurred.
     * @type {string}
     * @memberof TransactionRequestDto
     */
    'date': string;
    /**
     * The unique identifier of the user who initiated or is affected by this transaction.
     * @type {string}
     * @memberof TransactionRequestDto
     */
    'user': string;
    /**
     * The unique identifier of the client company associated with the transaction.
     * @type {string}
     * @memberof TransactionRequestDto
     */
    'clientCompany'?: string;
    /**
     * The unique identifier of the associated order. If this field is null or not provided, the transaction is considered a deposit to the user\'s balance. Otherwise, it is associated with a specific order.
     * @type {string}
     * @memberof TransactionRequestDto
     */
    'order'?: string;
    /**
     * A unique identifier that links the transaction to a specific integration. This field is optional and is used for tracking and reporting on transactions that have been processed through specific partnerships or integrations.
     * @type {string}
     * @memberof TransactionRequestDto
     */
    'integration'?: string;
}

export const TransactionRequestDtoBalanceTypeEnum = {
    Balance: 'BALANCE',
    ReservedBalance: 'RESERVED_BALANCE',
    DiscountBalance: 'DISCOUNT_BALANCE'
} as const;

export type TransactionRequestDtoBalanceTypeEnum = typeof TransactionRequestDtoBalanceTypeEnum[keyof typeof TransactionRequestDtoBalanceTypeEnum];
export const TransactionRequestDtoTypeEnum = {
    Withdraw: 'WITHDRAW',
    Deposit: 'DEPOSIT',
    Refund: 'REFUND'
} as const;

export type TransactionRequestDtoTypeEnum = typeof TransactionRequestDtoTypeEnum[keyof typeof TransactionRequestDtoTypeEnum];
export const TransactionRequestDtoStatusEnum = {
    Pending: 'PENDING',
    Processing: 'PROCESSING',
    Completed: 'COMPLETED',
    Cancel: 'CANCEL',
    Error: 'ERROR'
} as const;

export type TransactionRequestDtoStatusEnum = typeof TransactionRequestDtoStatusEnum[keyof typeof TransactionRequestDtoStatusEnum];

/**
 * 
 * @export
 * @interface TransactionResponseDto
 */
export interface TransactionResponseDto {
    /**
     * The type of balance associated with the transaction. This field indicates whether the transaction is related to the users credit or discount balance.
     * @type {string}
     * @memberof TransactionResponseDto
     */
    'balanceType': TransactionResponseDtoBalanceTypeEnum;
    /**
     * Specifies the nature of the transaction, indicating whether it is a deposit (adding funds), a withdrawal (removing funds).
     * @type {string}
     * @memberof TransactionResponseDto
     */
    'type': TransactionResponseDtoTypeEnum;
    /**
     * The full name of the user associated with the transaction.
     * @type {string}
     * @memberof TransactionResponseDto
     */
    'fullName'?: string;
    /**
     * The name of the company associated with this transaction.
     * @type {string}
     * @memberof TransactionResponseDto
     */
    'companyName'?: string;
    /**
     * A descriptive title for the integration associated with the transaction.
     * @type {string}
     * @memberof TransactionResponseDto
     */
    'integrationTitle'?: string;
    /**
     * The current status of the transaction.  This field indicates the progress and state of the transaction, such as whether it is pending, processing, successful, or failed.
     * @type {string}
     * @memberof TransactionResponseDto
     */
    'status': TransactionResponseDtoStatusEnum;
    /**
     * The total amount of the transaction. This value represents the monetary amount that will be added to or subtracted from the user\'s balance.
     * @type {number}
     * @memberof TransactionResponseDto
     */
    'amount': number;
    /**
     * The payment method used for the transaction. This field indicates how the customer paid for the transaction and is required.
     * @type {string}
     * @memberof TransactionResponseDto
     */
    'paymentMethod': string;
    /**
     * An internal note related to the transaction. This field is optional and is not visible to the customer, but can be used for bookkeeping or additional context.
     * @type {string}
     * @memberof TransactionResponseDto
     */
    'comment'?: string;
    /**
     * Additional data related to the transaction. This field is optional and is not visible to the customer. It can store metadata or extra details for internal use.
     * @type {object}
     * @memberof TransactionResponseDto
     */
    'payload'?: object;
    /**
     * The date and time when the transaction occurred.
     * @type {string}
     * @memberof TransactionResponseDto
     */
    'date': string;
    /**
     * The unique identifier of the payment.
     * @type {string}
     * @memberof TransactionResponseDto
     */
    'id'?: string;
    /**
     * 
     * @type {Company13}
     * @memberof TransactionResponseDto
     */
    'company': Company13;
    /**
     * 
     * @type {User7}
     * @memberof TransactionResponseDto
     */
    'user'?: User7;
    /**
     * 
     * @type {ClientCompany2}
     * @memberof TransactionResponseDto
     */
    'clientCompany'?: ClientCompany2;
    /**
     * 
     * @type {Order1}
     * @memberof TransactionResponseDto
     */
    'order'?: Order1;
    /**
     * 
     * @type {Integration3}
     * @memberof TransactionResponseDto
     */
    'integration'?: Integration3;
    /**
     * The date when the payment was created.
     * @type {string}
     * @memberof TransactionResponseDto
     */
    'createdAt'?: string;
    /**
     * The date when the payment was last updated.
     * @type {string}
     * @memberof TransactionResponseDto
     */
    'updatedAt'?: string;
}

export const TransactionResponseDtoBalanceTypeEnum = {
    Balance: 'BALANCE',
    ReservedBalance: 'RESERVED_BALANCE',
    DiscountBalance: 'DISCOUNT_BALANCE'
} as const;

export type TransactionResponseDtoBalanceTypeEnum = typeof TransactionResponseDtoBalanceTypeEnum[keyof typeof TransactionResponseDtoBalanceTypeEnum];
export const TransactionResponseDtoTypeEnum = {
    Withdraw: 'WITHDRAW',
    Deposit: 'DEPOSIT',
    Refund: 'REFUND'
} as const;

export type TransactionResponseDtoTypeEnum = typeof TransactionResponseDtoTypeEnum[keyof typeof TransactionResponseDtoTypeEnum];
export const TransactionResponseDtoStatusEnum = {
    Pending: 'PENDING',
    Processing: 'PROCESSING',
    Completed: 'COMPLETED',
    Cancel: 'CANCEL',
    Error: 'ERROR'
} as const;

export type TransactionResponseDtoStatusEnum = typeof TransactionResponseDtoStatusEnum[keyof typeof TransactionResponseDtoStatusEnum];

/**
 * @type TransferredFromUser
 * Stores the unique identifier of the user account from which the item was transferred, allowing for historical tracking.
 * @export
 */
export type TransferredFromUser = UserResponseDto | string;

/**
 * @type TransferredToUser
 * Stores the unique identifier of the user account to which the item was transferred, allowing for historical tracking.
 * @export
 */
export type TransferredToUser = UserResponseDto | string;

/**
 * 
 * @export
 * @interface UKDirectDataDto
 */
export interface UKDirectDataDto {
    /**
     * The unique domain ID of the related domain.
     * @type {number}
     * @memberof UKDirectDataDto
     */
    'relatedDomainId': number;
}
/**
 * 
 * @export
 * @interface UkAdditionalDataDto
 */
export interface UkAdditionalDataDto {
    /**
     * The category of the type of organization that the registration is being made for, e.g., LTD, PLC, LLP, SCH, RCHAR.
     * @type {string}
     * @memberof UkAdditionalDataDto
     */
    'registrantType': UkAdditionalDataDtoRegistrantTypeEnum;
    /**
     * For Registration Types LTD, PLC, LLP, IP, you should enter the registrant’s Companies House Registration Number.     For Registrant Type SCH, you should enter the DfES UK School number.     For Registrant Type RCHAR, you should enter the registrant\'s Registered Charity Number.
     * @type {string}
     * @memberof UkAdditionalDataDto
     */
    'companyNumber'?: string;
    /**
     * This is not the registered Name of the company (The registered Name of the company should be entered in the Organization Field). A trade name is also called a DBA (doing business as) name. A good example of this is Walmart. Walmart\'s legal business name is Wal-Mart Inc. but its trade name is just Walmart—that\'s the name it uses on its advertising and website, and what most people refer to it as.
     * @type {string}
     * @memberof UkAdditionalDataDto
     */
    'tradingName'?: string;
    /**
     * Indicates whether WHOis opt-out is enabled (true) or disabled (false).
     * @type {boolean}
     * @memberof UkAdditionalDataDto
     */
    'whoisOptOut'?: boolean;
}

export const UkAdditionalDataDtoRegistrantTypeEnum = {
    Tld: 'TLD',
    Plc: 'PLC',
    Ptnr: 'PTNR',
    Stra: 'STRA',
    Llp: 'LLP',
    Ip: 'IP',
    Ind: 'IND',
    Sch: 'SCH',
    Rchar: 'RCHAR',
    Gov: 'GOV',
    Crc: 'CRC',
    Stat: 'STAT',
    Other: 'OTHER',
    Find: 'FIND',
    Fcorp: 'FCORP',
    Fother: 'FOTHER'
} as const;

export type UkAdditionalDataDtoRegistrantTypeEnum = typeof UkAdditionalDataDtoRegistrantTypeEnum[keyof typeof UkAdditionalDataDtoRegistrantTypeEnum];

/**
 * 
 * @export
 * @interface UnitDto
 */
export interface UnitDto {
    /**
     * Unit identifier.
     * @type {string}
     * @memberof UnitDto
     */
    'id': string;
    /**
     * What is measured.
     * @type {string}
     * @memberof UnitDto
     */
    'unitDescription': string;
    /**
     * Billing interval.
     * @type {string}
     * @memberof UnitDto
     */
    'intervalDescription': string;
}
/**
 * @type UnsuspendTemplate
 * The template for unsuspending a product. This field represents the official name or identifier for the template, and it cannot be empty.
 * @export
 */
export type UnsuspendTemplate = TemplateResponseDto | string;

/**
 * 
 * @export
 * @interface UpdateClientRequestDto
 */
export interface UpdateClientRequestDto {
    /**
     * Represents the name of the item, such as a hosting domain, server IP, or the name of a domain.
     * @type {string}
     * @memberof UpdateClientRequestDto
     */
    'resourceName': string;
    /**
     * Indicates whether the item will automatically renew. Default behavior follows the user\'s specified preference.
     * @type {boolean}
     * @memberof UpdateClientRequestDto
     */
    'autorenew': boolean;
    /**
     * A comment associated with the item that can be accessed by all users.
     * @type {string}
     * @memberof UpdateClientRequestDto
     */
    'publicComment': string;
    /**
     * List of additional email addresses to which customer notifications will be sent.
     * @type {Array<string>}
     * @memberof UpdateClientRequestDto
     */
    'additionalNotificationEmails': Array<string>;
    /**
     * List of additional phone numbers to which customer notifications will be sent.
     * @type {Array<string>}
     * @memberof UpdateClientRequestDto
     */
    'additionalNotificationPhoneNumbers': Array<string>;
    /**
     * The date when the subscription for the item begins.
     * @type {string}
     * @memberof UpdateClientRequestDto
     */
    'startDate': string;
    /**
     * The date when the subscription for the item ends.
     * @type {string}
     * @memberof UpdateClientRequestDto
     */
    'endDate': string;
}
/**
 * 
 * @export
 * @interface UpdateCompanyBrandRequest
 */
export interface UpdateCompanyBrandRequest {
    /**
     * 
     * @type {object}
     * @memberof UpdateCompanyBrandRequest
     */
    'brand'?: object;
}
/**
 * 
 * @export
 * @interface UpdateCompanyDefaultLanguageRequest
 */
export interface UpdateCompanyDefaultLanguageRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateCompanyDefaultLanguageRequest
     */
    'defaultLanguage'?: UpdateCompanyDefaultLanguageRequestDefaultLanguageEnum;
}

export const UpdateCompanyDefaultLanguageRequestDefaultLanguageEnum = {
    Ab: 'AB',
    Aa: 'AA',
    Af: 'AF',
    Ak: 'AK',
    Sq: 'SQ',
    Am: 'AM',
    Ar: 'AR',
    An: 'AN',
    Hy: 'HY',
    As: 'AS',
    Av: 'AV',
    Ae: 'AE',
    Ay: 'AY',
    Az: 'AZ',
    Bm: 'BM',
    Ba: 'BA',
    Eu: 'EU',
    Be: 'BE',
    Bn: 'BN',
    Bi: 'BI',
    Bs: 'BS',
    Br: 'BR',
    Bg: 'BG',
    My: 'MY',
    Ca: 'CA',
    Km: 'KM',
    Ch: 'CH',
    Ce: 'CE',
    Ny: 'NY',
    Zh: 'ZH',
    Cu: 'CU',
    Cv: 'CV',
    Kw: 'KW',
    Co: 'CO',
    Cr: 'CR',
    Hr: 'HR',
    Cs: 'CS',
    Da: 'DA',
    Dv: 'DV',
    Nl: 'NL',
    Dz: 'DZ',
    En: 'EN',
    Eo: 'EO',
    Et: 'ET',
    Ee: 'EE',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Ff: 'FF',
    Gl: 'GL',
    Lg: 'LG',
    Ka: 'KA',
    De: 'DE',
    El: 'EL',
    Gn: 'GN',
    Gu: 'GU',
    Ht: 'HT',
    Ha: 'HA',
    He: 'HE',
    Hz: 'HZ',
    Hi: 'HI',
    Ho: 'HO',
    Hu: 'HU',
    Is: 'IS',
    Io: 'IO',
    Ig: 'IG',
    Id: 'ID',
    Ia: 'IA',
    Ie: 'IE',
    Iu: 'IU',
    Ik: 'IK',
    Ga: 'GA',
    It: 'IT',
    Ja: 'JA',
    Jv: 'JV',
    Kl: 'KL',
    Kn: 'KN',
    Kr: 'KR',
    Ks: 'KS',
    Kk: 'KK',
    Ki: 'KI',
    Rw: 'RW',
    Ky: 'KY',
    Kv: 'KV',
    Kg: 'KG',
    Ko: 'KO',
    Kj: 'KJ',
    Ku: 'KU',
    Lo: 'LO',
    La: 'LA',
    Lv: 'LV',
    Li: 'LI',
    Ln: 'LN',
    Lt: 'LT',
    Lu: 'LU',
    Lb: 'LB',
    Mk: 'MK',
    Mg: 'MG',
    Ms: 'MS',
    Ml: 'ML',
    Mt: 'MT',
    Gv: 'GV',
    Mi: 'MI',
    Mr: 'MR',
    Mh: 'MH',
    Mn: 'MN',
    Na: 'NA',
    Nv: 'NV',
    Nd: 'ND',
    Nr: 'NR',
    Ng: 'NG',
    Ne: 'NE',
    Se: 'SE',
    No: 'NO',
    Nb: 'NB',
    Nn: 'NN',
    Ii: 'II',
    Oc: 'OC',
    Oj: 'OJ',
    Or: 'OR',
    Om: 'OM',
    Os: 'OS',
    Pi: 'PI',
    Ps: 'PS',
    Fa: 'FA',
    Pl: 'PL',
    Pt: 'PT',
    Pa: 'PA',
    Qu: 'QU',
    Ro: 'RO',
    Rm: 'RM',
    Rn: 'RN',
    Ru: 'RU',
    Sm: 'SM',
    Sg: 'SG',
    Sa: 'SA',
    Sc: 'SC',
    Gd: 'GD',
    Sr: 'SR',
    Sn: 'SN',
    Ii2: 'II',
    Sd: 'SD',
    Si: 'SI',
    Sk: 'SK',
    Sl: 'SL',
    So: 'SO',
    St: 'ST',
    Es: 'ES',
    Su: 'SU',
    Sw: 'SW',
    Ss: 'SS',
    Sv: 'SV',
    Tl: 'TL',
    Ty: 'TY',
    Tg: 'TG',
    Ta: 'TA',
    Tt: 'TT',
    Te: 'TE',
    Th: 'TH',
    Bo: 'BO',
    Ti: 'TI',
    To: 'TO',
    Ts: 'TS',
    Tn: 'TN',
    Tr: 'TR',
    Tk: 'TK',
    Tw: 'TW',
    Ug: 'UG',
    Uk: 'UK',
    Ur: 'UR',
    Uz: 'UZ',
    Ve: 'VE',
    Vi: 'VI',
    Vo: 'VO',
    Wa: 'WA',
    Cy: 'CY',
    Fy: 'FY',
    Wo: 'WO',
    Xh: 'XH',
    Yi: 'YI',
    Yo: 'YO',
    Za: 'ZA',
    Zu: 'ZU'
} as const;

export type UpdateCompanyDefaultLanguageRequestDefaultLanguageEnum = typeof UpdateCompanyDefaultLanguageRequestDefaultLanguageEnum[keyof typeof UpdateCompanyDefaultLanguageRequestDefaultLanguageEnum];

/**
 * 
 * @export
 * @interface UpdateCompanyUsernameRequest
 */
export interface UpdateCompanyUsernameRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateCompanyUsernameRequest
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface UpdateIntegration200Response
 */
export interface UpdateIntegration200Response {
    /**
     * The HTTP status code indicating the result of the operation.
     * @type {any}
     * @memberof UpdateIntegration200Response
     */
    'code': any;
    /**
     * A human-readable message providing more details about the response.
     * @type {any}
     * @memberof UpdateIntegration200Response
     */
    'message': any;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateIntegration200Response
     */
    'data': boolean;
}
/**
 * 
 * @export
 * @interface UpdatePrivacyPolicyUrlRequest
 */
export interface UpdatePrivacyPolicyUrlRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdatePrivacyPolicyUrlRequest
     */
    'privacyPolicyUrl'?: string;
}
/**
 * @type UpdateTemplate
 * The template for updating a product. This field represents the official name or identifier for the template, and it cannot be empty.
 * @export
 */
export type UpdateTemplate = TemplateResponseDto | string;

/**
 * 
 * @export
 * @interface UpdateUserCommentsRequest
 */
export interface UpdateUserCommentsRequest {
    /**
     * The comments to be added to the user\'s profile.
     * @type {Array<string>}
     * @memberof UpdateUserCommentsRequest
     */
    'comments'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateUserTagsRequest
 */
export interface UpdateUserTagsRequest {
    /**
     * An array of tags to replace the existing tags on the user\'s profile.
     * @type {Array<string>}
     * @memberof UpdateUserTagsRequest
     */
    'tags'?: Array<string>;
}
/**
 * @type UpgradeTemplate
 * The template for upgrading a product. This field represents the official name or identifier for the template, and it cannot be empty.
 * @export
 */
export type UpgradeTemplate = TemplateResponseDto | string;

/**
 * 
 * @export
 * @interface UsAdditionalDataDto
 */
export interface UsAdditionalDataDto {
    /**
     * The purpose of the domain application. Possible values include:     - P1 (Business use for profit)     - P2 (Non-profit business, club, association, etc.)     - P3 (Personal use)     - P4 (Education purposes)     - P5 (Government purposes)
     * @type {string}
     * @memberof UsAdditionalDataDto
     */
    'appPurpose': UsAdditionalDataDtoAppPurposeEnum;
    /**
     * The category of the registrant. Possible values include:     - C11 (A natural person who is a United States citizen)     - C12 (A natural person who is a permanent resident of the United States of America, or     any of its possessions or territories)     - C21 (A US-based organization or company formed within one of the fifty (50) U.S. states,     the District of Columbia, or any of the United States possessions or territories, or organized     or otherwise constituted under the laws of a state of the United States of America, the     District of Columbia, or any of its possessions or territories or a U.S. federal, state, or local     government entity or a political subdivision thereof.)     - C31 (A foreign entity or organization that has a bona fide presence in the United States     of America or any of its possessions or territories who regularly engages in lawful activities     (sales of goods or services or other business, commercial or non-commercial, including     not-for-profit relations in the United States).)     - C32 (A foreign entity or organization that has an office or other facility in the United     States.)
     * @type {string}
     * @memberof UsAdditionalDataDto
     */
    'category': UsAdditionalDataDtoCategoryEnum;
}

export const UsAdditionalDataDtoAppPurposeEnum = {
    P1: 'P1',
    P2: 'P2',
    P3: 'P3',
    P4: 'P4',
    P5: 'P5'
} as const;

export type UsAdditionalDataDtoAppPurposeEnum = typeof UsAdditionalDataDtoAppPurposeEnum[keyof typeof UsAdditionalDataDtoAppPurposeEnum];
export const UsAdditionalDataDtoCategoryEnum = {
    C11: 'C11',
    C12: 'C12',
    C21: 'C21',
    C31: 'C31',
    C32: 'C32'
} as const;

export type UsAdditionalDataDtoCategoryEnum = typeof UsAdditionalDataDtoCategoryEnum[keyof typeof UsAdditionalDataDtoCategoryEnum];

/**
 * @type User
 * Detailed information about the user, including personal and account-related attributes.
 * @export
 */
export type User = UserResponseDto | string;

/**
 * @type User1
 * The unique identifier of the company associated with this contact.
 * @export
 */
export type User1 = UserResponseDto | string;

/**
 * @type User2
 * The identifier of the user who will receive the affiliate commission.
 * @export
 */
export type User2 = UserResponseDto | string;

/**
 * @type User3
 * A unique identifier for the user associated with this item, used to link the item to a specific user account.
 * @export
 */
export type User3 = UserResponseDto | string;

/**
 * @type User4
 * A unique identifier assigned to the user placing or associated with the order, ensuring the order is linked to the correct user.
 * @export
 */
export type User4 = UserResponseDto | string;

/**
 * @type User5
 * A unique identifier representing the user associated with this domain contact. This value is required and cannot be empty.
 * @export
 */
export type User5 = UserResponseDto | string;

/**
 * @type User6
 * Id of the user the invoice is published for
 * @export
 */
export type User6 = UserResponseDto | string;

/**
 * @type User7
 * The unique identifier of the user who initiated or is affected by this transaction.
 * @export
 */
export type User7 = UserResponseDto | string;

/**
 * 
 * @export
 * @interface UserBasketDto
 */
export interface UserBasketDto {
    /**
     * The unique identifier of the user.
     * @type {string}
     * @memberof UserBasketDto
     */
    'userId': string;
    /**
     * The user\'s shopping cart data.
     * @type {object}
     * @memberof UserBasketDto
     */
    'cart': object;
    /**
     * The date and time when the user\'s basket was last updated.
     * @type {string}
     * @memberof UserBasketDto
     */
    'updatedAt': string;
}
/**
 * @type UserID
 * The unique identifier of the user associated with the coupon. If provided, the coupon is restricted to this specific user. If not, the coupon is considered global and available to all users.
 * @export
 */
export type UserID = UserResponseDto | string;

/**
 * 
 * @export
 * @interface UserPricePolicyRequestDto
 */
export interface UserPricePolicyRequestDto {
    /**
     * A collection of price configurations, including duration-based and dynamic pricing options for the product.
     * @type {PricesDto}
     * @memberof UserPricePolicyRequestDto
     */
    'prices'?: PricesDto;
    /**
     * The unique identifier of the product.
     * @type {string}
     * @memberof UserPricePolicyRequestDto
     */
    'product': string;
}
/**
 * 
 * @export
 * @interface UserPricePolicyResponseDto
 */
export interface UserPricePolicyResponseDto {
    /**
     * A collection of price configurations, including duration-based and dynamic pricing options for the product.
     * @type {PricesDto}
     * @memberof UserPricePolicyResponseDto
     */
    'prices'?: PricesDto;
    /**
     * 
     * @type {Product}
     * @memberof UserPricePolicyResponseDto
     */
    'product': Product;
}
/**
 * 
 * @export
 * @interface UserResponseDto
 */
export interface UserResponseDto {
    /**
     * Email address connected to the user.
     * @type {string}
     * @memberof UserResponseDto
     */
    'email': string;
    /**
     * Indicates whether the user is restricted from making payments. When enabled, the user can manage their account and orders but cannot complete payment transactions.
     * @type {boolean}
     * @memberof UserResponseDto
     */
    'lockedPayments'?: boolean;
    /**
     * Indicates if a user is banned.
     * @type {boolean}
     * @memberof UserResponseDto
     */
    'banned'?: boolean;
    /**
     * An array containing comments related to the user. These comments are provided by the company and can only be viewed by users with the \'user read\' role. If the user does not have this role, null will be returned.
     * @type {Array<string>}
     * @memberof UserResponseDto
     */
    'comments'?: Array<string>;
    /**
     * Indicates the invoice frequency. If not set, the company\'s default invoice interval will be used when the value is null.
     * @type {string}
     * @memberof UserResponseDto
     */
    'invoiceInterval'?: UserResponseDtoInvoiceIntervalEnum;
    /**
     * Represents the user\'s preferred notification methods. Each boolean value indicates whether the user has accepted receiving notifications through email, SMS, or push notifications. If a method is set to `true`, it means the user has agreed to receive notifications via that method.
     * @type {AcceptedNotificationMethodsDto}
     * @memberof UserResponseDto
     */
    'acceptedNotificationMethods': AcceptedNotificationMethodsDto;
    /**
     * The user\'s persistent shopping cart, which retains items across sessions. This allows the user to continue their shopping experience without losing previously added items.
     * @type {UserBasketDto}
     * @memberof UserResponseDto
     */
    'persistentCart'?: UserBasketDto;
    /**
     * A list of tags associated with the user. These tags are used for user filtering and can only be seen by users with the \'user read\' role. Users cannot see their own tags.
     * @type {Array<string>}
     * @memberof UserResponseDto
     */
    'tags'?: Array<string>;
    /**
     * A list of additional email addresses to receive notifications. These emails are used to extend notification coverage to multiple recipients beyond the primary user.
     * @type {Array<string>}
     * @memberof UserResponseDto
     */
    'additionalNotificationEmails'?: Array<string>;
    /**
     * Represents the balance, primarily accumulated from affiliate programs, that can be applied as a discount on products. This balance is not related to credits but serves as a discount mechanism.
     * @type {number}
     * @memberof UserResponseDto
     */
    'discountBalance'?: number;
    /**
     * The amount of money that is temporarily reserved from the user\'s account. This balance is typically used for services or products that charge on a time-based or usage-based model, such as hourly rental fees.
     * @type {number}
     * @memberof UserResponseDto
     */
    'reservedBalance'?: number;
    /**
     * The amount of money that is available for the user to spend. This balance is typically used for services or products that charge on a time-based or usage-based model, such as hourly rental fees.
     * @type {number}
     * @memberof UserResponseDto
     */
    'creditBalance'?: number;
    /**
     * Represents the user\'s account balance, which may include funds available for transactions or other purposes within the system.
     * @type {number}
     * @memberof UserResponseDto
     */
    'balance'?: number;
    /**
     * Indicates whether the user\'s subscriptions or services should automatically renew.
     * @type {boolean}
     * @memberof UserResponseDto
     */
    'autoRenew': boolean;
    /**
     * Indicates whether the user has subscribed to the company\'s newsletter. For the subscription to be active, the user must have confirmed their subscription through email verification. Only users with an \'opt-in\' record will have this set to `true`.
     * @type {boolean}
     * @memberof UserResponseDto
     */
    'newsletterSubscribe'?: boolean;
    /**
     * The URL pointing to the user\'s profile picture. Update when the `authIntegrationData` is also updated.
     * @type {string}
     * @memberof UserResponseDto
     */
    'photoUrl'?: string;
    /**
     * A unique identifier for the user.
     * @type {string}
     * @memberof UserResponseDto
     */
    'id'?: string;
    /**
     * Specifies the user\'s preferred default language, primarily used for localization of notifications and user-facing content.
     * @type {string}
     * @memberof UserResponseDto
     */
    'defaultLanguage'?: UserResponseDtoDefaultLanguageEnum;
    /**
     * An array representing the companies a user is associated with, including the user\'s roles within each company.
     * @type {Array<CompanyRolesResponseDto>}
     * @memberof UserResponseDto
     */
    'companyRoles': Array<CompanyRolesResponseDto>;
    /**
     * 
     * @type {Company1}
     * @memberof UserResponseDto
     */
    'company'?: Company1;
    /**
     * An array of custom price policies assigned to the user. These policies override the general price policies for the user.
     * @type {Array<UserPricePolicyResponseDto>}
     * @memberof UserResponseDto
     */
    'userPricePolicies'?: Array<UserPricePolicyResponseDto>;
    /**
     * 
     * @type {UserSInvoiceContact}
     * @memberof UserResponseDto
     */
    'ownInvoiceContact'?: UserSInvoiceContact;
    /**
     * An array containing affiliates related to the user. Its an only rad value for the user.
     * @type {Array<UserResponseDtoCustomAffiliatesInner>}
     * @memberof UserResponseDto
     */
    'customAffiliates'?: Array<UserResponseDtoCustomAffiliatesInner>;
    /**
     * An array of payment subscriptions associated with the user.
     * @type {Array<PaymentSubscriptionResponseDto>}
     * @memberof UserResponseDto
     */
    'paymentSubscriptions'?: Array<PaymentSubscriptionResponseDto>;
    /**
     * 
     * @type {PricePolicy}
     * @memberof UserResponseDto
     */
    'pricePolicy'?: PricePolicy;
    /**
     * The date the user was created.
     * @type {string}
     * @memberof UserResponseDto
     */
    'createdAt': string;
    /**
     * The date the user was last updated.
     * @type {string}
     * @memberof UserResponseDto
     */
    'updatedAt': string;
}

export const UserResponseDtoInvoiceIntervalEnum = {
    Instant: 'instant',
    Weekly: 'weekly',
    Monthly: 'monthly',
    PerRequest: 'per request'
} as const;

export type UserResponseDtoInvoiceIntervalEnum = typeof UserResponseDtoInvoiceIntervalEnum[keyof typeof UserResponseDtoInvoiceIntervalEnum];
export const UserResponseDtoDefaultLanguageEnum = {
    Ab: 'AB',
    Aa: 'AA',
    Af: 'AF',
    Ak: 'AK',
    Sq: 'SQ',
    Am: 'AM',
    Ar: 'AR',
    An: 'AN',
    Hy: 'HY',
    As: 'AS',
    Av: 'AV',
    Ae: 'AE',
    Ay: 'AY',
    Az: 'AZ',
    Bm: 'BM',
    Ba: 'BA',
    Eu: 'EU',
    Be: 'BE',
    Bn: 'BN',
    Bi: 'BI',
    Bs: 'BS',
    Br: 'BR',
    Bg: 'BG',
    My: 'MY',
    Ca: 'CA',
    Km: 'KM',
    Ch: 'CH',
    Ce: 'CE',
    Ny: 'NY',
    Zh: 'ZH',
    Cu: 'CU',
    Cv: 'CV',
    Kw: 'KW',
    Co: 'CO',
    Cr: 'CR',
    Hr: 'HR',
    Cs: 'CS',
    Da: 'DA',
    Dv: 'DV',
    Nl: 'NL',
    Dz: 'DZ',
    En: 'EN',
    Eo: 'EO',
    Et: 'ET',
    Ee: 'EE',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Ff: 'FF',
    Gl: 'GL',
    Lg: 'LG',
    Ka: 'KA',
    De: 'DE',
    El: 'EL',
    Gn: 'GN',
    Gu: 'GU',
    Ht: 'HT',
    Ha: 'HA',
    He: 'HE',
    Hz: 'HZ',
    Hi: 'HI',
    Ho: 'HO',
    Hu: 'HU',
    Is: 'IS',
    Io: 'IO',
    Ig: 'IG',
    Id: 'ID',
    Ia: 'IA',
    Ie: 'IE',
    Iu: 'IU',
    Ik: 'IK',
    Ga: 'GA',
    It: 'IT',
    Ja: 'JA',
    Jv: 'JV',
    Kl: 'KL',
    Kn: 'KN',
    Kr: 'KR',
    Ks: 'KS',
    Kk: 'KK',
    Ki: 'KI',
    Rw: 'RW',
    Ky: 'KY',
    Kv: 'KV',
    Kg: 'KG',
    Ko: 'KO',
    Kj: 'KJ',
    Ku: 'KU',
    Lo: 'LO',
    La: 'LA',
    Lv: 'LV',
    Li: 'LI',
    Ln: 'LN',
    Lt: 'LT',
    Lu: 'LU',
    Lb: 'LB',
    Mk: 'MK',
    Mg: 'MG',
    Ms: 'MS',
    Ml: 'ML',
    Mt: 'MT',
    Gv: 'GV',
    Mi: 'MI',
    Mr: 'MR',
    Mh: 'MH',
    Mn: 'MN',
    Na: 'NA',
    Nv: 'NV',
    Nd: 'ND',
    Nr: 'NR',
    Ng: 'NG',
    Ne: 'NE',
    Se: 'SE',
    No: 'NO',
    Nb: 'NB',
    Nn: 'NN',
    Ii: 'II',
    Oc: 'OC',
    Oj: 'OJ',
    Or: 'OR',
    Om: 'OM',
    Os: 'OS',
    Pi: 'PI',
    Ps: 'PS',
    Fa: 'FA',
    Pl: 'PL',
    Pt: 'PT',
    Pa: 'PA',
    Qu: 'QU',
    Ro: 'RO',
    Rm: 'RM',
    Rn: 'RN',
    Ru: 'RU',
    Sm: 'SM',
    Sg: 'SG',
    Sa: 'SA',
    Sc: 'SC',
    Gd: 'GD',
    Sr: 'SR',
    Sn: 'SN',
    Ii2: 'II',
    Sd: 'SD',
    Si: 'SI',
    Sk: 'SK',
    Sl: 'SL',
    So: 'SO',
    St: 'ST',
    Es: 'ES',
    Su: 'SU',
    Sw: 'SW',
    Ss: 'SS',
    Sv: 'SV',
    Tl: 'TL',
    Ty: 'TY',
    Tg: 'TG',
    Ta: 'TA',
    Tt: 'TT',
    Te: 'TE',
    Th: 'TH',
    Bo: 'BO',
    Ti: 'TI',
    To: 'TO',
    Ts: 'TS',
    Tn: 'TN',
    Tr: 'TR',
    Tk: 'TK',
    Tw: 'TW',
    Ug: 'UG',
    Uk: 'UK',
    Ur: 'UR',
    Uz: 'UZ',
    Ve: 'VE',
    Vi: 'VI',
    Vo: 'VO',
    Wa: 'WA',
    Cy: 'CY',
    Fy: 'FY',
    Wo: 'WO',
    Xh: 'XH',
    Yi: 'YI',
    Yo: 'YO',
    Za: 'ZA',
    Zu: 'ZU'
} as const;

export type UserResponseDtoDefaultLanguageEnum = typeof UserResponseDtoDefaultLanguageEnum[keyof typeof UserResponseDtoDefaultLanguageEnum];

/**
 * @type UserResponseDtoCustomAffiliatesInner
 * @export
 */
export type UserResponseDtoCustomAffiliatesInner = AffiliateResponseDto | string;

/**
 * 
 * @export
 * @interface UserRolesRequestDto
 */
export interface UserRolesRequestDto {
    /**
     * A enum that describes the role and rights a user has to company.
     * @type {Array<string>}
     * @memberof UserRolesRequestDto
     */
    'roles': Array<UserRolesRequestDtoRolesEnum>;
    /**
     * A unique identifier for user.
     * @type {string}
     * @memberof UserRolesRequestDto
     */
    'user': string;
}

export const UserRolesRequestDtoRolesEnum = {
    SimpleUser: 'SIMPLE_USER',
    FullAccess: 'FULL_ACCESS',
    SuperAdmin: 'SUPER_ADMIN',
    OrderRead: 'ORDER_READ',
    OrderWrite: 'ORDER_WRITE',
    AddonRead: 'ADDON_READ',
    AddonWrite: 'ADDON_WRITE',
    AffiliateRead: 'AFFILIATE_READ',
    AffiliateWrite: 'AFFILIATE_WRITE',
    CompanyRead: 'COMPANY_READ',
    CompanyWrite: 'COMPANY_WRITE',
    TemplateRead: 'TEMPLATE_READ',
    TemplateWrite: 'TEMPLATE_WRITE',
    CouponRead: 'COUPON_READ',
    CouponWrite: 'COUPON_WRITE',
    DomainCategoryRead: 'DOMAIN_CATEGORY_READ',
    DomainCategoryWrite: 'DOMAIN_CATEGORY_WRITE',
    DomainContactRead: 'DOMAIN_CONTACT_READ',
    DomainContactWrite: 'DOMAIN_CONTACT_WRITE',
    DomainNameRead: 'DOMAIN_NAME_READ',
    DomainNameWrite: 'DOMAIN_NAME_WRITE',
    InvoiceContactRead: 'INVOICE_CONTACT_READ',
    InvoiceContactWrite: 'INVOICE_CONTACT_WRITE',
    InvoiceRead: 'INVOICE_READ',
    InvoiceWrite: 'INVOICE_WRITE',
    IpGroupsRead: 'IP_GROUPS_READ',
    IpGroupsWrite: 'IP_GROUPS_WRITE',
    IpsRead: 'IPS_READ',
    IpsWrite: 'IPS_WRITE',
    ItemsRead: 'ITEMS_READ',
    ItemsWrite: 'ITEMS_WRITE',
    OrdersRead: 'ORDERS_READ',
    OrdersWrite: 'ORDERS_WRITE',
    TransactionsRead: 'TRANSACTIONS_READ',
    TransactionsWrite: 'TRANSACTIONS_WRITE',
    PoliciesRead: 'POLICIES_READ',
    PoliciesWrite: 'POLICIES_WRITE',
    ProductCategoriesRead: 'PRODUCT_CATEGORIES_READ',
    ProductCategoriesWrite: 'PRODUCT_CATEGORIES_WRITE',
    ProductsRead: 'PRODUCTS_READ',
    ProductsWrite: 'PRODUCTS_WRITE',
    SettingsRead: 'SETTINGS_READ',
    SettingsWrite: 'SETTINGS_WRITE',
    IntegrationsRead: 'INTEGRATIONS_READ',
    IntegrationsWrite: 'INTEGRATIONS_WRITE',
    TldsRead: 'TLDS_READ',
    TldsWrite: 'TLDS_WRITE',
    UsersRead: 'USERS_READ',
    UsersWrite: 'USERS_WRITE',
    IssuesWrite: 'ISSUES_WRITE',
    IssuesRead: 'ISSUES_READ',
    ActionLogsRead: 'ACTION_LOGS_READ'
} as const;

export type UserRolesRequestDtoRolesEnum = typeof UserRolesRequestDtoRolesEnum[keyof typeof UserRolesRequestDtoRolesEnum];

/**
 * 
 * @export
 * @interface UserRolesResponseDto
 */
export interface UserRolesResponseDto {
    /**
     * A enum that describes the role and rights a user has to company.
     * @type {Array<string>}
     * @memberof UserRolesResponseDto
     */
    'roles': Array<UserRolesResponseDtoRolesEnum>;
    /**
     * 
     * @type {User}
     * @memberof UserRolesResponseDto
     */
    'user': User;
}

export const UserRolesResponseDtoRolesEnum = {
    SimpleUser: 'SIMPLE_USER',
    FullAccess: 'FULL_ACCESS',
    SuperAdmin: 'SUPER_ADMIN',
    OrderRead: 'ORDER_READ',
    OrderWrite: 'ORDER_WRITE',
    AddonRead: 'ADDON_READ',
    AddonWrite: 'ADDON_WRITE',
    AffiliateRead: 'AFFILIATE_READ',
    AffiliateWrite: 'AFFILIATE_WRITE',
    CompanyRead: 'COMPANY_READ',
    CompanyWrite: 'COMPANY_WRITE',
    TemplateRead: 'TEMPLATE_READ',
    TemplateWrite: 'TEMPLATE_WRITE',
    CouponRead: 'COUPON_READ',
    CouponWrite: 'COUPON_WRITE',
    DomainCategoryRead: 'DOMAIN_CATEGORY_READ',
    DomainCategoryWrite: 'DOMAIN_CATEGORY_WRITE',
    DomainContactRead: 'DOMAIN_CONTACT_READ',
    DomainContactWrite: 'DOMAIN_CONTACT_WRITE',
    DomainNameRead: 'DOMAIN_NAME_READ',
    DomainNameWrite: 'DOMAIN_NAME_WRITE',
    InvoiceContactRead: 'INVOICE_CONTACT_READ',
    InvoiceContactWrite: 'INVOICE_CONTACT_WRITE',
    InvoiceRead: 'INVOICE_READ',
    InvoiceWrite: 'INVOICE_WRITE',
    IpGroupsRead: 'IP_GROUPS_READ',
    IpGroupsWrite: 'IP_GROUPS_WRITE',
    IpsRead: 'IPS_READ',
    IpsWrite: 'IPS_WRITE',
    ItemsRead: 'ITEMS_READ',
    ItemsWrite: 'ITEMS_WRITE',
    OrdersRead: 'ORDERS_READ',
    OrdersWrite: 'ORDERS_WRITE',
    TransactionsRead: 'TRANSACTIONS_READ',
    TransactionsWrite: 'TRANSACTIONS_WRITE',
    PoliciesRead: 'POLICIES_READ',
    PoliciesWrite: 'POLICIES_WRITE',
    ProductCategoriesRead: 'PRODUCT_CATEGORIES_READ',
    ProductCategoriesWrite: 'PRODUCT_CATEGORIES_WRITE',
    ProductsRead: 'PRODUCTS_READ',
    ProductsWrite: 'PRODUCTS_WRITE',
    SettingsRead: 'SETTINGS_READ',
    SettingsWrite: 'SETTINGS_WRITE',
    IntegrationsRead: 'INTEGRATIONS_READ',
    IntegrationsWrite: 'INTEGRATIONS_WRITE',
    TldsRead: 'TLDS_READ',
    TldsWrite: 'TLDS_WRITE',
    UsersRead: 'USERS_READ',
    UsersWrite: 'USERS_WRITE',
    IssuesWrite: 'ISSUES_WRITE',
    IssuesRead: 'ISSUES_READ',
    ActionLogsRead: 'ACTION_LOGS_READ'
} as const;

export type UserRolesResponseDtoRolesEnum = typeof UserRolesResponseDtoRolesEnum[keyof typeof UserRolesResponseDtoRolesEnum];

/**
 * @type UserSInvoiceContact
 * The default invoice contact used by the user, containing the user\'s personal information such as name, surname, and other relevant details.
 * @export
 */
export type UserSInvoiceContact = InvoiceContactResponseDto | string;

/**
 * @type Value
 * Value of the field. String/Number, or FieldOptionDto/FieldOptionDto[] depending on type.
 * @export
 */
export type Value = FieldOptionDto | any | number | string;

/**
 * 
 * @export
 * @interface XXXMemberDataDto
 */
export interface XXXMemberDataDto {
    /**
     * Used to associate a member with a domain on registration.
     * @type {string}
     * @memberof XXXMemberDataDto
     */
    'memberId': string;
    /**
     * Used to associate a member with a domain on registration.
     * @type {string}
     * @memberof XXXMemberDataDto
     */
    'memberPassword'?: string;
    /**
     * Set to `true` if the domain is intended as a Non-Resolving domain. If not set, the .xxx registry will send a Membership email to the registrant contact’s email address if the email address is not already associated with a Member.
     * @type {boolean}
     * @memberof XXXMemberDataDto
     */
    'nonResolvin': boolean;
}

/**
 * ActivateItemsApi - axios parameter creator
 * @export
 */
export const ActivateItemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateItemsControllerActivateItem: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events/order/status/in-progress/activate-items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivateItemsApi - functional programming interface
 * @export
 */
export const ActivateItemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActivateItemsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateItemsControllerActivateItem(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateItemsControllerActivateItem(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActivateItemsApi.activateItemsControllerActivateItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ActivateItemsApi - factory interface
 * @export
 */
export const ActivateItemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActivateItemsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateItemsControllerActivateItem(options?: any): AxiosPromise<void> {
            return localVarFp.activateItemsControllerActivateItem(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActivateItemsApi - object-oriented interface
 * @export
 * @class ActivateItemsApi
 * @extends {BaseAPI}
 */
export class ActivateItemsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivateItemsApi
     */
    public activateItemsControllerActivateItem(options?: RawAxiosRequestConfig) {
        return ActivateItemsApiFp(this.configuration).activateItemsControllerActivateItem(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AddonsApi - axios parameter creator
 * @export
 */
export const AddonsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new addon. Returns an AddonDto.
         * @summary Create an addon
         * @param {string} companyId A unique identifier for the company.
         * @param {AddonRequestDto} addonRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAddon: async (companyId: string, addonRequestDto: AddonRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('createAddon', 'companyId', companyId)
            // verify required parameter 'addonRequestDto' is not null or undefined
            assertParamExists('createAddon', 'addonRequestDto', addonRequestDto)
            const localVarPath = `/addons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addonRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a certain addon. Returns null.
         * @summary Delete an addon
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id addon id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAddon: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deleteAddon', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAddon', 'id', id)
            const localVarPath = `/addons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all the addons. Returns an array of AddonDto.
         * @summary Get list of all addons
         * @param {string} companyId A unique identifier for the company.
         * @param {string} [query] searches in title and description
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAddons: async (companyId: string, query?: string, currentPage?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('findAddons', 'companyId', companyId)
            const localVarPath = `/addons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a certain addon. Returns an AddonResponseDto.
         * @summary Get an addon
         * @param {string} id ID
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddon: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAddon', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getAddon', 'companyId', companyId)
            const localVarPath = `/addons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a certain addon. Returns an AddonResponseDto.
         * @summary Update an addon
         * @param {string} id addon id
         * @param {string} companyId A unique identifier for the company.
         * @param {AddonRequestDto} addonRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAddon: async (id: string, companyId: string, addonRequestDto: AddonRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAddon', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateAddon', 'companyId', companyId)
            // verify required parameter 'addonRequestDto' is not null or undefined
            assertParamExists('updateAddon', 'addonRequestDto', addonRequestDto)
            const localVarPath = `/addons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addonRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddonsApi - functional programming interface
 * @export
 */
export const AddonsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddonsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new addon. Returns an AddonDto.
         * @summary Create an addon
         * @param {string} companyId A unique identifier for the company.
         * @param {AddonRequestDto} addonRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAddon(companyId: string, addonRequestDto: AddonRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAddon201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAddon(companyId, addonRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddonsApi.createAddon']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a certain addon. Returns null.
         * @summary Delete an addon
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id addon id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAddon(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAddon(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddonsApi.deleteAddon']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all the addons. Returns an array of AddonDto.
         * @summary Get list of all addons
         * @param {string} companyId A unique identifier for the company.
         * @param {string} [query] searches in title and description
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAddons(companyId: string, query?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindAddons200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAddons(companyId, query, currentPage, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddonsApi.findAddons']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a certain addon. Returns an AddonResponseDto.
         * @summary Get an addon
         * @param {string} id ID
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddon(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAddon201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddon(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddonsApi.getAddon']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a certain addon. Returns an AddonResponseDto.
         * @summary Update an addon
         * @param {string} id addon id
         * @param {string} companyId A unique identifier for the company.
         * @param {AddonRequestDto} addonRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAddon(id: string, companyId: string, addonRequestDto: AddonRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAddon201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAddon(id, companyId, addonRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddonsApi.updateAddon']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AddonsApi - factory interface
 * @export
 */
export const AddonsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddonsApiFp(configuration)
    return {
        /**
         * Creates a new addon. Returns an AddonDto.
         * @summary Create an addon
         * @param {string} companyId A unique identifier for the company.
         * @param {AddonRequestDto} addonRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAddon(companyId: string, addonRequestDto: AddonRequestDto, options?: any): AxiosPromise<CreateAddon201Response> {
            return localVarFp.createAddon(companyId, addonRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a certain addon. Returns null.
         * @summary Delete an addon
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id addon id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAddon(companyId: string, id: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.deleteAddon(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all the addons. Returns an array of AddonDto.
         * @summary Get list of all addons
         * @param {string} companyId A unique identifier for the company.
         * @param {string} [query] searches in title and description
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAddons(companyId: string, query?: string, currentPage?: number, perPage?: number, options?: any): AxiosPromise<FindAddons200Response> {
            return localVarFp.findAddons(companyId, query, currentPage, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a certain addon. Returns an AddonResponseDto.
         * @summary Get an addon
         * @param {string} id ID
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddon(id: string, companyId: string, options?: any): AxiosPromise<CreateAddon201Response> {
            return localVarFp.getAddon(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a certain addon. Returns an AddonResponseDto.
         * @summary Update an addon
         * @param {string} id addon id
         * @param {string} companyId A unique identifier for the company.
         * @param {AddonRequestDto} addonRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAddon(id: string, companyId: string, addonRequestDto: AddonRequestDto, options?: any): AxiosPromise<CreateAddon201Response> {
            return localVarFp.updateAddon(id, companyId, addonRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddonsApi - object-oriented interface
 * @export
 * @class AddonsApi
 * @extends {BaseAPI}
 */
export class AddonsApi extends BaseAPI {
    /**
     * Creates a new addon. Returns an AddonDto.
     * @summary Create an addon
     * @param {string} companyId A unique identifier for the company.
     * @param {AddonRequestDto} addonRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddonsApi
     */
    public createAddon(companyId: string, addonRequestDto: AddonRequestDto, options?: RawAxiosRequestConfig) {
        return AddonsApiFp(this.configuration).createAddon(companyId, addonRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a certain addon. Returns null.
     * @summary Delete an addon
     * @param {string} companyId A unique identifier for the company.
     * @param {string} id addon id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddonsApi
     */
    public deleteAddon(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return AddonsApiFp(this.configuration).deleteAddon(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all the addons. Returns an array of AddonDto.
     * @summary Get list of all addons
     * @param {string} companyId A unique identifier for the company.
     * @param {string} [query] searches in title and description
     * @param {number} [currentPage] current page
     * @param {number} [perPage] per Page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddonsApi
     */
    public findAddons(companyId: string, query?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return AddonsApiFp(this.configuration).findAddons(companyId, query, currentPage, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a certain addon. Returns an AddonResponseDto.
     * @summary Get an addon
     * @param {string} id ID
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddonsApi
     */
    public getAddon(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return AddonsApiFp(this.configuration).getAddon(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a certain addon. Returns an AddonResponseDto.
     * @summary Update an addon
     * @param {string} id addon id
     * @param {string} companyId A unique identifier for the company.
     * @param {AddonRequestDto} addonRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddonsApi
     */
    public updateAddon(id: string, companyId: string, addonRequestDto: AddonRequestDto, options?: RawAxiosRequestConfig) {
        return AddonsApiFp(this.configuration).updateAddon(id, companyId, addonRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AffiliatesApi - axios parameter creator
 * @export
 */
export const AffiliatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new affiliate. Return a AffiliateResponseDto.
         * @summary Create a new affiliate
         * @param {string} companyId A unique identifier for the company.
         * @param {AffiliateRequestDto} affiliateRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAffiliate: async (companyId: string, affiliateRequestDto: AffiliateRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('createAffiliate', 'companyId', companyId)
            // verify required parameter 'affiliateRequestDto' is not null or undefined
            assertParamExists('createAffiliate', 'affiliateRequestDto', affiliateRequestDto)
            const localVarPath = `/affiliates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(affiliateRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a certain affiliate. Returns a boolean indicating success.
         * @summary Delete an affiliate
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id Affiliate ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAffiliate: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deleteAffiliate', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAffiliate', 'id', id)
            const localVarPath = `/affiliates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all affiliates. Returns an array of AffiliateDto.
         * @summary Get list of all affiliates
         * @param {string} companyId A unique identifier for the company.
         * @param {string} [productId] product id
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAffiliate: async (companyId: string, productId?: string, currentPage?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('findAffiliate', 'companyId', companyId)
            const localVarPath = `/affiliates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a certain affiliate. Returns a AffiliateResponseDto.
         * @summary Get an affiliate
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAffiliate: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getAffiliate', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAffiliate', 'id', id)
            const localVarPath = `/affiliates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a certain affiliate. Returns a AffiliateResponseDto.
         * @summary Update an affiliate
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id Affiliate ID
         * @param {AffiliateRequestDto} affiliateRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAffiliate: async (companyId: string, id: string, affiliateRequestDto: AffiliateRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateAffiliate', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAffiliate', 'id', id)
            // verify required parameter 'affiliateRequestDto' is not null or undefined
            assertParamExists('updateAffiliate', 'affiliateRequestDto', affiliateRequestDto)
            const localVarPath = `/affiliates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(affiliateRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AffiliatesApi - functional programming interface
 * @export
 */
export const AffiliatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AffiliatesApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new affiliate. Return a AffiliateResponseDto.
         * @summary Create a new affiliate
         * @param {string} companyId A unique identifier for the company.
         * @param {AffiliateRequestDto} affiliateRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAffiliate(companyId: string, affiliateRequestDto: AffiliateRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAffiliate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAffiliate(companyId, affiliateRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AffiliatesApi.createAffiliate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a certain affiliate. Returns a boolean indicating success.
         * @summary Delete an affiliate
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id Affiliate ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAffiliate(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAffiliate(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AffiliatesApi.deleteAffiliate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all affiliates. Returns an array of AffiliateDto.
         * @summary Get list of all affiliates
         * @param {string} companyId A unique identifier for the company.
         * @param {string} [productId] product id
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAffiliate(companyId: string, productId?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindAffiliate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAffiliate(companyId, productId, currentPage, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AffiliatesApi.findAffiliate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a certain affiliate. Returns a AffiliateResponseDto.
         * @summary Get an affiliate
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAffiliate(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAffiliate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAffiliate(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AffiliatesApi.getAffiliate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a certain affiliate. Returns a AffiliateResponseDto.
         * @summary Update an affiliate
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id Affiliate ID
         * @param {AffiliateRequestDto} affiliateRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAffiliate(companyId: string, id: string, affiliateRequestDto: AffiliateRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAffiliate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAffiliate(companyId, id, affiliateRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AffiliatesApi.updateAffiliate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AffiliatesApi - factory interface
 * @export
 */
export const AffiliatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AffiliatesApiFp(configuration)
    return {
        /**
         * Creates a new affiliate. Return a AffiliateResponseDto.
         * @summary Create a new affiliate
         * @param {string} companyId A unique identifier for the company.
         * @param {AffiliateRequestDto} affiliateRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAffiliate(companyId: string, affiliateRequestDto: AffiliateRequestDto, options?: any): AxiosPromise<CreateAffiliate201Response> {
            return localVarFp.createAffiliate(companyId, affiliateRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a certain affiliate. Returns a boolean indicating success.
         * @summary Delete an affiliate
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id Affiliate ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAffiliate(companyId: string, id: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.deleteAffiliate(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all affiliates. Returns an array of AffiliateDto.
         * @summary Get list of all affiliates
         * @param {string} companyId A unique identifier for the company.
         * @param {string} [productId] product id
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAffiliate(companyId: string, productId?: string, currentPage?: number, perPage?: number, options?: any): AxiosPromise<FindAffiliate200Response> {
            return localVarFp.findAffiliate(companyId, productId, currentPage, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a certain affiliate. Returns a AffiliateResponseDto.
         * @summary Get an affiliate
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAffiliate(companyId: string, id: string, options?: any): AxiosPromise<CreateAffiliate201Response> {
            return localVarFp.getAffiliate(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a certain affiliate. Returns a AffiliateResponseDto.
         * @summary Update an affiliate
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id Affiliate ID
         * @param {AffiliateRequestDto} affiliateRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAffiliate(companyId: string, id: string, affiliateRequestDto: AffiliateRequestDto, options?: any): AxiosPromise<CreateAffiliate201Response> {
            return localVarFp.updateAffiliate(companyId, id, affiliateRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AffiliatesApi - object-oriented interface
 * @export
 * @class AffiliatesApi
 * @extends {BaseAPI}
 */
export class AffiliatesApi extends BaseAPI {
    /**
     * Creates a new affiliate. Return a AffiliateResponseDto.
     * @summary Create a new affiliate
     * @param {string} companyId A unique identifier for the company.
     * @param {AffiliateRequestDto} affiliateRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AffiliatesApi
     */
    public createAffiliate(companyId: string, affiliateRequestDto: AffiliateRequestDto, options?: RawAxiosRequestConfig) {
        return AffiliatesApiFp(this.configuration).createAffiliate(companyId, affiliateRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a certain affiliate. Returns a boolean indicating success.
     * @summary Delete an affiliate
     * @param {string} companyId A unique identifier for the company.
     * @param {string} id Affiliate ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AffiliatesApi
     */
    public deleteAffiliate(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return AffiliatesApiFp(this.configuration).deleteAffiliate(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all affiliates. Returns an array of AffiliateDto.
     * @summary Get list of all affiliates
     * @param {string} companyId A unique identifier for the company.
     * @param {string} [productId] product id
     * @param {number} [currentPage] current page
     * @param {number} [perPage] per Page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AffiliatesApi
     */
    public findAffiliate(companyId: string, productId?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return AffiliatesApiFp(this.configuration).findAffiliate(companyId, productId, currentPage, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a certain affiliate. Returns a AffiliateResponseDto.
     * @summary Get an affiliate
     * @param {string} companyId A unique identifier for the company.
     * @param {string} id ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AffiliatesApi
     */
    public getAffiliate(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return AffiliatesApiFp(this.configuration).getAffiliate(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a certain affiliate. Returns a AffiliateResponseDto.
     * @summary Update an affiliate
     * @param {string} companyId A unique identifier for the company.
     * @param {string} id Affiliate ID
     * @param {AffiliateRequestDto} affiliateRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AffiliatesApi
     */
    public updateAffiliate(companyId: string, id: string, affiliateRequestDto: AffiliateRequestDto, options?: RawAxiosRequestConfig) {
        return AffiliatesApiFp(this.configuration).updateAffiliate(companyId, id, affiliateRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClientItemsApi - axios parameter creator
 * @export
 */
export const ClientItemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a specific item for a client by its unique ID. Returns the item details if found and belongs to the authenticated user.
         * @summary Get Client Item
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientItem: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getClientItem', 'id', id)
            const localVarPath = `/client/items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a paginated list of items for a client. Identify the company by its unique ID and specify pagination parameters. Returns a paginated response containing item details.
         * @summary Get Paginated Client Items
         * @param {string} companyId A unique identifier for the company.
         * @param {PaginationQueryDto} [pagination] Pagination parameters containing currentPage and perPage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaginatedClientItems: async (companyId: string, pagination?: PaginationQueryDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getPaginatedClientItems', 'companyId', companyId)
            const localVarPath = `/client/items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (pagination !== undefined) {
                for (const [key, value] of Object.entries(pagination)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel a specific item for a client by its unique ID. Validates that the item exists, belongs to the authenticated user, has idle status, and is not a bundled child item. Returns a boolean indicating success.
         * @summary Item Client Cancel
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to cancel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemClientCancel: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemClientCancel', 'id', id)
            const localVarPath = `/client/items/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Postpone a specific item for a client by its unique ID. Validates that the item exists, belongs to the authenticated user, is within 10 days of expiration, and can be postponed. Returns a boolean indicating success.
         * @summary Item Client Postpone
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to postpone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemClientPostpone: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemClientPostpone', 'id', id)
            const localVarPath = `/client/items/{id}/postpone`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retry the action for a specific item that is in error status. Validates that the item exists, belongs to the authenticated user, and has error status. Returns a boolean indicating success.
         * @summary Item Client Retry
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item action to retry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemClientRetry: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemClientRetry', 'id', id)
            const localVarPath = `/client/items/{id}/retry`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a specific item for a client by its unique ID. Validates that the item exists and belongs to the authenticated user. Returns a boolean indicating success.
         * @summary Item Client Update
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to update.
         * @param {UpdateClientRequestDto} updateClientRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemClientUpdate: async (id: string, updateClientRequestDto: UpdateClientRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemClientUpdate', 'id', id)
            // verify required parameter 'updateClientRequestDto' is not null or undefined
            assertParamExists('itemClientUpdate', 'updateClientRequestDto', updateClientRequestDto)
            const localVarPath = `/client/items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateClientRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientItemsApi - functional programming interface
 * @export
 */
export const ClientItemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClientItemsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a specific item for a client by its unique ID. Returns the item details if found and belongs to the authenticated user.
         * @summary Get Client Item
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClientItem(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetClientItem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClientItem(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientItemsApi.getClientItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a paginated list of items for a client. Identify the company by its unique ID and specify pagination parameters. Returns a paginated response containing item details.
         * @summary Get Paginated Client Items
         * @param {string} companyId A unique identifier for the company.
         * @param {PaginationQueryDto} [pagination] Pagination parameters containing currentPage and perPage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaginatedClientItems(companyId: string, pagination?: PaginationQueryDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPaginatedClientItems200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaginatedClientItems(companyId, pagination, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientItemsApi.getPaginatedClientItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel a specific item for a client by its unique ID. Validates that the item exists, belongs to the authenticated user, has idle status, and is not a bundled child item. Returns a boolean indicating success.
         * @summary Item Client Cancel
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to cancel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemClientCancel(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemClientCancel(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientItemsApi.itemClientCancel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Postpone a specific item for a client by its unique ID. Validates that the item exists, belongs to the authenticated user, is within 10 days of expiration, and can be postponed. Returns a boolean indicating success.
         * @summary Item Client Postpone
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to postpone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemClientPostpone(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemClientPostpone(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientItemsApi.itemClientPostpone']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retry the action for a specific item that is in error status. Validates that the item exists, belongs to the authenticated user, and has error status. Returns a boolean indicating success.
         * @summary Item Client Retry
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item action to retry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemClientRetry(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemClientRetry(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientItemsApi.itemClientRetry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a specific item for a client by its unique ID. Validates that the item exists and belongs to the authenticated user. Returns a boolean indicating success.
         * @summary Item Client Update
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to update.
         * @param {UpdateClientRequestDto} updateClientRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemClientUpdate(id: string, updateClientRequestDto: UpdateClientRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemClientUpdate(id, updateClientRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientItemsApi.itemClientUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClientItemsApi - factory interface
 * @export
 */
export const ClientItemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClientItemsApiFp(configuration)
    return {
        /**
         * Retrieve a specific item for a client by its unique ID. Returns the item details if found and belongs to the authenticated user.
         * @summary Get Client Item
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientItem(id: string, options?: any): AxiosPromise<GetClientItem200Response> {
            return localVarFp.getClientItem(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a paginated list of items for a client. Identify the company by its unique ID and specify pagination parameters. Returns a paginated response containing item details.
         * @summary Get Paginated Client Items
         * @param {string} companyId A unique identifier for the company.
         * @param {PaginationQueryDto} [pagination] Pagination parameters containing currentPage and perPage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaginatedClientItems(companyId: string, pagination?: PaginationQueryDto, options?: any): AxiosPromise<GetPaginatedClientItems200Response> {
            return localVarFp.getPaginatedClientItems(companyId, pagination, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel a specific item for a client by its unique ID. Validates that the item exists, belongs to the authenticated user, has idle status, and is not a bundled child item. Returns a boolean indicating success.
         * @summary Item Client Cancel
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to cancel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemClientCancel(id: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.itemClientCancel(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Postpone a specific item for a client by its unique ID. Validates that the item exists, belongs to the authenticated user, is within 10 days of expiration, and can be postponed. Returns a boolean indicating success.
         * @summary Item Client Postpone
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to postpone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemClientPostpone(id: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.itemClientPostpone(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retry the action for a specific item that is in error status. Validates that the item exists, belongs to the authenticated user, and has error status. Returns a boolean indicating success.
         * @summary Item Client Retry
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item action to retry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemClientRetry(id: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.itemClientRetry(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a specific item for a client by its unique ID. Validates that the item exists and belongs to the authenticated user. Returns a boolean indicating success.
         * @summary Item Client Update
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to update.
         * @param {UpdateClientRequestDto} updateClientRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemClientUpdate(id: string, updateClientRequestDto: UpdateClientRequestDto, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.itemClientUpdate(id, updateClientRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClientItemsApi - object-oriented interface
 * @export
 * @class ClientItemsApi
 * @extends {BaseAPI}
 */
export class ClientItemsApi extends BaseAPI {
    /**
     * Retrieve a specific item for a client by its unique ID. Returns the item details if found and belongs to the authenticated user.
     * @summary Get Client Item
     * @param {string} id A unique identifier for the item. Use this parameter to specify which item to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientItemsApi
     */
    public getClientItem(id: string, options?: RawAxiosRequestConfig) {
        return ClientItemsApiFp(this.configuration).getClientItem(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a paginated list of items for a client. Identify the company by its unique ID and specify pagination parameters. Returns a paginated response containing item details.
     * @summary Get Paginated Client Items
     * @param {string} companyId A unique identifier for the company.
     * @param {PaginationQueryDto} [pagination] Pagination parameters containing currentPage and perPage.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientItemsApi
     */
    public getPaginatedClientItems(companyId: string, pagination?: PaginationQueryDto, options?: RawAxiosRequestConfig) {
        return ClientItemsApiFp(this.configuration).getPaginatedClientItems(companyId, pagination, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel a specific item for a client by its unique ID. Validates that the item exists, belongs to the authenticated user, has idle status, and is not a bundled child item. Returns a boolean indicating success.
     * @summary Item Client Cancel
     * @param {string} id A unique identifier for the item. Use this parameter to specify which item to cancel.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientItemsApi
     */
    public itemClientCancel(id: string, options?: RawAxiosRequestConfig) {
        return ClientItemsApiFp(this.configuration).itemClientCancel(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Postpone a specific item for a client by its unique ID. Validates that the item exists, belongs to the authenticated user, is within 10 days of expiration, and can be postponed. Returns a boolean indicating success.
     * @summary Item Client Postpone
     * @param {string} id A unique identifier for the item. Use this parameter to specify which item to postpone.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientItemsApi
     */
    public itemClientPostpone(id: string, options?: RawAxiosRequestConfig) {
        return ClientItemsApiFp(this.configuration).itemClientPostpone(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retry the action for a specific item that is in error status. Validates that the item exists, belongs to the authenticated user, and has error status. Returns a boolean indicating success.
     * @summary Item Client Retry
     * @param {string} id A unique identifier for the item. Use this parameter to specify which item action to retry.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientItemsApi
     */
    public itemClientRetry(id: string, options?: RawAxiosRequestConfig) {
        return ClientItemsApiFp(this.configuration).itemClientRetry(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a specific item for a client by its unique ID. Validates that the item exists and belongs to the authenticated user. Returns a boolean indicating success.
     * @summary Item Client Update
     * @param {string} id A unique identifier for the item. Use this parameter to specify which item to update.
     * @param {UpdateClientRequestDto} updateClientRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientItemsApi
     */
    public itemClientUpdate(id: string, updateClientRequestDto: UpdateClientRequestDto, options?: RawAxiosRequestConfig) {
        return ClientItemsApiFp(this.configuration).itemClientUpdate(id, updateClientRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClientOrdersApi - axios parameter creator
 * @export
 */
export const ClientOrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {OrderRequestDto} orderRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientOrderControllerCreateOrder: async (orderRequestDto: OrderRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderRequestDto' is not null or undefined
            assertParamExists('clientOrderControllerCreateOrder', 'orderRequestDto', orderRequestDto)
            const localVarPath = `/client/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} currentPage 
         * @param {number} perPage 
         * @param {string} status 
         * @param {number} orderNumber 
         * @param {boolean} archived 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientOrderControllerGetClientOrders: async (currentPage: number, perPage: number, status: string, orderNumber: number, archived: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'currentPage' is not null or undefined
            assertParamExists('clientOrderControllerGetClientOrders', 'currentPage', currentPage)
            // verify required parameter 'perPage' is not null or undefined
            assertParamExists('clientOrderControllerGetClientOrders', 'perPage', perPage)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('clientOrderControllerGetClientOrders', 'status', status)
            // verify required parameter 'orderNumber' is not null or undefined
            assertParamExists('clientOrderControllerGetClientOrders', 'orderNumber', orderNumber)
            // verify required parameter 'archived' is not null or undefined
            assertParamExists('clientOrderControllerGetClientOrders', 'archived', archived)
            const localVarPath = `/client/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (orderNumber !== undefined) {
                localVarQueryParameter['orderNumber'] = orderNumber;
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientOrderControllerGetOrder: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('clientOrderControllerGetOrder', 'id', id)
            const localVarPath = `/client/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientOrdersApi - functional programming interface
 * @export
 */
export const ClientOrdersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClientOrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {OrderRequestDto} orderRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientOrderControllerCreateOrder(orderRequestDto: OrderRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientOrderControllerCreateOrder(orderRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientOrdersApi.clientOrderControllerCreateOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} currentPage 
         * @param {number} perPage 
         * @param {string} status 
         * @param {number} orderNumber 
         * @param {boolean} archived 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientOrderControllerGetClientOrders(currentPage: number, perPage: number, status: string, orderNumber: number, archived: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientOrderControllerGetClientOrders(currentPage, perPage, status, orderNumber, archived, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientOrdersApi.clientOrderControllerGetClientOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientOrderControllerGetOrder(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientOrderControllerGetOrder(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientOrdersApi.clientOrderControllerGetOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClientOrdersApi - factory interface
 * @export
 */
export const ClientOrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClientOrdersApiFp(configuration)
    return {
        /**
         * 
         * @param {OrderRequestDto} orderRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientOrderControllerCreateOrder(orderRequestDto: OrderRequestDto, options?: any): AxiosPromise<void> {
            return localVarFp.clientOrderControllerCreateOrder(orderRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} currentPage 
         * @param {number} perPage 
         * @param {string} status 
         * @param {number} orderNumber 
         * @param {boolean} archived 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientOrderControllerGetClientOrders(currentPage: number, perPage: number, status: string, orderNumber: number, archived: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.clientOrderControllerGetClientOrders(currentPage, perPage, status, orderNumber, archived, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientOrderControllerGetOrder(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.clientOrderControllerGetOrder(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClientOrdersApi - object-oriented interface
 * @export
 * @class ClientOrdersApi
 * @extends {BaseAPI}
 */
export class ClientOrdersApi extends BaseAPI {
    /**
     * 
     * @param {OrderRequestDto} orderRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientOrdersApi
     */
    public clientOrderControllerCreateOrder(orderRequestDto: OrderRequestDto, options?: RawAxiosRequestConfig) {
        return ClientOrdersApiFp(this.configuration).clientOrderControllerCreateOrder(orderRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} currentPage 
     * @param {number} perPage 
     * @param {string} status 
     * @param {number} orderNumber 
     * @param {boolean} archived 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientOrdersApi
     */
    public clientOrderControllerGetClientOrders(currentPage: number, perPage: number, status: string, orderNumber: number, archived: boolean, options?: RawAxiosRequestConfig) {
        return ClientOrdersApiFp(this.configuration).clientOrderControllerGetClientOrders(currentPage, perPage, status, orderNumber, archived, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientOrdersApi
     */
    public clientOrderControllerGetOrder(id: string, options?: RawAxiosRequestConfig) {
        return ClientOrdersApiFp(this.configuration).clientOrderControllerGetOrder(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClientUsersApi - axios parameter creator
 * @export
 */
export const ClientUsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds an additional notification email for the authenticated client user and returns a boolean indicating success.
         * @summary Add Client Additional Notification Email
         * @param {string} newEmail The new email to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addClientAdditionalNotificationEmail: async (newEmail: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newEmail' is not null or undefined
            assertParamExists('addClientAdditionalNotificationEmail', 'newEmail', newEmail)
            const localVarPath = `/client/users/additional-notification-emails`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (newEmail !== undefined) {
                localVarQueryParameter['newEmail'] = newEmail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} companyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientUserControllerDeleteUser: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('clientUserControllerDeleteUser', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('clientUserControllerDeleteUser', 'companyId', companyId)
            const localVarPath = `/client/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the additional notification emails for the authenticated client user.
         * @summary Get Client Additional Notification Emails
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientAdditionalNotificationEmail: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/client/users/additional-notification-emails`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the authenticated client user\'s details.
         * @summary Get Client User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/client/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the balance for the authenticated client user.
         * @summary Get Client User Balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientUserBalance: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/client/users/get-balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the transactions for the authenticated client user.
         * @summary Get Client User Transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientUserTransactions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/client/users/get-user-transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes an additional notification email for the authenticated client user and returns a boolean indicating success.
         * @summary Remove Client Additional Notification Email
         * @param {string} emailToRemove The email to remove.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeClientAdditionalNotificationEmail: async (emailToRemove: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'emailToRemove' is not null or undefined
            assertParamExists('removeClientAdditionalNotificationEmail', 'emailToRemove', emailToRemove)
            const localVarPath = `/client/users/remove-additional-notification-email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (emailToRemove !== undefined) {
                localVarQueryParameter['emailToRemove'] = emailToRemove;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the balance for the authenticated client user and returns a boolean indicating success.
         * @summary Update Client User Balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClientUserBalance: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/client/users/update-balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the default language for the authenticated client user and returns a boolean indicating success.
         * @summary Update Client User Default Language
         * @param {UpdateClientUserDefaultLanguageLanguageEnum} language The language to set as default.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClientUserDefaultLanguage: async (language: UpdateClientUserDefaultLanguageLanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'language' is not null or undefined
            assertParamExists('updateClientUserDefaultLanguage', 'language', language)
            const localVarPath = `/client/users/languages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the invoice contact for the authenticated client user and returns a boolean indicating success.
         * @summary Update Client User Invoice Contact
         * @param {string} invoiceContactId The ID of the invoice contact to set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClientUserInvoiceContact: async (invoiceContactId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceContactId' is not null or undefined
            assertParamExists('updateClientUserInvoiceContact', 'invoiceContactId', invoiceContactId)
            const localVarPath = `/client/users/invoice-contact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (invoiceContactId !== undefined) {
                localVarQueryParameter['invoiceContactId'] = invoiceContactId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the invoice interval for the authenticated client user and returns a boolean indicating success.
         * @summary Update Client User Invoice Interval
         * @param {UpdateClientUserInvoiceIntervalInvoiceIntervalEnum} invoiceInterval The invoice interval to set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClientUserInvoiceInterval: async (invoiceInterval: UpdateClientUserInvoiceIntervalInvoiceIntervalEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'invoiceInterval' is not null or undefined
            assertParamExists('updateClientUserInvoiceInterval', 'invoiceInterval', invoiceInterval)
            const localVarPath = `/client/users/invoice-interval`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (invoiceInterval !== undefined) {
                localVarQueryParameter['invoiceInterval'] = invoiceInterval;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientUsersApi - functional programming interface
 * @export
 */
export const ClientUsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClientUsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds an additional notification email for the authenticated client user and returns a boolean indicating success.
         * @summary Add Client Additional Notification Email
         * @param {string} newEmail The new email to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addClientAdditionalNotificationEmail(newEmail: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addClientAdditionalNotificationEmail(newEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientUsersApi.addClientAdditionalNotificationEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} companyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientUserControllerDeleteUser(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clientUserControllerDeleteUser(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientUsersApi.clientUserControllerDeleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the additional notification emails for the authenticated client user.
         * @summary Get Client Additional Notification Emails
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClientAdditionalNotificationEmail(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserAdditionalNotificationEmails200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClientAdditionalNotificationEmail(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientUsersApi.getClientAdditionalNotificationEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the authenticated client user\'s details.
         * @summary Get Client User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClientUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClientUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientUsersApi.getClientUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the balance for the authenticated client user.
         * @summary Get Client User Balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClientUserBalance(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserBalance200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClientUserBalance(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientUsersApi.getClientUserBalance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the transactions for the authenticated client user.
         * @summary Get Client User Transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClientUserTransactions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserTransactions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClientUserTransactions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientUsersApi.getClientUserTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes an additional notification email for the authenticated client user and returns a boolean indicating success.
         * @summary Remove Client Additional Notification Email
         * @param {string} emailToRemove The email to remove.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeClientAdditionalNotificationEmail(emailToRemove: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeClientAdditionalNotificationEmail(emailToRemove, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientUsersApi.removeClientAdditionalNotificationEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the balance for the authenticated client user and returns a boolean indicating success.
         * @summary Update Client User Balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateClientUserBalance(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateClientUserBalance(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientUsersApi.updateClientUserBalance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the default language for the authenticated client user and returns a boolean indicating success.
         * @summary Update Client User Default Language
         * @param {UpdateClientUserDefaultLanguageLanguageEnum} language The language to set as default.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateClientUserDefaultLanguage(language: UpdateClientUserDefaultLanguageLanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateClientUserDefaultLanguage(language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientUsersApi.updateClientUserDefaultLanguage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the invoice contact for the authenticated client user and returns a boolean indicating success.
         * @summary Update Client User Invoice Contact
         * @param {string} invoiceContactId The ID of the invoice contact to set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateClientUserInvoiceContact(invoiceContactId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateClientUserInvoiceContact(invoiceContactId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientUsersApi.updateClientUserInvoiceContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the invoice interval for the authenticated client user and returns a boolean indicating success.
         * @summary Update Client User Invoice Interval
         * @param {UpdateClientUserInvoiceIntervalInvoiceIntervalEnum} invoiceInterval The invoice interval to set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateClientUserInvoiceInterval(invoiceInterval: UpdateClientUserInvoiceIntervalInvoiceIntervalEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateClientUserInvoiceInterval(invoiceInterval, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClientUsersApi.updateClientUserInvoiceInterval']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClientUsersApi - factory interface
 * @export
 */
export const ClientUsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClientUsersApiFp(configuration)
    return {
        /**
         * Adds an additional notification email for the authenticated client user and returns a boolean indicating success.
         * @summary Add Client Additional Notification Email
         * @param {string} newEmail The new email to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addClientAdditionalNotificationEmail(newEmail: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.addClientAdditionalNotificationEmail(newEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} companyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientUserControllerDeleteUser(id: string, companyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.clientUserControllerDeleteUser(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the additional notification emails for the authenticated client user.
         * @summary Get Client Additional Notification Emails
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientAdditionalNotificationEmail(options?: any): AxiosPromise<GetUserAdditionalNotificationEmails200Response> {
            return localVarFp.getClientAdditionalNotificationEmail(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the authenticated client user\'s details.
         * @summary Get Client User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientUser(options?: any): AxiosPromise<GetUser200Response> {
            return localVarFp.getClientUser(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the balance for the authenticated client user.
         * @summary Get Client User Balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientUserBalance(options?: any): AxiosPromise<GetUserBalance200Response> {
            return localVarFp.getClientUserBalance(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the transactions for the authenticated client user.
         * @summary Get Client User Transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientUserTransactions(options?: any): AxiosPromise<GetUserTransactions200Response> {
            return localVarFp.getClientUserTransactions(options).then((request) => request(axios, basePath));
        },
        /**
         * Removes an additional notification email for the authenticated client user and returns a boolean indicating success.
         * @summary Remove Client Additional Notification Email
         * @param {string} emailToRemove The email to remove.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeClientAdditionalNotificationEmail(emailToRemove: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.removeClientAdditionalNotificationEmail(emailToRemove, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the balance for the authenticated client user and returns a boolean indicating success.
         * @summary Update Client User Balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClientUserBalance(options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.updateClientUserBalance(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the default language for the authenticated client user and returns a boolean indicating success.
         * @summary Update Client User Default Language
         * @param {UpdateClientUserDefaultLanguageLanguageEnum} language The language to set as default.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClientUserDefaultLanguage(language: UpdateClientUserDefaultLanguageLanguageEnum, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.updateClientUserDefaultLanguage(language, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the invoice contact for the authenticated client user and returns a boolean indicating success.
         * @summary Update Client User Invoice Contact
         * @param {string} invoiceContactId The ID of the invoice contact to set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClientUserInvoiceContact(invoiceContactId: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.updateClientUserInvoiceContact(invoiceContactId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the invoice interval for the authenticated client user and returns a boolean indicating success.
         * @summary Update Client User Invoice Interval
         * @param {UpdateClientUserInvoiceIntervalInvoiceIntervalEnum} invoiceInterval The invoice interval to set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClientUserInvoiceInterval(invoiceInterval: UpdateClientUserInvoiceIntervalInvoiceIntervalEnum, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.updateClientUserInvoiceInterval(invoiceInterval, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClientUsersApi - object-oriented interface
 * @export
 * @class ClientUsersApi
 * @extends {BaseAPI}
 */
export class ClientUsersApi extends BaseAPI {
    /**
     * Adds an additional notification email for the authenticated client user and returns a boolean indicating success.
     * @summary Add Client Additional Notification Email
     * @param {string} newEmail The new email to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientUsersApi
     */
    public addClientAdditionalNotificationEmail(newEmail: string, options?: RawAxiosRequestConfig) {
        return ClientUsersApiFp(this.configuration).addClientAdditionalNotificationEmail(newEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} companyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientUsersApi
     */
    public clientUserControllerDeleteUser(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ClientUsersApiFp(this.configuration).clientUserControllerDeleteUser(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the additional notification emails for the authenticated client user.
     * @summary Get Client Additional Notification Emails
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientUsersApi
     */
    public getClientAdditionalNotificationEmail(options?: RawAxiosRequestConfig) {
        return ClientUsersApiFp(this.configuration).getClientAdditionalNotificationEmail(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the authenticated client user\'s details.
     * @summary Get Client User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientUsersApi
     */
    public getClientUser(options?: RawAxiosRequestConfig) {
        return ClientUsersApiFp(this.configuration).getClientUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the balance for the authenticated client user.
     * @summary Get Client User Balance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientUsersApi
     */
    public getClientUserBalance(options?: RawAxiosRequestConfig) {
        return ClientUsersApiFp(this.configuration).getClientUserBalance(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the transactions for the authenticated client user.
     * @summary Get Client User Transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientUsersApi
     */
    public getClientUserTransactions(options?: RawAxiosRequestConfig) {
        return ClientUsersApiFp(this.configuration).getClientUserTransactions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes an additional notification email for the authenticated client user and returns a boolean indicating success.
     * @summary Remove Client Additional Notification Email
     * @param {string} emailToRemove The email to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientUsersApi
     */
    public removeClientAdditionalNotificationEmail(emailToRemove: string, options?: RawAxiosRequestConfig) {
        return ClientUsersApiFp(this.configuration).removeClientAdditionalNotificationEmail(emailToRemove, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the balance for the authenticated client user and returns a boolean indicating success.
     * @summary Update Client User Balance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientUsersApi
     */
    public updateClientUserBalance(options?: RawAxiosRequestConfig) {
        return ClientUsersApiFp(this.configuration).updateClientUserBalance(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the default language for the authenticated client user and returns a boolean indicating success.
     * @summary Update Client User Default Language
     * @param {UpdateClientUserDefaultLanguageLanguageEnum} language The language to set as default.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientUsersApi
     */
    public updateClientUserDefaultLanguage(language: UpdateClientUserDefaultLanguageLanguageEnum, options?: RawAxiosRequestConfig) {
        return ClientUsersApiFp(this.configuration).updateClientUserDefaultLanguage(language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the invoice contact for the authenticated client user and returns a boolean indicating success.
     * @summary Update Client User Invoice Contact
     * @param {string} invoiceContactId The ID of the invoice contact to set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientUsersApi
     */
    public updateClientUserInvoiceContact(invoiceContactId: string, options?: RawAxiosRequestConfig) {
        return ClientUsersApiFp(this.configuration).updateClientUserInvoiceContact(invoiceContactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the invoice interval for the authenticated client user and returns a boolean indicating success.
     * @summary Update Client User Invoice Interval
     * @param {UpdateClientUserInvoiceIntervalInvoiceIntervalEnum} invoiceInterval The invoice interval to set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientUsersApi
     */
    public updateClientUserInvoiceInterval(invoiceInterval: UpdateClientUserInvoiceIntervalInvoiceIntervalEnum, options?: RawAxiosRequestConfig) {
        return ClientUsersApiFp(this.configuration).updateClientUserInvoiceInterval(invoiceInterval, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const UpdateClientUserDefaultLanguageLanguageEnum = {
    Ab: 'AB',
    Aa: 'AA',
    Af: 'AF',
    Ak: 'AK',
    Sq: 'SQ',
    Am: 'AM',
    Ar: 'AR',
    An: 'AN',
    Hy: 'HY',
    As: 'AS',
    Av: 'AV',
    Ae: 'AE',
    Ay: 'AY',
    Az: 'AZ',
    Bm: 'BM',
    Ba: 'BA',
    Eu: 'EU',
    Be: 'BE',
    Bn: 'BN',
    Bi: 'BI',
    Bs: 'BS',
    Br: 'BR',
    Bg: 'BG',
    My: 'MY',
    Ca: 'CA',
    Km: 'KM',
    Ch: 'CH',
    Ce: 'CE',
    Ny: 'NY',
    Zh: 'ZH',
    Cu: 'CU',
    Cv: 'CV',
    Kw: 'KW',
    Co: 'CO',
    Cr: 'CR',
    Hr: 'HR',
    Cs: 'CS',
    Da: 'DA',
    Dv: 'DV',
    Nl: 'NL',
    Dz: 'DZ',
    En: 'EN',
    Eo: 'EO',
    Et: 'ET',
    Ee: 'EE',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Ff: 'FF',
    Gl: 'GL',
    Lg: 'LG',
    Ka: 'KA',
    De: 'DE',
    El: 'EL',
    Gn: 'GN',
    Gu: 'GU',
    Ht: 'HT',
    Ha: 'HA',
    He: 'HE',
    Hz: 'HZ',
    Hi: 'HI',
    Ho: 'HO',
    Hu: 'HU',
    Is: 'IS',
    Io: 'IO',
    Ig: 'IG',
    Id: 'ID',
    Ia: 'IA',
    Ie: 'IE',
    Iu: 'IU',
    Ik: 'IK',
    Ga: 'GA',
    It: 'IT',
    Ja: 'JA',
    Jv: 'JV',
    Kl: 'KL',
    Kn: 'KN',
    Kr: 'KR',
    Ks: 'KS',
    Kk: 'KK',
    Ki: 'KI',
    Rw: 'RW',
    Ky: 'KY',
    Kv: 'KV',
    Kg: 'KG',
    Ko: 'KO',
    Kj: 'KJ',
    Ku: 'KU',
    Lo: 'LO',
    La: 'LA',
    Lv: 'LV',
    Li: 'LI',
    Ln: 'LN',
    Lt: 'LT',
    Lu: 'LU',
    Lb: 'LB',
    Mk: 'MK',
    Mg: 'MG',
    Ms: 'MS',
    Ml: 'ML',
    Mt: 'MT',
    Gv: 'GV',
    Mi: 'MI',
    Mr: 'MR',
    Mh: 'MH',
    Mn: 'MN',
    Na: 'NA',
    Nv: 'NV',
    Nd: 'ND',
    Nr: 'NR',
    Ng: 'NG',
    Ne: 'NE',
    Se: 'SE',
    No: 'NO',
    Nb: 'NB',
    Nn: 'NN',
    Ii: 'II',
    Oc: 'OC',
    Oj: 'OJ',
    Or: 'OR',
    Om: 'OM',
    Os: 'OS',
    Pi: 'PI',
    Ps: 'PS',
    Fa: 'FA',
    Pl: 'PL',
    Pt: 'PT',
    Pa: 'PA',
    Qu: 'QU',
    Ro: 'RO',
    Rm: 'RM',
    Rn: 'RN',
    Ru: 'RU',
    Sm: 'SM',
    Sg: 'SG',
    Sa: 'SA',
    Sc: 'SC',
    Gd: 'GD',
    Sr: 'SR',
    Sn: 'SN',
    Ii2: 'II',
    Sd: 'SD',
    Si: 'SI',
    Sk: 'SK',
    Sl: 'SL',
    So: 'SO',
    St: 'ST',
    Es: 'ES',
    Su: 'SU',
    Sw: 'SW',
    Ss: 'SS',
    Sv: 'SV',
    Tl: 'TL',
    Ty: 'TY',
    Tg: 'TG',
    Ta: 'TA',
    Tt: 'TT',
    Te: 'TE',
    Th: 'TH',
    Bo: 'BO',
    Ti: 'TI',
    To: 'TO',
    Ts: 'TS',
    Tn: 'TN',
    Tr: 'TR',
    Tk: 'TK',
    Tw: 'TW',
    Ug: 'UG',
    Uk: 'UK',
    Ur: 'UR',
    Uz: 'UZ',
    Ve: 'VE',
    Vi: 'VI',
    Vo: 'VO',
    Wa: 'WA',
    Cy: 'CY',
    Fy: 'FY',
    Wo: 'WO',
    Xh: 'XH',
    Yi: 'YI',
    Yo: 'YO',
    Za: 'ZA',
    Zu: 'ZU'
} as const;
export type UpdateClientUserDefaultLanguageLanguageEnum = typeof UpdateClientUserDefaultLanguageLanguageEnum[keyof typeof UpdateClientUserDefaultLanguageLanguageEnum];
/**
 * @export
 */
export const UpdateClientUserInvoiceIntervalInvoiceIntervalEnum = {
    Instant: 'instant',
    Weekly: 'weekly',
    Monthly: 'monthly',
    PerRequest: 'per request'
} as const;
export type UpdateClientUserInvoiceIntervalInvoiceIntervalEnum = typeof UpdateClientUserInvoiceIntervalInvoiceIntervalEnum[keyof typeof UpdateClientUserInvoiceIntervalInvoiceIntervalEnum];


/**
 * CompaniesApi - axios parameter creator
 * @export
 */
export const CompaniesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Updates the roles of a user within a specific company.
         * @summary Update user roles in a company
         * @param {string} email The email of the user.
         * @param {string} companyId A unique identifier for the company.
         * @param {CompanyUpdateUserRolesRequest} companyUpdateUserRolesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyUpdateUserRoles: async (email: string, companyId: string, companyUpdateUserRolesRequest: CompanyUpdateUserRolesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('companyUpdateUserRoles', 'email', email)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('companyUpdateUserRoles', 'companyId', companyId)
            // verify required parameter 'companyUpdateUserRolesRequest' is not null or undefined
            assertParamExists('companyUpdateUserRoles', 'companyUpdateUserRolesRequest', companyUpdateUserRolesRequest)
            const localVarPath = `/companies/access/{email}`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(companyUpdateUserRolesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new company and returns the company data.
         * @summary Create Company
         * @param {CompanyRequestDto} companyRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCompany: async (companyRequestDto: CompanyRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyRequestDto' is not null or undefined
            assertParamExists('createCompany', 'companyRequestDto', companyRequestDto)
            const localVarPath = `/companies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(companyRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a company by its ID. Returns an empty response on success.
         * @summary Delete Company
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCompany: async (companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deleteCompany', 'companyId', companyId)
            const localVarPath = `/companies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edits the comment for a specified company. Returns a boolean indicating success.
         * @summary Edit Company Comment
         * @param {string} companyId A unique identifier for the company.
         * @param {EditCompanyCommentRequest} editCompanyCommentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editCompanyComment: async (companyId: string, editCompanyCommentRequest: EditCompanyCommentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('editCompanyComment', 'companyId', companyId)
            // verify required parameter 'editCompanyCommentRequest' is not null or undefined
            assertParamExists('editCompanyComment', 'editCompanyCommentRequest', editCompanyCommentRequest)
            const localVarPath = `/companies/edit-comment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editCompanyCommentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single company by its ID. Returns a single company response.
         * @summary Get Company
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompany: async (companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getCompany', 'companyId', companyId)
            const localVarPath = `/companies/company`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the balance of a specified company.
         * @summary Get Company Balance
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompanyBalance: async (companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getCompanyBalance', 'companyId', companyId)
            const localVarPath = `/companies/get-balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves public information for a single company by its ID.
         * @summary Get Company Public Info
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompanyPublicInfo: async (companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getCompanyPublicInfo', 'companyId', companyId)
            const localVarPath = `/companies/{companyId}/info`
                .replace(`{${"companyId"}}`, encodeURIComponent(String(companyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves public information for a single company by its username/URL.
         * @summary Get Company Public Info By Url
         * @param {string} username The username or URL of the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompanyPublicInfoByUrl: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getCompanyPublicInfoByUrl', 'username', username)
            const localVarPath = `/companies/{username}/public-data`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a paginated list of companies. Returns a paginated response with company data.
         * @summary Get Paginated Companies
         * @param {string} companyId 
         * @param {number} [perPage] per Page 
         * @param {number} [currentPage] current page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaginatedCompanies: async (companyId: string, perPage?: number, currentPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getPaginatedCompanies', 'companyId', companyId)
            const localVarPath = `/companies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Installs an integration for a specified company. Returns a boolean indicating success.
         * @summary Install Company Integration
         * @param {string} companyId A unique identifier for the company.
         * @param {string} integrationId A unique identifier for the integration.
         * @param {InstallCompanyIntegrationRequest} installCompanyIntegrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installCompanyIntegration: async (companyId: string, integrationId: string, installCompanyIntegrationRequest: InstallCompanyIntegrationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('installCompanyIntegration', 'companyId', companyId)
            // verify required parameter 'integrationId' is not null or undefined
            assertParamExists('installCompanyIntegration', 'integrationId', integrationId)
            // verify required parameter 'installCompanyIntegrationRequest' is not null or undefined
            assertParamExists('installCompanyIntegration', 'installCompanyIntegrationRequest', installCompanyIntegrationRequest)
            const localVarPath = `/companies/{integrationId}/integration/install`
                .replace(`{${"integrationId"}}`, encodeURIComponent(String(integrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(installCompanyIntegrationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Locks a company, preventing any modifications. Returns a boolean indicating success.
         * @summary Lock Company
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockCompany: async (companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('lockCompany', 'companyId', companyId)
            const localVarPath = `/companies/lock`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the credit balance for a specified company. Returns a boolean indicating success.
         * @summary Set Company Credit Balance
         * @param {string} companyId A unique identifier for the company.
         * @param {SetCompanyCreditBalanceRequest} setCompanyCreditBalanceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCompanyCreditBalance: async (companyId: string, setCompanyCreditBalanceRequest: SetCompanyCreditBalanceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('setCompanyCreditBalance', 'companyId', companyId)
            // verify required parameter 'setCompanyCreditBalanceRequest' is not null or undefined
            assertParamExists('setCompanyCreditBalance', 'setCompanyCreditBalanceRequest', setCompanyCreditBalanceRequest)
            const localVarPath = `/companies/set-credit-balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setCompanyCreditBalanceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uninstalls an integration from a specified company. Returns a boolean indicating success.
         * @summary Uninstall Company Integration
         * @param {string} companyId A unique identifier for the company.
         * @param {string} integrationId A unique identifier for the integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallCompanyIntegration: async (companyId: string, integrationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('uninstallCompanyIntegration', 'companyId', companyId)
            // verify required parameter 'integrationId' is not null or undefined
            assertParamExists('uninstallCompanyIntegration', 'integrationId', integrationId)
            const localVarPath = `/companies/{integrationId}/integration/uninstall`
                .replace(`{${"integrationId"}}`, encodeURIComponent(String(integrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unlocks a company, allowing modifications. Returns a boolean indicating success.
         * @summary Unlock Company
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockCompany: async (companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('unlockCompany', 'companyId', companyId)
            const localVarPath = `/companies/unlock`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a specified company\'s details. Returns a boolean indicating success.
         * @summary Update Company
         * @param {string} companyId A unique identifier for the company.
         * @param {CompanyUpdateRequestDto} companyUpdateRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCompany: async (companyId: string, companyUpdateRequestDto: CompanyUpdateRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateCompany', 'companyId', companyId)
            // verify required parameter 'companyUpdateRequestDto' is not null or undefined
            assertParamExists('updateCompany', 'companyUpdateRequestDto', companyUpdateRequestDto)
            const localVarPath = `/companies/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(companyUpdateRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the brand details (logo, icon, colors) for a specified company. Returns a boolean indicating success.
         * @summary Update Company Brand
         * @param {string} companyId A unique identifier for the company.
         * @param {UpdateCompanyBrandRequest} updateCompanyBrandRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCompanyBrand: async (companyId: string, updateCompanyBrandRequest: UpdateCompanyBrandRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateCompanyBrand', 'companyId', companyId)
            // verify required parameter 'updateCompanyBrandRequest' is not null or undefined
            assertParamExists('updateCompanyBrand', 'updateCompanyBrandRequest', updateCompanyBrandRequest)
            const localVarPath = `/companies/update-brand`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCompanyBrandRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the default language for a specified company. Returns a boolean indicating success.
         * @summary Update Company Default Language
         * @param {string} companyId A unique identifier for the company.
         * @param {UpdateCompanyDefaultLanguageRequest} updateCompanyDefaultLanguageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCompanyDefaultLanguage: async (companyId: string, updateCompanyDefaultLanguageRequest: UpdateCompanyDefaultLanguageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateCompanyDefaultLanguage', 'companyId', companyId)
            // verify required parameter 'updateCompanyDefaultLanguageRequest' is not null or undefined
            assertParamExists('updateCompanyDefaultLanguage', 'updateCompanyDefaultLanguageRequest', updateCompanyDefaultLanguageRequest)
            const localVarPath = `/companies/set-default-language`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCompanyDefaultLanguageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the username/URL for a specified company. Returns a boolean indicating success.
         * @summary Update Company Username
         * @param {string} companyId A unique identifier for the company.
         * @param {UpdateCompanyUsernameRequest} updateCompanyUsernameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCompanyUsername: async (companyId: string, updateCompanyUsernameRequest: UpdateCompanyUsernameRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateCompanyUsername', 'companyId', companyId)
            // verify required parameter 'updateCompanyUsernameRequest' is not null or undefined
            assertParamExists('updateCompanyUsername', 'updateCompanyUsernameRequest', updateCompanyUsernameRequest)
            const localVarPath = `/companies/set-username`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCompanyUsernameRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the privacy policy URL for a specified company. Returns a boolean indicating success.
         * @summary Update Privacy Policy URL
         * @param {string} companyId A unique identifier for the company.
         * @param {UpdatePrivacyPolicyUrlRequest} updatePrivacyPolicyUrlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePrivacyPolicyUrl: async (companyId: string, updatePrivacyPolicyUrlRequest: UpdatePrivacyPolicyUrlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updatePrivacyPolicyUrl', 'companyId', companyId)
            // verify required parameter 'updatePrivacyPolicyUrlRequest' is not null or undefined
            assertParamExists('updatePrivacyPolicyUrl', 'updatePrivacyPolicyUrlRequest', updatePrivacyPolicyUrlRequest)
            const localVarPath = `/companies/set-privacy-policy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePrivacyPolicyUrlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CompaniesApi - functional programming interface
 * @export
 */
export const CompaniesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CompaniesApiAxiosParamCreator(configuration)
    return {
        /**
         * Updates the roles of a user within a specific company.
         * @summary Update user roles in a company
         * @param {string} email The email of the user.
         * @param {string} companyId A unique identifier for the company.
         * @param {CompanyUpdateUserRolesRequest} companyUpdateUserRolesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async companyUpdateUserRoles(email: string, companyId: string, companyUpdateUserRolesRequest: CompanyUpdateUserRolesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.companyUpdateUserRoles(email, companyId, companyUpdateUserRolesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompaniesApi.companyUpdateUserRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new company and returns the company data.
         * @summary Create Company
         * @param {CompanyRequestDto} companyRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCompany(companyRequestDto: CompanyRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCompany201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCompany(companyRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompaniesApi.createCompany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a company by its ID. Returns an empty response on success.
         * @summary Delete Company
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCompany(companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCompany(companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompaniesApi.deleteCompany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edits the comment for a specified company. Returns a boolean indicating success.
         * @summary Edit Company Comment
         * @param {string} companyId A unique identifier for the company.
         * @param {EditCompanyCommentRequest} editCompanyCommentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editCompanyComment(companyId: string, editCompanyCommentRequest: EditCompanyCommentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editCompanyComment(companyId, editCompanyCommentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompaniesApi.editCompanyComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a single company by its ID. Returns a single company response.
         * @summary Get Company
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCompany(companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCompany201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCompany(companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompaniesApi.getCompany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the balance of a specified company.
         * @summary Get Company Balance
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCompanyBalance(companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCompanyBalance200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCompanyBalance(companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompaniesApi.getCompanyBalance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves public information for a single company by its ID.
         * @summary Get Company Public Info
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCompanyPublicInfo(companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCompanyPublicInfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCompanyPublicInfo(companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompaniesApi.getCompanyPublicInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves public information for a single company by its username/URL.
         * @summary Get Company Public Info By Url
         * @param {string} username The username or URL of the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCompanyPublicInfoByUrl(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCompanyPublicInfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCompanyPublicInfoByUrl(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompaniesApi.getCompanyPublicInfoByUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a paginated list of companies. Returns a paginated response with company data.
         * @summary Get Paginated Companies
         * @param {string} companyId 
         * @param {number} [perPage] per Page 
         * @param {number} [currentPage] current page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaginatedCompanies(companyId: string, perPage?: number, currentPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPaginatedCompanies200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaginatedCompanies(companyId, perPage, currentPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompaniesApi.getPaginatedCompanies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Installs an integration for a specified company. Returns a boolean indicating success.
         * @summary Install Company Integration
         * @param {string} companyId A unique identifier for the company.
         * @param {string} integrationId A unique identifier for the integration.
         * @param {InstallCompanyIntegrationRequest} installCompanyIntegrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async installCompanyIntegration(companyId: string, integrationId: string, installCompanyIntegrationRequest: InstallCompanyIntegrationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.installCompanyIntegration(companyId, integrationId, installCompanyIntegrationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompaniesApi.installCompanyIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Locks a company, preventing any modifications. Returns a boolean indicating success.
         * @summary Lock Company
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lockCompany(companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lockCompany(companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompaniesApi.lockCompany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sets the credit balance for a specified company. Returns a boolean indicating success.
         * @summary Set Company Credit Balance
         * @param {string} companyId A unique identifier for the company.
         * @param {SetCompanyCreditBalanceRequest} setCompanyCreditBalanceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setCompanyCreditBalance(companyId: string, setCompanyCreditBalanceRequest: SetCompanyCreditBalanceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setCompanyCreditBalance(companyId, setCompanyCreditBalanceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompaniesApi.setCompanyCreditBalance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Uninstalls an integration from a specified company. Returns a boolean indicating success.
         * @summary Uninstall Company Integration
         * @param {string} companyId A unique identifier for the company.
         * @param {string} integrationId A unique identifier for the integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uninstallCompanyIntegration(companyId: string, integrationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uninstallCompanyIntegration(companyId, integrationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompaniesApi.uninstallCompanyIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unlocks a company, allowing modifications. Returns a boolean indicating success.
         * @summary Unlock Company
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlockCompany(companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlockCompany(companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompaniesApi.unlockCompany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a specified company\'s details. Returns a boolean indicating success.
         * @summary Update Company
         * @param {string} companyId A unique identifier for the company.
         * @param {CompanyUpdateRequestDto} companyUpdateRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCompany(companyId: string, companyUpdateRequestDto: CompanyUpdateRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCompany(companyId, companyUpdateRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompaniesApi.updateCompany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the brand details (logo, icon, colors) for a specified company. Returns a boolean indicating success.
         * @summary Update Company Brand
         * @param {string} companyId A unique identifier for the company.
         * @param {UpdateCompanyBrandRequest} updateCompanyBrandRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCompanyBrand(companyId: string, updateCompanyBrandRequest: UpdateCompanyBrandRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCompanyBrand(companyId, updateCompanyBrandRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompaniesApi.updateCompanyBrand']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the default language for a specified company. Returns a boolean indicating success.
         * @summary Update Company Default Language
         * @param {string} companyId A unique identifier for the company.
         * @param {UpdateCompanyDefaultLanguageRequest} updateCompanyDefaultLanguageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCompanyDefaultLanguage(companyId: string, updateCompanyDefaultLanguageRequest: UpdateCompanyDefaultLanguageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCompanyDefaultLanguage(companyId, updateCompanyDefaultLanguageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompaniesApi.updateCompanyDefaultLanguage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the username/URL for a specified company. Returns a boolean indicating success.
         * @summary Update Company Username
         * @param {string} companyId A unique identifier for the company.
         * @param {UpdateCompanyUsernameRequest} updateCompanyUsernameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCompanyUsername(companyId: string, updateCompanyUsernameRequest: UpdateCompanyUsernameRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCompanyUsername(companyId, updateCompanyUsernameRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompaniesApi.updateCompanyUsername']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the privacy policy URL for a specified company. Returns a boolean indicating success.
         * @summary Update Privacy Policy URL
         * @param {string} companyId A unique identifier for the company.
         * @param {UpdatePrivacyPolicyUrlRequest} updatePrivacyPolicyUrlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePrivacyPolicyUrl(companyId: string, updatePrivacyPolicyUrlRequest: UpdatePrivacyPolicyUrlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePrivacyPolicyUrl(companyId, updatePrivacyPolicyUrlRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompaniesApi.updatePrivacyPolicyUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CompaniesApi - factory interface
 * @export
 */
export const CompaniesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CompaniesApiFp(configuration)
    return {
        /**
         * Updates the roles of a user within a specific company.
         * @summary Update user roles in a company
         * @param {string} email The email of the user.
         * @param {string} companyId A unique identifier for the company.
         * @param {CompanyUpdateUserRolesRequest} companyUpdateUserRolesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        companyUpdateUserRoles(email: string, companyId: string, companyUpdateUserRolesRequest: CompanyUpdateUserRolesRequest, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.companyUpdateUserRoles(email, companyId, companyUpdateUserRolesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new company and returns the company data.
         * @summary Create Company
         * @param {CompanyRequestDto} companyRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCompany(companyRequestDto: CompanyRequestDto, options?: any): AxiosPromise<CreateCompany201Response> {
            return localVarFp.createCompany(companyRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a company by its ID. Returns an empty response on success.
         * @summary Delete Company
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCompany(companyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCompany(companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Edits the comment for a specified company. Returns a boolean indicating success.
         * @summary Edit Company Comment
         * @param {string} companyId A unique identifier for the company.
         * @param {EditCompanyCommentRequest} editCompanyCommentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editCompanyComment(companyId: string, editCompanyCommentRequest: EditCompanyCommentRequest, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.editCompanyComment(companyId, editCompanyCommentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single company by its ID. Returns a single company response.
         * @summary Get Company
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompany(companyId: string, options?: any): AxiosPromise<CreateCompany201Response> {
            return localVarFp.getCompany(companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the balance of a specified company.
         * @summary Get Company Balance
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompanyBalance(companyId: string, options?: any): AxiosPromise<GetCompanyBalance200Response> {
            return localVarFp.getCompanyBalance(companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves public information for a single company by its ID.
         * @summary Get Company Public Info
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompanyPublicInfo(companyId: string, options?: any): AxiosPromise<GetCompanyPublicInfo200Response> {
            return localVarFp.getCompanyPublicInfo(companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves public information for a single company by its username/URL.
         * @summary Get Company Public Info By Url
         * @param {string} username The username or URL of the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompanyPublicInfoByUrl(username: string, options?: any): AxiosPromise<GetCompanyPublicInfo200Response> {
            return localVarFp.getCompanyPublicInfoByUrl(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a paginated list of companies. Returns a paginated response with company data.
         * @summary Get Paginated Companies
         * @param {string} companyId 
         * @param {number} [perPage] per Page 
         * @param {number} [currentPage] current page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaginatedCompanies(companyId: string, perPage?: number, currentPage?: number, options?: any): AxiosPromise<GetPaginatedCompanies200Response> {
            return localVarFp.getPaginatedCompanies(companyId, perPage, currentPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Installs an integration for a specified company. Returns a boolean indicating success.
         * @summary Install Company Integration
         * @param {string} companyId A unique identifier for the company.
         * @param {string} integrationId A unique identifier for the integration.
         * @param {InstallCompanyIntegrationRequest} installCompanyIntegrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installCompanyIntegration(companyId: string, integrationId: string, installCompanyIntegrationRequest: InstallCompanyIntegrationRequest, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.installCompanyIntegration(companyId, integrationId, installCompanyIntegrationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Locks a company, preventing any modifications. Returns a boolean indicating success.
         * @summary Lock Company
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockCompany(companyId: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.lockCompany(companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the credit balance for a specified company. Returns a boolean indicating success.
         * @summary Set Company Credit Balance
         * @param {string} companyId A unique identifier for the company.
         * @param {SetCompanyCreditBalanceRequest} setCompanyCreditBalanceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCompanyCreditBalance(companyId: string, setCompanyCreditBalanceRequest: SetCompanyCreditBalanceRequest, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.setCompanyCreditBalance(companyId, setCompanyCreditBalanceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Uninstalls an integration from a specified company. Returns a boolean indicating success.
         * @summary Uninstall Company Integration
         * @param {string} companyId A unique identifier for the company.
         * @param {string} integrationId A unique identifier for the integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallCompanyIntegration(companyId: string, integrationId: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.uninstallCompanyIntegration(companyId, integrationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Unlocks a company, allowing modifications. Returns a boolean indicating success.
         * @summary Unlock Company
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockCompany(companyId: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.unlockCompany(companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a specified company\'s details. Returns a boolean indicating success.
         * @summary Update Company
         * @param {string} companyId A unique identifier for the company.
         * @param {CompanyUpdateRequestDto} companyUpdateRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCompany(companyId: string, companyUpdateRequestDto: CompanyUpdateRequestDto, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.updateCompany(companyId, companyUpdateRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the brand details (logo, icon, colors) for a specified company. Returns a boolean indicating success.
         * @summary Update Company Brand
         * @param {string} companyId A unique identifier for the company.
         * @param {UpdateCompanyBrandRequest} updateCompanyBrandRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCompanyBrand(companyId: string, updateCompanyBrandRequest: UpdateCompanyBrandRequest, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.updateCompanyBrand(companyId, updateCompanyBrandRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the default language for a specified company. Returns a boolean indicating success.
         * @summary Update Company Default Language
         * @param {string} companyId A unique identifier for the company.
         * @param {UpdateCompanyDefaultLanguageRequest} updateCompanyDefaultLanguageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCompanyDefaultLanguage(companyId: string, updateCompanyDefaultLanguageRequest: UpdateCompanyDefaultLanguageRequest, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.updateCompanyDefaultLanguage(companyId, updateCompanyDefaultLanguageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the username/URL for a specified company. Returns a boolean indicating success.
         * @summary Update Company Username
         * @param {string} companyId A unique identifier for the company.
         * @param {UpdateCompanyUsernameRequest} updateCompanyUsernameRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCompanyUsername(companyId: string, updateCompanyUsernameRequest: UpdateCompanyUsernameRequest, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.updateCompanyUsername(companyId, updateCompanyUsernameRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the privacy policy URL for a specified company. Returns a boolean indicating success.
         * @summary Update Privacy Policy URL
         * @param {string} companyId A unique identifier for the company.
         * @param {UpdatePrivacyPolicyUrlRequest} updatePrivacyPolicyUrlRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePrivacyPolicyUrl(companyId: string, updatePrivacyPolicyUrlRequest: UpdatePrivacyPolicyUrlRequest, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.updatePrivacyPolicyUrl(companyId, updatePrivacyPolicyUrlRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CompaniesApi - object-oriented interface
 * @export
 * @class CompaniesApi
 * @extends {BaseAPI}
 */
export class CompaniesApi extends BaseAPI {
    /**
     * Updates the roles of a user within a specific company.
     * @summary Update user roles in a company
     * @param {string} email The email of the user.
     * @param {string} companyId A unique identifier for the company.
     * @param {CompanyUpdateUserRolesRequest} companyUpdateUserRolesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompaniesApi
     */
    public companyUpdateUserRoles(email: string, companyId: string, companyUpdateUserRolesRequest: CompanyUpdateUserRolesRequest, options?: RawAxiosRequestConfig) {
        return CompaniesApiFp(this.configuration).companyUpdateUserRoles(email, companyId, companyUpdateUserRolesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new company and returns the company data.
     * @summary Create Company
     * @param {CompanyRequestDto} companyRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompaniesApi
     */
    public createCompany(companyRequestDto: CompanyRequestDto, options?: RawAxiosRequestConfig) {
        return CompaniesApiFp(this.configuration).createCompany(companyRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a company by its ID. Returns an empty response on success.
     * @summary Delete Company
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompaniesApi
     */
    public deleteCompany(companyId: string, options?: RawAxiosRequestConfig) {
        return CompaniesApiFp(this.configuration).deleteCompany(companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edits the comment for a specified company. Returns a boolean indicating success.
     * @summary Edit Company Comment
     * @param {string} companyId A unique identifier for the company.
     * @param {EditCompanyCommentRequest} editCompanyCommentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompaniesApi
     */
    public editCompanyComment(companyId: string, editCompanyCommentRequest: EditCompanyCommentRequest, options?: RawAxiosRequestConfig) {
        return CompaniesApiFp(this.configuration).editCompanyComment(companyId, editCompanyCommentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a single company by its ID. Returns a single company response.
     * @summary Get Company
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompaniesApi
     */
    public getCompany(companyId: string, options?: RawAxiosRequestConfig) {
        return CompaniesApiFp(this.configuration).getCompany(companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the balance of a specified company.
     * @summary Get Company Balance
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompaniesApi
     */
    public getCompanyBalance(companyId: string, options?: RawAxiosRequestConfig) {
        return CompaniesApiFp(this.configuration).getCompanyBalance(companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves public information for a single company by its ID.
     * @summary Get Company Public Info
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompaniesApi
     */
    public getCompanyPublicInfo(companyId: string, options?: RawAxiosRequestConfig) {
        return CompaniesApiFp(this.configuration).getCompanyPublicInfo(companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves public information for a single company by its username/URL.
     * @summary Get Company Public Info By Url
     * @param {string} username The username or URL of the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompaniesApi
     */
    public getCompanyPublicInfoByUrl(username: string, options?: RawAxiosRequestConfig) {
        return CompaniesApiFp(this.configuration).getCompanyPublicInfoByUrl(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a paginated list of companies. Returns a paginated response with company data.
     * @summary Get Paginated Companies
     * @param {string} companyId 
     * @param {number} [perPage] per Page 
     * @param {number} [currentPage] current page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompaniesApi
     */
    public getPaginatedCompanies(companyId: string, perPage?: number, currentPage?: number, options?: RawAxiosRequestConfig) {
        return CompaniesApiFp(this.configuration).getPaginatedCompanies(companyId, perPage, currentPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Installs an integration for a specified company. Returns a boolean indicating success.
     * @summary Install Company Integration
     * @param {string} companyId A unique identifier for the company.
     * @param {string} integrationId A unique identifier for the integration.
     * @param {InstallCompanyIntegrationRequest} installCompanyIntegrationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompaniesApi
     */
    public installCompanyIntegration(companyId: string, integrationId: string, installCompanyIntegrationRequest: InstallCompanyIntegrationRequest, options?: RawAxiosRequestConfig) {
        return CompaniesApiFp(this.configuration).installCompanyIntegration(companyId, integrationId, installCompanyIntegrationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Locks a company, preventing any modifications. Returns a boolean indicating success.
     * @summary Lock Company
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompaniesApi
     */
    public lockCompany(companyId: string, options?: RawAxiosRequestConfig) {
        return CompaniesApiFp(this.configuration).lockCompany(companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets the credit balance for a specified company. Returns a boolean indicating success.
     * @summary Set Company Credit Balance
     * @param {string} companyId A unique identifier for the company.
     * @param {SetCompanyCreditBalanceRequest} setCompanyCreditBalanceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompaniesApi
     */
    public setCompanyCreditBalance(companyId: string, setCompanyCreditBalanceRequest: SetCompanyCreditBalanceRequest, options?: RawAxiosRequestConfig) {
        return CompaniesApiFp(this.configuration).setCompanyCreditBalance(companyId, setCompanyCreditBalanceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uninstalls an integration from a specified company. Returns a boolean indicating success.
     * @summary Uninstall Company Integration
     * @param {string} companyId A unique identifier for the company.
     * @param {string} integrationId A unique identifier for the integration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompaniesApi
     */
    public uninstallCompanyIntegration(companyId: string, integrationId: string, options?: RawAxiosRequestConfig) {
        return CompaniesApiFp(this.configuration).uninstallCompanyIntegration(companyId, integrationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unlocks a company, allowing modifications. Returns a boolean indicating success.
     * @summary Unlock Company
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompaniesApi
     */
    public unlockCompany(companyId: string, options?: RawAxiosRequestConfig) {
        return CompaniesApiFp(this.configuration).unlockCompany(companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a specified company\'s details. Returns a boolean indicating success.
     * @summary Update Company
     * @param {string} companyId A unique identifier for the company.
     * @param {CompanyUpdateRequestDto} companyUpdateRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompaniesApi
     */
    public updateCompany(companyId: string, companyUpdateRequestDto: CompanyUpdateRequestDto, options?: RawAxiosRequestConfig) {
        return CompaniesApiFp(this.configuration).updateCompany(companyId, companyUpdateRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the brand details (logo, icon, colors) for a specified company. Returns a boolean indicating success.
     * @summary Update Company Brand
     * @param {string} companyId A unique identifier for the company.
     * @param {UpdateCompanyBrandRequest} updateCompanyBrandRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompaniesApi
     */
    public updateCompanyBrand(companyId: string, updateCompanyBrandRequest: UpdateCompanyBrandRequest, options?: RawAxiosRequestConfig) {
        return CompaniesApiFp(this.configuration).updateCompanyBrand(companyId, updateCompanyBrandRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the default language for a specified company. Returns a boolean indicating success.
     * @summary Update Company Default Language
     * @param {string} companyId A unique identifier for the company.
     * @param {UpdateCompanyDefaultLanguageRequest} updateCompanyDefaultLanguageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompaniesApi
     */
    public updateCompanyDefaultLanguage(companyId: string, updateCompanyDefaultLanguageRequest: UpdateCompanyDefaultLanguageRequest, options?: RawAxiosRequestConfig) {
        return CompaniesApiFp(this.configuration).updateCompanyDefaultLanguage(companyId, updateCompanyDefaultLanguageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the username/URL for a specified company. Returns a boolean indicating success.
     * @summary Update Company Username
     * @param {string} companyId A unique identifier for the company.
     * @param {UpdateCompanyUsernameRequest} updateCompanyUsernameRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompaniesApi
     */
    public updateCompanyUsername(companyId: string, updateCompanyUsernameRequest: UpdateCompanyUsernameRequest, options?: RawAxiosRequestConfig) {
        return CompaniesApiFp(this.configuration).updateCompanyUsername(companyId, updateCompanyUsernameRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the privacy policy URL for a specified company. Returns a boolean indicating success.
     * @summary Update Privacy Policy URL
     * @param {string} companyId A unique identifier for the company.
     * @param {UpdatePrivacyPolicyUrlRequest} updatePrivacyPolicyUrlRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompaniesApi
     */
    public updatePrivacyPolicyUrl(companyId: string, updatePrivacyPolicyUrlRequest: UpdatePrivacyPolicyUrlRequest, options?: RawAxiosRequestConfig) {
        return CompaniesApiFp(this.configuration).updatePrivacyPolicyUrl(companyId, updatePrivacyPolicyUrlRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CompletedTransactionListenerApi - axios parameter creator
 * @export
 */
export const CompletedTransactionListenerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completedTransactionListenerTransactionCompleted: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events/transaction/created/process-transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CompletedTransactionListenerApi - functional programming interface
 * @export
 */
export const CompletedTransactionListenerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CompletedTransactionListenerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completedTransactionListenerTransactionCompleted(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completedTransactionListenerTransactionCompleted(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CompletedTransactionListenerApi.completedTransactionListenerTransactionCompleted']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CompletedTransactionListenerApi - factory interface
 * @export
 */
export const CompletedTransactionListenerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CompletedTransactionListenerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completedTransactionListenerTransactionCompleted(options?: any): AxiosPromise<void> {
            return localVarFp.completedTransactionListenerTransactionCompleted(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CompletedTransactionListenerApi - object-oriented interface
 * @export
 * @class CompletedTransactionListenerApi
 * @extends {BaseAPI}
 */
export class CompletedTransactionListenerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompletedTransactionListenerApi
     */
    public completedTransactionListenerTransactionCompleted(options?: RawAxiosRequestConfig) {
        return CompletedTransactionListenerApiFp(this.configuration).completedTransactionListenerTransactionCompleted(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CouponsApi - axios parameter creator
 * @export
 */
export const CouponsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new coupon for a specific company. Returns created coupon as CouponResponseDto object
         * @summary Create a coupon
         * @param {string} companyId A unique identifier for the company.
         * @param {CouponRequestDto} couponRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCoupon: async (companyId: string, couponRequestDto: CouponRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('createCoupon', 'companyId', companyId)
            // verify required parameter 'couponRequestDto' is not null or undefined
            assertParamExists('createCoupon', 'couponRequestDto', couponRequestDto)
            const localVarPath = `/coupons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(couponRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific coupon associated with a company. Checks if the coupon is in active use before deletion.
         * @summary Delete a coupon
         * @param {string} id The unique identifier of the coupon to delete.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoupon: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCoupon', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deleteCoupon', 'companyId', companyId)
            const localVarPath = `/coupons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of coupons based on various criteria including product IDs, date ranges, and pagination. Returns an array of CouponDto objects
         * @summary Get list of all coupons
         * @param {string} companyId A unique identifier for the company.
         * @param {Array<any>} productIds An array of product IDs to filter coupons by.
         * @param {string} [fromStartDate] Start date to filter coupons created on or after this date.
         * @param {string} [toStartDate] End date to filter coupons created on or before this date.
         * @param {string} [fromEndDate] Start date to filter coupons valid on or after this date.
         * @param {string} [toEndDate] End date to filter coupons valid on or before this date.
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCoupons: async (companyId: string, productIds: Array<any>, fromStartDate?: string, toStartDate?: string, fromEndDate?: string, toEndDate?: string, currentPage?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('findCoupons', 'companyId', companyId)
            // verify required parameter 'productIds' is not null or undefined
            assertParamExists('findCoupons', 'productIds', productIds)
            const localVarPath = `/coupons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (productIds) {
                localVarQueryParameter['productIds'] = productIds;
            }

            if (fromStartDate !== undefined) {
                localVarQueryParameter['fromStartDate'] = (fromStartDate as any instanceof Date) ?
                    (fromStartDate as any).toISOString() :
                    fromStartDate;
            }

            if (toStartDate !== undefined) {
                localVarQueryParameter['toStartDate'] = (toStartDate as any instanceof Date) ?
                    (toStartDate as any).toISOString() :
                    toStartDate;
            }

            if (fromEndDate !== undefined) {
                localVarQueryParameter['fromEndDate'] = (fromEndDate as any instanceof Date) ?
                    (fromEndDate as any).toISOString() :
                    fromEndDate;
            }

            if (toEndDate !== undefined) {
                localVarQueryParameter['toEndDate'] = (toEndDate as any instanceof Date) ?
                    (toEndDate as any).toISOString() :
                    toEndDate;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a coupon\'s details based on its unique ID and company. Returns CouponResponseDto object
         * @summary Get a coupon
         * @param {string} id The unique identifier of the coupon.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoupon: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCoupon', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getCoupon', 'companyId', companyId)
            const localVarPath = `/coupons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the details of an existing coupon associated with a specific company. Returns updated CouponDto object
         * @summary Update a coupon
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id The unique identifier of the coupon to update.
         * @param {CouponRequestDto} couponRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCoupon: async (companyId: string, id: string, couponRequestDto: CouponRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateCoupon', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCoupon', 'id', id)
            // verify required parameter 'couponRequestDto' is not null or undefined
            assertParamExists('updateCoupon', 'couponRequestDto', couponRequestDto)
            const localVarPath = `/coupons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(couponRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CouponsApi - functional programming interface
 * @export
 */
export const CouponsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CouponsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new coupon for a specific company. Returns created coupon as CouponResponseDto object
         * @summary Create a coupon
         * @param {string} companyId A unique identifier for the company.
         * @param {CouponRequestDto} couponRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCoupon(companyId: string, couponRequestDto: CouponRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCoupon201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCoupon(companyId, couponRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CouponsApi.createCoupon']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a specific coupon associated with a company. Checks if the coupon is in active use before deletion.
         * @summary Delete a coupon
         * @param {string} id The unique identifier of the coupon to delete.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCoupon(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCoupon(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CouponsApi.deleteCoupon']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of coupons based on various criteria including product IDs, date ranges, and pagination. Returns an array of CouponDto objects
         * @summary Get list of all coupons
         * @param {string} companyId A unique identifier for the company.
         * @param {Array<any>} productIds An array of product IDs to filter coupons by.
         * @param {string} [fromStartDate] Start date to filter coupons created on or after this date.
         * @param {string} [toStartDate] End date to filter coupons created on or before this date.
         * @param {string} [fromEndDate] Start date to filter coupons valid on or after this date.
         * @param {string} [toEndDate] End date to filter coupons valid on or before this date.
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findCoupons(companyId: string, productIds: Array<any>, fromStartDate?: string, toStartDate?: string, fromEndDate?: string, toEndDate?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindCoupons200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findCoupons(companyId, productIds, fromStartDate, toStartDate, fromEndDate, toEndDate, currentPage, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CouponsApi.findCoupons']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a coupon\'s details based on its unique ID and company. Returns CouponResponseDto object
         * @summary Get a coupon
         * @param {string} id The unique identifier of the coupon.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCoupon(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCoupon201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCoupon(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CouponsApi.getCoupon']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the details of an existing coupon associated with a specific company. Returns updated CouponDto object
         * @summary Update a coupon
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id The unique identifier of the coupon to update.
         * @param {CouponRequestDto} couponRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCoupon(companyId: string, id: string, couponRequestDto: CouponRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCoupon201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCoupon(companyId, id, couponRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CouponsApi.updateCoupon']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CouponsApi - factory interface
 * @export
 */
export const CouponsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CouponsApiFp(configuration)
    return {
        /**
         * Create a new coupon for a specific company. Returns created coupon as CouponResponseDto object
         * @summary Create a coupon
         * @param {string} companyId A unique identifier for the company.
         * @param {CouponRequestDto} couponRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCoupon(companyId: string, couponRequestDto: CouponRequestDto, options?: any): AxiosPromise<CreateCoupon201Response> {
            return localVarFp.createCoupon(companyId, couponRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific coupon associated with a company. Checks if the coupon is in active use before deletion.
         * @summary Delete a coupon
         * @param {string} id The unique identifier of the coupon to delete.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCoupon(id: string, companyId: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.deleteCoupon(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of coupons based on various criteria including product IDs, date ranges, and pagination. Returns an array of CouponDto objects
         * @summary Get list of all coupons
         * @param {string} companyId A unique identifier for the company.
         * @param {Array<any>} productIds An array of product IDs to filter coupons by.
         * @param {string} [fromStartDate] Start date to filter coupons created on or after this date.
         * @param {string} [toStartDate] End date to filter coupons created on or before this date.
         * @param {string} [fromEndDate] Start date to filter coupons valid on or after this date.
         * @param {string} [toEndDate] End date to filter coupons valid on or before this date.
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCoupons(companyId: string, productIds: Array<any>, fromStartDate?: string, toStartDate?: string, fromEndDate?: string, toEndDate?: string, currentPage?: number, perPage?: number, options?: any): AxiosPromise<FindCoupons200Response> {
            return localVarFp.findCoupons(companyId, productIds, fromStartDate, toStartDate, fromEndDate, toEndDate, currentPage, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a coupon\'s details based on its unique ID and company. Returns CouponResponseDto object
         * @summary Get a coupon
         * @param {string} id The unique identifier of the coupon.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoupon(id: string, companyId: string, options?: any): AxiosPromise<CreateCoupon201Response> {
            return localVarFp.getCoupon(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the details of an existing coupon associated with a specific company. Returns updated CouponDto object
         * @summary Update a coupon
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id The unique identifier of the coupon to update.
         * @param {CouponRequestDto} couponRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCoupon(companyId: string, id: string, couponRequestDto: CouponRequestDto, options?: any): AxiosPromise<CreateCoupon201Response> {
            return localVarFp.updateCoupon(companyId, id, couponRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CouponsApi - object-oriented interface
 * @export
 * @class CouponsApi
 * @extends {BaseAPI}
 */
export class CouponsApi extends BaseAPI {
    /**
     * Create a new coupon for a specific company. Returns created coupon as CouponResponseDto object
     * @summary Create a coupon
     * @param {string} companyId A unique identifier for the company.
     * @param {CouponRequestDto} couponRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApi
     */
    public createCoupon(companyId: string, couponRequestDto: CouponRequestDto, options?: RawAxiosRequestConfig) {
        return CouponsApiFp(this.configuration).createCoupon(companyId, couponRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific coupon associated with a company. Checks if the coupon is in active use before deletion.
     * @summary Delete a coupon
     * @param {string} id The unique identifier of the coupon to delete.
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApi
     */
    public deleteCoupon(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return CouponsApiFp(this.configuration).deleteCoupon(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of coupons based on various criteria including product IDs, date ranges, and pagination. Returns an array of CouponDto objects
     * @summary Get list of all coupons
     * @param {string} companyId A unique identifier for the company.
     * @param {Array<any>} productIds An array of product IDs to filter coupons by.
     * @param {string} [fromStartDate] Start date to filter coupons created on or after this date.
     * @param {string} [toStartDate] End date to filter coupons created on or before this date.
     * @param {string} [fromEndDate] Start date to filter coupons valid on or after this date.
     * @param {string} [toEndDate] End date to filter coupons valid on or before this date.
     * @param {number} [currentPage] current page
     * @param {number} [perPage] per Page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApi
     */
    public findCoupons(companyId: string, productIds: Array<any>, fromStartDate?: string, toStartDate?: string, fromEndDate?: string, toEndDate?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return CouponsApiFp(this.configuration).findCoupons(companyId, productIds, fromStartDate, toStartDate, fromEndDate, toEndDate, currentPage, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a coupon\'s details based on its unique ID and company. Returns CouponResponseDto object
     * @summary Get a coupon
     * @param {string} id The unique identifier of the coupon.
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApi
     */
    public getCoupon(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return CouponsApiFp(this.configuration).getCoupon(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the details of an existing coupon associated with a specific company. Returns updated CouponDto object
     * @summary Update a coupon
     * @param {string} companyId A unique identifier for the company.
     * @param {string} id The unique identifier of the coupon to update.
     * @param {CouponRequestDto} couponRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponsApi
     */
    public updateCoupon(companyId: string, id: string, couponRequestDto: CouponRequestDto, options?: RawAxiosRequestConfig) {
        return CouponsApiFp(this.configuration).updateCoupon(companyId, id, couponRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DomainCategoriesApi - axios parameter creator
 * @export
 */
export const DomainCategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new domain category. Returns a DomainCategoryDto.
         * @summary Create a domain category
         * @param {string} companyId A unique identifier for the company.
         * @param {DomainCategoryRequestDto} domainCategoryRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomainCategory: async (companyId: string, domainCategoryRequestDto: DomainCategoryRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('createDomainCategory', 'companyId', companyId)
            // verify required parameter 'domainCategoryRequestDto' is not null or undefined
            assertParamExists('createDomainCategory', 'domainCategoryRequestDto', domainCategoryRequestDto)
            const localVarPath = `/domain-categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainCategoryRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a certain domain category. Returns a DomainCategoryDto.
         * @summary Delete a domain category
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id DomainCategory ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomainCategory: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deleteDomainCategory', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDomainCategory', 'id', id)
            const localVarPath = `/domain-categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all domain categories. Returns an array of DomainCategoryResponseDto.
         * @summary Get list of all domain categories
         * @param {string} companyId A unique identifier for the company.
         * @param {string} [description] 
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDomainCategories: async (companyId: string, description?: string, currentPage?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('findDomainCategories', 'companyId', companyId)
            const localVarPath = `/domain-categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a certain domain category. Returns a DomainCategoryResponseDto.
         * @summary Get a domain category
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainCategory: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getDomainCategory', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDomainCategory', 'id', id)
            const localVarPath = `/domain-categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a certain domain category. Returns a DomainCategoryResponseDto.
         * @summary Update a domain category
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id DomainCategory ID
         * @param {DomainCategoryRequestDto} domainCategoryRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainCategory: async (companyId: string, id: string, domainCategoryRequestDto: DomainCategoryRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainCategory', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainCategory', 'id', id)
            // verify required parameter 'domainCategoryRequestDto' is not null or undefined
            assertParamExists('updateDomainCategory', 'domainCategoryRequestDto', domainCategoryRequestDto)
            const localVarPath = `/domain-categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainCategoryRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DomainCategoriesApi - functional programming interface
 * @export
 */
export const DomainCategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DomainCategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new domain category. Returns a DomainCategoryDto.
         * @summary Create a domain category
         * @param {string} companyId A unique identifier for the company.
         * @param {DomainCategoryRequestDto} domainCategoryRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDomainCategory(companyId: string, domainCategoryRequestDto: DomainCategoryRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDomainCategory201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDomainCategory(companyId, domainCategoryRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainCategoriesApi.createDomainCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a certain domain category. Returns a DomainCategoryDto.
         * @summary Delete a domain category
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id DomainCategory ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDomainCategory(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDomainCategory(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainCategoriesApi.deleteDomainCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all domain categories. Returns an array of DomainCategoryResponseDto.
         * @summary Get list of all domain categories
         * @param {string} companyId A unique identifier for the company.
         * @param {string} [description] 
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findDomainCategories(companyId: string, description?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindDomainCategories200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findDomainCategories(companyId, description, currentPage, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainCategoriesApi.findDomainCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a certain domain category. Returns a DomainCategoryResponseDto.
         * @summary Get a domain category
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDomainCategory(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDomainCategory201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDomainCategory(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainCategoriesApi.getDomainCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a certain domain category. Returns a DomainCategoryResponseDto.
         * @summary Update a domain category
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id DomainCategory ID
         * @param {DomainCategoryRequestDto} domainCategoryRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainCategory(companyId: string, id: string, domainCategoryRequestDto: DomainCategoryRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDomainCategory201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainCategory(companyId, id, domainCategoryRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainCategoriesApi.updateDomainCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DomainCategoriesApi - factory interface
 * @export
 */
export const DomainCategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DomainCategoriesApiFp(configuration)
    return {
        /**
         * Creates a new domain category. Returns a DomainCategoryDto.
         * @summary Create a domain category
         * @param {string} companyId A unique identifier for the company.
         * @param {DomainCategoryRequestDto} domainCategoryRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomainCategory(companyId: string, domainCategoryRequestDto: DomainCategoryRequestDto, options?: any): AxiosPromise<CreateDomainCategory201Response> {
            return localVarFp.createDomainCategory(companyId, domainCategoryRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a certain domain category. Returns a DomainCategoryDto.
         * @summary Delete a domain category
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id DomainCategory ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomainCategory(companyId: string, id: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.deleteDomainCategory(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all domain categories. Returns an array of DomainCategoryResponseDto.
         * @summary Get list of all domain categories
         * @param {string} companyId A unique identifier for the company.
         * @param {string} [description] 
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDomainCategories(companyId: string, description?: string, currentPage?: number, perPage?: number, options?: any): AxiosPromise<FindDomainCategories200Response> {
            return localVarFp.findDomainCategories(companyId, description, currentPage, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a certain domain category. Returns a DomainCategoryResponseDto.
         * @summary Get a domain category
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainCategory(companyId: string, id: string, options?: any): AxiosPromise<CreateDomainCategory201Response> {
            return localVarFp.getDomainCategory(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a certain domain category. Returns a DomainCategoryResponseDto.
         * @summary Update a domain category
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id DomainCategory ID
         * @param {DomainCategoryRequestDto} domainCategoryRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainCategory(companyId: string, id: string, domainCategoryRequestDto: DomainCategoryRequestDto, options?: any): AxiosPromise<CreateDomainCategory201Response> {
            return localVarFp.updateDomainCategory(companyId, id, domainCategoryRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DomainCategoriesApi - object-oriented interface
 * @export
 * @class DomainCategoriesApi
 * @extends {BaseAPI}
 */
export class DomainCategoriesApi extends BaseAPI {
    /**
     * Creates a new domain category. Returns a DomainCategoryDto.
     * @summary Create a domain category
     * @param {string} companyId A unique identifier for the company.
     * @param {DomainCategoryRequestDto} domainCategoryRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainCategoriesApi
     */
    public createDomainCategory(companyId: string, domainCategoryRequestDto: DomainCategoryRequestDto, options?: RawAxiosRequestConfig) {
        return DomainCategoriesApiFp(this.configuration).createDomainCategory(companyId, domainCategoryRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a certain domain category. Returns a DomainCategoryDto.
     * @summary Delete a domain category
     * @param {string} companyId A unique identifier for the company.
     * @param {string} id DomainCategory ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainCategoriesApi
     */
    public deleteDomainCategory(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return DomainCategoriesApiFp(this.configuration).deleteDomainCategory(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all domain categories. Returns an array of DomainCategoryResponseDto.
     * @summary Get list of all domain categories
     * @param {string} companyId A unique identifier for the company.
     * @param {string} [description] 
     * @param {number} [currentPage] current page
     * @param {number} [perPage] per Page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainCategoriesApi
     */
    public findDomainCategories(companyId: string, description?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return DomainCategoriesApiFp(this.configuration).findDomainCategories(companyId, description, currentPage, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a certain domain category. Returns a DomainCategoryResponseDto.
     * @summary Get a domain category
     * @param {string} companyId A unique identifier for the company.
     * @param {string} id ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainCategoriesApi
     */
    public getDomainCategory(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return DomainCategoriesApiFp(this.configuration).getDomainCategory(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a certain domain category. Returns a DomainCategoryResponseDto.
     * @summary Update a domain category
     * @param {string} companyId A unique identifier for the company.
     * @param {string} id DomainCategory ID
     * @param {DomainCategoryRequestDto} domainCategoryRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainCategoriesApi
     */
    public updateDomainCategory(companyId: string, id: string, domainCategoryRequestDto: DomainCategoryRequestDto, options?: RawAxiosRequestConfig) {
        return DomainCategoriesApiFp(this.configuration).updateDomainCategory(companyId, id, domainCategoryRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DomainContactsApi - axios parameter creator
 * @export
 */
export const DomainContactsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new domain contact associated with a specific company based on the provided \'companyId\' path parameter. You should provide the details of the new domain contact in the request body using the \'DomainContactDto\'. This endpoint returns the domain contact data(\'DomainContactDto\') with a 201 status code upon success.
         * @summary Create Domain Contact
         * @param {string} companyId A unique identifier for the company.
         * @param {DomainContactRequestDto} domainContactRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomainContact: async (companyId: string, domainContactRequestDto: DomainContactRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('createDomainContact', 'companyId', companyId)
            // verify required parameter 'domainContactRequestDto' is not null or undefined
            assertParamExists('createDomainContact', 'domainContactRequestDto', domainContactRequestDto)
            const localVarPath = `/domain-contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainContactRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a domain contact associated with a specific company. Provide the \'id\' of the domain contact you want to delete and the \'companyId\' it belongs to as path parameters. This endpoint returns a success response with a 200 status code upon successful deletion.
         * @summary Delete Domain Contact
         * @param {string} id The ID of the domain contact to delete.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomainContact: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDomainContact', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deleteDomainContact', 'companyId', companyId)
            const localVarPath = `/domain-contacts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of domain contacts associated with a specific company based on the provided parameters. You can filter the results by name, street, postcode, organization, city, state, telephone, fax, or email using the \'query\' parameter. If you want to filter by the country code, you can use the \'country\' parameter. You can also paginate the results by specifying the \'currentPage\' and \'perPage\' parameters. This endpoint returns a list of domain contacts (type: DomainContactDto) associated with the specified company.
         * @summary Get List of All Domain Contacts
         * @param {string} companyId A unique identifier for the company.
         * @param {string} [query] A query string for searching domain contacts by name, street, postcode, organization, city, state, telephone, fax, or email. (Optional)
         * @param {FindDomainContactsCountryEnum} [country] Filter domain contacts by the ISO 3166-1-alpha-2 country code. (Optional)
         * @param {string} [userId] Filter by the ID of the parent domain contact. (Optional)
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDomainContacts: async (companyId: string, query?: string, country?: FindDomainContactsCountryEnum, userId?: string, currentPage?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('findDomainContacts', 'companyId', companyId)
            const localVarPath = `/domain-contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a specific domain contact associated with a company based on the provided parameters. This endpoint allows you to retrieve a specific domain contact by specifying its \'id\' and the \'companyId\' it belongs to. It returns detailed information about the domain contact.
         * @summary Get a Domain Contact
         * @param {string} id The ID of the domain contact.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainContact: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDomainContact', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getDomainContact', 'companyId', companyId)
            const localVarPath = `/domain-contacts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact you want to update and the \'companyId\' it belongs to as path parameters. You should include the updated domain contact details in the request body using \'DomainContactDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update Domain Contact
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id The ID of the domain contact to update.
         * @param {DomainContactRequestDto} domainContactRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContact: async (companyId: string, id: string, domainContactRequestDto: DomainContactRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainContact', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainContact', 'id', id)
            // verify required parameter 'domainContactRequestDto' is not null or undefined
            assertParamExists('updateDomainContact', 'domainContactRequestDto', domainContactRequestDto)
            const localVarPath = `/domain-contacts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainContactRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'AfnicAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update Afnic Additional Data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId A unique identifier for the company.
         * @param {AfnicAdditionalDataDto} afnicAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactAfnicAdditionalData: async (id: string, companyId: string, afnicAdditionalDataDto: AfnicAdditionalDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainContactAfnicAdditionalData', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainContactAfnicAdditionalData', 'companyId', companyId)
            // verify required parameter 'afnicAdditionalDataDto' is not null or undefined
            assertParamExists('updateDomainContactAfnicAdditionalData', 'afnicAdditionalDataDto', afnicAdditionalDataDto)
            const localVarPath = `/domain-contacts/{id}/additional/afnic`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(afnicAdditionalDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'CatAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update Cat Additional Data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId A unique identifier for the company.
         * @param {CatAdditionalDataDto} catAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactCatAdditionalData: async (id: string, companyId: string, catAdditionalDataDto: CatAdditionalDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainContactCatAdditionalData', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainContactCatAdditionalData', 'companyId', companyId)
            // verify required parameter 'catAdditionalDataDto' is not null or undefined
            assertParamExists('updateDomainContactCatAdditionalData', 'catAdditionalDataDto', catAdditionalDataDto)
            const localVarPath = `/domain-contacts/{id}/additional/cat`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(catAdditionalDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'DeAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update DE Additional Data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId A unique identifier for the company.
         * @param {DeAdditionalDataDto} deAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactDeAdditionalData: async (id: string, companyId: string, deAdditionalDataDto: DeAdditionalDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainContactDeAdditionalData', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainContactDeAdditionalData', 'companyId', companyId)
            // verify required parameter 'deAdditionalDataDto' is not null or undefined
            assertParamExists('updateDomainContactDeAdditionalData', 'deAdditionalDataDto', deAdditionalDataDto)
            const localVarPath = `/domain-contacts/{id}/additional/de`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deAdditionalDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'EsAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update ES Additional Data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId A unique identifier for the company.
         * @param {EsAdditionalDataDto} esAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactEsAdditionalData: async (id: string, companyId: string, esAdditionalDataDto: EsAdditionalDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainContactEsAdditionalData', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainContactEsAdditionalData', 'companyId', companyId)
            // verify required parameter 'esAdditionalDataDto' is not null or undefined
            assertParamExists('updateDomainContactEsAdditionalData', 'esAdditionalDataDto', esAdditionalDataDto)
            const localVarPath = `/domain-contacts/{id}/additional/es`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(esAdditionalDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'EuBeAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update EU-BE Additional Data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId A unique identifier for the company.
         * @param {EuBeAdditionalDataDto} euBeAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactEuBeAdditionalData: async (id: string, companyId: string, euBeAdditionalDataDto: EuBeAdditionalDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainContactEuBeAdditionalData', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainContactEuBeAdditionalData', 'companyId', companyId)
            // verify required parameter 'euBeAdditionalDataDto' is not null or undefined
            assertParamExists('updateDomainContactEuBeAdditionalData', 'euBeAdditionalDataDto', euBeAdditionalDataDto)
            const localVarPath = `/domain-contacts/{id}/additional/eu-be`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(euBeAdditionalDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'ItAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update IT Additional Data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId A unique identifier for the company.
         * @param {ItAdditionalDataDto} itAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactItAdditionalData: async (id: string, companyId: string, itAdditionalDataDto: ItAdditionalDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainContactItAdditionalData', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainContactItAdditionalData', 'companyId', companyId)
            // verify required parameter 'itAdditionalDataDto' is not null or undefined
            assertParamExists('updateDomainContactItAdditionalData', 'itAdditionalDataDto', itAdditionalDataDto)
            const localVarPath = `/domain-contacts/{id}/additional/it`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itAdditionalDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'ItAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactResponseDto\') with a 200 status code upon success.
         * @summary Update LV Additional Data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId A unique identifier for the company.
         * @param {LvAdditionalDataDto} lvAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactLvAdditionalData: async (id: string, companyId: string, lvAdditionalDataDto: LvAdditionalDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainContactLvAdditionalData', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainContactLvAdditionalData', 'companyId', companyId)
            // verify required parameter 'lvAdditionalDataDto' is not null or undefined
            assertParamExists('updateDomainContactLvAdditionalData', 'lvAdditionalDataDto', lvAdditionalDataDto)
            const localVarPath = `/domain-contacts/{id}/additional/lv`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lvAdditionalDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'NlAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update NL Additional Data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId A unique identifier for the company.
         * @param {NlAdditionalDataDto} nlAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactNlAdditionalData: async (id: string, companyId: string, nlAdditionalDataDto: NlAdditionalDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainContactNlAdditionalData', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainContactNlAdditionalData', 'companyId', companyId)
            // verify required parameter 'nlAdditionalDataDto' is not null or undefined
            assertParamExists('updateDomainContactNlAdditionalData', 'nlAdditionalDataDto', nlAdditionalDataDto)
            const localVarPath = `/domain-contacts/{id}/additional/nl`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nlAdditionalDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update additional data for a domain contact in the \'Pro\' category associated with a specific company. Specify the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. Include the updated additional data details in the request body using \'ProAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update Pro Additional Data
         * @param {string} id The ID of the domain contact to update.
         * @param {string} companyId A unique identifier for the company.
         * @param {ProAdditionalDataDto} proAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactProAdditionalData: async (id: string, companyId: string, proAdditionalDataDto: ProAdditionalDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainContactProAdditionalData', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainContactProAdditionalData', 'companyId', companyId)
            // verify required parameter 'proAdditionalDataDto' is not null or undefined
            assertParamExists('updateDomainContactProAdditionalData', 'proAdditionalDataDto', proAdditionalDataDto)
            const localVarPath = `/domain-contacts/{id}/additional/pro`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(proAdditionalDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update additional data for a domain contact in the \'UK\' category associated with a specific company. Specify the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. Include the updated additional data details in the request body using \'UkAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update UK Additional Data
         * @param {string} id The ID of the domain contact to update.
         * @param {string} companyId A unique identifier for the company.
         * @param {UkAdditionalDataDto} ukAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactUkAdditionalData: async (id: string, companyId: string, ukAdditionalDataDto: UkAdditionalDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainContactUkAdditionalData', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainContactUkAdditionalData', 'companyId', companyId)
            // verify required parameter 'ukAdditionalDataDto' is not null or undefined
            assertParamExists('updateDomainContactUkAdditionalData', 'ukAdditionalDataDto', ukAdditionalDataDto)
            const localVarPath = `/domain-contacts/{id}/additional/uk`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ukAdditionalDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update additional data for a domain contact in the \'US\' category associated with a specific company. Specify the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. Include the updated additional data details in the request body using \'UsAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update US Additional Data
         * @param {string} id The ID of the domain contact to update.
         * @param {string} companyId A unique identifier for the company.
         * @param {UsAdditionalDataDto} usAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactUsAdditionalData: async (id: string, companyId: string, usAdditionalDataDto: UsAdditionalDataDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDomainContactUsAdditionalData', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateDomainContactUsAdditionalData', 'companyId', companyId)
            // verify required parameter 'usAdditionalDataDto' is not null or undefined
            assertParamExists('updateDomainContactUsAdditionalData', 'usAdditionalDataDto', usAdditionalDataDto)
            const localVarPath = `/domain-contacts/{id}/additional/us`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usAdditionalDataDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DomainContactsApi - functional programming interface
 * @export
 */
export const DomainContactsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DomainContactsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new domain contact associated with a specific company based on the provided \'companyId\' path parameter. You should provide the details of the new domain contact in the request body using the \'DomainContactDto\'. This endpoint returns the domain contact data(\'DomainContactDto\') with a 201 status code upon success.
         * @summary Create Domain Contact
         * @param {string} companyId A unique identifier for the company.
         * @param {DomainContactRequestDto} domainContactRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDomainContact(companyId: string, domainContactRequestDto: DomainContactRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDomainContact201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDomainContact(companyId, domainContactRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainContactsApi.createDomainContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a domain contact associated with a specific company. Provide the \'id\' of the domain contact you want to delete and the \'companyId\' it belongs to as path parameters. This endpoint returns a success response with a 200 status code upon successful deletion.
         * @summary Delete Domain Contact
         * @param {string} id The ID of the domain contact to delete.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDomainContact(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDomainContact(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainContactsApi.deleteDomainContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of domain contacts associated with a specific company based on the provided parameters. You can filter the results by name, street, postcode, organization, city, state, telephone, fax, or email using the \'query\' parameter. If you want to filter by the country code, you can use the \'country\' parameter. You can also paginate the results by specifying the \'currentPage\' and \'perPage\' parameters. This endpoint returns a list of domain contacts (type: DomainContactDto) associated with the specified company.
         * @summary Get List of All Domain Contacts
         * @param {string} companyId A unique identifier for the company.
         * @param {string} [query] A query string for searching domain contacts by name, street, postcode, organization, city, state, telephone, fax, or email. (Optional)
         * @param {FindDomainContactsCountryEnum} [country] Filter domain contacts by the ISO 3166-1-alpha-2 country code. (Optional)
         * @param {string} [userId] Filter by the ID of the parent domain contact. (Optional)
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findDomainContacts(companyId: string, query?: string, country?: FindDomainContactsCountryEnum, userId?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindDomainContacts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findDomainContacts(companyId, query, country, userId, currentPage, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainContactsApi.findDomainContacts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a specific domain contact associated with a company based on the provided parameters. This endpoint allows you to retrieve a specific domain contact by specifying its \'id\' and the \'companyId\' it belongs to. It returns detailed information about the domain contact.
         * @summary Get a Domain Contact
         * @param {string} id The ID of the domain contact.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDomainContact(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDomainContact201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDomainContact(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainContactsApi.getDomainContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact you want to update and the \'companyId\' it belongs to as path parameters. You should include the updated domain contact details in the request body using \'DomainContactDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update Domain Contact
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id The ID of the domain contact to update.
         * @param {DomainContactRequestDto} domainContactRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainContact(companyId: string, id: string, domainContactRequestDto: DomainContactRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDomainContact201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainContact(companyId, id, domainContactRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainContactsApi.updateDomainContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'AfnicAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update Afnic Additional Data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId A unique identifier for the company.
         * @param {AfnicAdditionalDataDto} afnicAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainContactAfnicAdditionalData(id: string, companyId: string, afnicAdditionalDataDto: AfnicAdditionalDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDomainContact201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainContactAfnicAdditionalData(id, companyId, afnicAdditionalDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainContactsApi.updateDomainContactAfnicAdditionalData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'CatAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update Cat Additional Data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId A unique identifier for the company.
         * @param {CatAdditionalDataDto} catAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainContactCatAdditionalData(id: string, companyId: string, catAdditionalDataDto: CatAdditionalDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDomainContact201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainContactCatAdditionalData(id, companyId, catAdditionalDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainContactsApi.updateDomainContactCatAdditionalData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'DeAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update DE Additional Data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId A unique identifier for the company.
         * @param {DeAdditionalDataDto} deAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainContactDeAdditionalData(id: string, companyId: string, deAdditionalDataDto: DeAdditionalDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDomainContact201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainContactDeAdditionalData(id, companyId, deAdditionalDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainContactsApi.updateDomainContactDeAdditionalData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'EsAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update ES Additional Data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId A unique identifier for the company.
         * @param {EsAdditionalDataDto} esAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainContactEsAdditionalData(id: string, companyId: string, esAdditionalDataDto: EsAdditionalDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDomainContact201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainContactEsAdditionalData(id, companyId, esAdditionalDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainContactsApi.updateDomainContactEsAdditionalData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'EuBeAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update EU-BE Additional Data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId A unique identifier for the company.
         * @param {EuBeAdditionalDataDto} euBeAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainContactEuBeAdditionalData(id: string, companyId: string, euBeAdditionalDataDto: EuBeAdditionalDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDomainContact201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainContactEuBeAdditionalData(id, companyId, euBeAdditionalDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainContactsApi.updateDomainContactEuBeAdditionalData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'ItAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update IT Additional Data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId A unique identifier for the company.
         * @param {ItAdditionalDataDto} itAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainContactItAdditionalData(id: string, companyId: string, itAdditionalDataDto: ItAdditionalDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDomainContact201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainContactItAdditionalData(id, companyId, itAdditionalDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainContactsApi.updateDomainContactItAdditionalData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'ItAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactResponseDto\') with a 200 status code upon success.
         * @summary Update LV Additional Data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId A unique identifier for the company.
         * @param {LvAdditionalDataDto} lvAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainContactLvAdditionalData(id: string, companyId: string, lvAdditionalDataDto: LvAdditionalDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDomainContact201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainContactLvAdditionalData(id, companyId, lvAdditionalDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainContactsApi.updateDomainContactLvAdditionalData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'NlAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update NL Additional Data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId A unique identifier for the company.
         * @param {NlAdditionalDataDto} nlAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainContactNlAdditionalData(id: string, companyId: string, nlAdditionalDataDto: NlAdditionalDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDomainContact201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainContactNlAdditionalData(id, companyId, nlAdditionalDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainContactsApi.updateDomainContactNlAdditionalData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update additional data for a domain contact in the \'Pro\' category associated with a specific company. Specify the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. Include the updated additional data details in the request body using \'ProAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update Pro Additional Data
         * @param {string} id The ID of the domain contact to update.
         * @param {string} companyId A unique identifier for the company.
         * @param {ProAdditionalDataDto} proAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainContactProAdditionalData(id: string, companyId: string, proAdditionalDataDto: ProAdditionalDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDomainContact201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainContactProAdditionalData(id, companyId, proAdditionalDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainContactsApi.updateDomainContactProAdditionalData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update additional data for a domain contact in the \'UK\' category associated with a specific company. Specify the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. Include the updated additional data details in the request body using \'UkAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update UK Additional Data
         * @param {string} id The ID of the domain contact to update.
         * @param {string} companyId A unique identifier for the company.
         * @param {UkAdditionalDataDto} ukAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainContactUkAdditionalData(id: string, companyId: string, ukAdditionalDataDto: UkAdditionalDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDomainContact201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainContactUkAdditionalData(id, companyId, ukAdditionalDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainContactsApi.updateDomainContactUkAdditionalData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update additional data for a domain contact in the \'US\' category associated with a specific company. Specify the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. Include the updated additional data details in the request body using \'UsAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update US Additional Data
         * @param {string} id The ID of the domain contact to update.
         * @param {string} companyId A unique identifier for the company.
         * @param {UsAdditionalDataDto} usAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDomainContactUsAdditionalData(id: string, companyId: string, usAdditionalDataDto: UsAdditionalDataDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDomainContact201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDomainContactUsAdditionalData(id, companyId, usAdditionalDataDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainContactsApi.updateDomainContactUsAdditionalData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DomainContactsApi - factory interface
 * @export
 */
export const DomainContactsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DomainContactsApiFp(configuration)
    return {
        /**
         * Creates a new domain contact associated with a specific company based on the provided \'companyId\' path parameter. You should provide the details of the new domain contact in the request body using the \'DomainContactDto\'. This endpoint returns the domain contact data(\'DomainContactDto\') with a 201 status code upon success.
         * @summary Create Domain Contact
         * @param {string} companyId A unique identifier for the company.
         * @param {DomainContactRequestDto} domainContactRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomainContact(companyId: string, domainContactRequestDto: DomainContactRequestDto, options?: any): AxiosPromise<CreateDomainContact201Response> {
            return localVarFp.createDomainContact(companyId, domainContactRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a domain contact associated with a specific company. Provide the \'id\' of the domain contact you want to delete and the \'companyId\' it belongs to as path parameters. This endpoint returns a success response with a 200 status code upon successful deletion.
         * @summary Delete Domain Contact
         * @param {string} id The ID of the domain contact to delete.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomainContact(id: string, companyId: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.deleteDomainContact(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of domain contacts associated with a specific company based on the provided parameters. You can filter the results by name, street, postcode, organization, city, state, telephone, fax, or email using the \'query\' parameter. If you want to filter by the country code, you can use the \'country\' parameter. You can also paginate the results by specifying the \'currentPage\' and \'perPage\' parameters. This endpoint returns a list of domain contacts (type: DomainContactDto) associated with the specified company.
         * @summary Get List of All Domain Contacts
         * @param {string} companyId A unique identifier for the company.
         * @param {string} [query] A query string for searching domain contacts by name, street, postcode, organization, city, state, telephone, fax, or email. (Optional)
         * @param {FindDomainContactsCountryEnum} [country] Filter domain contacts by the ISO 3166-1-alpha-2 country code. (Optional)
         * @param {string} [userId] Filter by the ID of the parent domain contact. (Optional)
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDomainContacts(companyId: string, query?: string, country?: FindDomainContactsCountryEnum, userId?: string, currentPage?: number, perPage?: number, options?: any): AxiosPromise<FindDomainContacts200Response> {
            return localVarFp.findDomainContacts(companyId, query, country, userId, currentPage, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a specific domain contact associated with a company based on the provided parameters. This endpoint allows you to retrieve a specific domain contact by specifying its \'id\' and the \'companyId\' it belongs to. It returns detailed information about the domain contact.
         * @summary Get a Domain Contact
         * @param {string} id The ID of the domain contact.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomainContact(id: string, companyId: string, options?: any): AxiosPromise<CreateDomainContact201Response> {
            return localVarFp.getDomainContact(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact you want to update and the \'companyId\' it belongs to as path parameters. You should include the updated domain contact details in the request body using \'DomainContactDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update Domain Contact
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id The ID of the domain contact to update.
         * @param {DomainContactRequestDto} domainContactRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContact(companyId: string, id: string, domainContactRequestDto: DomainContactRequestDto, options?: any): AxiosPromise<CreateDomainContact201Response> {
            return localVarFp.updateDomainContact(companyId, id, domainContactRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'AfnicAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update Afnic Additional Data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId A unique identifier for the company.
         * @param {AfnicAdditionalDataDto} afnicAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactAfnicAdditionalData(id: string, companyId: string, afnicAdditionalDataDto: AfnicAdditionalDataDto, options?: any): AxiosPromise<CreateDomainContact201Response> {
            return localVarFp.updateDomainContactAfnicAdditionalData(id, companyId, afnicAdditionalDataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'CatAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update Cat Additional Data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId A unique identifier for the company.
         * @param {CatAdditionalDataDto} catAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactCatAdditionalData(id: string, companyId: string, catAdditionalDataDto: CatAdditionalDataDto, options?: any): AxiosPromise<CreateDomainContact201Response> {
            return localVarFp.updateDomainContactCatAdditionalData(id, companyId, catAdditionalDataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'DeAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update DE Additional Data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId A unique identifier for the company.
         * @param {DeAdditionalDataDto} deAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactDeAdditionalData(id: string, companyId: string, deAdditionalDataDto: DeAdditionalDataDto, options?: any): AxiosPromise<CreateDomainContact201Response> {
            return localVarFp.updateDomainContactDeAdditionalData(id, companyId, deAdditionalDataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'EsAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update ES Additional Data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId A unique identifier for the company.
         * @param {EsAdditionalDataDto} esAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactEsAdditionalData(id: string, companyId: string, esAdditionalDataDto: EsAdditionalDataDto, options?: any): AxiosPromise<CreateDomainContact201Response> {
            return localVarFp.updateDomainContactEsAdditionalData(id, companyId, esAdditionalDataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'EuBeAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update EU-BE Additional Data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId A unique identifier for the company.
         * @param {EuBeAdditionalDataDto} euBeAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactEuBeAdditionalData(id: string, companyId: string, euBeAdditionalDataDto: EuBeAdditionalDataDto, options?: any): AxiosPromise<CreateDomainContact201Response> {
            return localVarFp.updateDomainContactEuBeAdditionalData(id, companyId, euBeAdditionalDataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'ItAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update IT Additional Data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId A unique identifier for the company.
         * @param {ItAdditionalDataDto} itAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactItAdditionalData(id: string, companyId: string, itAdditionalDataDto: ItAdditionalDataDto, options?: any): AxiosPromise<CreateDomainContact201Response> {
            return localVarFp.updateDomainContactItAdditionalData(id, companyId, itAdditionalDataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'ItAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactResponseDto\') with a 200 status code upon success.
         * @summary Update LV Additional Data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId A unique identifier for the company.
         * @param {LvAdditionalDataDto} lvAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactLvAdditionalData(id: string, companyId: string, lvAdditionalDataDto: LvAdditionalDataDto, options?: any): AxiosPromise<CreateDomainContact201Response> {
            return localVarFp.updateDomainContactLvAdditionalData(id, companyId, lvAdditionalDataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'NlAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update NL Additional Data
         * @param {string} id The ID of the domain contact to update additional data for.
         * @param {string} companyId A unique identifier for the company.
         * @param {NlAdditionalDataDto} nlAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactNlAdditionalData(id: string, companyId: string, nlAdditionalDataDto: NlAdditionalDataDto, options?: any): AxiosPromise<CreateDomainContact201Response> {
            return localVarFp.updateDomainContactNlAdditionalData(id, companyId, nlAdditionalDataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Update additional data for a domain contact in the \'Pro\' category associated with a specific company. Specify the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. Include the updated additional data details in the request body using \'ProAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update Pro Additional Data
         * @param {string} id The ID of the domain contact to update.
         * @param {string} companyId A unique identifier for the company.
         * @param {ProAdditionalDataDto} proAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactProAdditionalData(id: string, companyId: string, proAdditionalDataDto: ProAdditionalDataDto, options?: any): AxiosPromise<CreateDomainContact201Response> {
            return localVarFp.updateDomainContactProAdditionalData(id, companyId, proAdditionalDataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Update additional data for a domain contact in the \'UK\' category associated with a specific company. Specify the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. Include the updated additional data details in the request body using \'UkAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update UK Additional Data
         * @param {string} id The ID of the domain contact to update.
         * @param {string} companyId A unique identifier for the company.
         * @param {UkAdditionalDataDto} ukAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactUkAdditionalData(id: string, companyId: string, ukAdditionalDataDto: UkAdditionalDataDto, options?: any): AxiosPromise<CreateDomainContact201Response> {
            return localVarFp.updateDomainContactUkAdditionalData(id, companyId, ukAdditionalDataDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Update additional data for a domain contact in the \'US\' category associated with a specific company. Specify the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. Include the updated additional data details in the request body using \'UsAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
         * @summary Update US Additional Data
         * @param {string} id The ID of the domain contact to update.
         * @param {string} companyId A unique identifier for the company.
         * @param {UsAdditionalDataDto} usAdditionalDataDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomainContactUsAdditionalData(id: string, companyId: string, usAdditionalDataDto: UsAdditionalDataDto, options?: any): AxiosPromise<CreateDomainContact201Response> {
            return localVarFp.updateDomainContactUsAdditionalData(id, companyId, usAdditionalDataDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DomainContactsApi - object-oriented interface
 * @export
 * @class DomainContactsApi
 * @extends {BaseAPI}
 */
export class DomainContactsApi extends BaseAPI {
    /**
     * Creates a new domain contact associated with a specific company based on the provided \'companyId\' path parameter. You should provide the details of the new domain contact in the request body using the \'DomainContactDto\'. This endpoint returns the domain contact data(\'DomainContactDto\') with a 201 status code upon success.
     * @summary Create Domain Contact
     * @param {string} companyId A unique identifier for the company.
     * @param {DomainContactRequestDto} domainContactRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainContactsApi
     */
    public createDomainContact(companyId: string, domainContactRequestDto: DomainContactRequestDto, options?: RawAxiosRequestConfig) {
        return DomainContactsApiFp(this.configuration).createDomainContact(companyId, domainContactRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a domain contact associated with a specific company. Provide the \'id\' of the domain contact you want to delete and the \'companyId\' it belongs to as path parameters. This endpoint returns a success response with a 200 status code upon successful deletion.
     * @summary Delete Domain Contact
     * @param {string} id The ID of the domain contact to delete.
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainContactsApi
     */
    public deleteDomainContact(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return DomainContactsApiFp(this.configuration).deleteDomainContact(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of domain contacts associated with a specific company based on the provided parameters. You can filter the results by name, street, postcode, organization, city, state, telephone, fax, or email using the \'query\' parameter. If you want to filter by the country code, you can use the \'country\' parameter. You can also paginate the results by specifying the \'currentPage\' and \'perPage\' parameters. This endpoint returns a list of domain contacts (type: DomainContactDto) associated with the specified company.
     * @summary Get List of All Domain Contacts
     * @param {string} companyId A unique identifier for the company.
     * @param {string} [query] A query string for searching domain contacts by name, street, postcode, organization, city, state, telephone, fax, or email. (Optional)
     * @param {FindDomainContactsCountryEnum} [country] Filter domain contacts by the ISO 3166-1-alpha-2 country code. (Optional)
     * @param {string} [userId] Filter by the ID of the parent domain contact. (Optional)
     * @param {number} [currentPage] current page
     * @param {number} [perPage] per Page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainContactsApi
     */
    public findDomainContacts(companyId: string, query?: string, country?: FindDomainContactsCountryEnum, userId?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return DomainContactsApiFp(this.configuration).findDomainContacts(companyId, query, country, userId, currentPage, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a specific domain contact associated with a company based on the provided parameters. This endpoint allows you to retrieve a specific domain contact by specifying its \'id\' and the \'companyId\' it belongs to. It returns detailed information about the domain contact.
     * @summary Get a Domain Contact
     * @param {string} id The ID of the domain contact.
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainContactsApi
     */
    public getDomainContact(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return DomainContactsApiFp(this.configuration).getDomainContact(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact you want to update and the \'companyId\' it belongs to as path parameters. You should include the updated domain contact details in the request body using \'DomainContactDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
     * @summary Update Domain Contact
     * @param {string} companyId A unique identifier for the company.
     * @param {string} id The ID of the domain contact to update.
     * @param {DomainContactRequestDto} domainContactRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainContactsApi
     */
    public updateDomainContact(companyId: string, id: string, domainContactRequestDto: DomainContactRequestDto, options?: RawAxiosRequestConfig) {
        return DomainContactsApiFp(this.configuration).updateDomainContact(companyId, id, domainContactRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'AfnicAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
     * @summary Update Afnic Additional Data
     * @param {string} id The ID of the domain contact to update additional data for.
     * @param {string} companyId A unique identifier for the company.
     * @param {AfnicAdditionalDataDto} afnicAdditionalDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainContactsApi
     */
    public updateDomainContactAfnicAdditionalData(id: string, companyId: string, afnicAdditionalDataDto: AfnicAdditionalDataDto, options?: RawAxiosRequestConfig) {
        return DomainContactsApiFp(this.configuration).updateDomainContactAfnicAdditionalData(id, companyId, afnicAdditionalDataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'CatAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
     * @summary Update Cat Additional Data
     * @param {string} id The ID of the domain contact to update additional data for.
     * @param {string} companyId A unique identifier for the company.
     * @param {CatAdditionalDataDto} catAdditionalDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainContactsApi
     */
    public updateDomainContactCatAdditionalData(id: string, companyId: string, catAdditionalDataDto: CatAdditionalDataDto, options?: RawAxiosRequestConfig) {
        return DomainContactsApiFp(this.configuration).updateDomainContactCatAdditionalData(id, companyId, catAdditionalDataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'DeAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
     * @summary Update DE Additional Data
     * @param {string} id The ID of the domain contact to update additional data for.
     * @param {string} companyId A unique identifier for the company.
     * @param {DeAdditionalDataDto} deAdditionalDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainContactsApi
     */
    public updateDomainContactDeAdditionalData(id: string, companyId: string, deAdditionalDataDto: DeAdditionalDataDto, options?: RawAxiosRequestConfig) {
        return DomainContactsApiFp(this.configuration).updateDomainContactDeAdditionalData(id, companyId, deAdditionalDataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'EsAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
     * @summary Update ES Additional Data
     * @param {string} id The ID of the domain contact to update additional data for.
     * @param {string} companyId A unique identifier for the company.
     * @param {EsAdditionalDataDto} esAdditionalDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainContactsApi
     */
    public updateDomainContactEsAdditionalData(id: string, companyId: string, esAdditionalDataDto: EsAdditionalDataDto, options?: RawAxiosRequestConfig) {
        return DomainContactsApiFp(this.configuration).updateDomainContactEsAdditionalData(id, companyId, esAdditionalDataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'EuBeAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
     * @summary Update EU-BE Additional Data
     * @param {string} id The ID of the domain contact to update additional data for.
     * @param {string} companyId A unique identifier for the company.
     * @param {EuBeAdditionalDataDto} euBeAdditionalDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainContactsApi
     */
    public updateDomainContactEuBeAdditionalData(id: string, companyId: string, euBeAdditionalDataDto: EuBeAdditionalDataDto, options?: RawAxiosRequestConfig) {
        return DomainContactsApiFp(this.configuration).updateDomainContactEuBeAdditionalData(id, companyId, euBeAdditionalDataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'ItAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
     * @summary Update IT Additional Data
     * @param {string} id The ID of the domain contact to update additional data for.
     * @param {string} companyId A unique identifier for the company.
     * @param {ItAdditionalDataDto} itAdditionalDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainContactsApi
     */
    public updateDomainContactItAdditionalData(id: string, companyId: string, itAdditionalDataDto: ItAdditionalDataDto, options?: RawAxiosRequestConfig) {
        return DomainContactsApiFp(this.configuration).updateDomainContactItAdditionalData(id, companyId, itAdditionalDataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'ItAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactResponseDto\') with a 200 status code upon success.
     * @summary Update LV Additional Data
     * @param {string} id The ID of the domain contact to update additional data for.
     * @param {string} companyId A unique identifier for the company.
     * @param {LvAdditionalDataDto} lvAdditionalDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainContactsApi
     */
    public updateDomainContactLvAdditionalData(id: string, companyId: string, lvAdditionalDataDto: LvAdditionalDataDto, options?: RawAxiosRequestConfig) {
        return DomainContactsApiFp(this.configuration).updateDomainContactLvAdditionalData(id, companyId, lvAdditionalDataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'NlAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
     * @summary Update NL Additional Data
     * @param {string} id The ID of the domain contact to update additional data for.
     * @param {string} companyId A unique identifier for the company.
     * @param {NlAdditionalDataDto} nlAdditionalDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainContactsApi
     */
    public updateDomainContactNlAdditionalData(id: string, companyId: string, nlAdditionalDataDto: NlAdditionalDataDto, options?: RawAxiosRequestConfig) {
        return DomainContactsApiFp(this.configuration).updateDomainContactNlAdditionalData(id, companyId, nlAdditionalDataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update additional data for a domain contact in the \'Pro\' category associated with a specific company. Specify the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. Include the updated additional data details in the request body using \'ProAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
     * @summary Update Pro Additional Data
     * @param {string} id The ID of the domain contact to update.
     * @param {string} companyId A unique identifier for the company.
     * @param {ProAdditionalDataDto} proAdditionalDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainContactsApi
     */
    public updateDomainContactProAdditionalData(id: string, companyId: string, proAdditionalDataDto: ProAdditionalDataDto, options?: RawAxiosRequestConfig) {
        return DomainContactsApiFp(this.configuration).updateDomainContactProAdditionalData(id, companyId, proAdditionalDataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update additional data for a domain contact in the \'UK\' category associated with a specific company. Specify the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. Include the updated additional data details in the request body using \'UkAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
     * @summary Update UK Additional Data
     * @param {string} id The ID of the domain contact to update.
     * @param {string} companyId A unique identifier for the company.
     * @param {UkAdditionalDataDto} ukAdditionalDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainContactsApi
     */
    public updateDomainContactUkAdditionalData(id: string, companyId: string, ukAdditionalDataDto: UkAdditionalDataDto, options?: RawAxiosRequestConfig) {
        return DomainContactsApiFp(this.configuration).updateDomainContactUkAdditionalData(id, companyId, ukAdditionalDataDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update additional data for a domain contact in the \'US\' category associated with a specific company. Specify the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. Include the updated additional data details in the request body using \'UsAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
     * @summary Update US Additional Data
     * @param {string} id The ID of the domain contact to update.
     * @param {string} companyId A unique identifier for the company.
     * @param {UsAdditionalDataDto} usAdditionalDataDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainContactsApi
     */
    public updateDomainContactUsAdditionalData(id: string, companyId: string, usAdditionalDataDto: UsAdditionalDataDto, options?: RawAxiosRequestConfig) {
        return DomainContactsApiFp(this.configuration).updateDomainContactUsAdditionalData(id, companyId, usAdditionalDataDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const FindDomainContactsCountryEnum = {
    Af: 'AF',
    Al: 'AL',
    Dz: 'DZ',
    As: 'AS',
    Ad: 'AD',
    Ao: 'AO',
    Ai: 'AI',
    Aq: 'AQ',
    Ag: 'AG',
    Ar: 'AR',
    Am: 'AM',
    Aw: 'AW',
    Au: 'AU',
    At: 'AT',
    Az: 'AZ',
    Bs: 'BS',
    Bh: 'BH',
    Bd: 'BD',
    Bb: 'BB',
    By: 'BY',
    Be: 'BE',
    Bz: 'BZ',
    Bj: 'BJ',
    Bm: 'BM',
    Bt: 'BT',
    Bo: 'BO',
    Bq: 'BQ',
    Ba: 'BA',
    Bw: 'BW',
    Bv: 'BV',
    Br: 'BR',
    Io: 'IO',
    Bn: 'BN',
    Bg: 'BG',
    Bf: 'BF',
    Bi: 'BI',
    Kh: 'KH',
    Cm: 'CM',
    Ca: 'CA',
    Cv: 'CV',
    Ky: 'KY',
    Cf: 'CF',
    Td: 'TD',
    Cl: 'CL',
    Cn: 'CN',
    Cx: 'CX',
    Cc: 'CC',
    Co: 'CO',
    Km: 'KM',
    Cg: 'CG',
    Cd: 'CD',
    Ck: 'CK',
    Cr: 'CR',
    Ci: 'CI',
    Hr: 'HR',
    Cu: 'CU',
    Cw: 'CW',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Dj: 'DJ',
    Dm: 'DM',
    Do: 'DO',
    Ec: 'EC',
    Eg: 'EG',
    Sv: 'SV',
    Gq: 'GQ',
    Er: 'ER',
    Ee: 'EE',
    Et: 'ET',
    Fk: 'FK',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Gf: 'GF',
    Pf: 'PF',
    Tf: 'TF',
    Ga: 'GA',
    Gm: 'GM',
    Ge: 'GE',
    De: 'DE',
    Gh: 'GH',
    Gi: 'GI',
    Gr: 'GR',
    Gl: 'GL',
    Gd: 'GD',
    Gp: 'GP',
    Gu: 'GU',
    Gt: 'GT',
    Gg: 'GG',
    Gn: 'GN',
    Gw: 'GW',
    Gy: 'GY',
    Ht: 'HT',
    Hm: 'HM',
    Va: 'VA',
    Hn: 'HN',
    Hk: 'HK',
    Hu: 'HU',
    Is: 'IS',
    In: 'IN',
    Id: 'ID',
    Ir: 'IR',
    Iq: 'IQ',
    Ie: 'IE',
    Im: 'IM',
    Il: 'IL',
    It: 'IT',
    Jm: 'JM',
    Jp: 'JP',
    Je: 'JE',
    Jo: 'JO',
    Kz: 'KZ',
    Ke: 'KE',
    Ki: 'KI',
    Kp: 'KP',
    Kr: 'KR',
    Kw: 'KW',
    Kg: 'KG',
    La: 'LA',
    Lv: 'LV',
    Lb: 'LB',
    Ls: 'LS',
    Lr: 'LR',
    Ly: 'LY',
    Li: 'LI',
    Lt: 'LT',
    Lu: 'LU',
    Mo: 'MO',
    Mk: 'MK',
    Mg: 'MG',
    Mw: 'MW',
    My: 'MY',
    Mv: 'MV',
    Ml: 'ML',
    Mt: 'MT',
    Mh: 'MH',
    Mq: 'MQ',
    Mr: 'MR',
    Mu: 'MU',
    Tn: 'TN',
    Tr: 'TR',
    Tm: 'TM',
    Tc: 'TC',
    Tv: 'TV',
    Ug: 'UG',
    Ua: 'UA',
    Ae: 'AE',
    Gb: 'GB',
    Us: 'US',
    Um: 'UM',
    Uy: 'UY',
    Uz: 'UZ',
    Vu: 'VU',
    Ve: 'VE',
    Vn: 'VN',
    Vg: 'VG',
    Vi: 'VI',
    Wf: 'WF',
    Eh: 'EH',
    Ye: 'YE',
    Zm: 'ZM',
    Zw: 'ZW',
    Yt: 'YT',
    Mx: 'MX',
    Fm: 'FM',
    Md: 'MD',
    Mc: 'MC',
    Mn: 'MN',
    Me: 'ME',
    Ms: 'MS',
    Ma: 'MA',
    Mz: 'MZ',
    Mm: 'MM',
    Na: 'NA',
    Nr: 'NR',
    Np: 'NP',
    Nl: 'NL',
    Nc: 'NC',
    Nz: 'NZ',
    Ni: 'NI',
    Ne: 'NE',
    Ng: 'NG',
    Nu: 'NU',
    Nf: 'NF',
    Mp: 'MP',
    No: 'NO',
    Om: 'OM',
    Pk: 'PK',
    Pw: 'PW',
    Ps: 'PS',
    Pa: 'PA',
    Pg: 'PG',
    Py: 'PY',
    Pe: 'PE',
    Ph: 'PH',
    Pn: 'PN',
    Pl: 'PL',
    Pt: 'PT',
    Pr: 'PR',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Ru: 'RU',
    Rw: 'RW',
    Bl: 'BL',
    Sh: 'SH',
    Kn: 'KN',
    Lc: 'LC',
    Mf: 'MF',
    Pm: 'PM',
    Vc: 'VC',
    Ws: 'WS',
    Sm: 'SM',
    St: 'ST',
    Sa: 'SA',
    Sn: 'SN',
    Rs: 'RS',
    Sc: 'SC',
    Sl: 'SL',
    Sg: 'SG',
    Sx: 'SX',
    Sk: 'SK',
    Si: 'SI',
    Sb: 'SB',
    So: 'SO',
    Za: 'ZA',
    Gs: 'GS',
    Ss: 'SS',
    Es: 'ES',
    Lk: 'LK',
    Sd: 'SD',
    Sr: 'SR',
    Sj: 'SJ',
    Sz: 'SZ',
    Se: 'SE',
    Ch: 'CH',
    Sy: 'SY',
    Tw: 'TW',
    Tj: 'TJ',
    Tz: 'TZ',
    Th: 'TH',
    Tl: 'TL',
    Tg: 'TG',
    Tk: 'TK',
    To: 'TO',
    Tt: 'TT'
} as const;
export type FindDomainContactsCountryEnum = typeof FindDomainContactsCountryEnum[keyof typeof FindDomainContactsCountryEnum];


/**
 * IntegrationsApi - axios parameter creator
 * @export
 */
export const IntegrationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Accepts the results of a URL validation job.
         * @summary Accept URLs Validation Results
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptUrlsValidationResults: async (body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('acceptUrlsValidationResults', 'body', body)
            const localVarPath = `/integrations/validation-results`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Activates a specific integration.
         * @summary Activate Integration
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateIntegration: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('activateIntegration', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('activateIntegration', 'id', id)
            const localVarPath = `/integrations/{id}/activate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new integration for a company.
         * @summary Create Integration
         * @param {string} companyId A unique identifier for the company.
         * @param {IntegrationRequestDto} integrationRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIntegration: async (companyId: string, integrationRequestDto: IntegrationRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('createIntegration', 'companyId', companyId)
            // verify required parameter 'integrationRequestDto' is not null or undefined
            assertParamExists('createIntegration', 'integrationRequestDto', integrationRequestDto)
            const localVarPath = `/integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(integrationRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deactivates a specific integration.
         * @summary Deactivate Integration
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateIntegration: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deactivateIntegration', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deactivateIntegration', 'id', id)
            const localVarPath = `/integrations/{id}/deactivate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deactivates maintenance mode for a specific integration.
         * @summary Deactivate Maintenance
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateMaintenance: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deactivateMaintenance', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deactivateMaintenance', 'id', id)
            const localVarPath = `/integrations/{id}/deactivate-maintenance`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a specific integration.
         * @summary Delete Integration
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIntegration: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deleteIntegration', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteIntegration', 'id', id)
            const localVarPath = `/integrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves detailed information for a specific integration by its ID, scoped to a company.
         * @summary Get Integration
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegration: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getIntegration', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIntegration', 'id', id)
            const localVarPath = `/integrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves public information for a specific integration by its ID.
         * @summary Get Integration Public Info
         * @param {string} id A unique identifier for the integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationPublicInfo: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIntegrationPublicInfo', 'id', id)
            const localVarPath = `/integrations/{id}/public`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a paginated list of integrations, with optional filters for type and company.
         * @summary Get Integrations
         * @param {string} [type] Filter integrations by type. Available values: product, notification, domain, application, dns, payment, invoice
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {string} [companyId] The ID of the company to filter integrations by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrations: async (type?: string, currentPage?: number, perPage?: number, companyId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Publishes an integration, making it publicly available.
         * @summary Publish Integration
         * @param {string} id A unique identifier for the integration.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishIntegration: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('publishIntegration', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('publishIntegration', 'companyId', companyId)
            const localVarPath = `/integrations/{id}/publish`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refreshes the secret for a specific integration, invalidating the old one.
         * @summary Refresh Secret
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshSecret: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('refreshSecret', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('refreshSecret', 'id', id)
            const localVarPath = `/integrations/{id}/refresh-secret`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unpublishes an integration, making it private.
         * @summary Unpublish Integration
         * @param {string} id A unique identifier for the integration.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpublishIntegration: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unpublishIntegration', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('unpublishIntegration', 'companyId', companyId)
            const localVarPath = `/integrations/{id}/unpublish`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing integration.
         * @summary Update Integration
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the integration.
         * @param {IntegrationUpdateRequestDto} integrationUpdateRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIntegration: async (companyId: string, id: string, integrationUpdateRequestDto: IntegrationUpdateRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateIntegration', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateIntegration', 'id', id)
            // verify required parameter 'integrationUpdateRequestDto' is not null or undefined
            assertParamExists('updateIntegration', 'integrationUpdateRequestDto', integrationUpdateRequestDto)
            const localVarPath = `/integrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(integrationUpdateRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the information of a specific integration by fetching the latest from the integration\'s info endpoint.
         * @summary Update Integration Info
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIntegrationInfo: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateIntegrationInfo', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateIntegrationInfo', 'id', id)
            const localVarPath = `/integrations/{id}/update-info`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts the validation process for a specific integration.
         * @summary Validate Integration
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateIntegration: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('validateIntegration', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('validateIntegration', 'id', id)
            const localVarPath = `/integrations/{id}/validate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validates the item attributes for a given product.
         * @summary Validate Item Attributes
         * @param {string} companyId A unique identifier for the company.
         * @param {string} productId The ID of the product.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateItemAttributes: async (companyId: string, productId: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('validateItemAttributes', 'companyId', companyId)
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('validateItemAttributes', 'productId', productId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('validateItemAttributes', 'body', body)
            const localVarPath = `/integrations/validate/item-attributes/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validates the product attributes for a given product.
         * @summary Validate Product Attributes
         * @param {string} companyId A unique identifier for the company.
         * @param {string} productId The ID of the product.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateProductAttributes: async (companyId: string, productId: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('validateProductAttributes', 'companyId', companyId)
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('validateProductAttributes', 'productId', productId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('validateProductAttributes', 'body', body)
            const localVarPath = `/integrations/validate/product-attributes/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IntegrationsApi - functional programming interface
 * @export
 */
export const IntegrationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IntegrationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Accepts the results of a URL validation job.
         * @summary Accept URLs Validation Results
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acceptUrlsValidationResults(body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acceptUrlsValidationResults(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.acceptUrlsValidationResults']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Activates a specific integration.
         * @summary Activate Integration
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateIntegration(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateIntegration(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.activateIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new integration for a company.
         * @summary Create Integration
         * @param {string} companyId A unique identifier for the company.
         * @param {IntegrationRequestDto} integrationRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createIntegration(companyId: string, integrationRequestDto: IntegrationRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateIntegration201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createIntegration(companyId, integrationRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.createIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deactivates a specific integration.
         * @summary Deactivate Integration
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateIntegration(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateIntegration(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.deactivateIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deactivates maintenance mode for a specific integration.
         * @summary Deactivate Maintenance
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateMaintenance(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateMaintenance(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.deactivateMaintenance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a specific integration.
         * @summary Delete Integration
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteIntegration(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteIntegration(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.deleteIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves detailed information for a specific integration by its ID, scoped to a company.
         * @summary Get Integration
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIntegration(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateIntegration201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIntegration(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.getIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves public information for a specific integration by its ID.
         * @summary Get Integration Public Info
         * @param {string} id A unique identifier for the integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIntegrationPublicInfo(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetIntegrationPublicInfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIntegrationPublicInfo(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.getIntegrationPublicInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a paginated list of integrations, with optional filters for type and company.
         * @summary Get Integrations
         * @param {string} [type] Filter integrations by type. Available values: product, notification, domain, application, dns, payment, invoice
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {string} [companyId] The ID of the company to filter integrations by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIntegrations(type?: string, currentPage?: number, perPage?: number, companyId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetIntegrations200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIntegrations(type, currentPage, perPage, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.getIntegrations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Publishes an integration, making it publicly available.
         * @summary Publish Integration
         * @param {string} id A unique identifier for the integration.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publishIntegration(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publishIntegration(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.publishIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Refreshes the secret for a specific integration, invalidating the old one.
         * @summary Refresh Secret
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshSecret(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshSecret200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshSecret(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.refreshSecret']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unpublishes an integration, making it private.
         * @summary Unpublish Integration
         * @param {string} id A unique identifier for the integration.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unpublishIntegration(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unpublishIntegration(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.unpublishIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an existing integration.
         * @summary Update Integration
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the integration.
         * @param {IntegrationUpdateRequestDto} integrationUpdateRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateIntegration(companyId: string, id: string, integrationUpdateRequestDto: IntegrationUpdateRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateIntegration(companyId, id, integrationUpdateRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.updateIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the information of a specific integration by fetching the latest from the integration\'s info endpoint.
         * @summary Update Integration Info
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateIntegrationInfo(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateIntegrationInfo(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.updateIntegrationInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Starts the validation process for a specific integration.
         * @summary Validate Integration
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateIntegration(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateIntegration(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.validateIntegration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Validates the item attributes for a given product.
         * @summary Validate Item Attributes
         * @param {string} companyId A unique identifier for the company.
         * @param {string} productId The ID of the product.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateItemAttributes(companyId: string, productId: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateItemAttributes(companyId, productId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.validateItemAttributes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Validates the product attributes for a given product.
         * @summary Validate Product Attributes
         * @param {string} companyId A unique identifier for the company.
         * @param {string} productId The ID of the product.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateProductAttributes(companyId: string, productId: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateProductAttributes(companyId, productId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.validateProductAttributes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IntegrationsApi - factory interface
 * @export
 */
export const IntegrationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IntegrationsApiFp(configuration)
    return {
        /**
         * Accepts the results of a URL validation job.
         * @summary Accept URLs Validation Results
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptUrlsValidationResults(body: object, options?: any): AxiosPromise<void> {
            return localVarFp.acceptUrlsValidationResults(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Activates a specific integration.
         * @summary Activate Integration
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateIntegration(companyId: string, id: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.activateIntegration(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new integration for a company.
         * @summary Create Integration
         * @param {string} companyId A unique identifier for the company.
         * @param {IntegrationRequestDto} integrationRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIntegration(companyId: string, integrationRequestDto: IntegrationRequestDto, options?: any): AxiosPromise<CreateIntegration201Response> {
            return localVarFp.createIntegration(companyId, integrationRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deactivates a specific integration.
         * @summary Deactivate Integration
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateIntegration(companyId: string, id: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.deactivateIntegration(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Deactivates maintenance mode for a specific integration.
         * @summary Deactivate Maintenance
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateMaintenance(companyId: string, id: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.deactivateMaintenance(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a specific integration.
         * @summary Delete Integration
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIntegration(companyId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteIntegration(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves detailed information for a specific integration by its ID, scoped to a company.
         * @summary Get Integration
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegration(companyId: string, id: string, options?: any): AxiosPromise<CreateIntegration201Response> {
            return localVarFp.getIntegration(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves public information for a specific integration by its ID.
         * @summary Get Integration Public Info
         * @param {string} id A unique identifier for the integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationPublicInfo(id: string, options?: any): AxiosPromise<GetIntegrationPublicInfo200Response> {
            return localVarFp.getIntegrationPublicInfo(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a paginated list of integrations, with optional filters for type and company.
         * @summary Get Integrations
         * @param {string} [type] Filter integrations by type. Available values: product, notification, domain, application, dns, payment, invoice
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {string} [companyId] The ID of the company to filter integrations by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrations(type?: string, currentPage?: number, perPage?: number, companyId?: string, options?: any): AxiosPromise<GetIntegrations200Response> {
            return localVarFp.getIntegrations(type, currentPage, perPage, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Publishes an integration, making it publicly available.
         * @summary Publish Integration
         * @param {string} id A unique identifier for the integration.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishIntegration(id: string, companyId: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.publishIntegration(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Refreshes the secret for a specific integration, invalidating the old one.
         * @summary Refresh Secret
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshSecret(companyId: string, id: string, options?: any): AxiosPromise<RefreshSecret200Response> {
            return localVarFp.refreshSecret(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Unpublishes an integration, making it private.
         * @summary Unpublish Integration
         * @param {string} id A unique identifier for the integration.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpublishIntegration(id: string, companyId: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.unpublishIntegration(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing integration.
         * @summary Update Integration
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the integration.
         * @param {IntegrationUpdateRequestDto} integrationUpdateRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIntegration(companyId: string, id: string, integrationUpdateRequestDto: IntegrationUpdateRequestDto, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.updateIntegration(companyId, id, integrationUpdateRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the information of a specific integration by fetching the latest from the integration\'s info endpoint.
         * @summary Update Integration Info
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIntegrationInfo(companyId: string, id: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.updateIntegrationInfo(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Starts the validation process for a specific integration.
         * @summary Validate Integration
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateIntegration(companyId: string, id: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.validateIntegration(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Validates the item attributes for a given product.
         * @summary Validate Item Attributes
         * @param {string} companyId A unique identifier for the company.
         * @param {string} productId The ID of the product.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateItemAttributes(companyId: string, productId: string, body: object, options?: any): AxiosPromise<object> {
            return localVarFp.validateItemAttributes(companyId, productId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Validates the product attributes for a given product.
         * @summary Validate Product Attributes
         * @param {string} companyId A unique identifier for the company.
         * @param {string} productId The ID of the product.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateProductAttributes(companyId: string, productId: string, body: object, options?: any): AxiosPromise<object> {
            return localVarFp.validateProductAttributes(companyId, productId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IntegrationsApi - object-oriented interface
 * @export
 * @class IntegrationsApi
 * @extends {BaseAPI}
 */
export class IntegrationsApi extends BaseAPI {
    /**
     * Accepts the results of a URL validation job.
     * @summary Accept URLs Validation Results
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public acceptUrlsValidationResults(body: object, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).acceptUrlsValidationResults(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Activates a specific integration.
     * @summary Activate Integration
     * @param {string} companyId A unique identifier for the company.
     * @param {string} id A unique identifier for the integration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public activateIntegration(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).activateIntegration(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new integration for a company.
     * @summary Create Integration
     * @param {string} companyId A unique identifier for the company.
     * @param {IntegrationRequestDto} integrationRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public createIntegration(companyId: string, integrationRequestDto: IntegrationRequestDto, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).createIntegration(companyId, integrationRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deactivates a specific integration.
     * @summary Deactivate Integration
     * @param {string} companyId A unique identifier for the company.
     * @param {string} id A unique identifier for the integration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public deactivateIntegration(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).deactivateIntegration(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deactivates maintenance mode for a specific integration.
     * @summary Deactivate Maintenance
     * @param {string} companyId A unique identifier for the company.
     * @param {string} id A unique identifier for the integration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public deactivateMaintenance(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).deactivateMaintenance(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a specific integration.
     * @summary Delete Integration
     * @param {string} companyId A unique identifier for the company.
     * @param {string} id A unique identifier for the integration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public deleteIntegration(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).deleteIntegration(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves detailed information for a specific integration by its ID, scoped to a company.
     * @summary Get Integration
     * @param {string} companyId A unique identifier for the company.
     * @param {string} id A unique identifier for the integration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getIntegration(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).getIntegration(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves public information for a specific integration by its ID.
     * @summary Get Integration Public Info
     * @param {string} id A unique identifier for the integration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getIntegrationPublicInfo(id: string, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).getIntegrationPublicInfo(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a paginated list of integrations, with optional filters for type and company.
     * @summary Get Integrations
     * @param {string} [type] Filter integrations by type. Available values: product, notification, domain, application, dns, payment, invoice
     * @param {number} [currentPage] current page
     * @param {number} [perPage] per Page 
     * @param {string} [companyId] The ID of the company to filter integrations by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public getIntegrations(type?: string, currentPage?: number, perPage?: number, companyId?: string, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).getIntegrations(type, currentPage, perPage, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Publishes an integration, making it publicly available.
     * @summary Publish Integration
     * @param {string} id A unique identifier for the integration.
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public publishIntegration(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).publishIntegration(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refreshes the secret for a specific integration, invalidating the old one.
     * @summary Refresh Secret
     * @param {string} companyId A unique identifier for the company.
     * @param {string} id A unique identifier for the integration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public refreshSecret(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).refreshSecret(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unpublishes an integration, making it private.
     * @summary Unpublish Integration
     * @param {string} id A unique identifier for the integration.
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public unpublishIntegration(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).unpublishIntegration(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing integration.
     * @summary Update Integration
     * @param {string} companyId A unique identifier for the company.
     * @param {string} id A unique identifier for the integration.
     * @param {IntegrationUpdateRequestDto} integrationUpdateRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public updateIntegration(companyId: string, id: string, integrationUpdateRequestDto: IntegrationUpdateRequestDto, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).updateIntegration(companyId, id, integrationUpdateRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the information of a specific integration by fetching the latest from the integration\'s info endpoint.
     * @summary Update Integration Info
     * @param {string} companyId A unique identifier for the company.
     * @param {string} id A unique identifier for the integration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public updateIntegrationInfo(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).updateIntegrationInfo(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starts the validation process for a specific integration.
     * @summary Validate Integration
     * @param {string} companyId A unique identifier for the company.
     * @param {string} id A unique identifier for the integration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public validateIntegration(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).validateIntegration(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validates the item attributes for a given product.
     * @summary Validate Item Attributes
     * @param {string} companyId A unique identifier for the company.
     * @param {string} productId The ID of the product.
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public validateItemAttributes(companyId: string, productId: string, body: object, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).validateItemAttributes(companyId, productId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validates the product attributes for a given product.
     * @summary Validate Product Attributes
     * @param {string} companyId A unique identifier for the company.
     * @param {string} productId The ID of the product.
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public validateProductAttributes(companyId: string, productId: string, body: object, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).validateProductAttributes(companyId, productId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InvoiceContactsApi - axios parameter creator
 * @export
 */
export const InvoiceContactsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint allows you to create a new invoice contact for a specific company. It returns a response containing the created invoice contact or an error response.
         * @summary Create a new invoice contact
         * @param {string} companyId companyId
         * @param {InvoiceContactRequestDto} invoiceContactRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceContact: async (companyId: string, invoiceContactRequestDto: InvoiceContactRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('createInvoiceContact', 'companyId', companyId)
            // verify required parameter 'invoiceContactRequestDto' is not null or undefined
            assertParamExists('createInvoiceContact', 'invoiceContactRequestDto', invoiceContactRequestDto)
            const localVarPath = `/invoice-contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(invoiceContactRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to delete an existing invoice contact for a specific company. It retrieves the invoice contact by ID and deletes it. It returns a response indicating the success of the deletion or an error response if the invoice contact is not found.
         * @summary Delete an invoice contact
         * @param {string} id Invoice contact ID
         * @param {string} companyId companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceContact: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteInvoiceContact', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deleteInvoiceContact', 'companyId', companyId)
            const localVarPath = `/invoice-contacts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves a list of invoice contacts based on the provided parameters. It allows filtering by company ID, query string, country, and pagination parameters.
         * @summary Get list of all invoice contacts
         * @param {string} companyId companyId
         * @param {string} [query] Query search for Name, Street, Postcode, Org, City, State, telephone, fax, email
         * @param {FindInvoiceContactsCountryEnum} [country] 
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findInvoiceContacts: async (companyId: string, query?: string, country?: FindInvoiceContactsCountryEnum, currentPage?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('findInvoiceContacts', 'companyId', companyId)
            const localVarPath = `/invoice-contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an invoice contacts
         * @param {string} id ID
         * @param {string} companyId companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceContact: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getInvoiceContact', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getInvoiceContact', 'companyId', companyId)
            const localVarPath = `/invoice-contacts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to update an existing invoice contact for a specific company. It retrieves the invoice contact by ID and updates its details based on the provided data. It returns a response containing the updated invoice contact or an error response.
         * @summary Update an invoice contact
         * @param {string} id Invoice contact ID
         * @param {string} companyId companyId
         * @param {InvoiceContactRequestDto} invoiceContactRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvoiceContact: async (id: string, companyId: string, invoiceContactRequestDto: InvoiceContactRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateInvoiceContact', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateInvoiceContact', 'companyId', companyId)
            // verify required parameter 'invoiceContactRequestDto' is not null or undefined
            assertParamExists('updateInvoiceContact', 'invoiceContactRequestDto', invoiceContactRequestDto)
            const localVarPath = `/invoice-contacts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(invoiceContactRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoiceContactsApi - functional programming interface
 * @export
 */
export const InvoiceContactsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvoiceContactsApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint allows you to create a new invoice contact for a specific company. It returns a response containing the created invoice contact or an error response.
         * @summary Create a new invoice contact
         * @param {string} companyId companyId
         * @param {InvoiceContactRequestDto} invoiceContactRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInvoiceContact(companyId: string, invoiceContactRequestDto: InvoiceContactRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceContactResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInvoiceContact(companyId, invoiceContactRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoiceContactsApi.createInvoiceContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint allows you to delete an existing invoice contact for a specific company. It retrieves the invoice contact by ID and deletes it. It returns a response indicating the success of the deletion or an error response if the invoice contact is not found.
         * @summary Delete an invoice contact
         * @param {string} id Invoice contact ID
         * @param {string} companyId companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInvoiceContact(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInvoiceContact(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoiceContactsApi.deleteInvoiceContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint retrieves a list of invoice contacts based on the provided parameters. It allows filtering by company ID, query string, country, and pagination parameters.
         * @summary Get list of all invoice contacts
         * @param {string} companyId companyId
         * @param {string} [query] Query search for Name, Street, Postcode, Org, City, State, telephone, fax, email
         * @param {FindInvoiceContactsCountryEnum} [country] 
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findInvoiceContacts(companyId: string, query?: string, country?: FindInvoiceContactsCountryEnum, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InvoiceContactResponseDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findInvoiceContacts(companyId, query, country, currentPage, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoiceContactsApi.findInvoiceContacts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get an invoice contacts
         * @param {string} id ID
         * @param {string} companyId companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoiceContact(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceContactResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoiceContact(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoiceContactsApi.getInvoiceContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint allows you to update an existing invoice contact for a specific company. It retrieves the invoice contact by ID and updates its details based on the provided data. It returns a response containing the updated invoice contact or an error response.
         * @summary Update an invoice contact
         * @param {string} id Invoice contact ID
         * @param {string} companyId companyId
         * @param {InvoiceContactRequestDto} invoiceContactRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateInvoiceContact(id: string, companyId: string, invoiceContactRequestDto: InvoiceContactRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceContactResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateInvoiceContact(id, companyId, invoiceContactRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoiceContactsApi.updateInvoiceContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InvoiceContactsApi - factory interface
 * @export
 */
export const InvoiceContactsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvoiceContactsApiFp(configuration)
    return {
        /**
         * This endpoint allows you to create a new invoice contact for a specific company. It returns a response containing the created invoice contact or an error response.
         * @summary Create a new invoice contact
         * @param {string} companyId companyId
         * @param {InvoiceContactRequestDto} invoiceContactRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceContact(companyId: string, invoiceContactRequestDto: InvoiceContactRequestDto, options?: any): AxiosPromise<InvoiceContactResponseDto> {
            return localVarFp.createInvoiceContact(companyId, invoiceContactRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to delete an existing invoice contact for a specific company. It retrieves the invoice contact by ID and deletes it. It returns a response indicating the success of the deletion or an error response if the invoice contact is not found.
         * @summary Delete an invoice contact
         * @param {string} id Invoice contact ID
         * @param {string} companyId companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceContact(id: string, companyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteInvoiceContact(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint retrieves a list of invoice contacts based on the provided parameters. It allows filtering by company ID, query string, country, and pagination parameters.
         * @summary Get list of all invoice contacts
         * @param {string} companyId companyId
         * @param {string} [query] Query search for Name, Street, Postcode, Org, City, State, telephone, fax, email
         * @param {FindInvoiceContactsCountryEnum} [country] 
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findInvoiceContacts(companyId: string, query?: string, country?: FindInvoiceContactsCountryEnum, currentPage?: number, perPage?: number, options?: any): AxiosPromise<Array<InvoiceContactResponseDto>> {
            return localVarFp.findInvoiceContacts(companyId, query, country, currentPage, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an invoice contacts
         * @param {string} id ID
         * @param {string} companyId companyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceContact(id: string, companyId: string, options?: any): AxiosPromise<InvoiceContactResponseDto> {
            return localVarFp.getInvoiceContact(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to update an existing invoice contact for a specific company. It retrieves the invoice contact by ID and updates its details based on the provided data. It returns a response containing the updated invoice contact or an error response.
         * @summary Update an invoice contact
         * @param {string} id Invoice contact ID
         * @param {string} companyId companyId
         * @param {InvoiceContactRequestDto} invoiceContactRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvoiceContact(id: string, companyId: string, invoiceContactRequestDto: InvoiceContactRequestDto, options?: any): AxiosPromise<InvoiceContactResponseDto> {
            return localVarFp.updateInvoiceContact(id, companyId, invoiceContactRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvoiceContactsApi - object-oriented interface
 * @export
 * @class InvoiceContactsApi
 * @extends {BaseAPI}
 */
export class InvoiceContactsApi extends BaseAPI {
    /**
     * This endpoint allows you to create a new invoice contact for a specific company. It returns a response containing the created invoice contact or an error response.
     * @summary Create a new invoice contact
     * @param {string} companyId companyId
     * @param {InvoiceContactRequestDto} invoiceContactRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceContactsApi
     */
    public createInvoiceContact(companyId: string, invoiceContactRequestDto: InvoiceContactRequestDto, options?: RawAxiosRequestConfig) {
        return InvoiceContactsApiFp(this.configuration).createInvoiceContact(companyId, invoiceContactRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to delete an existing invoice contact for a specific company. It retrieves the invoice contact by ID and deletes it. It returns a response indicating the success of the deletion or an error response if the invoice contact is not found.
     * @summary Delete an invoice contact
     * @param {string} id Invoice contact ID
     * @param {string} companyId companyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceContactsApi
     */
    public deleteInvoiceContact(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return InvoiceContactsApiFp(this.configuration).deleteInvoiceContact(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint retrieves a list of invoice contacts based on the provided parameters. It allows filtering by company ID, query string, country, and pagination parameters.
     * @summary Get list of all invoice contacts
     * @param {string} companyId companyId
     * @param {string} [query] Query search for Name, Street, Postcode, Org, City, State, telephone, fax, email
     * @param {FindInvoiceContactsCountryEnum} [country] 
     * @param {number} [currentPage] current page
     * @param {number} [perPage] per Page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceContactsApi
     */
    public findInvoiceContacts(companyId: string, query?: string, country?: FindInvoiceContactsCountryEnum, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return InvoiceContactsApiFp(this.configuration).findInvoiceContacts(companyId, query, country, currentPage, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an invoice contacts
     * @param {string} id ID
     * @param {string} companyId companyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceContactsApi
     */
    public getInvoiceContact(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return InvoiceContactsApiFp(this.configuration).getInvoiceContact(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to update an existing invoice contact for a specific company. It retrieves the invoice contact by ID and updates its details based on the provided data. It returns a response containing the updated invoice contact or an error response.
     * @summary Update an invoice contact
     * @param {string} id Invoice contact ID
     * @param {string} companyId companyId
     * @param {InvoiceContactRequestDto} invoiceContactRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceContactsApi
     */
    public updateInvoiceContact(id: string, companyId: string, invoiceContactRequestDto: InvoiceContactRequestDto, options?: RawAxiosRequestConfig) {
        return InvoiceContactsApiFp(this.configuration).updateInvoiceContact(id, companyId, invoiceContactRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const FindInvoiceContactsCountryEnum = {
    Af: 'AF',
    Al: 'AL',
    Dz: 'DZ',
    As: 'AS',
    Ad: 'AD',
    Ao: 'AO',
    Ai: 'AI',
    Aq: 'AQ',
    Ag: 'AG',
    Ar: 'AR',
    Am: 'AM',
    Aw: 'AW',
    Au: 'AU',
    At: 'AT',
    Az: 'AZ',
    Bs: 'BS',
    Bh: 'BH',
    Bd: 'BD',
    Bb: 'BB',
    By: 'BY',
    Be: 'BE',
    Bz: 'BZ',
    Bj: 'BJ',
    Bm: 'BM',
    Bt: 'BT',
    Bo: 'BO',
    Bq: 'BQ',
    Ba: 'BA',
    Bw: 'BW',
    Bv: 'BV',
    Br: 'BR',
    Io: 'IO',
    Bn: 'BN',
    Bg: 'BG',
    Bf: 'BF',
    Bi: 'BI',
    Kh: 'KH',
    Cm: 'CM',
    Ca: 'CA',
    Cv: 'CV',
    Ky: 'KY',
    Cf: 'CF',
    Td: 'TD',
    Cl: 'CL',
    Cn: 'CN',
    Cx: 'CX',
    Cc: 'CC',
    Co: 'CO',
    Km: 'KM',
    Cg: 'CG',
    Cd: 'CD',
    Ck: 'CK',
    Cr: 'CR',
    Ci: 'CI',
    Hr: 'HR',
    Cu: 'CU',
    Cw: 'CW',
    Cy: 'CY',
    Cz: 'CZ',
    Dk: 'DK',
    Dj: 'DJ',
    Dm: 'DM',
    Do: 'DO',
    Ec: 'EC',
    Eg: 'EG',
    Sv: 'SV',
    Gq: 'GQ',
    Er: 'ER',
    Ee: 'EE',
    Et: 'ET',
    Fk: 'FK',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Gf: 'GF',
    Pf: 'PF',
    Tf: 'TF',
    Ga: 'GA',
    Gm: 'GM',
    Ge: 'GE',
    De: 'DE',
    Gh: 'GH',
    Gi: 'GI',
    Gr: 'GR',
    Gl: 'GL',
    Gd: 'GD',
    Gp: 'GP',
    Gu: 'GU',
    Gt: 'GT',
    Gg: 'GG',
    Gn: 'GN',
    Gw: 'GW',
    Gy: 'GY',
    Ht: 'HT',
    Hm: 'HM',
    Va: 'VA',
    Hn: 'HN',
    Hk: 'HK',
    Hu: 'HU',
    Is: 'IS',
    In: 'IN',
    Id: 'ID',
    Ir: 'IR',
    Iq: 'IQ',
    Ie: 'IE',
    Im: 'IM',
    Il: 'IL',
    It: 'IT',
    Jm: 'JM',
    Jp: 'JP',
    Je: 'JE',
    Jo: 'JO',
    Kz: 'KZ',
    Ke: 'KE',
    Ki: 'KI',
    Kp: 'KP',
    Kr: 'KR',
    Kw: 'KW',
    Kg: 'KG',
    La: 'LA',
    Lv: 'LV',
    Lb: 'LB',
    Ls: 'LS',
    Lr: 'LR',
    Ly: 'LY',
    Li: 'LI',
    Lt: 'LT',
    Lu: 'LU',
    Mo: 'MO',
    Mk: 'MK',
    Mg: 'MG',
    Mw: 'MW',
    My: 'MY',
    Mv: 'MV',
    Ml: 'ML',
    Mt: 'MT',
    Mh: 'MH',
    Mq: 'MQ',
    Mr: 'MR',
    Mu: 'MU',
    Tn: 'TN',
    Tr: 'TR',
    Tm: 'TM',
    Tc: 'TC',
    Tv: 'TV',
    Ug: 'UG',
    Ua: 'UA',
    Ae: 'AE',
    Gb: 'GB',
    Us: 'US',
    Um: 'UM',
    Uy: 'UY',
    Uz: 'UZ',
    Vu: 'VU',
    Ve: 'VE',
    Vn: 'VN',
    Vg: 'VG',
    Vi: 'VI',
    Wf: 'WF',
    Eh: 'EH',
    Ye: 'YE',
    Zm: 'ZM',
    Zw: 'ZW',
    Yt: 'YT',
    Mx: 'MX',
    Fm: 'FM',
    Md: 'MD',
    Mc: 'MC',
    Mn: 'MN',
    Me: 'ME',
    Ms: 'MS',
    Ma: 'MA',
    Mz: 'MZ',
    Mm: 'MM',
    Na: 'NA',
    Nr: 'NR',
    Np: 'NP',
    Nl: 'NL',
    Nc: 'NC',
    Nz: 'NZ',
    Ni: 'NI',
    Ne: 'NE',
    Ng: 'NG',
    Nu: 'NU',
    Nf: 'NF',
    Mp: 'MP',
    No: 'NO',
    Om: 'OM',
    Pk: 'PK',
    Pw: 'PW',
    Ps: 'PS',
    Pa: 'PA',
    Pg: 'PG',
    Py: 'PY',
    Pe: 'PE',
    Ph: 'PH',
    Pn: 'PN',
    Pl: 'PL',
    Pt: 'PT',
    Pr: 'PR',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Ru: 'RU',
    Rw: 'RW',
    Bl: 'BL',
    Sh: 'SH',
    Kn: 'KN',
    Lc: 'LC',
    Mf: 'MF',
    Pm: 'PM',
    Vc: 'VC',
    Ws: 'WS',
    Sm: 'SM',
    St: 'ST',
    Sa: 'SA',
    Sn: 'SN',
    Rs: 'RS',
    Sc: 'SC',
    Sl: 'SL',
    Sg: 'SG',
    Sx: 'SX',
    Sk: 'SK',
    Si: 'SI',
    Sb: 'SB',
    So: 'SO',
    Za: 'ZA',
    Gs: 'GS',
    Ss: 'SS',
    Es: 'ES',
    Lk: 'LK',
    Sd: 'SD',
    Sr: 'SR',
    Sj: 'SJ',
    Sz: 'SZ',
    Se: 'SE',
    Ch: 'CH',
    Sy: 'SY',
    Tw: 'TW',
    Tj: 'TJ',
    Tz: 'TZ',
    Th: 'TH',
    Tl: 'TL',
    Tg: 'TG',
    Tk: 'TK',
    To: 'TO',
    Tt: 'TT'
} as const;
export type FindInvoiceContactsCountryEnum = typeof FindInvoiceContactsCountryEnum[keyof typeof FindInvoiceContactsCountryEnum];


/**
 * InvoicesApi - axios parameter creator
 * @export
 */
export const InvoicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel an invoice by its ID.
         * @summary Cancel an invoice
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelInvoice: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancelInvoice', 'id', id)
            const localVarPath = `/invoices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export invoices for a company.
         * @summary Export invoices
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportInvoice: async (companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('exportInvoice', 'companyId', companyId)
            const localVarPath = `/invoices/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all invoices for a specific company based on various filter options and pagination.
         * @summary Get list of all invoices
         * @param {string} companyId A unique identifier for the company.
         * @param {FindInvoicesStatusEnum} [status] Filter invoices by status (optional).
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findInvoices: async (companyId: string, status?: FindInvoicesStatusEnum, currentPage?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('findInvoices', 'companyId', companyId)
            const localVarPath = `/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific invoice for a company based on its unique identifier.
         * @summary Get an invoice
         * @param {string} id The unique identifier of the invoice to retrieve.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoice: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getInvoice', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getInvoice', 'companyId', companyId)
            const localVarPath = `/invoices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orderId 
         * @param {string} companyId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceControllerIssueInvoice: async (orderId: string, companyId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('invoiceControllerIssueInvoice', 'orderId', orderId)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('invoiceControllerIssueInvoice', 'companyId', companyId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('invoiceControllerIssueInvoice', 'userId', userId)
            const localVarPath = `/invoices/issue/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoicesApi - functional programming interface
 * @export
 */
export const InvoicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InvoicesApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel an invoice by its ID.
         * @summary Cancel an invoice
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelInvoice(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelInvoice(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.cancelInvoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Export invoices for a company.
         * @summary Export invoices
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportInvoice(companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshSecret200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportInvoice(companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.exportInvoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all invoices for a specific company based on various filter options and pagination.
         * @summary Get list of all invoices
         * @param {string} companyId A unique identifier for the company.
         * @param {FindInvoicesStatusEnum} [status] Filter invoices by status (optional).
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findInvoices(companyId: string, status?: FindInvoicesStatusEnum, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindInvoices200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findInvoices(companyId, status, currentPage, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.findInvoices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific invoice for a company based on its unique identifier.
         * @summary Get an invoice
         * @param {string} id The unique identifier of the invoice to retrieve.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvoice(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvoice200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvoice(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.getInvoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orderId 
         * @param {string} companyId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invoiceControllerIssueInvoice(orderId: string, companyId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invoiceControllerIssueInvoice(orderId, companyId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InvoicesApi.invoiceControllerIssueInvoice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InvoicesApi - factory interface
 * @export
 */
export const InvoicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InvoicesApiFp(configuration)
    return {
        /**
         * Cancel an invoice by its ID.
         * @summary Cancel an invoice
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelInvoice(id: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.cancelInvoice(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Export invoices for a company.
         * @summary Export invoices
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportInvoice(companyId: string, options?: any): AxiosPromise<RefreshSecret200Response> {
            return localVarFp.exportInvoice(companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all invoices for a specific company based on various filter options and pagination.
         * @summary Get list of all invoices
         * @param {string} companyId A unique identifier for the company.
         * @param {FindInvoicesStatusEnum} [status] Filter invoices by status (optional).
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findInvoices(companyId: string, status?: FindInvoicesStatusEnum, currentPage?: number, perPage?: number, options?: any): AxiosPromise<FindInvoices200Response> {
            return localVarFp.findInvoices(companyId, status, currentPage, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific invoice for a company based on its unique identifier.
         * @summary Get an invoice
         * @param {string} id The unique identifier of the invoice to retrieve.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoice(id: string, companyId: string, options?: any): AxiosPromise<GetInvoice200Response> {
            return localVarFp.getInvoice(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orderId 
         * @param {string} companyId 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceControllerIssueInvoice(orderId: string, companyId: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.invoiceControllerIssueInvoice(orderId, companyId, userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InvoicesApi - object-oriented interface
 * @export
 * @class InvoicesApi
 * @extends {BaseAPI}
 */
export class InvoicesApi extends BaseAPI {
    /**
     * Cancel an invoice by its ID.
     * @summary Cancel an invoice
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public cancelInvoice(id: string, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).cancelInvoice(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export invoices for a company.
     * @summary Export invoices
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public exportInvoice(companyId: string, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).exportInvoice(companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all invoices for a specific company based on various filter options and pagination.
     * @summary Get list of all invoices
     * @param {string} companyId A unique identifier for the company.
     * @param {FindInvoicesStatusEnum} [status] Filter invoices by status (optional).
     * @param {number} [currentPage] current page
     * @param {number} [perPage] per Page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public findInvoices(companyId: string, status?: FindInvoicesStatusEnum, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).findInvoices(companyId, status, currentPage, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific invoice for a company based on its unique identifier.
     * @summary Get an invoice
     * @param {string} id The unique identifier of the invoice to retrieve.
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public getInvoice(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).getInvoice(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orderId 
     * @param {string} companyId 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicesApi
     */
    public invoiceControllerIssueInvoice(orderId: string, companyId: string, userId: string, options?: RawAxiosRequestConfig) {
        return InvoicesApiFp(this.configuration).invoiceControllerIssueInvoice(orderId, companyId, userId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const FindInvoicesStatusEnum = {
    Pending: 'PENDING',
    Success: 'SUCCESS',
    Failed: 'FAILED'
} as const;
export type FindInvoicesStatusEnum = typeof FindInvoicesStatusEnum[keyof typeof FindInvoicesStatusEnum];


/**
 * IssuesApi - axios parameter creator
 * @export
 */
export const IssuesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new issue. Returns an IssueResponseDto.
         * @summary Create an issue
         * @param {string} companyId A unique identifier for the company.
         * @param {IssueRequestDto} issueRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIssue: async (companyId: string, issueRequestDto: IssueRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('createIssue', 'companyId', companyId)
            // verify required parameter 'issueRequestDto' is not null or undefined
            assertParamExists('createIssue', 'issueRequestDto', issueRequestDto)
            const localVarPath = `/issues`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(issueRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a certain issue. Returns null.
         * @summary Delete an issue
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id Issue ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIssue: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deleteIssue', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteIssue', 'id', id)
            const localVarPath = `/issues/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all issues. Returns an array of IssueResponseDto.
         * @summary Get list of all issues
         * @param {string} companyId A unique identifier for the company.
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {boolean} [resolved] 
         * @param {FindIssuesIssueCategoryEnum} [issueCategory] 
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findIssues: async (companyId: string, title?: string, description?: string, resolved?: boolean, issueCategory?: FindIssuesIssueCategoryEnum, currentPage?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('findIssues', 'companyId', companyId)
            const localVarPath = `/issues`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (resolved !== undefined) {
                localVarQueryParameter['resolved'] = resolved;
            }

            if (issueCategory !== undefined) {
                localVarQueryParameter['issueCategory'] = issueCategory;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a certain issue. Returns an IssueResponseDto.
         * @summary Get an issue
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIssue: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getIssue', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIssue', 'id', id)
            const localVarPath = `/issues/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} companyId 
         * @param {string} fromDate 
         * @param {string} toDate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuesControllerExportIssuesToCsv: async (companyId: string, fromDate: string, toDate: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('issuesControllerExportIssuesToCsv', 'companyId', companyId)
            // verify required parameter 'fromDate' is not null or undefined
            assertParamExists('issuesControllerExportIssuesToCsv', 'fromDate', fromDate)
            // verify required parameter 'toDate' is not null or undefined
            assertParamExists('issuesControllerExportIssuesToCsv', 'toDate', toDate)
            const localVarPath = `/issues/export-to-csv`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a certain issue. Returns an IssueResponseDto.
         * @summary Update an issue
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id Product Category ID
         * @param {IssueRequestDto} issueRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIssue: async (companyId: string, id: string, issueRequestDto: IssueRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateIssue', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateIssue', 'id', id)
            // verify required parameter 'issueRequestDto' is not null or undefined
            assertParamExists('updateIssue', 'issueRequestDto', issueRequestDto)
            const localVarPath = `/issues/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(issueRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IssuesApi - functional programming interface
 * @export
 */
export const IssuesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IssuesApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new issue. Returns an IssueResponseDto.
         * @summary Create an issue
         * @param {string} companyId A unique identifier for the company.
         * @param {IssueRequestDto} issueRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createIssue(companyId: string, issueRequestDto: IssueRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateIssue201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createIssue(companyId, issueRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssuesApi.createIssue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a certain issue. Returns null.
         * @summary Delete an issue
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id Issue ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteIssue(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteIssue(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssuesApi.deleteIssue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all issues. Returns an array of IssueResponseDto.
         * @summary Get list of all issues
         * @param {string} companyId A unique identifier for the company.
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {boolean} [resolved] 
         * @param {FindIssuesIssueCategoryEnum} [issueCategory] 
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findIssues(companyId: string, title?: string, description?: string, resolved?: boolean, issueCategory?: FindIssuesIssueCategoryEnum, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindIssues200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findIssues(companyId, title, description, resolved, issueCategory, currentPage, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssuesApi.findIssues']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a certain issue. Returns an IssueResponseDto.
         * @summary Get an issue
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIssue(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateIssue201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIssue(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssuesApi.getIssue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} companyId 
         * @param {string} fromDate 
         * @param {string} toDate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issuesControllerExportIssuesToCsv(companyId: string, fromDate: string, toDate: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issuesControllerExportIssuesToCsv(companyId, fromDate, toDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssuesApi.issuesControllerExportIssuesToCsv']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a certain issue. Returns an IssueResponseDto.
         * @summary Update an issue
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id Product Category ID
         * @param {IssueRequestDto} issueRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateIssue(companyId: string, id: string, issueRequestDto: IssueRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateIssue201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateIssue(companyId, id, issueRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IssuesApi.updateIssue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IssuesApi - factory interface
 * @export
 */
export const IssuesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IssuesApiFp(configuration)
    return {
        /**
         * Creates a new issue. Returns an IssueResponseDto.
         * @summary Create an issue
         * @param {string} companyId A unique identifier for the company.
         * @param {IssueRequestDto} issueRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIssue(companyId: string, issueRequestDto: IssueRequestDto, options?: any): AxiosPromise<CreateIssue201Response> {
            return localVarFp.createIssue(companyId, issueRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a certain issue. Returns null.
         * @summary Delete an issue
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id Issue ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIssue(companyId: string, id: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.deleteIssue(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all issues. Returns an array of IssueResponseDto.
         * @summary Get list of all issues
         * @param {string} companyId A unique identifier for the company.
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {boolean} [resolved] 
         * @param {FindIssuesIssueCategoryEnum} [issueCategory] 
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findIssues(companyId: string, title?: string, description?: string, resolved?: boolean, issueCategory?: FindIssuesIssueCategoryEnum, currentPage?: number, perPage?: number, options?: any): AxiosPromise<FindIssues200Response> {
            return localVarFp.findIssues(companyId, title, description, resolved, issueCategory, currentPage, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a certain issue. Returns an IssueResponseDto.
         * @summary Get an issue
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIssue(companyId: string, id: string, options?: any): AxiosPromise<CreateIssue201Response> {
            return localVarFp.getIssue(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} companyId 
         * @param {string} fromDate 
         * @param {string} toDate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuesControllerExportIssuesToCsv(companyId: string, fromDate: string, toDate: string, options?: any): AxiosPromise<void> {
            return localVarFp.issuesControllerExportIssuesToCsv(companyId, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a certain issue. Returns an IssueResponseDto.
         * @summary Update an issue
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id Product Category ID
         * @param {IssueRequestDto} issueRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIssue(companyId: string, id: string, issueRequestDto: IssueRequestDto, options?: any): AxiosPromise<CreateIssue201Response> {
            return localVarFp.updateIssue(companyId, id, issueRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IssuesApi - object-oriented interface
 * @export
 * @class IssuesApi
 * @extends {BaseAPI}
 */
export class IssuesApi extends BaseAPI {
    /**
     * Creates a new issue. Returns an IssueResponseDto.
     * @summary Create an issue
     * @param {string} companyId A unique identifier for the company.
     * @param {IssueRequestDto} issueRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesApi
     */
    public createIssue(companyId: string, issueRequestDto: IssueRequestDto, options?: RawAxiosRequestConfig) {
        return IssuesApiFp(this.configuration).createIssue(companyId, issueRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a certain issue. Returns null.
     * @summary Delete an issue
     * @param {string} companyId A unique identifier for the company.
     * @param {string} id Issue ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesApi
     */
    public deleteIssue(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return IssuesApiFp(this.configuration).deleteIssue(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all issues. Returns an array of IssueResponseDto.
     * @summary Get list of all issues
     * @param {string} companyId A unique identifier for the company.
     * @param {string} [title] 
     * @param {string} [description] 
     * @param {boolean} [resolved] 
     * @param {FindIssuesIssueCategoryEnum} [issueCategory] 
     * @param {number} [currentPage] current page
     * @param {number} [perPage] per Page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesApi
     */
    public findIssues(companyId: string, title?: string, description?: string, resolved?: boolean, issueCategory?: FindIssuesIssueCategoryEnum, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return IssuesApiFp(this.configuration).findIssues(companyId, title, description, resolved, issueCategory, currentPage, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a certain issue. Returns an IssueResponseDto.
     * @summary Get an issue
     * @param {string} companyId A unique identifier for the company.
     * @param {string} id ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesApi
     */
    public getIssue(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return IssuesApiFp(this.configuration).getIssue(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} companyId 
     * @param {string} fromDate 
     * @param {string} toDate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesApi
     */
    public issuesControllerExportIssuesToCsv(companyId: string, fromDate: string, toDate: string, options?: RawAxiosRequestConfig) {
        return IssuesApiFp(this.configuration).issuesControllerExportIssuesToCsv(companyId, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a certain issue. Returns an IssueResponseDto.
     * @summary Update an issue
     * @param {string} companyId A unique identifier for the company.
     * @param {string} id Product Category ID
     * @param {IssueRequestDto} issueRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesApi
     */
    public updateIssue(companyId: string, id: string, issueRequestDto: IssueRequestDto, options?: RawAxiosRequestConfig) {
        return IssuesApiFp(this.configuration).updateIssue(companyId, id, issueRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const FindIssuesIssueCategoryEnum = {
    Order: 'order',
    OrderItem: 'order_item',
    Other: 'other'
} as const;
export type FindIssuesIssueCategoryEnum = typeof FindIssuesIssueCategoryEnum[keyof typeof FindIssuesIssueCategoryEnum];


/**
 * ItemsApi - axios parameter creator
 * @export
 */
export const ItemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add affiliate data to an item. The affiliate must not have already been accepted or paid. Returns a boolean indicating success.
         * @summary Add Affiliate User
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to add affiliate data to.
         * @param {string} companyId A unique identifier for the company.
         * @param {AffiliateDataRequestDto} affiliateDataRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAffiliateUser: async (id: string, companyId: string, affiliateDataRequestDto: AffiliateDataRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addAffiliateUser', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('addAffiliateUser', 'companyId', companyId)
            // verify required parameter 'affiliateDataRequestDto' is not null or undefined
            assertParamExists('addAffiliateUser', 'affiliateDataRequestDto', affiliateDataRequestDto)
            const localVarPath = `/items/{id}/affiliate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(affiliateDataRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific item by its unique ID within a company. Returns the item details.
         * @summary Get Item
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getItem', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItem', 'id', id)
            const localVarPath = `/items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve items that are pending transfer. Validates the hash and checks permissions. Returns an array of items.
         * @summary Get Items For Transfer
         * @param {string} companyid A unique identifier for the company.
         * @param {string} hash Security hash for validating the transfer request.
         * @param {string} receiverId Unique identifier for the receiver user.
         * @param {number} timestamp Timestamp for the transfer request expiration.
         * @param {string} senderId Unique identifier for the sender user.
         * @param {Array<string>} itemids Array of item IDs to be transferred.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsForTransfer: async (companyid: string, hash: string, receiverId: string, timestamp: number, senderId: string, itemids: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyid' is not null or undefined
            assertParamExists('getItemsForTransfer', 'companyid', companyid)
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('getItemsForTransfer', 'hash', hash)
            // verify required parameter 'receiverId' is not null or undefined
            assertParamExists('getItemsForTransfer', 'receiverId', receiverId)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('getItemsForTransfer', 'timestamp', timestamp)
            // verify required parameter 'senderId' is not null or undefined
            assertParamExists('getItemsForTransfer', 'senderId', senderId)
            // verify required parameter 'itemids' is not null or undefined
            assertParamExists('getItemsForTransfer', 'itemids', itemids)
            const localVarPath = `/items/transfer/accept`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyid !== undefined) {
                localVarQueryParameter['companyid'] = companyid;
            }

            if (hash !== undefined) {
                localVarQueryParameter['hash'] = hash;
            }

            if (receiverId !== undefined) {
                localVarQueryParameter['receiver-id'] = receiverId;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (senderId !== undefined) {
                localVarQueryParameter['sender-id'] = senderId;
            }

            if (itemids) {
                localVarQueryParameter['itemids'] = itemids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a paginated list of items for a specific company. Optionally filter by user ID. Returns an array of items with pagination metadata.
         * @summary Get Paginated Items
         * @param {string} companyId A unique identifier for the company.
         * @param {string} [userId] Optional unique identifier for the user. Filter items by user.
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaginatedItems: async (companyId: string, userId?: string, currentPage?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getPaginatedItems', 'companyId', companyId)
            const localVarPath = `/items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accept the transfer of items from one user to another. Validates the hash, checks permissions, and transfers ownership. Returns a boolean indicating success.
         * @summary Item Accept Transfer
         * @param {string} companyid A unique identifier for the company.
         * @param {string} hash Security hash for validating the transfer request.
         * @param {string} receiverId Unique identifier for the receiver user.
         * @param {number} timestamp Timestamp for the transfer request expiration.
         * @param {string} senderId Unique identifier for the sender user.
         * @param {Array<string>} itemids Array of item IDs to be transferred.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemAcceptTransfer: async (companyid: string, hash: string, receiverId: string, timestamp: number, senderId: string, itemids: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyid' is not null or undefined
            assertParamExists('itemAcceptTransfer', 'companyid', companyid)
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('itemAcceptTransfer', 'hash', hash)
            // verify required parameter 'receiverId' is not null or undefined
            assertParamExists('itemAcceptTransfer', 'receiverId', receiverId)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('itemAcceptTransfer', 'timestamp', timestamp)
            // verify required parameter 'senderId' is not null or undefined
            assertParamExists('itemAcceptTransfer', 'senderId', senderId)
            // verify required parameter 'itemids' is not null or undefined
            assertParamExists('itemAcceptTransfer', 'itemids', itemids)
            const localVarPath = `/items/transfer/accept`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyid !== undefined) {
                localVarQueryParameter['companyid'] = companyid;
            }

            if (hash !== undefined) {
                localVarQueryParameter['hash'] = hash;
            }

            if (receiverId !== undefined) {
                localVarQueryParameter['receiver-id'] = receiverId;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (senderId !== undefined) {
                localVarQueryParameter['sender-id'] = senderId;
            }

            if (itemids) {
                localVarQueryParameter['itemids'] = itemids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attach an item to a parent bundle. Both items must belong to the same user and the item end dates must be within 10 days of each other. Returns a boolean indicating success.
         * @summary Item Attach To Bundle
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to attach to bundle.
         * @param {string} companyId A unique identifier for the company.
         * @param {ItemAttachToBundleRequest} itemAttachToBundleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemAttachToBundle: async (id: string, companyId: string, itemAttachToBundleRequest: ItemAttachToBundleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemAttachToBundle', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('itemAttachToBundle', 'companyId', companyId)
            // verify required parameter 'itemAttachToBundleRequest' is not null or undefined
            assertParamExists('itemAttachToBundle', 'itemAttachToBundleRequest', itemAttachToBundleRequest)
            const localVarPath = `/items/{id}/bundles/attach`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemAttachToBundleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel an item. The item must be in idle status and cannot be a bundled child item. Returns a boolean indicating success.
         * @summary Item Cancel
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to cancel.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemCancel: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemCancel', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('itemCancel', 'companyId', companyId)
            const localVarPath = `/items/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} companyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemControllerItemOwnershipCertificate: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemControllerItemOwnershipCertificate', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('itemControllerItemOwnershipCertificate', 'companyId', companyId)
            const localVarPath = `/items/{id}/ownershipCertificate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} companyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemControllerItemTransfer: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemControllerItemTransfer', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('itemControllerItemTransfer', 'companyId', companyId)
            const localVarPath = `/items/{id}/transfer/{userId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an item. The item must be in suspended, soft_deleted, error, canceled, or refunded status and cannot be a bundled child item. Returns no content.
         * @summary Item Delete
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to delete.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemDelete: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemDelete', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('itemDelete', 'companyId', companyId)
            const localVarPath = `/items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Detach a child item from its parent bundle. The item must be a child item and not in inprogress, canceled, or refunded status. Returns a boolean indicating success.
         * @summary Item Detach From Bundle
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to detach from bundle.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemDetachFromBundle: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemDetachFromBundle', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('itemDetachFromBundle', 'companyId', companyId)
            const localVarPath = `/items/{id}/bundles/detach`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Postpone an item\'s end date. The item must be within 10 days of its end date and cannot be a bundled child item. Returns a boolean indicating success.
         * @summary Item Postpone
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to postpone.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemPostpone: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemPostpone', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('itemPostpone', 'companyId', companyId)
            const localVarPath = `/items/{id}/postpone`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retry the action for an item that is in error status. The item status must be error. Returns a boolean indicating success.
         * @summary Item Retry
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to retry.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemRetry: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemRetry', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('itemRetry', 'companyId', companyId)
            const localVarPath = `/items/{id}/retry`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Suspend an item. The item must be in active, expired, trial, or postponed status and cannot be a bundled child item. Returns a boolean indicating success.
         * @summary Item Suspend
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to suspend.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemSuspend: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemSuspend', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('itemSuspend', 'companyId', companyId)
            const localVarPath = `/items/{id}/suspend`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unsuspend an item. The item must be in suspended status and cannot be a bundled child item. Returns a boolean indicating success.
         * @summary Item Unsuspend
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to unsuspend.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemUnsuspend: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemUnsuspend', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('itemUnsuspend', 'companyId', companyId)
            const localVarPath = `/items/{id}/unsuspend`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing item by its unique ID within a company. Provide the updated item data in the request body. Returns a boolean indicating success.
         * @summary Item Update
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to update.
         * @param {string} companyId A unique identifier for the company.
         * @param {ItemUpdateRequestDto} itemUpdateRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemUpdate: async (id: string, companyId: string, itemUpdateRequestDto: ItemUpdateRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemUpdate', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('itemUpdate', 'companyId', companyId)
            // verify required parameter 'itemUpdateRequestDto' is not null or undefined
            assertParamExists('itemUpdate', 'itemUpdateRequestDto', itemUpdateRequestDto)
            const localVarPath = `/items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemUpdateRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove affiliate data from an item. The affiliate must not have already been accepted or paid. Returns a boolean indicating success.
         * @summary Remove Affiliate From Item
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to remove affiliate data from.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAffiliateFromItem: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeAffiliateFromItem', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('removeAffiliateFromItem', 'companyId', companyId)
            const localVarPath = `/items/{id}/affiliate-remove`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore the original price for an item. The item and order must be in idle status. Returns a boolean indicating success.
         * @summary Restore Item Price
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to restore price for.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreItemPrice: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('restoreItemPrice', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('restoreItemPrice', 'companyId', companyId)
            const localVarPath = `/items/{id}/restore-price`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set custom prices for an item. The item must be in idle status and the order must be pending. Returns a boolean indicating success.
         * @summary Set Item Custom Prices
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to set custom prices for.
         * @param {string} companyId A unique identifier for the company.
         * @param {CustomPricesRequestDto} customPricesRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setItemCustomPrices: async (id: string, companyId: string, customPricesRequestDto: CustomPricesRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setItemCustomPrices', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('setItemCustomPrices', 'companyId', companyId)
            // verify required parameter 'customPricesRequestDto' is not null or undefined
            assertParamExists('setItemCustomPrices', 'customPricesRequestDto', customPricesRequestDto)
            const localVarPath = `/items/{id}/custom-prices`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customPricesRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsApi - functional programming interface
 * @export
 */
export const ItemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsApiAxiosParamCreator(configuration)
    return {
        /**
         * Add affiliate data to an item. The affiliate must not have already been accepted or paid. Returns a boolean indicating success.
         * @summary Add Affiliate User
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to add affiliate data to.
         * @param {string} companyId A unique identifier for the company.
         * @param {AffiliateDataRequestDto} affiliateDataRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAffiliateUser(id: string, companyId: string, affiliateDataRequestDto: AffiliateDataRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAffiliateUser(id, companyId, affiliateDataRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.addAffiliateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific item by its unique ID within a company. Returns the item details.
         * @summary Get Item
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItem(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetItem200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItem(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.getItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve items that are pending transfer. Validates the hash and checks permissions. Returns an array of items.
         * @summary Get Items For Transfer
         * @param {string} companyid A unique identifier for the company.
         * @param {string} hash Security hash for validating the transfer request.
         * @param {string} receiverId Unique identifier for the receiver user.
         * @param {number} timestamp Timestamp for the transfer request expiration.
         * @param {string} senderId Unique identifier for the sender user.
         * @param {Array<string>} itemids Array of item IDs to be transferred.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsForTransfer(companyid: string, hash: string, receiverId: string, timestamp: number, senderId: string, itemids: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetItemsForTransfer200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemsForTransfer(companyid, hash, receiverId, timestamp, senderId, itemids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.getItemsForTransfer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a paginated list of items for a specific company. Optionally filter by user ID. Returns an array of items with pagination metadata.
         * @summary Get Paginated Items
         * @param {string} companyId A unique identifier for the company.
         * @param {string} [userId] Optional unique identifier for the user. Filter items by user.
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaginatedItems(companyId: string, userId?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPaginatedItems200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaginatedItems(companyId, userId, currentPage, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.getPaginatedItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Accept the transfer of items from one user to another. Validates the hash, checks permissions, and transfers ownership. Returns a boolean indicating success.
         * @summary Item Accept Transfer
         * @param {string} companyid A unique identifier for the company.
         * @param {string} hash Security hash for validating the transfer request.
         * @param {string} receiverId Unique identifier for the receiver user.
         * @param {number} timestamp Timestamp for the transfer request expiration.
         * @param {string} senderId Unique identifier for the sender user.
         * @param {Array<string>} itemids Array of item IDs to be transferred.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemAcceptTransfer(companyid: string, hash: string, receiverId: string, timestamp: number, senderId: string, itemids: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemAcceptTransfer(companyid, hash, receiverId, timestamp, senderId, itemids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.itemAcceptTransfer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Attach an item to a parent bundle. Both items must belong to the same user and the item end dates must be within 10 days of each other. Returns a boolean indicating success.
         * @summary Item Attach To Bundle
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to attach to bundle.
         * @param {string} companyId A unique identifier for the company.
         * @param {ItemAttachToBundleRequest} itemAttachToBundleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemAttachToBundle(id: string, companyId: string, itemAttachToBundleRequest: ItemAttachToBundleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemAttachToBundle(id, companyId, itemAttachToBundleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.itemAttachToBundle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel an item. The item must be in idle status and cannot be a bundled child item. Returns a boolean indicating success.
         * @summary Item Cancel
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to cancel.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemCancel(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemCancel(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.itemCancel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} companyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemControllerItemOwnershipCertificate(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemControllerItemOwnershipCertificate(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.itemControllerItemOwnershipCertificate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} companyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemControllerItemTransfer(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemControllerItemTransfer(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.itemControllerItemTransfer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an item. The item must be in suspended, soft_deleted, error, canceled, or refunded status and cannot be a bundled child item. Returns no content.
         * @summary Item Delete
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to delete.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemDelete(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemDelete(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.itemDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Detach a child item from its parent bundle. The item must be a child item and not in inprogress, canceled, or refunded status. Returns a boolean indicating success.
         * @summary Item Detach From Bundle
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to detach from bundle.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemDetachFromBundle(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemDetachFromBundle(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.itemDetachFromBundle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Postpone an item\'s end date. The item must be within 10 days of its end date and cannot be a bundled child item. Returns a boolean indicating success.
         * @summary Item Postpone
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to postpone.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemPostpone(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemPostpone(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.itemPostpone']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retry the action for an item that is in error status. The item status must be error. Returns a boolean indicating success.
         * @summary Item Retry
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to retry.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemRetry(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemRetry(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.itemRetry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Suspend an item. The item must be in active, expired, trial, or postponed status and cannot be a bundled child item. Returns a boolean indicating success.
         * @summary Item Suspend
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to suspend.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemSuspend(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemSuspend(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.itemSuspend']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unsuspend an item. The item must be in suspended status and cannot be a bundled child item. Returns a boolean indicating success.
         * @summary Item Unsuspend
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to unsuspend.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemUnsuspend(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemUnsuspend(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.itemUnsuspend']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing item by its unique ID within a company. Provide the updated item data in the request body. Returns a boolean indicating success.
         * @summary Item Update
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to update.
         * @param {string} companyId A unique identifier for the company.
         * @param {ItemUpdateRequestDto} itemUpdateRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemUpdate(id: string, companyId: string, itemUpdateRequestDto: ItemUpdateRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemUpdate(id, companyId, itemUpdateRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.itemUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove affiliate data from an item. The affiliate must not have already been accepted or paid. Returns a boolean indicating success.
         * @summary Remove Affiliate From Item
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to remove affiliate data from.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAffiliateFromItem(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAffiliateFromItem(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.removeAffiliateFromItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Restore the original price for an item. The item and order must be in idle status. Returns a boolean indicating success.
         * @summary Restore Item Price
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to restore price for.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreItemPrice(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreItemPrice(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.restoreItemPrice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set custom prices for an item. The item must be in idle status and the order must be pending. Returns a boolean indicating success.
         * @summary Set Item Custom Prices
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to set custom prices for.
         * @param {string} companyId A unique identifier for the company.
         * @param {CustomPricesRequestDto} customPricesRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setItemCustomPrices(id: string, companyId: string, customPricesRequestDto: CustomPricesRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setItemCustomPrices(id, companyId, customPricesRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.setItemCustomPrices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ItemsApi - factory interface
 * @export
 */
export const ItemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsApiFp(configuration)
    return {
        /**
         * Add affiliate data to an item. The affiliate must not have already been accepted or paid. Returns a boolean indicating success.
         * @summary Add Affiliate User
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to add affiliate data to.
         * @param {string} companyId A unique identifier for the company.
         * @param {AffiliateDataRequestDto} affiliateDataRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAffiliateUser(id: string, companyId: string, affiliateDataRequestDto: AffiliateDataRequestDto, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.addAffiliateUser(id, companyId, affiliateDataRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific item by its unique ID within a company. Returns the item details.
         * @summary Get Item
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem(companyId: string, id: string, options?: any): AxiosPromise<GetItem200Response> {
            return localVarFp.getItem(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve items that are pending transfer. Validates the hash and checks permissions. Returns an array of items.
         * @summary Get Items For Transfer
         * @param {string} companyid A unique identifier for the company.
         * @param {string} hash Security hash for validating the transfer request.
         * @param {string} receiverId Unique identifier for the receiver user.
         * @param {number} timestamp Timestamp for the transfer request expiration.
         * @param {string} senderId Unique identifier for the sender user.
         * @param {Array<string>} itemids Array of item IDs to be transferred.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsForTransfer(companyid: string, hash: string, receiverId: string, timestamp: number, senderId: string, itemids: Array<string>, options?: any): AxiosPromise<GetItemsForTransfer200Response> {
            return localVarFp.getItemsForTransfer(companyid, hash, receiverId, timestamp, senderId, itemids, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a paginated list of items for a specific company. Optionally filter by user ID. Returns an array of items with pagination metadata.
         * @summary Get Paginated Items
         * @param {string} companyId A unique identifier for the company.
         * @param {string} [userId] Optional unique identifier for the user. Filter items by user.
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaginatedItems(companyId: string, userId?: string, currentPage?: number, perPage?: number, options?: any): AxiosPromise<GetPaginatedItems200Response> {
            return localVarFp.getPaginatedItems(companyId, userId, currentPage, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Accept the transfer of items from one user to another. Validates the hash, checks permissions, and transfers ownership. Returns a boolean indicating success.
         * @summary Item Accept Transfer
         * @param {string} companyid A unique identifier for the company.
         * @param {string} hash Security hash for validating the transfer request.
         * @param {string} receiverId Unique identifier for the receiver user.
         * @param {number} timestamp Timestamp for the transfer request expiration.
         * @param {string} senderId Unique identifier for the sender user.
         * @param {Array<string>} itemids Array of item IDs to be transferred.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemAcceptTransfer(companyid: string, hash: string, receiverId: string, timestamp: number, senderId: string, itemids: Array<string>, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.itemAcceptTransfer(companyid, hash, receiverId, timestamp, senderId, itemids, options).then((request) => request(axios, basePath));
        },
        /**
         * Attach an item to a parent bundle. Both items must belong to the same user and the item end dates must be within 10 days of each other. Returns a boolean indicating success.
         * @summary Item Attach To Bundle
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to attach to bundle.
         * @param {string} companyId A unique identifier for the company.
         * @param {ItemAttachToBundleRequest} itemAttachToBundleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemAttachToBundle(id: string, companyId: string, itemAttachToBundleRequest: ItemAttachToBundleRequest, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.itemAttachToBundle(id, companyId, itemAttachToBundleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel an item. The item must be in idle status and cannot be a bundled child item. Returns a boolean indicating success.
         * @summary Item Cancel
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to cancel.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemCancel(id: string, companyId: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.itemCancel(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} companyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemControllerItemOwnershipCertificate(id: string, companyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.itemControllerItemOwnershipCertificate(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} companyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemControllerItemTransfer(id: string, companyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.itemControllerItemTransfer(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an item. The item must be in suspended, soft_deleted, error, canceled, or refunded status and cannot be a bundled child item. Returns no content.
         * @summary Item Delete
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to delete.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemDelete(id: string, companyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.itemDelete(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Detach a child item from its parent bundle. The item must be a child item and not in inprogress, canceled, or refunded status. Returns a boolean indicating success.
         * @summary Item Detach From Bundle
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to detach from bundle.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemDetachFromBundle(id: string, companyId: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.itemDetachFromBundle(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Postpone an item\'s end date. The item must be within 10 days of its end date and cannot be a bundled child item. Returns a boolean indicating success.
         * @summary Item Postpone
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to postpone.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemPostpone(id: string, companyId: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.itemPostpone(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retry the action for an item that is in error status. The item status must be error. Returns a boolean indicating success.
         * @summary Item Retry
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to retry.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemRetry(id: string, companyId: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.itemRetry(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Suspend an item. The item must be in active, expired, trial, or postponed status and cannot be a bundled child item. Returns a boolean indicating success.
         * @summary Item Suspend
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to suspend.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemSuspend(id: string, companyId: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.itemSuspend(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Unsuspend an item. The item must be in suspended status and cannot be a bundled child item. Returns a boolean indicating success.
         * @summary Item Unsuspend
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to unsuspend.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemUnsuspend(id: string, companyId: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.itemUnsuspend(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing item by its unique ID within a company. Provide the updated item data in the request body. Returns a boolean indicating success.
         * @summary Item Update
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to update.
         * @param {string} companyId A unique identifier for the company.
         * @param {ItemUpdateRequestDto} itemUpdateRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemUpdate(id: string, companyId: string, itemUpdateRequestDto: ItemUpdateRequestDto, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.itemUpdate(id, companyId, itemUpdateRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove affiliate data from an item. The affiliate must not have already been accepted or paid. Returns a boolean indicating success.
         * @summary Remove Affiliate From Item
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to remove affiliate data from.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAffiliateFromItem(id: string, companyId: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.removeAffiliateFromItem(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore the original price for an item. The item and order must be in idle status. Returns a boolean indicating success.
         * @summary Restore Item Price
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to restore price for.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreItemPrice(id: string, companyId: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.restoreItemPrice(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Set custom prices for an item. The item must be in idle status and the order must be pending. Returns a boolean indicating success.
         * @summary Set Item Custom Prices
         * @param {string} id A unique identifier for the item. Use this parameter to specify which item to set custom prices for.
         * @param {string} companyId A unique identifier for the company.
         * @param {CustomPricesRequestDto} customPricesRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setItemCustomPrices(id: string, companyId: string, customPricesRequestDto: CustomPricesRequestDto, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.setItemCustomPrices(id, companyId, customPricesRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsApi - object-oriented interface
 * @export
 * @class ItemsApi
 * @extends {BaseAPI}
 */
export class ItemsApi extends BaseAPI {
    /**
     * Add affiliate data to an item. The affiliate must not have already been accepted or paid. Returns a boolean indicating success.
     * @summary Add Affiliate User
     * @param {string} id A unique identifier for the item. Use this parameter to specify which item to add affiliate data to.
     * @param {string} companyId A unique identifier for the company.
     * @param {AffiliateDataRequestDto} affiliateDataRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public addAffiliateUser(id: string, companyId: string, affiliateDataRequestDto: AffiliateDataRequestDto, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).addAffiliateUser(id, companyId, affiliateDataRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific item by its unique ID within a company. Returns the item details.
     * @summary Get Item
     * @param {string} companyId A unique identifier for the company.
     * @param {string} id A unique identifier for the item. Use this parameter to specify which item to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public getItem(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).getItem(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve items that are pending transfer. Validates the hash and checks permissions. Returns an array of items.
     * @summary Get Items For Transfer
     * @param {string} companyid A unique identifier for the company.
     * @param {string} hash Security hash for validating the transfer request.
     * @param {string} receiverId Unique identifier for the receiver user.
     * @param {number} timestamp Timestamp for the transfer request expiration.
     * @param {string} senderId Unique identifier for the sender user.
     * @param {Array<string>} itemids Array of item IDs to be transferred.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public getItemsForTransfer(companyid: string, hash: string, receiverId: string, timestamp: number, senderId: string, itemids: Array<string>, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).getItemsForTransfer(companyid, hash, receiverId, timestamp, senderId, itemids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a paginated list of items for a specific company. Optionally filter by user ID. Returns an array of items with pagination metadata.
     * @summary Get Paginated Items
     * @param {string} companyId A unique identifier for the company.
     * @param {string} [userId] Optional unique identifier for the user. Filter items by user.
     * @param {number} [currentPage] current page
     * @param {number} [perPage] per Page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public getPaginatedItems(companyId: string, userId?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).getPaginatedItems(companyId, userId, currentPage, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accept the transfer of items from one user to another. Validates the hash, checks permissions, and transfers ownership. Returns a boolean indicating success.
     * @summary Item Accept Transfer
     * @param {string} companyid A unique identifier for the company.
     * @param {string} hash Security hash for validating the transfer request.
     * @param {string} receiverId Unique identifier for the receiver user.
     * @param {number} timestamp Timestamp for the transfer request expiration.
     * @param {string} senderId Unique identifier for the sender user.
     * @param {Array<string>} itemids Array of item IDs to be transferred.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemAcceptTransfer(companyid: string, hash: string, receiverId: string, timestamp: number, senderId: string, itemids: Array<string>, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).itemAcceptTransfer(companyid, hash, receiverId, timestamp, senderId, itemids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Attach an item to a parent bundle. Both items must belong to the same user and the item end dates must be within 10 days of each other. Returns a boolean indicating success.
     * @summary Item Attach To Bundle
     * @param {string} id A unique identifier for the item. Use this parameter to specify which item to attach to bundle.
     * @param {string} companyId A unique identifier for the company.
     * @param {ItemAttachToBundleRequest} itemAttachToBundleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemAttachToBundle(id: string, companyId: string, itemAttachToBundleRequest: ItemAttachToBundleRequest, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).itemAttachToBundle(id, companyId, itemAttachToBundleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel an item. The item must be in idle status and cannot be a bundled child item. Returns a boolean indicating success.
     * @summary Item Cancel
     * @param {string} id A unique identifier for the item. Use this parameter to specify which item to cancel.
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemCancel(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).itemCancel(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} companyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemControllerItemOwnershipCertificate(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).itemControllerItemOwnershipCertificate(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} companyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemControllerItemTransfer(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).itemControllerItemTransfer(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an item. The item must be in suspended, soft_deleted, error, canceled, or refunded status and cannot be a bundled child item. Returns no content.
     * @summary Item Delete
     * @param {string} id A unique identifier for the item. Use this parameter to specify which item to delete.
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemDelete(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).itemDelete(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Detach a child item from its parent bundle. The item must be a child item and not in inprogress, canceled, or refunded status. Returns a boolean indicating success.
     * @summary Item Detach From Bundle
     * @param {string} id A unique identifier for the item. Use this parameter to specify which item to detach from bundle.
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemDetachFromBundle(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).itemDetachFromBundle(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Postpone an item\'s end date. The item must be within 10 days of its end date and cannot be a bundled child item. Returns a boolean indicating success.
     * @summary Item Postpone
     * @param {string} id A unique identifier for the item. Use this parameter to specify which item to postpone.
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemPostpone(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).itemPostpone(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retry the action for an item that is in error status. The item status must be error. Returns a boolean indicating success.
     * @summary Item Retry
     * @param {string} id A unique identifier for the item. Use this parameter to specify which item to retry.
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemRetry(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).itemRetry(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Suspend an item. The item must be in active, expired, trial, or postponed status and cannot be a bundled child item. Returns a boolean indicating success.
     * @summary Item Suspend
     * @param {string} id A unique identifier for the item. Use this parameter to specify which item to suspend.
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemSuspend(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).itemSuspend(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unsuspend an item. The item must be in suspended status and cannot be a bundled child item. Returns a boolean indicating success.
     * @summary Item Unsuspend
     * @param {string} id A unique identifier for the item. Use this parameter to specify which item to unsuspend.
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemUnsuspend(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).itemUnsuspend(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing item by its unique ID within a company. Provide the updated item data in the request body. Returns a boolean indicating success.
     * @summary Item Update
     * @param {string} id A unique identifier for the item. Use this parameter to specify which item to update.
     * @param {string} companyId A unique identifier for the company.
     * @param {ItemUpdateRequestDto} itemUpdateRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public itemUpdate(id: string, companyId: string, itemUpdateRequestDto: ItemUpdateRequestDto, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).itemUpdate(id, companyId, itemUpdateRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove affiliate data from an item. The affiliate must not have already been accepted or paid. Returns a boolean indicating success.
     * @summary Remove Affiliate From Item
     * @param {string} id A unique identifier for the item. Use this parameter to specify which item to remove affiliate data from.
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public removeAffiliateFromItem(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).removeAffiliateFromItem(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore the original price for an item. The item and order must be in idle status. Returns a boolean indicating success.
     * @summary Restore Item Price
     * @param {string} id A unique identifier for the item. Use this parameter to specify which item to restore price for.
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public restoreItemPrice(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).restoreItemPrice(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set custom prices for an item. The item must be in idle status and the order must be pending. Returns a boolean indicating success.
     * @summary Set Item Custom Prices
     * @param {string} id A unique identifier for the item. Use this parameter to specify which item to set custom prices for.
     * @param {string} companyId A unique identifier for the company.
     * @param {CustomPricesRequestDto} customPricesRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public setItemCustomPrices(id: string, companyId: string, customPricesRequestDto: CustomPricesRequestDto, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).setItemCustomPrices(id, companyId, customPricesRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NotifyIntegrationsApi - axios parameter creator
 * @export
 */
export const NotifyIntegrationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyIntegrationsNotifyIntegrations: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events/user/created/notify-integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotifyIntegrationsApi - functional programming interface
 * @export
 */
export const NotifyIntegrationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotifyIntegrationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notifyIntegrationsNotifyIntegrations(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notifyIntegrationsNotifyIntegrations(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotifyIntegrationsApi.notifyIntegrationsNotifyIntegrations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NotifyIntegrationsApi - factory interface
 * @export
 */
export const NotifyIntegrationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotifyIntegrationsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyIntegrationsNotifyIntegrations(options?: any): AxiosPromise<void> {
            return localVarFp.notifyIntegrationsNotifyIntegrations(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotifyIntegrationsApi - object-oriented interface
 * @export
 * @class NotifyIntegrationsApi
 * @extends {BaseAPI}
 */
export class NotifyIntegrationsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotifyIntegrationsApi
     */
    public notifyIntegrationsNotifyIntegrations(options?: RawAxiosRequestConfig) {
        return NotifyIntegrationsApiFp(this.configuration).notifyIntegrationsNotifyIntegrations(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrdersApi - axios parameter creator
 * @export
 */
export const OrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {string} companyId 
         * @param {ItemRequestDto} itemRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerAddItem: async (id: string, companyId: string, itemRequestDto: ItemRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orderControllerAddItem', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('orderControllerAddItem', 'companyId', companyId)
            // verify required parameter 'itemRequestDto' is not null or undefined
            assertParamExists('orderControllerAddItem', 'itemRequestDto', itemRequestDto)
            const localVarPath = `/orders/{id}/add-item`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} companyId 
         * @param {string} newInvoiceContactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerChangeInvoiceContact: async (id: string, companyId: string, newInvoiceContactId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orderControllerChangeInvoiceContact', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('orderControllerChangeInvoiceContact', 'companyId', companyId)
            // verify required parameter 'newInvoiceContactId' is not null or undefined
            assertParamExists('orderControllerChangeInvoiceContact', 'newInvoiceContactId', newInvoiceContactId)
            const localVarPath = `/orders/{id}/invoice-contact/{newInvoiceContactId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"newInvoiceContactId"}}`, encodeURIComponent(String(newInvoiceContactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} companyId 
         * @param {OrderRequestDto} orderRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerCreateOrder: async (companyId: string, orderRequestDto: OrderRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('orderControllerCreateOrder', 'companyId', companyId)
            // verify required parameter 'orderRequestDto' is not null or undefined
            assertParamExists('orderControllerCreateOrder', 'orderRequestDto', orderRequestDto)
            const localVarPath = `/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} companyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerDeleteOrder: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orderControllerDeleteOrder', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('orderControllerDeleteOrder', 'companyId', companyId)
            const localVarPath = `/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} companyId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerGetOrder: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('orderControllerGetOrder', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orderControllerGetOrder', 'id', id)
            const localVarPath = `/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} companyId 
         * @param {number} currentPage 
         * @param {number} perPage 
         * @param {string} status 
         * @param {number} orderNumber 
         * @param {boolean} archived 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerGetPaginatedOrders: async (companyId: string, currentPage: number, perPage: number, status: string, orderNumber: number, archived: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('orderControllerGetPaginatedOrders', 'companyId', companyId)
            // verify required parameter 'currentPage' is not null or undefined
            assertParamExists('orderControllerGetPaginatedOrders', 'currentPage', currentPage)
            // verify required parameter 'perPage' is not null or undefined
            assertParamExists('orderControllerGetPaginatedOrders', 'perPage', perPage)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('orderControllerGetPaginatedOrders', 'status', status)
            // verify required parameter 'orderNumber' is not null or undefined
            assertParamExists('orderControllerGetPaginatedOrders', 'orderNumber', orderNumber)
            // verify required parameter 'archived' is not null or undefined
            assertParamExists('orderControllerGetPaginatedOrders', 'archived', archived)
            const localVarPath = `/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (orderNumber !== undefined) {
                localVarQueryParameter['orderNumber'] = orderNumber;
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} companyId 
         * @param {RefundRequestDto} refundRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerItemRefund: async (companyId: string, refundRequestDto: RefundRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('orderControllerItemRefund', 'companyId', companyId)
            // verify required parameter 'refundRequestDto' is not null or undefined
            assertParamExists('orderControllerItemRefund', 'refundRequestDto', refundRequestDto)
            const localVarPath = `/orders/refund`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refundRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} itemId 
         * @param {string} companyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerRemoveItem: async (id: string, itemId: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orderControllerRemoveItem', 'id', id)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('orderControllerRemoveItem', 'itemId', itemId)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('orderControllerRemoveItem', 'companyId', companyId)
            const localVarPath = `/orders/{id}/remove-item/{itemId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} companyId 
         * @param {string} id 
         * @param {Array<string>} emails 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerResendOrderEmail: async (companyId: string, id: string, emails: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('orderControllerResendOrderEmail', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('orderControllerResendOrderEmail', 'id', id)
            // verify required parameter 'emails' is not null or undefined
            assertParamExists('orderControllerResendOrderEmail', 'emails', emails)
            const localVarPath = `/orders/{id}/resend-order-email`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (emails) {
                localVarQueryParameter['emails'] = emails;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} companyId 
         * @param {Array<string>} emails 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerResendPaymentEmail: async (companyId: string, emails: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('orderControllerResendPaymentEmail', 'companyId', companyId)
            // verify required parameter 'emails' is not null or undefined
            assertParamExists('orderControllerResendPaymentEmail', 'emails', emails)
            const localVarPath = `/orders/{id}/resend-payment-email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (emails) {
                localVarQueryParameter['emails'] = emails;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrdersApi - functional programming interface
 * @export
 */
export const OrdersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {string} companyId 
         * @param {ItemRequestDto} itemRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderControllerAddItem(id: string, companyId: string, itemRequestDto: ItemRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderControllerAddItem(id, companyId, itemRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.orderControllerAddItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} companyId 
         * @param {string} newInvoiceContactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderControllerChangeInvoiceContact(id: string, companyId: string, newInvoiceContactId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderControllerChangeInvoiceContact(id, companyId, newInvoiceContactId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.orderControllerChangeInvoiceContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} companyId 
         * @param {OrderRequestDto} orderRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderControllerCreateOrder(companyId: string, orderRequestDto: OrderRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderControllerCreateOrder(companyId, orderRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.orderControllerCreateOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} companyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderControllerDeleteOrder(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderControllerDeleteOrder(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.orderControllerDeleteOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} companyId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderControllerGetOrder(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderControllerGetOrder(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.orderControllerGetOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} companyId 
         * @param {number} currentPage 
         * @param {number} perPage 
         * @param {string} status 
         * @param {number} orderNumber 
         * @param {boolean} archived 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderControllerGetPaginatedOrders(companyId: string, currentPage: number, perPage: number, status: string, orderNumber: number, archived: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderControllerGetPaginatedOrders(companyId, currentPage, perPage, status, orderNumber, archived, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.orderControllerGetPaginatedOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} companyId 
         * @param {RefundRequestDto} refundRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderControllerItemRefund(companyId: string, refundRequestDto: RefundRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderControllerItemRefund(companyId, refundRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.orderControllerItemRefund']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} itemId 
         * @param {string} companyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderControllerRemoveItem(id: string, itemId: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderControllerRemoveItem(id, itemId, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.orderControllerRemoveItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} companyId 
         * @param {string} id 
         * @param {Array<string>} emails 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderControllerResendOrderEmail(companyId: string, id: string, emails: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderControllerResendOrderEmail(companyId, id, emails, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.orderControllerResendOrderEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} companyId 
         * @param {Array<string>} emails 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderControllerResendPaymentEmail(companyId: string, emails: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderControllerResendPaymentEmail(companyId, emails, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.orderControllerResendPaymentEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrdersApi - factory interface
 * @export
 */
export const OrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrdersApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {string} companyId 
         * @param {ItemRequestDto} itemRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerAddItem(id: string, companyId: string, itemRequestDto: ItemRequestDto, options?: any): AxiosPromise<void> {
            return localVarFp.orderControllerAddItem(id, companyId, itemRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} companyId 
         * @param {string} newInvoiceContactId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerChangeInvoiceContact(id: string, companyId: string, newInvoiceContactId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orderControllerChangeInvoiceContact(id, companyId, newInvoiceContactId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} companyId 
         * @param {OrderRequestDto} orderRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerCreateOrder(companyId: string, orderRequestDto: OrderRequestDto, options?: any): AxiosPromise<void> {
            return localVarFp.orderControllerCreateOrder(companyId, orderRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} companyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerDeleteOrder(id: string, companyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orderControllerDeleteOrder(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} companyId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerGetOrder(companyId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.orderControllerGetOrder(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} companyId 
         * @param {number} currentPage 
         * @param {number} perPage 
         * @param {string} status 
         * @param {number} orderNumber 
         * @param {boolean} archived 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerGetPaginatedOrders(companyId: string, currentPage: number, perPage: number, status: string, orderNumber: number, archived: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.orderControllerGetPaginatedOrders(companyId, currentPage, perPage, status, orderNumber, archived, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} companyId 
         * @param {RefundRequestDto} refundRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerItemRefund(companyId: string, refundRequestDto: RefundRequestDto, options?: any): AxiosPromise<void> {
            return localVarFp.orderControllerItemRefund(companyId, refundRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} itemId 
         * @param {string} companyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerRemoveItem(id: string, itemId: string, companyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.orderControllerRemoveItem(id, itemId, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} companyId 
         * @param {string} id 
         * @param {Array<string>} emails 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerResendOrderEmail(companyId: string, id: string, emails: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.orderControllerResendOrderEmail(companyId, id, emails, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} companyId 
         * @param {Array<string>} emails 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderControllerResendPaymentEmail(companyId: string, emails: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.orderControllerResendPaymentEmail(companyId, emails, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
export class OrdersApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {string} companyId 
     * @param {ItemRequestDto} itemRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public orderControllerAddItem(id: string, companyId: string, itemRequestDto: ItemRequestDto, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).orderControllerAddItem(id, companyId, itemRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} companyId 
     * @param {string} newInvoiceContactId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public orderControllerChangeInvoiceContact(id: string, companyId: string, newInvoiceContactId: string, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).orderControllerChangeInvoiceContact(id, companyId, newInvoiceContactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} companyId 
     * @param {OrderRequestDto} orderRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public orderControllerCreateOrder(companyId: string, orderRequestDto: OrderRequestDto, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).orderControllerCreateOrder(companyId, orderRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} companyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public orderControllerDeleteOrder(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).orderControllerDeleteOrder(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} companyId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public orderControllerGetOrder(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).orderControllerGetOrder(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} companyId 
     * @param {number} currentPage 
     * @param {number} perPage 
     * @param {string} status 
     * @param {number} orderNumber 
     * @param {boolean} archived 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public orderControllerGetPaginatedOrders(companyId: string, currentPage: number, perPage: number, status: string, orderNumber: number, archived: boolean, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).orderControllerGetPaginatedOrders(companyId, currentPage, perPage, status, orderNumber, archived, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} companyId 
     * @param {RefundRequestDto} refundRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public orderControllerItemRefund(companyId: string, refundRequestDto: RefundRequestDto, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).orderControllerItemRefund(companyId, refundRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} itemId 
     * @param {string} companyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public orderControllerRemoveItem(id: string, itemId: string, companyId: string, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).orderControllerRemoveItem(id, itemId, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} companyId 
     * @param {string} id 
     * @param {Array<string>} emails 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public orderControllerResendOrderEmail(companyId: string, id: string, emails: Array<string>, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).orderControllerResendOrderEmail(companyId, id, emails, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} companyId 
     * @param {Array<string>} emails 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public orderControllerResendPaymentEmail(companyId: string, emails: Array<string>, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).orderControllerResendPaymentEmail(companyId, emails, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PoliciesApi - axios parameter creator
 * @export
 */
export const PoliciesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new policy for a company. Returns PolicyResponseDto object
         * @summary Create a policy
         * @param {string} companyId A unique identifier for the company.
         * @param {PolicyRequestDto} policyRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicy: async (companyId: string, policyRequestDto: PolicyRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('createPolicy', 'companyId', companyId)
            // verify required parameter 'policyRequestDto' is not null or undefined
            assertParamExists('createPolicy', 'policyRequestDto', policyRequestDto)
            const localVarPath = `/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(policyRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a policy associated with a company. Return true on success
         * @summary Delete a policy
         * @param {string} id The unique identifier of the policy to be deleted.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePolicy: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePolicy', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deletePolicy', 'companyId', companyId)
            const localVarPath = `/policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of policies associated with a specific company. Returns an array of PolicyResponseDto objects
         * @summary Get list of all policies
         * @param {string} companyId A unique identifier for the company.
         * @param {string} [query] A search query to filter policies based on their title or description.
         * @param {boolean} [_default] If set to true, retrieves only default policies. Default is false.
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPolicies: async (companyId: string, query?: string, _default?: boolean, currentPage?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('findPolicies', 'companyId', companyId)
            const localVarPath = `/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (_default !== undefined) {
                localVarQueryParameter['_default'] = _default;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific policy associated with a specific company.Returns PolicyResponseDto object
         * @summary Get a policy
         * @param {string} id The unique identifier of the policy to retrieve.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicy: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPolicy', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getPolicy', 'companyId', companyId)
            const localVarPath = `/policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing policy for a company. Returns updated Policy
         * @summary Update a policy
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id The unique identifier of the policy to be updated.
         * @param {PolicyRequestDto} policyRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicy: async (companyId: string, id: string, policyRequestDto: PolicyRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updatePolicy', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePolicy', 'id', id)
            // verify required parameter 'policyRequestDto' is not null or undefined
            assertParamExists('updatePolicy', 'policyRequestDto', policyRequestDto)
            const localVarPath = `/policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(policyRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PoliciesApi - functional programming interface
 * @export
 */
export const PoliciesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PoliciesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new policy for a company. Returns PolicyResponseDto object
         * @summary Create a policy
         * @param {string} companyId A unique identifier for the company.
         * @param {PolicyRequestDto} policyRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPolicy(companyId: string, policyRequestDto: PolicyRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePolicy201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPolicy(companyId, policyRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.createPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a policy associated with a company. Return true on success
         * @summary Delete a policy
         * @param {string} id The unique identifier of the policy to be deleted.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePolicy(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePolicy(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.deletePolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of policies associated with a specific company. Returns an array of PolicyResponseDto objects
         * @summary Get list of all policies
         * @param {string} companyId A unique identifier for the company.
         * @param {string} [query] A search query to filter policies based on their title or description.
         * @param {boolean} [_default] If set to true, retrieves only default policies. Default is false.
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findPolicies(companyId: string, query?: string, _default?: boolean, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindPolicies200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findPolicies(companyId, query, _default, currentPage, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.findPolicies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific policy associated with a specific company.Returns PolicyResponseDto object
         * @summary Get a policy
         * @param {string} id The unique identifier of the policy to retrieve.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPolicy(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePolicy201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicy(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.getPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing policy for a company. Returns updated Policy
         * @summary Update a policy
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id The unique identifier of the policy to be updated.
         * @param {PolicyRequestDto} policyRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePolicy(companyId: string, id: string, policyRequestDto: PolicyRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePolicy201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePolicy(companyId, id, policyRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.updatePolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PoliciesApi - factory interface
 * @export
 */
export const PoliciesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PoliciesApiFp(configuration)
    return {
        /**
         * Create a new policy for a company. Returns PolicyResponseDto object
         * @summary Create a policy
         * @param {string} companyId A unique identifier for the company.
         * @param {PolicyRequestDto} policyRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicy(companyId: string, policyRequestDto: PolicyRequestDto, options?: any): AxiosPromise<CreatePolicy201Response> {
            return localVarFp.createPolicy(companyId, policyRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a policy associated with a company. Return true on success
         * @summary Delete a policy
         * @param {string} id The unique identifier of the policy to be deleted.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePolicy(id: string, companyId: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.deletePolicy(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of policies associated with a specific company. Returns an array of PolicyResponseDto objects
         * @summary Get list of all policies
         * @param {string} companyId A unique identifier for the company.
         * @param {string} [query] A search query to filter policies based on their title or description.
         * @param {boolean} [_default] If set to true, retrieves only default policies. Default is false.
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPolicies(companyId: string, query?: string, _default?: boolean, currentPage?: number, perPage?: number, options?: any): AxiosPromise<FindPolicies200Response> {
            return localVarFp.findPolicies(companyId, query, _default, currentPage, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific policy associated with a specific company.Returns PolicyResponseDto object
         * @summary Get a policy
         * @param {string} id The unique identifier of the policy to retrieve.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPolicy(id: string, companyId: string, options?: any): AxiosPromise<CreatePolicy201Response> {
            return localVarFp.getPolicy(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing policy for a company. Returns updated Policy
         * @summary Update a policy
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id The unique identifier of the policy to be updated.
         * @param {PolicyRequestDto} policyRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicy(companyId: string, id: string, policyRequestDto: PolicyRequestDto, options?: any): AxiosPromise<CreatePolicy201Response> {
            return localVarFp.updatePolicy(companyId, id, policyRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PoliciesApi - object-oriented interface
 * @export
 * @class PoliciesApi
 * @extends {BaseAPI}
 */
export class PoliciesApi extends BaseAPI {
    /**
     * Create a new policy for a company. Returns PolicyResponseDto object
     * @summary Create a policy
     * @param {string} companyId A unique identifier for the company.
     * @param {PolicyRequestDto} policyRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public createPolicy(companyId: string, policyRequestDto: PolicyRequestDto, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).createPolicy(companyId, policyRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a policy associated with a company. Return true on success
     * @summary Delete a policy
     * @param {string} id The unique identifier of the policy to be deleted.
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public deletePolicy(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).deletePolicy(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of policies associated with a specific company. Returns an array of PolicyResponseDto objects
     * @summary Get list of all policies
     * @param {string} companyId A unique identifier for the company.
     * @param {string} [query] A search query to filter policies based on their title or description.
     * @param {boolean} [_default] If set to true, retrieves only default policies. Default is false.
     * @param {number} [currentPage] current page
     * @param {number} [perPage] per Page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public findPolicies(companyId: string, query?: string, _default?: boolean, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).findPolicies(companyId, query, _default, currentPage, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific policy associated with a specific company.Returns PolicyResponseDto object
     * @summary Get a policy
     * @param {string} id The unique identifier of the policy to retrieve.
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public getPolicy(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).getPolicy(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing policy for a company. Returns updated Policy
     * @summary Update a policy
     * @param {string} companyId A unique identifier for the company.
     * @param {string} id The unique identifier of the policy to be updated.
     * @param {PolicyRequestDto} policyRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public updatePolicy(companyId: string, id: string, policyRequestDto: PolicyRequestDto, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).updatePolicy(companyId, id, policyRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductCategoriesApi - axios parameter creator
 * @export
 */
export const ProductCategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Recieve the unique identifiers of a company(companyId) as well as the information needed for the creation of a product category. it the creates the product category and then returns the product category data as created
         * @summary Create a product category
         * @param {string} companyId A unique identifier for the company.
         * @param {ProductCategoryRequestDto} productCategoryRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductCategory: async (companyId: string, productCategoryRequestDto: ProductCategoryRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('createProductCategory', 'companyId', companyId)
            // verify required parameter 'productCategoryRequestDto' is not null or undefined
            assertParamExists('createProductCategory', 'productCategoryRequestDto', productCategoryRequestDto)
            const localVarPath = `/product-categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productCategoryRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Recieve the unique identifiers of a company(companyId) and the product category(id) and deletes it. It then returns success or not
         * @summary Delete a product category
         * @param {string} id Product Category ID
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductCategory: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProductCategory', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deleteProductCategory', 'companyId', companyId)
            const localVarPath = `/product-categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receive  the unique identifier of the company(companyId) and return all product categories associated with it. In the case of also recieving a query, these categories are filtered based on this query by title and/or description  
         * @summary Get list of all product categories
         * @param {string} companyId A unique identifier for the company.
         * @param {string} [query] A search query to filter results by title and description
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProductCategories: async (companyId: string, query?: string, currentPage?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('findProductCategories', 'companyId', companyId)
            const localVarPath = `/product-categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Recieve the unique identifiers of a company(companyId) and a product category(id) and return the product category information/data.
         * @summary Get a product category
         * @param {string} id  The ID of the product category belonging to the company
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductCategory: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProductCategory', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getProductCategory', 'companyId', companyId)
            const localVarPath = `/product-categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Recieve the unique identifiers of a company(companyId) and a product category(id) as well as the updated Product category data. It then udates it and returns the updated product category information/data
         * @summary Update a product category
         * @param {string} id Product Category ID
         * @param {string} companyId A unique identifier for the company.
         * @param {ProductCategoryRequestDto} productCategoryRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductCategory: async (id: string, companyId: string, productCategoryRequestDto: ProductCategoryRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProductCategory', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateProductCategory', 'companyId', companyId)
            // verify required parameter 'productCategoryRequestDto' is not null or undefined
            assertParamExists('updateProductCategory', 'productCategoryRequestDto', productCategoryRequestDto)
            const localVarPath = `/product-categories/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productCategoryRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductCategoriesApi - functional programming interface
 * @export
 */
export const ProductCategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductCategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         *  Recieve the unique identifiers of a company(companyId) as well as the information needed for the creation of a product category. it the creates the product category and then returns the product category data as created
         * @summary Create a product category
         * @param {string} companyId A unique identifier for the company.
         * @param {ProductCategoryRequestDto} productCategoryRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProductCategory(companyId: string, productCategoryRequestDto: ProductCategoryRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProductCategory201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProductCategory(companyId, productCategoryRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductCategoriesApi.createProductCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Recieve the unique identifiers of a company(companyId) and the product category(id) and deletes it. It then returns success or not
         * @summary Delete a product category
         * @param {string} id Product Category ID
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProductCategory(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProductCategory(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductCategoriesApi.deleteProductCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Receive  the unique identifier of the company(companyId) and return all product categories associated with it. In the case of also recieving a query, these categories are filtered based on this query by title and/or description  
         * @summary Get list of all product categories
         * @param {string} companyId A unique identifier for the company.
         * @param {string} [query] A search query to filter results by title and description
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findProductCategories(companyId: string, query?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindProductCategories200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findProductCategories(companyId, query, currentPage, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductCategoriesApi.findProductCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Recieve the unique identifiers of a company(companyId) and a product category(id) and return the product category information/data.
         * @summary Get a product category
         * @param {string} id  The ID of the product category belonging to the company
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductCategory(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProductCategory201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductCategory(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductCategoriesApi.getProductCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Recieve the unique identifiers of a company(companyId) and a product category(id) as well as the updated Product category data. It then udates it and returns the updated product category information/data
         * @summary Update a product category
         * @param {string} id Product Category ID
         * @param {string} companyId A unique identifier for the company.
         * @param {ProductCategoryRequestDto} productCategoryRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProductCategory(id: string, companyId: string, productCategoryRequestDto: ProductCategoryRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProductCategory201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProductCategory(id, companyId, productCategoryRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductCategoriesApi.updateProductCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductCategoriesApi - factory interface
 * @export
 */
export const ProductCategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductCategoriesApiFp(configuration)
    return {
        /**
         *  Recieve the unique identifiers of a company(companyId) as well as the information needed for the creation of a product category. it the creates the product category and then returns the product category data as created
         * @summary Create a product category
         * @param {string} companyId A unique identifier for the company.
         * @param {ProductCategoryRequestDto} productCategoryRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductCategory(companyId: string, productCategoryRequestDto: ProductCategoryRequestDto, options?: any): AxiosPromise<CreateProductCategory201Response> {
            return localVarFp.createProductCategory(companyId, productCategoryRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         *  Recieve the unique identifiers of a company(companyId) and the product category(id) and deletes it. It then returns success or not
         * @summary Delete a product category
         * @param {string} id Product Category ID
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductCategory(id: string, companyId: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.deleteProductCategory(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Receive  the unique identifier of the company(companyId) and return all product categories associated with it. In the case of also recieving a query, these categories are filtered based on this query by title and/or description  
         * @summary Get list of all product categories
         * @param {string} companyId A unique identifier for the company.
         * @param {string} [query] A search query to filter results by title and description
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProductCategories(companyId: string, query?: string, currentPage?: number, perPage?: number, options?: any): AxiosPromise<FindProductCategories200Response> {
            return localVarFp.findProductCategories(companyId, query, currentPage, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         *  Recieve the unique identifiers of a company(companyId) and a product category(id) and return the product category information/data.
         * @summary Get a product category
         * @param {string} id  The ID of the product category belonging to the company
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductCategory(id: string, companyId: string, options?: any): AxiosPromise<CreateProductCategory201Response> {
            return localVarFp.getProductCategory(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         *  Recieve the unique identifiers of a company(companyId) and a product category(id) as well as the updated Product category data. It then udates it and returns the updated product category information/data
         * @summary Update a product category
         * @param {string} id Product Category ID
         * @param {string} companyId A unique identifier for the company.
         * @param {ProductCategoryRequestDto} productCategoryRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductCategory(id: string, companyId: string, productCategoryRequestDto: ProductCategoryRequestDto, options?: any): AxiosPromise<CreateProductCategory201Response> {
            return localVarFp.updateProductCategory(id, companyId, productCategoryRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductCategoriesApi - object-oriented interface
 * @export
 * @class ProductCategoriesApi
 * @extends {BaseAPI}
 */
export class ProductCategoriesApi extends BaseAPI {
    /**
     *  Recieve the unique identifiers of a company(companyId) as well as the information needed for the creation of a product category. it the creates the product category and then returns the product category data as created
     * @summary Create a product category
     * @param {string} companyId A unique identifier for the company.
     * @param {ProductCategoryRequestDto} productCategoryRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    public createProductCategory(companyId: string, productCategoryRequestDto: ProductCategoryRequestDto, options?: RawAxiosRequestConfig) {
        return ProductCategoriesApiFp(this.configuration).createProductCategory(companyId, productCategoryRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Recieve the unique identifiers of a company(companyId) and the product category(id) and deletes it. It then returns success or not
     * @summary Delete a product category
     * @param {string} id Product Category ID
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    public deleteProductCategory(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ProductCategoriesApiFp(this.configuration).deleteProductCategory(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Receive  the unique identifier of the company(companyId) and return all product categories associated with it. In the case of also recieving a query, these categories are filtered based on this query by title and/or description  
     * @summary Get list of all product categories
     * @param {string} companyId A unique identifier for the company.
     * @param {string} [query] A search query to filter results by title and description
     * @param {number} [currentPage] current page
     * @param {number} [perPage] per Page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    public findProductCategories(companyId: string, query?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return ProductCategoriesApiFp(this.configuration).findProductCategories(companyId, query, currentPage, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Recieve the unique identifiers of a company(companyId) and a product category(id) and return the product category information/data.
     * @summary Get a product category
     * @param {string} id  The ID of the product category belonging to the company
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    public getProductCategory(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ProductCategoriesApiFp(this.configuration).getProductCategory(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Recieve the unique identifiers of a company(companyId) and a product category(id) as well as the updated Product category data. It then udates it and returns the updated product category information/data
     * @summary Update a product category
     * @param {string} id Product Category ID
     * @param {string} companyId A unique identifier for the company.
     * @param {ProductCategoryRequestDto} productCategoryRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoriesApi
     */
    public updateProductCategory(id: string, companyId: string, productCategoryRequestDto: ProductCategoryRequestDto, options?: RawAxiosRequestConfig) {
        return ProductCategoriesApiFp(this.configuration).updateProductCategory(id, companyId, productCategoryRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activates a product.
         * @summary Activate a product
         * @param {string} id A unique identifier for the product.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateProduct: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('activateProduct', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('activateProduct', 'companyId', companyId)
            const localVarPath = `/products/{id}/activate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Archives a product.
         * @summary Archive a product
         * @param {string} id A unique identifier for the product.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveProduct: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('archiveProduct', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('archiveProduct', 'companyId', companyId)
            const localVarPath = `/products/{id}/archive`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new product for a company.
         * @summary Create a product
         * @param {string} companyId A unique identifier for the company.
         * @param {CreateRequestDto} createRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct: async (companyId: string, createRequestDto: CreateRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('createProduct', 'companyId', companyId)
            // verify required parameter 'createRequestDto' is not null or undefined
            assertParamExists('createProduct', 'createRequestDto', createRequestDto)
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deactivates a product.
         * @summary Deactivate a product
         * @param {string} id A unique identifier for the product.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateProduct: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deactivateProduct', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deactivateProduct', 'companyId', companyId)
            const localVarPath = `/products/{id}/deactivate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a product.
         * @summary Delete a product
         * @param {string} id A unique identifier for the product.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProduct', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deleteProduct', 'companyId', companyId)
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a paginated list of products for a specific company. Supports filtering by name and archived status.
         * @summary List products for a company
         * @param {string} companyId A unique identifier for the company.
         * @param {string} [name] Filter products by name.
         * @param {boolean} [archived] Filter products by archived status.
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompanyPaginatedProducts: async (companyId: string, name?: string, archived?: boolean, currentPage?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getCompanyPaginatedProducts', 'companyId', companyId)
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (archived !== undefined) {
                localVarQueryParameter['archived'] = archived;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single product by its ID.
         * @summary Get a product by ID
         * @param {string} id A unique identifier for the product.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProduct', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getProduct', 'companyId', companyId)
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restores an archived product.
         * @summary Restore an archived product
         * @param {string} id A unique identifier for the product.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreArchivedProduct: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('restoreArchivedProduct', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('restoreArchivedProduct', 'companyId', companyId)
            const localVarPath = `/products/{id}/restore-archived`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing product.
         * @summary Update a product
         * @param {string} id A unique identifier for the product.
         * @param {string} companyId A unique identifier for the company.
         * @param {ProductUpdateRequestDto} productUpdateRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct: async (id: string, companyId: string, productUpdateRequestDto: ProductUpdateRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProduct', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateProduct', 'companyId', companyId)
            // verify required parameter 'productUpdateRequestDto' is not null or undefined
            assertParamExists('updateProduct', 'productUpdateRequestDto', productUpdateRequestDto)
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productUpdateRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * Activates a product.
         * @summary Activate a product
         * @param {string} id A unique identifier for the product.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateProduct(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateProduct(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.activateProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Archives a product.
         * @summary Archive a product
         * @param {string} id A unique identifier for the product.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveProduct(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.archiveProduct(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.archiveProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new product for a company.
         * @summary Create a product
         * @param {string} companyId A unique identifier for the company.
         * @param {CreateRequestDto} createRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProduct(companyId: string, createRequestDto: CreateRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateProduct201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProduct(companyId, createRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.createProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deactivates a product.
         * @summary Deactivate a product
         * @param {string} id A unique identifier for the product.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateProduct(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateProduct(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.deactivateProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a product.
         * @summary Delete a product
         * @param {string} id A unique identifier for the product.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProduct(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProduct(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.deleteProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a paginated list of products for a specific company. Supports filtering by name and archived status.
         * @summary List products for a company
         * @param {string} companyId A unique identifier for the company.
         * @param {string} [name] Filter products by name.
         * @param {boolean} [archived] Filter products by archived status.
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCompanyPaginatedProducts(companyId: string, name?: string, archived?: boolean, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCompanyPaginatedProducts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCompanyPaginatedProducts(companyId, name, archived, currentPage, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.getCompanyPaginatedProducts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a single product by its ID.
         * @summary Get a product by ID
         * @param {string} id A unique identifier for the product.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProduct(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProduct200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProduct(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.getProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Restores an archived product.
         * @summary Restore an archived product
         * @param {string} id A unique identifier for the product.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreArchivedProduct(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreArchivedProduct(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.restoreArchivedProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an existing product.
         * @summary Update a product
         * @param {string} id A unique identifier for the product.
         * @param {string} companyId A unique identifier for the company.
         * @param {ProductUpdateRequestDto} productUpdateRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProduct(id: string, companyId: string, productUpdateRequestDto: ProductUpdateRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProduct(id, companyId, productUpdateRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductsApi.updateProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsApiFp(configuration)
    return {
        /**
         * Activates a product.
         * @summary Activate a product
         * @param {string} id A unique identifier for the product.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateProduct(id: string, companyId: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.activateProduct(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Archives a product.
         * @summary Archive a product
         * @param {string} id A unique identifier for the product.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveProduct(id: string, companyId: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.archiveProduct(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new product for a company.
         * @summary Create a product
         * @param {string} companyId A unique identifier for the company.
         * @param {CreateRequestDto} createRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct(companyId: string, createRequestDto: CreateRequestDto, options?: any): AxiosPromise<CreateProduct201Response> {
            return localVarFp.createProduct(companyId, createRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deactivates a product.
         * @summary Deactivate a product
         * @param {string} id A unique identifier for the product.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateProduct(id: string, companyId: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.deactivateProduct(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a product.
         * @summary Delete a product
         * @param {string} id A unique identifier for the product.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct(id: string, companyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProduct(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a paginated list of products for a specific company. Supports filtering by name and archived status.
         * @summary List products for a company
         * @param {string} companyId A unique identifier for the company.
         * @param {string} [name] Filter products by name.
         * @param {boolean} [archived] Filter products by archived status.
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompanyPaginatedProducts(companyId: string, name?: string, archived?: boolean, currentPage?: number, perPage?: number, options?: any): AxiosPromise<GetCompanyPaginatedProducts200Response> {
            return localVarFp.getCompanyPaginatedProducts(companyId, name, archived, currentPage, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single product by its ID.
         * @summary Get a product by ID
         * @param {string} id A unique identifier for the product.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProduct(id: string, companyId: string, options?: any): AxiosPromise<GetProduct200Response> {
            return localVarFp.getProduct(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Restores an archived product.
         * @summary Restore an archived product
         * @param {string} id A unique identifier for the product.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreArchivedProduct(id: string, companyId: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.restoreArchivedProduct(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing product.
         * @summary Update a product
         * @param {string} id A unique identifier for the product.
         * @param {string} companyId A unique identifier for the company.
         * @param {ProductUpdateRequestDto} productUpdateRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct(id: string, companyId: string, productUpdateRequestDto: ProductUpdateRequestDto, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.updateProduct(id, companyId, productUpdateRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * Activates a product.
     * @summary Activate a product
     * @param {string} id A unique identifier for the product.
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public activateProduct(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).activateProduct(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Archives a product.
     * @summary Archive a product
     * @param {string} id A unique identifier for the product.
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public archiveProduct(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).archiveProduct(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new product for a company.
     * @summary Create a product
     * @param {string} companyId A unique identifier for the company.
     * @param {CreateRequestDto} createRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public createProduct(companyId: string, createRequestDto: CreateRequestDto, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).createProduct(companyId, createRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deactivates a product.
     * @summary Deactivate a product
     * @param {string} id A unique identifier for the product.
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public deactivateProduct(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).deactivateProduct(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a product.
     * @summary Delete a product
     * @param {string} id A unique identifier for the product.
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public deleteProduct(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).deleteProduct(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a paginated list of products for a specific company. Supports filtering by name and archived status.
     * @summary List products for a company
     * @param {string} companyId A unique identifier for the company.
     * @param {string} [name] Filter products by name.
     * @param {boolean} [archived] Filter products by archived status.
     * @param {number} [currentPage] current page
     * @param {number} [perPage] per Page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getCompanyPaginatedProducts(companyId: string, name?: string, archived?: boolean, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).getCompanyPaginatedProducts(companyId, name, archived, currentPage, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a single product by its ID.
     * @summary Get a product by ID
     * @param {string} id A unique identifier for the product.
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProduct(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).getProduct(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restores an archived product.
     * @summary Restore an archived product
     * @param {string} id A unique identifier for the product.
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public restoreArchivedProduct(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).restoreArchivedProduct(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing product.
     * @summary Update a product
     * @param {string} id A unique identifier for the product.
     * @param {string} companyId A unique identifier for the company.
     * @param {ProductUpdateRequestDto} productUpdateRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public updateProduct(id: string, companyId: string, productUpdateRequestDto: ProductUpdateRequestDto, options?: RawAxiosRequestConfig) {
        return ProductsApiFp(this.configuration).updateProduct(id, companyId, productUpdateRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PubSubResponseApi - axios parameter creator
 * @export
 */
export const PubSubResponseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pubSubResponseControllerFailureResponse: async (body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('pubSubResponseControllerFailureResponse', 'body', body)
            const localVarPath = `/pubsub-response/failure`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pubSubResponseControllerSuccessResponse: async (body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('pubSubResponseControllerSuccessResponse', 'body', body)
            const localVarPath = `/pubsub-response/success`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PubSubResponseApi - functional programming interface
 * @export
 */
export const PubSubResponseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PubSubResponseApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pubSubResponseControllerFailureResponse(body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pubSubResponseControllerFailureResponse(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PubSubResponseApi.pubSubResponseControllerFailureResponse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pubSubResponseControllerSuccessResponse(body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pubSubResponseControllerSuccessResponse(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PubSubResponseApi.pubSubResponseControllerSuccessResponse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PubSubResponseApi - factory interface
 * @export
 */
export const PubSubResponseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PubSubResponseApiFp(configuration)
    return {
        /**
         * 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pubSubResponseControllerFailureResponse(body: object, options?: any): AxiosPromise<void> {
            return localVarFp.pubSubResponseControllerFailureResponse(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pubSubResponseControllerSuccessResponse(body: object, options?: any): AxiosPromise<void> {
            return localVarFp.pubSubResponseControllerSuccessResponse(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PubSubResponseApi - object-oriented interface
 * @export
 * @class PubSubResponseApi
 * @extends {BaseAPI}
 */
export class PubSubResponseApi extends BaseAPI {
    /**
     * 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PubSubResponseApi
     */
    public pubSubResponseControllerFailureResponse(body: object, options?: RawAxiosRequestConfig) {
        return PubSubResponseApiFp(this.configuration).pubSubResponseControllerFailureResponse(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PubSubResponseApi
     */
    public pubSubResponseControllerSuccessResponse(body: object, options?: RawAxiosRequestConfig) {
        return PubSubResponseApiFp(this.configuration).pubSubResponseControllerSuccessResponse(body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TemplatesApi - axios parameter creator
 * @export
 */
export const TemplatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new template . Returns a TemplateDto.
         * @summary Create a template
         * @param {string} companyId A unique identifier for the company.
         * @param {TemplateRequestDto} templateRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplate: async (companyId: string, templateRequestDto: TemplateRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('createTemplate', 'companyId', companyId)
            // verify required parameter 'templateRequestDto' is not null or undefined
            assertParamExists('createTemplate', 'templateRequestDto', templateRequestDto)
            const localVarPath = `/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(templateRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a certain template. Returns null.
         * @summary Delete a template
         * @param {string} id Template ID
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTemplate', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deleteTemplate', 'companyId', companyId)
            const localVarPath = `/templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list all templates. Returns an array of TemplateResponseDto.
         * @summary Get list of all templates
         * @param {string} companyId A unique identifier for the company.
         * @param {FindTemplatesActionEnum} [action] get templates by action
         * @param {string} [title] 
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTemplates: async (companyId: string, action?: FindTemplatesActionEnum, title?: string, currentPage?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('findTemplates', 'companyId', companyId)
            const localVarPath = `/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a certain template. Returns a TemplateDto.
         * @summary Get a template
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplate: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getTemplate', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTemplate', 'id', id)
            const localVarPath = `/templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a certain template. Returns a TemplateResponseDto.
         * @summary Update a template
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id Template ID
         * @param {TemplateRequestDto} templateRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTemplate: async (companyId: string, id: string, templateRequestDto: TemplateRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateTemplate', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTemplate', 'id', id)
            // verify required parameter 'templateRequestDto' is not null or undefined
            assertParamExists('updateTemplate', 'templateRequestDto', templateRequestDto)
            const localVarPath = `/templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(templateRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplatesApi - functional programming interface
 * @export
 */
export const TemplatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TemplatesApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new template . Returns a TemplateDto.
         * @summary Create a template
         * @param {string} companyId A unique identifier for the company.
         * @param {TemplateRequestDto} templateRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTemplate(companyId: string, templateRequestDto: TemplateRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTemplate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTemplate(companyId, templateRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.createTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a certain template. Returns null.
         * @summary Delete a template
         * @param {string} id Template ID
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTemplate(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTemplate(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.deleteTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list all templates. Returns an array of TemplateResponseDto.
         * @summary Get list of all templates
         * @param {string} companyId A unique identifier for the company.
         * @param {FindTemplatesActionEnum} [action] get templates by action
         * @param {string} [title] 
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTemplates(companyId: string, action?: FindTemplatesActionEnum, title?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindTemplates200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTemplates(companyId, action, title, currentPage, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.findTemplates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a certain template. Returns a TemplateDto.
         * @summary Get a template
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTemplate(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTemplate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTemplate(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.getTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a certain template. Returns a TemplateResponseDto.
         * @summary Update a template
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id Template ID
         * @param {TemplateRequestDto} templateRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTemplate(companyId: string, id: string, templateRequestDto: TemplateRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTemplate201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTemplate(companyId, id, templateRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.updateTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TemplatesApi - factory interface
 * @export
 */
export const TemplatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TemplatesApiFp(configuration)
    return {
        /**
         * Creates a new template . Returns a TemplateDto.
         * @summary Create a template
         * @param {string} companyId A unique identifier for the company.
         * @param {TemplateRequestDto} templateRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplate(companyId: string, templateRequestDto: TemplateRequestDto, options?: any): AxiosPromise<CreateTemplate201Response> {
            return localVarFp.createTemplate(companyId, templateRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a certain template. Returns null.
         * @summary Delete a template
         * @param {string} id Template ID
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate(id: string, companyId: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.deleteTemplate(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list all templates. Returns an array of TemplateResponseDto.
         * @summary Get list of all templates
         * @param {string} companyId A unique identifier for the company.
         * @param {FindTemplatesActionEnum} [action] get templates by action
         * @param {string} [title] 
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTemplates(companyId: string, action?: FindTemplatesActionEnum, title?: string, currentPage?: number, perPage?: number, options?: any): AxiosPromise<FindTemplates200Response> {
            return localVarFp.findTemplates(companyId, action, title, currentPage, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a certain template. Returns a TemplateDto.
         * @summary Get a template
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplate(companyId: string, id: string, options?: any): AxiosPromise<CreateTemplate201Response> {
            return localVarFp.getTemplate(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a certain template. Returns a TemplateResponseDto.
         * @summary Update a template
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id Template ID
         * @param {TemplateRequestDto} templateRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTemplate(companyId: string, id: string, templateRequestDto: TemplateRequestDto, options?: any): AxiosPromise<CreateTemplate201Response> {
            return localVarFp.updateTemplate(companyId, id, templateRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TemplatesApi - object-oriented interface
 * @export
 * @class TemplatesApi
 * @extends {BaseAPI}
 */
export class TemplatesApi extends BaseAPI {
    /**
     * Creates a new template . Returns a TemplateDto.
     * @summary Create a template
     * @param {string} companyId A unique identifier for the company.
     * @param {TemplateRequestDto} templateRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public createTemplate(companyId: string, templateRequestDto: TemplateRequestDto, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).createTemplate(companyId, templateRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a certain template. Returns null.
     * @summary Delete a template
     * @param {string} id Template ID
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public deleteTemplate(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).deleteTemplate(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list all templates. Returns an array of TemplateResponseDto.
     * @summary Get list of all templates
     * @param {string} companyId A unique identifier for the company.
     * @param {FindTemplatesActionEnum} [action] get templates by action
     * @param {string} [title] 
     * @param {number} [currentPage] current page
     * @param {number} [perPage] per Page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public findTemplates(companyId: string, action?: FindTemplatesActionEnum, title?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).findTemplates(companyId, action, title, currentPage, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a certain template. Returns a TemplateDto.
     * @summary Get a template
     * @param {string} companyId A unique identifier for the company.
     * @param {string} id ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public getTemplate(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).getTemplate(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a certain template. Returns a TemplateResponseDto.
     * @summary Update a template
     * @param {string} companyId A unique identifier for the company.
     * @param {string} id Template ID
     * @param {TemplateRequestDto} templateRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public updateTemplate(companyId: string, id: string, templateRequestDto: TemplateRequestDto, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).updateTemplate(companyId, id, templateRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const FindTemplatesActionEnum = {
    Create: 'item/create',
    Suspend: 'item/suspend',
    Unsuspend: 'item/unsuspend',
    Renew: 'item/renew',
    Cancel: 'item/cancel',
    Delete: 'item/delete',
    Upgrade: 'item/upgrade',
    Downgrade: 'item/downgrade'
} as const;
export type FindTemplatesActionEnum = typeof FindTemplatesActionEnum[keyof typeof FindTemplatesActionEnum];


/**
 * TldsApi - axios parameter creator
 * @export
 */
export const TldsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new tld .Returns a TldResponseDto
         * @summary Create a TLD
         * @param {string} companyId 
         * @param {TldRequestDto} tldRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTld: async (companyId: string, tldRequestDto: TldRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('createTld', 'companyId', companyId)
            // verify required parameter 'tldRequestDto' is not null or undefined
            assertParamExists('createTld', 'tldRequestDto', tldRequestDto)
            const localVarPath = `/tlds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tldRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a certain tld .Returns null.
         * @summary Delete a TLD
         * @param {string} companyId 
         * @param {string} id Tld id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTld: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deleteTld', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTld', 'id', id)
            const localVarPath = `/tlds/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all Tlds .Returns an arry of TldResponseDto.
         * @summary Get list of all TLDs
         * @param {string} companyId 
         * @param {string} [tld] tld name
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTlds: async (companyId: string, tld?: string, currentPage?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('findTlds', 'companyId', companyId)
            const localVarPath = `/tlds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (tld !== undefined) {
                localVarQueryParameter['tld'] = tld;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a certain tld .Returns a TldResponseDto
         * @summary Get a TLD
         * @param {string} companyId 
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTld: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getTld', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTld', 'id', id)
            const localVarPath = `/tlds/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a certain tld .Returns a TldResponseDto
         * @summary Update a TLD
         * @param {string} companyId 
         * @param {string} id Tld Id
         * @param {TldRequestDto} tldRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTld: async (companyId: string, id: string, tldRequestDto: TldRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateTld', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTld', 'id', id)
            // verify required parameter 'tldRequestDto' is not null or undefined
            assertParamExists('updateTld', 'tldRequestDto', tldRequestDto)
            const localVarPath = `/tlds/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tldRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TldsApi - functional programming interface
 * @export
 */
export const TldsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TldsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new tld .Returns a TldResponseDto
         * @summary Create a TLD
         * @param {string} companyId 
         * @param {TldRequestDto} tldRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTld(companyId: string, tldRequestDto: TldRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTld201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTld(companyId, tldRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TldsApi.createTld']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a certain tld .Returns null.
         * @summary Delete a TLD
         * @param {string} companyId 
         * @param {string} id Tld id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTld(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTld(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TldsApi.deleteTld']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all Tlds .Returns an arry of TldResponseDto.
         * @summary Get list of all TLDs
         * @param {string} companyId 
         * @param {string} [tld] tld name
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTlds(companyId: string, tld?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindTlds200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTlds(companyId, tld, currentPage, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TldsApi.findTlds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a certain tld .Returns a TldResponseDto
         * @summary Get a TLD
         * @param {string} companyId 
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTld(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTld201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTld(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TldsApi.getTld']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a certain tld .Returns a TldResponseDto
         * @summary Update a TLD
         * @param {string} companyId 
         * @param {string} id Tld Id
         * @param {TldRequestDto} tldRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTld(companyId: string, id: string, tldRequestDto: TldRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTld201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTld(companyId, id, tldRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TldsApi.updateTld']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TldsApi - factory interface
 * @export
 */
export const TldsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TldsApiFp(configuration)
    return {
        /**
         * Creates a new tld .Returns a TldResponseDto
         * @summary Create a TLD
         * @param {string} companyId 
         * @param {TldRequestDto} tldRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTld(companyId: string, tldRequestDto: TldRequestDto, options?: any): AxiosPromise<CreateTld201Response> {
            return localVarFp.createTld(companyId, tldRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a certain tld .Returns null.
         * @summary Delete a TLD
         * @param {string} companyId 
         * @param {string} id Tld id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTld(companyId: string, id: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.deleteTld(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all Tlds .Returns an arry of TldResponseDto.
         * @summary Get list of all TLDs
         * @param {string} companyId 
         * @param {string} [tld] tld name
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTlds(companyId: string, tld?: string, currentPage?: number, perPage?: number, options?: any): AxiosPromise<FindTlds200Response> {
            return localVarFp.findTlds(companyId, tld, currentPage, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a certain tld .Returns a TldResponseDto
         * @summary Get a TLD
         * @param {string} companyId 
         * @param {string} id ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTld(companyId: string, id: string, options?: any): AxiosPromise<CreateTld201Response> {
            return localVarFp.getTld(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a certain tld .Returns a TldResponseDto
         * @summary Update a TLD
         * @param {string} companyId 
         * @param {string} id Tld Id
         * @param {TldRequestDto} tldRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTld(companyId: string, id: string, tldRequestDto: TldRequestDto, options?: any): AxiosPromise<CreateTld201Response> {
            return localVarFp.updateTld(companyId, id, tldRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TldsApi - object-oriented interface
 * @export
 * @class TldsApi
 * @extends {BaseAPI}
 */
export class TldsApi extends BaseAPI {
    /**
     * Creates a new tld .Returns a TldResponseDto
     * @summary Create a TLD
     * @param {string} companyId 
     * @param {TldRequestDto} tldRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TldsApi
     */
    public createTld(companyId: string, tldRequestDto: TldRequestDto, options?: RawAxiosRequestConfig) {
        return TldsApiFp(this.configuration).createTld(companyId, tldRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a certain tld .Returns null.
     * @summary Delete a TLD
     * @param {string} companyId 
     * @param {string} id Tld id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TldsApi
     */
    public deleteTld(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return TldsApiFp(this.configuration).deleteTld(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all Tlds .Returns an arry of TldResponseDto.
     * @summary Get list of all TLDs
     * @param {string} companyId 
     * @param {string} [tld] tld name
     * @param {number} [currentPage] current page
     * @param {number} [perPage] per Page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TldsApi
     */
    public findTlds(companyId: string, tld?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return TldsApiFp(this.configuration).findTlds(companyId, tld, currentPage, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a certain tld .Returns a TldResponseDto
     * @summary Get a TLD
     * @param {string} companyId 
     * @param {string} id ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TldsApi
     */
    public getTld(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return TldsApiFp(this.configuration).getTld(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a certain tld .Returns a TldResponseDto
     * @summary Update a TLD
     * @param {string} companyId 
     * @param {string} id Tld Id
     * @param {TldRequestDto} tldRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TldsApi
     */
    public updateTld(companyId: string, id: string, tldRequestDto: TldRequestDto, options?: RawAxiosRequestConfig) {
        return TldsApiFp(this.configuration).updateTld(companyId, id, tldRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Initiate a transaction with the provided transaction details and obtain a redirect URL for transaction processing. Returns TransactionRedirectUrlDto object
         * @summary Create a transaction
         * @param {string} companyId A unique identifier for the company.
         * @param {TransactionRequestDto} transactionRequestDto Transaction details for the transaction request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransaction: async (companyId: string, transactionRequestDto: TransactionRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('createTransaction', 'companyId', companyId)
            // verify required parameter 'transactionRequestDto' is not null or undefined
            assertParamExists('createTransaction', 'transactionRequestDto', transactionRequestDto)
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a transaction record in the specified company.
         * @summary Delete a transaction
         * @param {string} id The unique identifier of the transaction to be deleted.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransaction: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTransaction', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deleteTransaction', 'companyId', companyId)
            const localVarPath = `/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export a list of transaction for the specified company.
         * @summary Export transactions
         * @param {string} companyId A unique identifier for the company.
         * @param {string} [userId] The unique identifier of the specific user of which the transaction will be exporeted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportTransaction: async (companyId: string, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('exportTransaction', 'companyId', companyId)
            const localVarPath = `/transactions/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of transactions based on various filtering parameters. Returns an array of TransactionResponseDto objects
         * @summary Get list of all transactions
         * @param {string} companyId A unique identifier for the company.
         * @param {string} userId 
         * @param {FindTransactionsTypeEnum} [type] Filter transactions by type.
         * @param {string} [integration] Filter transactions by service integration ID or title.
         * @param {FindTransactionsStatusEnum} [status] Filter transactions by status.
         * @param {number} [fromValue] Filter transactions with values greater than or equal to this value.
         * @param {number} [toValue] Filter transactions with values less than or equal to this value.
         * @param {string} [fromDate] Filter transactions with dates on or after this date (in ISO 8601 format).
         * @param {string} [toDate] Filter transactions with dates on or before this date (in ISO 8601 format).
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTransactions: async (companyId: string, userId: string, type?: FindTransactionsTypeEnum, integration?: string, status?: FindTransactionsStatusEnum, fromValue?: number, toValue?: number, fromDate?: string, toDate?: string, currentPage?: number, perPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('findTransactions', 'companyId', companyId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('findTransactions', 'userId', userId)
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (integration !== undefined) {
                localVarQueryParameter['integration'] = integration;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (fromValue !== undefined) {
                localVarQueryParameter['fromValue'] = fromValue;
            }

            if (toValue !== undefined) {
                localVarQueryParameter['toValue'] = toValue;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve detailed information about a transaction by its unique identifier. Returns TransactionResponseDto object
         * @summary Get a transaction
         * @param {string} id The unique identifier of the transaction.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gettransaction: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gettransaction', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('gettransaction', 'companyId', companyId)
            const localVarPath = `/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing transaction record in the specified company. Returns updated TransactionResponseDto
         * @summary Update a transaction
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id The unique identifier of the transaction to be updated.
         * @param {TransactionRequestDto} transactionRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransaction: async (companyId: string, id: string, transactionRequestDto: TransactionRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateTransaction', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTransaction', 'id', id)
            // verify required parameter 'transactionRequestDto' is not null or undefined
            assertParamExists('updateTransaction', 'transactionRequestDto', transactionRequestDto)
            const localVarPath = `/transactions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Initiate a transaction with the provided transaction details and obtain a redirect URL for transaction processing. Returns TransactionRedirectUrlDto object
         * @summary Create a transaction
         * @param {string} companyId A unique identifier for the company.
         * @param {TransactionRequestDto} transactionRequestDto Transaction details for the transaction request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransaction(companyId: string, transactionRequestDto: TransactionRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateTransaction200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransaction(companyId, transactionRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.createTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a transaction record in the specified company.
         * @summary Delete a transaction
         * @param {string} id The unique identifier of the transaction to be deleted.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTransaction(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Gettransaction200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTransaction(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.deleteTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Export a list of transaction for the specified company.
         * @summary Export transactions
         * @param {string} companyId A unique identifier for the company.
         * @param {string} [userId] The unique identifier of the specific user of which the transaction will be exporeted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportTransaction(companyId: string, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserTransactions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportTransaction(companyId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.exportTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of transactions based on various filtering parameters. Returns an array of TransactionResponseDto objects
         * @summary Get list of all transactions
         * @param {string} companyId A unique identifier for the company.
         * @param {string} userId 
         * @param {FindTransactionsTypeEnum} [type] Filter transactions by type.
         * @param {string} [integration] Filter transactions by service integration ID or title.
         * @param {FindTransactionsStatusEnum} [status] Filter transactions by status.
         * @param {number} [fromValue] Filter transactions with values greater than or equal to this value.
         * @param {number} [toValue] Filter transactions with values less than or equal to this value.
         * @param {string} [fromDate] Filter transactions with dates on or after this date (in ISO 8601 format).
         * @param {string} [toDate] Filter transactions with dates on or before this date (in ISO 8601 format).
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTransactions(companyId: string, userId: string, type?: FindTransactionsTypeEnum, integration?: string, status?: FindTransactionsStatusEnum, fromValue?: number, toValue?: number, fromDate?: string, toDate?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindTransactions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTransactions(companyId, userId, type, integration, status, fromValue, toValue, fromDate, toDate, currentPage, perPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.findTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve detailed information about a transaction by its unique identifier. Returns TransactionResponseDto object
         * @summary Get a transaction
         * @param {string} id The unique identifier of the transaction.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gettransaction(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Gettransaction200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gettransaction(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.gettransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing transaction record in the specified company. Returns updated TransactionResponseDto
         * @summary Update a transaction
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id The unique identifier of the transaction to be updated.
         * @param {TransactionRequestDto} transactionRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTransaction(companyId: string, id: string, transactionRequestDto: TransactionRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Gettransaction200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTransaction(companyId, id, transactionRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.updateTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionsApiFp(configuration)
    return {
        /**
         * Initiate a transaction with the provided transaction details and obtain a redirect URL for transaction processing. Returns TransactionRedirectUrlDto object
         * @summary Create a transaction
         * @param {string} companyId A unique identifier for the company.
         * @param {TransactionRequestDto} transactionRequestDto Transaction details for the transaction request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransaction(companyId: string, transactionRequestDto: TransactionRequestDto, options?: any): AxiosPromise<CreateTransaction200Response> {
            return localVarFp.createTransaction(companyId, transactionRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a transaction record in the specified company.
         * @summary Delete a transaction
         * @param {string} id The unique identifier of the transaction to be deleted.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransaction(id: string, companyId: string, options?: any): AxiosPromise<Gettransaction200Response> {
            return localVarFp.deleteTransaction(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Export a list of transaction for the specified company.
         * @summary Export transactions
         * @param {string} companyId A unique identifier for the company.
         * @param {string} [userId] The unique identifier of the specific user of which the transaction will be exporeted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportTransaction(companyId: string, userId?: string, options?: any): AxiosPromise<GetUserTransactions200Response> {
            return localVarFp.exportTransaction(companyId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of transactions based on various filtering parameters. Returns an array of TransactionResponseDto objects
         * @summary Get list of all transactions
         * @param {string} companyId A unique identifier for the company.
         * @param {string} userId 
         * @param {FindTransactionsTypeEnum} [type] Filter transactions by type.
         * @param {string} [integration] Filter transactions by service integration ID or title.
         * @param {FindTransactionsStatusEnum} [status] Filter transactions by status.
         * @param {number} [fromValue] Filter transactions with values greater than or equal to this value.
         * @param {number} [toValue] Filter transactions with values less than or equal to this value.
         * @param {string} [fromDate] Filter transactions with dates on or after this date (in ISO 8601 format).
         * @param {string} [toDate] Filter transactions with dates on or before this date (in ISO 8601 format).
         * @param {number} [currentPage] current page
         * @param {number} [perPage] per Page 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTransactions(companyId: string, userId: string, type?: FindTransactionsTypeEnum, integration?: string, status?: FindTransactionsStatusEnum, fromValue?: number, toValue?: number, fromDate?: string, toDate?: string, currentPage?: number, perPage?: number, options?: any): AxiosPromise<FindTransactions200Response> {
            return localVarFp.findTransactions(companyId, userId, type, integration, status, fromValue, toValue, fromDate, toDate, currentPage, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve detailed information about a transaction by its unique identifier. Returns TransactionResponseDto object
         * @summary Get a transaction
         * @param {string} id The unique identifier of the transaction.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gettransaction(id: string, companyId: string, options?: any): AxiosPromise<Gettransaction200Response> {
            return localVarFp.gettransaction(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing transaction record in the specified company. Returns updated TransactionResponseDto
         * @summary Update a transaction
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id The unique identifier of the transaction to be updated.
         * @param {TransactionRequestDto} transactionRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTransaction(companyId: string, id: string, transactionRequestDto: TransactionRequestDto, options?: any): AxiosPromise<Gettransaction200Response> {
            return localVarFp.updateTransaction(companyId, id, transactionRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     * Initiate a transaction with the provided transaction details and obtain a redirect URL for transaction processing. Returns TransactionRedirectUrlDto object
     * @summary Create a transaction
     * @param {string} companyId A unique identifier for the company.
     * @param {TransactionRequestDto} transactionRequestDto Transaction details for the transaction request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public createTransaction(companyId: string, transactionRequestDto: TransactionRequestDto, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).createTransaction(companyId, transactionRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a transaction record in the specified company.
     * @summary Delete a transaction
     * @param {string} id The unique identifier of the transaction to be deleted.
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public deleteTransaction(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).deleteTransaction(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export a list of transaction for the specified company.
     * @summary Export transactions
     * @param {string} companyId A unique identifier for the company.
     * @param {string} [userId] The unique identifier of the specific user of which the transaction will be exporeted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public exportTransaction(companyId: string, userId?: string, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).exportTransaction(companyId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of transactions based on various filtering parameters. Returns an array of TransactionResponseDto objects
     * @summary Get list of all transactions
     * @param {string} companyId A unique identifier for the company.
     * @param {string} userId 
     * @param {FindTransactionsTypeEnum} [type] Filter transactions by type.
     * @param {string} [integration] Filter transactions by service integration ID or title.
     * @param {FindTransactionsStatusEnum} [status] Filter transactions by status.
     * @param {number} [fromValue] Filter transactions with values greater than or equal to this value.
     * @param {number} [toValue] Filter transactions with values less than or equal to this value.
     * @param {string} [fromDate] Filter transactions with dates on or after this date (in ISO 8601 format).
     * @param {string} [toDate] Filter transactions with dates on or before this date (in ISO 8601 format).
     * @param {number} [currentPage] current page
     * @param {number} [perPage] per Page 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public findTransactions(companyId: string, userId: string, type?: FindTransactionsTypeEnum, integration?: string, status?: FindTransactionsStatusEnum, fromValue?: number, toValue?: number, fromDate?: string, toDate?: string, currentPage?: number, perPage?: number, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).findTransactions(companyId, userId, type, integration, status, fromValue, toValue, fromDate, toDate, currentPage, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve detailed information about a transaction by its unique identifier. Returns TransactionResponseDto object
     * @summary Get a transaction
     * @param {string} id The unique identifier of the transaction.
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public gettransaction(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).gettransaction(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing transaction record in the specified company. Returns updated TransactionResponseDto
     * @summary Update a transaction
     * @param {string} companyId A unique identifier for the company.
     * @param {string} id The unique identifier of the transaction to be updated.
     * @param {TransactionRequestDto} transactionRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public updateTransaction(companyId: string, id: string, transactionRequestDto: TransactionRequestDto, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).updateTransaction(companyId, id, transactionRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const FindTransactionsTypeEnum = {
    Order: 'ORDER',
    Credits: 'CREDITS'
} as const;
export type FindTransactionsTypeEnum = typeof FindTransactionsTypeEnum[keyof typeof FindTransactionsTypeEnum];
/**
 * @export
 */
export const FindTransactionsStatusEnum = {
    Pending: 'PENDING',
    Processing: 'PROCESSING',
    Completed: 'COMPLETED',
    Cancel: 'CANCEL',
    Error: 'ERROR'
} as const;
export type FindTransactionsStatusEnum = typeof FindTransactionsStatusEnum[keyof typeof FindTransactionsStatusEnum];


/**
 * UpdateOwnerWithCompanyRolesEventsListenerApi - axios parameter creator
 * @export
 */
export const UpdateOwnerWithCompanyRolesEventsListenerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOwnerWithCompanyRolesEventsListenerUpdateOwnerWithCompanyRoles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/events/company/created/update-owner-with-company-roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UpdateOwnerWithCompanyRolesEventsListenerApi - functional programming interface
 * @export
 */
export const UpdateOwnerWithCompanyRolesEventsListenerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UpdateOwnerWithCompanyRolesEventsListenerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOwnerWithCompanyRolesEventsListenerUpdateOwnerWithCompanyRoles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOwnerWithCompanyRolesEventsListenerUpdateOwnerWithCompanyRoles(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UpdateOwnerWithCompanyRolesEventsListenerApi.updateOwnerWithCompanyRolesEventsListenerUpdateOwnerWithCompanyRoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UpdateOwnerWithCompanyRolesEventsListenerApi - factory interface
 * @export
 */
export const UpdateOwnerWithCompanyRolesEventsListenerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UpdateOwnerWithCompanyRolesEventsListenerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOwnerWithCompanyRolesEventsListenerUpdateOwnerWithCompanyRoles(options?: any): AxiosPromise<void> {
            return localVarFp.updateOwnerWithCompanyRolesEventsListenerUpdateOwnerWithCompanyRoles(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UpdateOwnerWithCompanyRolesEventsListenerApi - object-oriented interface
 * @export
 * @class UpdateOwnerWithCompanyRolesEventsListenerApi
 * @extends {BaseAPI}
 */
export class UpdateOwnerWithCompanyRolesEventsListenerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdateOwnerWithCompanyRolesEventsListenerApi
     */
    public updateOwnerWithCompanyRolesEventsListenerUpdateOwnerWithCompanyRoles(options?: RawAxiosRequestConfig) {
        return UpdateOwnerWithCompanyRolesEventsListenerApiFp(this.configuration).updateOwnerWithCompanyRolesEventsListenerUpdateOwnerWithCompanyRoles(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a notification email for a user within a company. Identify the user by their unique ID and provide the new email address as a query parameter. Returns a boolean indicating success.
         * @summary Add notification email
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to retrieve additional notification emails within the specified company.
         * @param {string} companyId A unique identifier for the company.
         * @param {string} newEmail The email to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNotificationEmail: async (id: string, companyId: string, newEmail: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addNotificationEmail', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('addNotificationEmail', 'companyId', companyId)
            // verify required parameter 'newEmail' is not null or undefined
            assertParamExists('addNotificationEmail', 'newEmail', newEmail)
            const localVarPath = `/users/{id}/additional-notification-emails`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (newEmail !== undefined) {
                localVarQueryParameter['newEmail'] = newEmail;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Activate a ban on a user within a specific company. You can specify the user by their unique ID and the company using its unique ID. Returns a boolean indicating success.
         * @summary Ban User
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user you want to ban within the specified company.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        banUser: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('banUser', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('banUser', 'companyId', companyId)
            const localVarPath = `/users/{id}/ban`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a custom token for a user and return it
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customToken: async (companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('customToken', 'companyId', companyId)
            const localVarPath = `/users/custom-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a user related to a specific company. You can specify the user by their unique ID and the company using its unique ID. The operation includes checks for balance, active payments, and parent-child relationships.Returns an empty response.
         * @summary Delete a user
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user you want to delete within the specified company.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUser', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deleteUser', 'companyId', companyId)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all users related to the specified company with optional filters applied. Returns an array of UserResponseDto objects.
         * @summary Get list of all users
         * @param {string} companyId A unique identifier for the company.
         * @param {number} [perPage] per Page 
         * @param {number} [currentPage] current page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompanyPaginatedUsers: async (companyId: string, perPage?: number, currentPage?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getCompanyPaginatedUsers', 'companyId', companyId)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve detailed information about a user related to a specific company using the user\'s unique ID within the company as a parameter. Returns a single UserDto object containing user-related data.
         * @summary Get a user
         * @param {string} id A unique identifier for the user.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUser', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getUser', 'companyId', companyId)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the additional notification emails of a user related to a company. Identify the user by their unique ID and specify the company using the company ID. Returns an array of email addresses.
         * @summary Get additional notification emails of user
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to retrieve additional notification emails within the specified company.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAdditionalNotificationEmails: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserAdditionalNotificationEmails', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getUserAdditionalNotificationEmails', 'companyId', companyId)
            const localVarPath = `/users/{id}/additional-notification-emails`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the balance information for a specific user
         * @summary Get user balance
         * @param {string} id A unique identifier for the user
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBalance: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserBalance', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getUserBalance', 'companyId', companyId)
            const localVarPath = `/users/{id}/get-balance`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve comments related to a user within a company. Identify the user by their unique ID and specify the company using the company ID.Returns an array of comments.
         * @summary Get user comments
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to retrieve comments within the specified company.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserComments: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserComments', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getUserComments', 'companyId', companyId)
            const localVarPath = `/users/{id}/comments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all payments of a user
         * @summary Get user payments
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user on whose profile you want to update the tags within the specified company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTransactions: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getUserTransactions', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserTransactions', 'id', id)
            const localVarPath = `/users/{id}/get-user-transactions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lock the payments for a user within a specific company. You can specify the user by their unique ID and the company using its unique ID. Returns a boolean indicating success.
         * @summary Lock User
         * @param {string} id A unique identifier for the user. Use this parameter to specify which user\&#39;s payments to lock.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockUser: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('lockUser', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('lockUser', 'companyId', companyId)
            const localVarPath = `/users/{id}/lock`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove an additional notification email to a user related to a company. Identify the user by their unique ID and specify the company using the company ID. Returns a boolean indicating success.
         * @summary Remove additional notification emails to user
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to remove additional notification emails within the specified company.
         * @param {string} companyId A unique identifier for the company.
         * @param {string} emailToRemove The email to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserAdditionalNotificationEmails: async (id: string, companyId: string, emailToRemove: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeUserAdditionalNotificationEmails', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('removeUserAdditionalNotificationEmails', 'companyId', companyId)
            // verify required parameter 'emailToRemove' is not null or undefined
            assertParamExists('removeUserAdditionalNotificationEmails', 'emailToRemove', emailToRemove)
            const localVarPath = `/users/{id}/remove-additional-notification-email`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (emailToRemove !== undefined) {
                localVarQueryParameter['emailToRemove'] = emailToRemove;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets a specific credit balance for a user
         * @summary Set user credit balance
         * @param {string} id A unique identifier for the user
         * @param {string} companyId A unique identifier for the company.
         * @param {number} creditBalance The new credit balance to set for the user. Must be a non-negative number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserCreditBalance: async (id: string, companyId: string, creditBalance: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setUserCreditBalance', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('setUserCreditBalance', 'companyId', companyId)
            // verify required parameter 'creditBalance' is not null or undefined
            assertParamExists('setUserCreditBalance', 'creditBalance', creditBalance)
            const localVarPath = `/users/{id}/set-credit-balance`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (creditBalance !== undefined) {
                localVarQueryParameter['creditBalance'] = creditBalance;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unban a previously banned user within a specific company. You can specify the user by their unique ID and the company using its unique ID. Returns a boolean indicating success.
         * @summary Unban User
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user you want to unban within the specified company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbanUser: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('unbanUser', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unbanUser', 'id', id)
            const localVarPath = `/users/{id}/unban`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unlock the payments of a previously locked user within a specific company. You can specify the user by their unique ID and the company using its unique ID.Returns a boolean indicating success.
         * @summary Unlock User
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user whose payments you want to unlock within the specified company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockUser: async (companyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('unlockUser', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unlockUser', 'id', id)
            const localVarPath = `/users/{id}/unlock`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the balance for a specific user
         * @summary Update user balance
         * @param {string} id A unique identifier for the user
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserBalance: async (id: string, companyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserBalance', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateUserBalance', 'companyId', companyId)
            const localVarPath = `/users/{id}/update-balance`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the comments for a user related to a specific company. Use the user ID and company ID to identify the user, and provide the new comments in the body of the request. Returns a boolean indicating success.
         * @summary Update user comments
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to add a comment within the specified company.
         * @param {string} companyId A unique identifier for the company.
         * @param {UpdateUserCommentsRequest} updateUserCommentsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserComments: async (id: string, companyId: string, updateUserCommentsRequest: UpdateUserCommentsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserComments', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateUserComments', 'companyId', companyId)
            // verify required parameter 'updateUserCommentsRequest' is not null or undefined
            assertParamExists('updateUserComments', 'updateUserCommentsRequest', updateUserCommentsRequest)
            const localVarPath = `/users/{id}/comments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserCommentsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add custom price policies to a user related to a company. Identify the user by their unique ID and the company by its unique ID. Provide an array of custom price policies using the request body. Returns a boolean indicating success.
         * @summary Update custom price policies
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user to which you want to add custom price policies within the specified company.
         * @param {string} companyId A unique identifier for the company.
         * @param {Array<UserPricePolicyRequestDto>} userPricePolicyRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserCustomPricePolicies: async (id: string, companyId: string, userPricePolicyRequestDto: Array<UserPricePolicyRequestDto>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserCustomPricePolicies', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateUserCustomPricePolicies', 'companyId', companyId)
            // verify required parameter 'userPricePolicyRequestDto' is not null or undefined
            assertParamExists('updateUserCustomPricePolicies', 'userPricePolicyRequestDto', userPricePolicyRequestDto)
            const localVarPath = `/users/{id}/custom-price-policies`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userPricePolicyRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the invoice contact for a specific user
         * @summary Update user invoice contact
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the user
         * @param {string} invoiceContactId A unique identifier for the invoice contact to be assigned to the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInvoiceContact: async (companyId: string, id: string, invoiceContactId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateUserInvoiceContact', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserInvoiceContact', 'id', id)
            // verify required parameter 'invoiceContactId' is not null or undefined
            assertParamExists('updateUserInvoiceContact', 'invoiceContactId', invoiceContactId)
            const localVarPath = `/users/{id}/invoice-contact`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (invoiceContactId !== undefined) {
                localVarQueryParameter['invoiceContactId'] = invoiceContactId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the invoice interval for a user related to a company. Identify the user by their unique ID and specify the new invoice interval. Returns a boolean indicating success.
         * @summary Update invoice interval
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to update the invoice interval within the specified company.
         * @param {UpdateUserInvoiceIntervalInvoiceIntervalEnum} invoiceInterval The new invoice interval to be set for the user. Choose from available options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInvoiceInterval: async (companyId: string, id: string, invoiceInterval: UpdateUserInvoiceIntervalInvoiceIntervalEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateUserInvoiceInterval', 'companyId', companyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserInvoiceInterval', 'id', id)
            // verify required parameter 'invoiceInterval' is not null or undefined
            assertParamExists('updateUserInvoiceInterval', 'invoiceInterval', invoiceInterval)
            const localVarPath = `/users/{id}/invoice-interval`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (invoiceInterval !== undefined) {
                localVarQueryParameter['invoiceInterval'] = invoiceInterval;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update languages
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user whose preferred languages you want to update within the specified company.
         * @param {string} companyId A unique identifier for the company.
         * @param {UpdateUserLanguagesLanguageEnum} language The new language preference for the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserLanguages: async (id: string, companyId: string, language: UpdateUserLanguagesLanguageEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserLanguages', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateUserLanguages', 'companyId', companyId)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('updateUserLanguages', 'language', language)
            const localVarPath = `/users/{id}/languages`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the tags for a user within a specific company. Identify the user by their unique ID and the company by its unique ID. Provide an array of tags to replace the existing tags on the user\'s profile. Returns a boolean indicating success.
         * @summary Update user tags
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user on whose profile you want to update the tags within the specified company.
         * @param {string} companyId A unique identifier for the company.
         * @param {UpdateUserTagsRequest} updateUserTagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserTags: async (id: string, companyId: string, updateUserTagsRequest: UpdateUserTagsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserTags', 'id', id)
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateUserTags', 'companyId', companyId)
            // verify required parameter 'updateUserTagsRequest' is not null or undefined
            assertParamExists('updateUserTags', 'updateUserTagsRequest', updateUserTagsRequest)
            const localVarPath = `/users/{id}/tags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (companyId !== undefined) {
                localVarQueryParameter['companyId'] = companyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserTagsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a notification email for a user within a company. Identify the user by their unique ID and provide the new email address as a query parameter. Returns a boolean indicating success.
         * @summary Add notification email
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to retrieve additional notification emails within the specified company.
         * @param {string} companyId A unique identifier for the company.
         * @param {string} newEmail The email to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addNotificationEmail(id: string, companyId: string, newEmail: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addNotificationEmail(id, companyId, newEmail, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.addNotificationEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Activate a ban on a user within a specific company. You can specify the user by their unique ID and the company using its unique ID. Returns a boolean indicating success.
         * @summary Ban User
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user you want to ban within the specified company.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async banUser(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.banUser(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.banUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a custom token for a user and return it
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customToken(companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomToken201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customToken(companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.customToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a user related to a specific company. You can specify the user by their unique ID and the company using its unique ID. The operation includes checks for balance, active payments, and parent-child relationships.Returns an empty response.
         * @summary Delete a user
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user you want to delete within the specified company.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.deleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all users related to the specified company with optional filters applied. Returns an array of UserResponseDto objects.
         * @summary Get list of all users
         * @param {string} companyId A unique identifier for the company.
         * @param {number} [perPage] per Page 
         * @param {number} [currentPage] current page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCompanyPaginatedUsers(companyId: string, perPage?: number, currentPage?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCompanyPaginatedUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCompanyPaginatedUsers(companyId, perPage, currentPage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getCompanyPaginatedUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve detailed information about a user related to a specific company using the user\'s unique ID within the company as a parameter. Returns a single UserDto object containing user-related data.
         * @summary Get a user
         * @param {string} id A unique identifier for the user.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the additional notification emails of a user related to a company. Identify the user by their unique ID and specify the company using the company ID. Returns an array of email addresses.
         * @summary Get additional notification emails of user
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to retrieve additional notification emails within the specified company.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAdditionalNotificationEmails(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserAdditionalNotificationEmails200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAdditionalNotificationEmails(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUserAdditionalNotificationEmails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the balance information for a specific user
         * @summary Get user balance
         * @param {string} id A unique identifier for the user
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserBalance(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserBalance200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserBalance(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUserBalance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve comments related to a user within a company. Identify the user by their unique ID and specify the company using the company ID.Returns an array of comments.
         * @summary Get user comments
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to retrieve comments within the specified company.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserComments(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserAdditionalNotificationEmails200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserComments(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUserComments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all payments of a user
         * @summary Get user payments
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user on whose profile you want to update the tags within the specified company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTransactions(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserTransactions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTransactions(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUserTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lock the payments for a user within a specific company. You can specify the user by their unique ID and the company using its unique ID. Returns a boolean indicating success.
         * @summary Lock User
         * @param {string} id A unique identifier for the user. Use this parameter to specify which user\&#39;s payments to lock.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lockUser(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lockUser(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.lockUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove an additional notification email to a user related to a company. Identify the user by their unique ID and specify the company using the company ID. Returns a boolean indicating success.
         * @summary Remove additional notification emails to user
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to remove additional notification emails within the specified company.
         * @param {string} companyId A unique identifier for the company.
         * @param {string} emailToRemove The email to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUserAdditionalNotificationEmails(id: string, companyId: string, emailToRemove: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeUserAdditionalNotificationEmails(id, companyId, emailToRemove, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.removeUserAdditionalNotificationEmails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sets a specific credit balance for a user
         * @summary Set user credit balance
         * @param {string} id A unique identifier for the user
         * @param {string} companyId A unique identifier for the company.
         * @param {number} creditBalance The new credit balance to set for the user. Must be a non-negative number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setUserCreditBalance(id: string, companyId: string, creditBalance: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setUserCreditBalance(id, companyId, creditBalance, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.setUserCreditBalance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unban a previously banned user within a specific company. You can specify the user by their unique ID and the company using its unique ID. Returns a boolean indicating success.
         * @summary Unban User
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user you want to unban within the specified company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unbanUser(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unbanUser(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.unbanUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unlock the payments of a previously locked user within a specific company. You can specify the user by their unique ID and the company using its unique ID.Returns a boolean indicating success.
         * @summary Unlock User
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user whose payments you want to unlock within the specified company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlockUser(companyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlockUser(companyId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.unlockUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the balance for a specific user
         * @summary Update user balance
         * @param {string} id A unique identifier for the user
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserBalance(id: string, companyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserBalance(id, companyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUserBalance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the comments for a user related to a specific company. Use the user ID and company ID to identify the user, and provide the new comments in the body of the request. Returns a boolean indicating success.
         * @summary Update user comments
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to add a comment within the specified company.
         * @param {string} companyId A unique identifier for the company.
         * @param {UpdateUserCommentsRequest} updateUserCommentsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserComments(id: string, companyId: string, updateUserCommentsRequest: UpdateUserCommentsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserComments(id, companyId, updateUserCommentsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUserComments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add custom price policies to a user related to a company. Identify the user by their unique ID and the company by its unique ID. Provide an array of custom price policies using the request body. Returns a boolean indicating success.
         * @summary Update custom price policies
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user to which you want to add custom price policies within the specified company.
         * @param {string} companyId A unique identifier for the company.
         * @param {Array<UserPricePolicyRequestDto>} userPricePolicyRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserCustomPricePolicies(id: string, companyId: string, userPricePolicyRequestDto: Array<UserPricePolicyRequestDto>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserCustomPricePolicies(id, companyId, userPricePolicyRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUserCustomPricePolicies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the invoice contact for a specific user
         * @summary Update user invoice contact
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the user
         * @param {string} invoiceContactId A unique identifier for the invoice contact to be assigned to the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserInvoiceContact(companyId: string, id: string, invoiceContactId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserInvoiceContact(companyId, id, invoiceContactId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUserInvoiceContact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the invoice interval for a user related to a company. Identify the user by their unique ID and specify the new invoice interval. Returns a boolean indicating success.
         * @summary Update invoice interval
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to update the invoice interval within the specified company.
         * @param {UpdateUserInvoiceIntervalInvoiceIntervalEnum} invoiceInterval The new invoice interval to be set for the user. Choose from available options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserInvoiceInterval(companyId: string, id: string, invoiceInterval: UpdateUserInvoiceIntervalInvoiceIntervalEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserInvoiceInterval(companyId, id, invoiceInterval, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUserInvoiceInterval']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update languages
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user whose preferred languages you want to update within the specified company.
         * @param {string} companyId A unique identifier for the company.
         * @param {UpdateUserLanguagesLanguageEnum} language The new language preference for the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserLanguages(id: string, companyId: string, language: UpdateUserLanguagesLanguageEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserLanguages(id, companyId, language, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUserLanguages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the tags for a user within a specific company. Identify the user by their unique ID and the company by its unique ID. Provide an array of tags to replace the existing tags on the user\'s profile. Returns a boolean indicating success.
         * @summary Update user tags
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user on whose profile you want to update the tags within the specified company.
         * @param {string} companyId A unique identifier for the company.
         * @param {UpdateUserTagsRequest} updateUserTagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserTags(id: string, companyId: string, updateUserTagsRequest: UpdateUserTagsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIntegration200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserTags(id, companyId, updateUserTagsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateUserTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Add a notification email for a user within a company. Identify the user by their unique ID and provide the new email address as a query parameter. Returns a boolean indicating success.
         * @summary Add notification email
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to retrieve additional notification emails within the specified company.
         * @param {string} companyId A unique identifier for the company.
         * @param {string} newEmail The email to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNotificationEmail(id: string, companyId: string, newEmail: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.addNotificationEmail(id, companyId, newEmail, options).then((request) => request(axios, basePath));
        },
        /**
         * Activate a ban on a user within a specific company. You can specify the user by their unique ID and the company using its unique ID. Returns a boolean indicating success.
         * @summary Ban User
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user you want to ban within the specified company.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        banUser(id: string, companyId: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.banUser(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a custom token for a user and return it
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customToken(companyId: string, options?: any): AxiosPromise<CustomToken201Response> {
            return localVarFp.customToken(companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a user related to a specific company. You can specify the user by their unique ID and the company using its unique ID. The operation includes checks for balance, active payments, and parent-child relationships.Returns an empty response.
         * @summary Delete a user
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user you want to delete within the specified company.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: string, companyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUser(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all users related to the specified company with optional filters applied. Returns an array of UserResponseDto objects.
         * @summary Get list of all users
         * @param {string} companyId A unique identifier for the company.
         * @param {number} [perPage] per Page 
         * @param {number} [currentPage] current page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompanyPaginatedUsers(companyId: string, perPage?: number, currentPage?: number, options?: any): AxiosPromise<GetCompanyPaginatedUsers200Response> {
            return localVarFp.getCompanyPaginatedUsers(companyId, perPage, currentPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve detailed information about a user related to a specific company using the user\'s unique ID within the company as a parameter. Returns a single UserDto object containing user-related data.
         * @summary Get a user
         * @param {string} id A unique identifier for the user.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: string, companyId: string, options?: any): AxiosPromise<GetUser200Response> {
            return localVarFp.getUser(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the additional notification emails of a user related to a company. Identify the user by their unique ID and specify the company using the company ID. Returns an array of email addresses.
         * @summary Get additional notification emails of user
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to retrieve additional notification emails within the specified company.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAdditionalNotificationEmails(id: string, companyId: string, options?: any): AxiosPromise<GetUserAdditionalNotificationEmails200Response> {
            return localVarFp.getUserAdditionalNotificationEmails(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the balance information for a specific user
         * @summary Get user balance
         * @param {string} id A unique identifier for the user
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBalance(id: string, companyId: string, options?: any): AxiosPromise<GetUserBalance200Response> {
            return localVarFp.getUserBalance(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve comments related to a user within a company. Identify the user by their unique ID and specify the company using the company ID.Returns an array of comments.
         * @summary Get user comments
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to retrieve comments within the specified company.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserComments(id: string, companyId: string, options?: any): AxiosPromise<GetUserAdditionalNotificationEmails200Response> {
            return localVarFp.getUserComments(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all payments of a user
         * @summary Get user payments
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user on whose profile you want to update the tags within the specified company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTransactions(companyId: string, id: string, options?: any): AxiosPromise<GetUserTransactions200Response> {
            return localVarFp.getUserTransactions(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Lock the payments for a user within a specific company. You can specify the user by their unique ID and the company using its unique ID. Returns a boolean indicating success.
         * @summary Lock User
         * @param {string} id A unique identifier for the user. Use this parameter to specify which user\&#39;s payments to lock.
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lockUser(id: string, companyId: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.lockUser(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove an additional notification email to a user related to a company. Identify the user by their unique ID and specify the company using the company ID. Returns a boolean indicating success.
         * @summary Remove additional notification emails to user
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to remove additional notification emails within the specified company.
         * @param {string} companyId A unique identifier for the company.
         * @param {string} emailToRemove The email to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserAdditionalNotificationEmails(id: string, companyId: string, emailToRemove: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.removeUserAdditionalNotificationEmails(id, companyId, emailToRemove, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets a specific credit balance for a user
         * @summary Set user credit balance
         * @param {string} id A unique identifier for the user
         * @param {string} companyId A unique identifier for the company.
         * @param {number} creditBalance The new credit balance to set for the user. Must be a non-negative number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserCreditBalance(id: string, companyId: string, creditBalance: number, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.setUserCreditBalance(id, companyId, creditBalance, options).then((request) => request(axios, basePath));
        },
        /**
         * Unban a previously banned user within a specific company. You can specify the user by their unique ID and the company using its unique ID. Returns a boolean indicating success.
         * @summary Unban User
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user you want to unban within the specified company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unbanUser(companyId: string, id: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.unbanUser(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Unlock the payments of a previously locked user within a specific company. You can specify the user by their unique ID and the company using its unique ID.Returns a boolean indicating success.
         * @summary Unlock User
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user whose payments you want to unlock within the specified company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockUser(companyId: string, id: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.unlockUser(companyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the balance for a specific user
         * @summary Update user balance
         * @param {string} id A unique identifier for the user
         * @param {string} companyId A unique identifier for the company.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserBalance(id: string, companyId: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.updateUserBalance(id, companyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the comments for a user related to a specific company. Use the user ID and company ID to identify the user, and provide the new comments in the body of the request. Returns a boolean indicating success.
         * @summary Update user comments
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to add a comment within the specified company.
         * @param {string} companyId A unique identifier for the company.
         * @param {UpdateUserCommentsRequest} updateUserCommentsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserComments(id: string, companyId: string, updateUserCommentsRequest: UpdateUserCommentsRequest, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.updateUserComments(id, companyId, updateUserCommentsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Add custom price policies to a user related to a company. Identify the user by their unique ID and the company by its unique ID. Provide an array of custom price policies using the request body. Returns a boolean indicating success.
         * @summary Update custom price policies
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user to which you want to add custom price policies within the specified company.
         * @param {string} companyId A unique identifier for the company.
         * @param {Array<UserPricePolicyRequestDto>} userPricePolicyRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserCustomPricePolicies(id: string, companyId: string, userPricePolicyRequestDto: Array<UserPricePolicyRequestDto>, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.updateUserCustomPricePolicies(id, companyId, userPricePolicyRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the invoice contact for a specific user
         * @summary Update user invoice contact
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the user
         * @param {string} invoiceContactId A unique identifier for the invoice contact to be assigned to the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInvoiceContact(companyId: string, id: string, invoiceContactId: string, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.updateUserInvoiceContact(companyId, id, invoiceContactId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the invoice interval for a user related to a company. Identify the user by their unique ID and specify the new invoice interval. Returns a boolean indicating success.
         * @summary Update invoice interval
         * @param {string} companyId A unique identifier for the company.
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to update the invoice interval within the specified company.
         * @param {UpdateUserInvoiceIntervalInvoiceIntervalEnum} invoiceInterval The new invoice interval to be set for the user. Choose from available options.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInvoiceInterval(companyId: string, id: string, invoiceInterval: UpdateUserInvoiceIntervalInvoiceIntervalEnum, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.updateUserInvoiceInterval(companyId, id, invoiceInterval, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update languages
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user whose preferred languages you want to update within the specified company.
         * @param {string} companyId A unique identifier for the company.
         * @param {UpdateUserLanguagesLanguageEnum} language The new language preference for the user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserLanguages(id: string, companyId: string, language: UpdateUserLanguagesLanguageEnum, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.updateUserLanguages(id, companyId, language, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the tags for a user within a specific company. Identify the user by their unique ID and the company by its unique ID. Provide an array of tags to replace the existing tags on the user\'s profile. Returns a boolean indicating success.
         * @summary Update user tags
         * @param {string} id A unique identifier for the user. Use this parameter to specify the user on whose profile you want to update the tags within the specified company.
         * @param {string} companyId A unique identifier for the company.
         * @param {UpdateUserTagsRequest} updateUserTagsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserTags(id: string, companyId: string, updateUserTagsRequest: UpdateUserTagsRequest, options?: any): AxiosPromise<UpdateIntegration200Response> {
            return localVarFp.updateUserTags(id, companyId, updateUserTagsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Add a notification email for a user within a company. Identify the user by their unique ID and provide the new email address as a query parameter. Returns a boolean indicating success.
     * @summary Add notification email
     * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to retrieve additional notification emails within the specified company.
     * @param {string} companyId A unique identifier for the company.
     * @param {string} newEmail The email to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public addNotificationEmail(id: string, companyId: string, newEmail: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).addNotificationEmail(id, companyId, newEmail, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Activate a ban on a user within a specific company. You can specify the user by their unique ID and the company using its unique ID. Returns a boolean indicating success.
     * @summary Ban User
     * @param {string} id A unique identifier for the user. Use this parameter to specify the user you want to ban within the specified company.
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public banUser(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).banUser(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a custom token for a user and return it
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public customToken(companyId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).customToken(companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a user related to a specific company. You can specify the user by their unique ID and the company using its unique ID. The operation includes checks for balance, active payments, and parent-child relationships.Returns an empty response.
     * @summary Delete a user
     * @param {string} id A unique identifier for the user. Use this parameter to specify the user you want to delete within the specified company.
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).deleteUser(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all users related to the specified company with optional filters applied. Returns an array of UserResponseDto objects.
     * @summary Get list of all users
     * @param {string} companyId A unique identifier for the company.
     * @param {number} [perPage] per Page 
     * @param {number} [currentPage] current page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getCompanyPaginatedUsers(companyId: string, perPage?: number, currentPage?: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getCompanyPaginatedUsers(companyId, perPage, currentPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve detailed information about a user related to a specific company using the user\'s unique ID within the company as a parameter. Returns a single UserDto object containing user-related data.
     * @summary Get a user
     * @param {string} id A unique identifier for the user.
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUser(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the additional notification emails of a user related to a company. Identify the user by their unique ID and specify the company using the company ID. Returns an array of email addresses.
     * @summary Get additional notification emails of user
     * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to retrieve additional notification emails within the specified company.
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserAdditionalNotificationEmails(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserAdditionalNotificationEmails(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the balance information for a specific user
     * @summary Get user balance
     * @param {string} id A unique identifier for the user
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserBalance(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserBalance(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve comments related to a user within a company. Identify the user by their unique ID and specify the company using the company ID.Returns an array of comments.
     * @summary Get user comments
     * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to retrieve comments within the specified company.
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserComments(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserComments(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all payments of a user
     * @summary Get user payments
     * @param {string} companyId A unique identifier for the company.
     * @param {string} id A unique identifier for the user. Use this parameter to specify the user on whose profile you want to update the tags within the specified company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserTransactions(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserTransactions(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lock the payments for a user within a specific company. You can specify the user by their unique ID and the company using its unique ID. Returns a boolean indicating success.
     * @summary Lock User
     * @param {string} id A unique identifier for the user. Use this parameter to specify which user\&#39;s payments to lock.
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public lockUser(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).lockUser(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove an additional notification email to a user related to a company. Identify the user by their unique ID and specify the company using the company ID. Returns a boolean indicating success.
     * @summary Remove additional notification emails to user
     * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to remove additional notification emails within the specified company.
     * @param {string} companyId A unique identifier for the company.
     * @param {string} emailToRemove The email to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public removeUserAdditionalNotificationEmails(id: string, companyId: string, emailToRemove: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).removeUserAdditionalNotificationEmails(id, companyId, emailToRemove, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets a specific credit balance for a user
     * @summary Set user credit balance
     * @param {string} id A unique identifier for the user
     * @param {string} companyId A unique identifier for the company.
     * @param {number} creditBalance The new credit balance to set for the user. Must be a non-negative number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public setUserCreditBalance(id: string, companyId: string, creditBalance: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).setUserCreditBalance(id, companyId, creditBalance, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unban a previously banned user within a specific company. You can specify the user by their unique ID and the company using its unique ID. Returns a boolean indicating success.
     * @summary Unban User
     * @param {string} companyId A unique identifier for the company.
     * @param {string} id A unique identifier for the user. Use this parameter to specify the user you want to unban within the specified company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public unbanUser(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).unbanUser(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unlock the payments of a previously locked user within a specific company. You can specify the user by their unique ID and the company using its unique ID.Returns a boolean indicating success.
     * @summary Unlock User
     * @param {string} companyId A unique identifier for the company.
     * @param {string} id A unique identifier for the user. Use this parameter to specify the user whose payments you want to unlock within the specified company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public unlockUser(companyId: string, id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).unlockUser(companyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the balance for a specific user
     * @summary Update user balance
     * @param {string} id A unique identifier for the user
     * @param {string} companyId A unique identifier for the company.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserBalance(id: string, companyId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserBalance(id, companyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the comments for a user related to a specific company. Use the user ID and company ID to identify the user, and provide the new comments in the body of the request. Returns a boolean indicating success.
     * @summary Update user comments
     * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to add a comment within the specified company.
     * @param {string} companyId A unique identifier for the company.
     * @param {UpdateUserCommentsRequest} updateUserCommentsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserComments(id: string, companyId: string, updateUserCommentsRequest: UpdateUserCommentsRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserComments(id, companyId, updateUserCommentsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add custom price policies to a user related to a company. Identify the user by their unique ID and the company by its unique ID. Provide an array of custom price policies using the request body. Returns a boolean indicating success.
     * @summary Update custom price policies
     * @param {string} id A unique identifier for the user. Use this parameter to specify the user to which you want to add custom price policies within the specified company.
     * @param {string} companyId A unique identifier for the company.
     * @param {Array<UserPricePolicyRequestDto>} userPricePolicyRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserCustomPricePolicies(id: string, companyId: string, userPricePolicyRequestDto: Array<UserPricePolicyRequestDto>, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserCustomPricePolicies(id, companyId, userPricePolicyRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the invoice contact for a specific user
     * @summary Update user invoice contact
     * @param {string} companyId A unique identifier for the company.
     * @param {string} id A unique identifier for the user
     * @param {string} invoiceContactId A unique identifier for the invoice contact to be assigned to the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserInvoiceContact(companyId: string, id: string, invoiceContactId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserInvoiceContact(companyId, id, invoiceContactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the invoice interval for a user related to a company. Identify the user by their unique ID and specify the new invoice interval. Returns a boolean indicating success.
     * @summary Update invoice interval
     * @param {string} companyId A unique identifier for the company.
     * @param {string} id A unique identifier for the user. Use this parameter to specify the user for whom you want to update the invoice interval within the specified company.
     * @param {UpdateUserInvoiceIntervalInvoiceIntervalEnum} invoiceInterval The new invoice interval to be set for the user. Choose from available options.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserInvoiceInterval(companyId: string, id: string, invoiceInterval: UpdateUserInvoiceIntervalInvoiceIntervalEnum, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserInvoiceInterval(companyId, id, invoiceInterval, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update languages
     * @param {string} id A unique identifier for the user. Use this parameter to specify the user whose preferred languages you want to update within the specified company.
     * @param {string} companyId A unique identifier for the company.
     * @param {UpdateUserLanguagesLanguageEnum} language The new language preference for the user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserLanguages(id: string, companyId: string, language: UpdateUserLanguagesLanguageEnum, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserLanguages(id, companyId, language, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the tags for a user within a specific company. Identify the user by their unique ID and the company by its unique ID. Provide an array of tags to replace the existing tags on the user\'s profile. Returns a boolean indicating success.
     * @summary Update user tags
     * @param {string} id A unique identifier for the user. Use this parameter to specify the user on whose profile you want to update the tags within the specified company.
     * @param {string} companyId A unique identifier for the company.
     * @param {UpdateUserTagsRequest} updateUserTagsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserTags(id: string, companyId: string, updateUserTagsRequest: UpdateUserTagsRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateUserTags(id, companyId, updateUserTagsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const UpdateUserInvoiceIntervalInvoiceIntervalEnum = {
    Instant: 'instant',
    Weekly: 'weekly',
    Monthly: 'monthly',
    PerRequest: 'per request'
} as const;
export type UpdateUserInvoiceIntervalInvoiceIntervalEnum = typeof UpdateUserInvoiceIntervalInvoiceIntervalEnum[keyof typeof UpdateUserInvoiceIntervalInvoiceIntervalEnum];
/**
 * @export
 */
export const UpdateUserLanguagesLanguageEnum = {
    Ab: 'AB',
    Aa: 'AA',
    Af: 'AF',
    Ak: 'AK',
    Sq: 'SQ',
    Am: 'AM',
    Ar: 'AR',
    An: 'AN',
    Hy: 'HY',
    As: 'AS',
    Av: 'AV',
    Ae: 'AE',
    Ay: 'AY',
    Az: 'AZ',
    Bm: 'BM',
    Ba: 'BA',
    Eu: 'EU',
    Be: 'BE',
    Bn: 'BN',
    Bi: 'BI',
    Bs: 'BS',
    Br: 'BR',
    Bg: 'BG',
    My: 'MY',
    Ca: 'CA',
    Km: 'KM',
    Ch: 'CH',
    Ce: 'CE',
    Ny: 'NY',
    Zh: 'ZH',
    Cu: 'CU',
    Cv: 'CV',
    Kw: 'KW',
    Co: 'CO',
    Cr: 'CR',
    Hr: 'HR',
    Cs: 'CS',
    Da: 'DA',
    Dv: 'DV',
    Nl: 'NL',
    Dz: 'DZ',
    En: 'EN',
    Eo: 'EO',
    Et: 'ET',
    Ee: 'EE',
    Fo: 'FO',
    Fj: 'FJ',
    Fi: 'FI',
    Fr: 'FR',
    Ff: 'FF',
    Gl: 'GL',
    Lg: 'LG',
    Ka: 'KA',
    De: 'DE',
    El: 'EL',
    Gn: 'GN',
    Gu: 'GU',
    Ht: 'HT',
    Ha: 'HA',
    He: 'HE',
    Hz: 'HZ',
    Hi: 'HI',
    Ho: 'HO',
    Hu: 'HU',
    Is: 'IS',
    Io: 'IO',
    Ig: 'IG',
    Id: 'ID',
    Ia: 'IA',
    Ie: 'IE',
    Iu: 'IU',
    Ik: 'IK',
    Ga: 'GA',
    It: 'IT',
    Ja: 'JA',
    Jv: 'JV',
    Kl: 'KL',
    Kn: 'KN',
    Kr: 'KR',
    Ks: 'KS',
    Kk: 'KK',
    Ki: 'KI',
    Rw: 'RW',
    Ky: 'KY',
    Kv: 'KV',
    Kg: 'KG',
    Ko: 'KO',
    Kj: 'KJ',
    Ku: 'KU',
    Lo: 'LO',
    La: 'LA',
    Lv: 'LV',
    Li: 'LI',
    Ln: 'LN',
    Lt: 'LT',
    Lu: 'LU',
    Lb: 'LB',
    Mk: 'MK',
    Mg: 'MG',
    Ms: 'MS',
    Ml: 'ML',
    Mt: 'MT',
    Gv: 'GV',
    Mi: 'MI',
    Mr: 'MR',
    Mh: 'MH',
    Mn: 'MN',
    Na: 'NA',
    Nv: 'NV',
    Nd: 'ND',
    Nr: 'NR',
    Ng: 'NG',
    Ne: 'NE',
    Se: 'SE',
    No: 'NO',
    Nb: 'NB',
    Nn: 'NN',
    Ii: 'II',
    Oc: 'OC',
    Oj: 'OJ',
    Or: 'OR',
    Om: 'OM',
    Os: 'OS',
    Pi: 'PI',
    Ps: 'PS',
    Fa: 'FA',
    Pl: 'PL',
    Pt: 'PT',
    Pa: 'PA',
    Qu: 'QU',
    Ro: 'RO',
    Rm: 'RM',
    Rn: 'RN',
    Ru: 'RU',
    Sm: 'SM',
    Sg: 'SG',
    Sa: 'SA',
    Sc: 'SC',
    Gd: 'GD',
    Sr: 'SR',
    Sn: 'SN',
    Ii2: 'II',
    Sd: 'SD',
    Si: 'SI',
    Sk: 'SK',
    Sl: 'SL',
    So: 'SO',
    St: 'ST',
    Es: 'ES',
    Su: 'SU',
    Sw: 'SW',
    Ss: 'SS',
    Sv: 'SV',
    Tl: 'TL',
    Ty: 'TY',
    Tg: 'TG',
    Ta: 'TA',
    Tt: 'TT',
    Te: 'TE',
    Th: 'TH',
    Bo: 'BO',
    Ti: 'TI',
    To: 'TO',
    Ts: 'TS',
    Tn: 'TN',
    Tr: 'TR',
    Tk: 'TK',
    Tw: 'TW',
    Ug: 'UG',
    Uk: 'UK',
    Ur: 'UR',
    Uz: 'UZ',
    Ve: 'VE',
    Vi: 'VI',
    Vo: 'VO',
    Wa: 'WA',
    Cy: 'CY',
    Fy: 'FY',
    Wo: 'WO',
    Xh: 'XH',
    Yi: 'YI',
    Yo: 'YO',
    Za: 'ZA',
    Zu: 'ZU'
} as const;
export type UpdateUserLanguagesLanguageEnum = typeof UpdateUserLanguagesLanguageEnum[keyof typeof UpdateUserLanguagesLanguageEnum];


