"use strict";
/**
 * Hoster API
 * Hosting automation. The easy way
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DomainContactsApi = exports.DomainContactsApiApiKeys = void 0;
const request_1 = __importDefault(require("request"));
const models_1 = require("../model/models");
const models_2 = require("../model/models");
const apis_1 = require("./apis");
let defaultBasePath = 'http://localhost:3000';
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
var DomainContactsApiApiKeys;
(function (DomainContactsApiApiKeys) {
})(DomainContactsApiApiKeys || (exports.DomainContactsApiApiKeys = DomainContactsApiApiKeys = {}));
class DomainContactsApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this._defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new models_1.VoidAuth(),
            'jwt': new models_2.HttpBearerAuth(),
        };
        this.interceptors = [];
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    set defaultHeaders(defaultHeaders) {
        this._defaultHeaders = defaultHeaders;
    }
    get defaultHeaders() {
        return this._defaultHeaders;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[DomainContactsApiApiKeys[key]].apiKey = value;
    }
    set accessToken(accessToken) {
        this.authentications.jwt.accessToken = accessToken;
    }
    addInterceptor(interceptor) {
        this.interceptors.push(interceptor);
    }
    /**
     * Creates a new domain contact associated with a specific company based on the provided \'companyId\' path parameter. You should provide the details of the new domain contact in the request body using the \'DomainContactDto\'. This endpoint returns the domain contact data(\'DomainContactDto\') with a 201 status code upon success.
     * @summary Creates a new domain contact
     * @param companyId companyId
     * @param domainContactDto
     */
    domainContactCreate(companyId_1, domainContactDto_1) {
        return __awaiter(this, arguments, void 0, function* (companyId, domainContactDto, options = { headers: {} }) {
            const localVarPath = this.basePath + '/domain-contacts';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'companyId' is not null or undefined
            if (companyId === null || companyId === undefined) {
                throw new Error('Required parameter companyId was null or undefined when calling domainContactCreate.');
            }
            // verify required parameter 'domainContactDto' is not null or undefined
            if (domainContactDto === null || domainContactDto === undefined) {
                throw new Error('Required parameter domainContactDto was null or undefined when calling domainContactCreate.');
            }
            if (companyId !== undefined) {
                localVarQueryParameters['companyId'] = models_1.ObjectSerializer.serialize(companyId, "string");
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarUseFormData = false;
            let localVarRequestOptions = {
                method: 'POST',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: models_1.ObjectSerializer.serialize(domainContactDto, "DomainContactDto")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.jwt.accessToken) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.jwt.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    if (localVarUseFormData) {
                        localVarRequestOptions.formData = localVarFormParams;
                    }
                    else {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    (0, request_1.default)(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = models_1.ObjectSerializer.deserialize(body, "DomainContactCreate200Response");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new apis_1.HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Deletes a domain contact associated with a specific company. Provide the \'id\' of the domain contact you want to delete and the \'companyId\' it belongs to as path parameters. This endpoint returns a success response with a 200 status code upon successful deletion.
     * @summary Delete an domain contact
     * @param id The ID of the domain contact to delete.
     * @param companyId The ID of the company associated with the domain contact.
     */
    domainContactDelete(id_1, companyId_1) {
        return __awaiter(this, arguments, void 0, function* (id, companyId, options = { headers: {} }) {
            const localVarPath = this.basePath + '/domain-contacts/{id}'
                .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new Error('Required parameter id was null or undefined when calling domainContactDelete.');
            }
            // verify required parameter 'companyId' is not null or undefined
            if (companyId === null || companyId === undefined) {
                throw new Error('Required parameter companyId was null or undefined when calling domainContactDelete.');
            }
            if (companyId !== undefined) {
                localVarQueryParameters['companyId'] = models_1.ObjectSerializer.serialize(companyId, "string");
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarUseFormData = false;
            let localVarRequestOptions = {
                method: 'DELETE',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.jwt.accessToken) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.jwt.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    if (localVarUseFormData) {
                        localVarRequestOptions.formData = localVarFormParams;
                    }
                    else {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    (0, request_1.default)(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = models_1.ObjectSerializer.deserialize(body, "InvoiceGet200Response");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new apis_1.HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Retrieves a list of domain contacts associated with a specific company based on the provided parameters. You can filter the results by name, street, postcode, organization, city, state, telephone, fax, or email using the \'query\' parameter. If you want to filter by the country code, you can use the \'country\' parameter. You can also paginate the results by specifying the \'currentPage\' and \'perPage\' parameters. This endpoint returns a list of domain contacts (type: DomainContactDto) associated with the specified company.
     * @summary Get list of all domain contacts
     * @param companyId The ID of the company for which you want to retrieve domain contacts.
     * @param query A query string for searching domain contacts by name, street, postcode, organization, city, state, telephone, fax, or email. (Optional)
     * @param country Filter domain contacts by the ISO 3166-1-alpha-2 country code. (Optional)
     * @param userId Filter by the ID of the parent domain contact. (Optional)
     * @param currentPage The current page number for pagination. (Optional)
     * @param perPage The number of items to display per page. (Optional)
     */
    domainContactFind(companyId_1, query_1, country_1, userId_1, currentPage_1, perPage_1) {
        return __awaiter(this, arguments, void 0, function* (companyId, query, country, userId, currentPage, perPage, options = { headers: {} }) {
            const localVarPath = this.basePath + '/domain-contacts';
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'companyId' is not null or undefined
            if (companyId === null || companyId === undefined) {
                throw new Error('Required parameter companyId was null or undefined when calling domainContactFind.');
            }
            if (companyId !== undefined) {
                localVarQueryParameters['companyId'] = models_1.ObjectSerializer.serialize(companyId, "string");
            }
            if (query !== undefined) {
                localVarQueryParameters['query'] = models_1.ObjectSerializer.serialize(query, "string");
            }
            if (country !== undefined) {
                localVarQueryParameters['country'] = models_1.ObjectSerializer.serialize(country, "'AF' | 'AL' | 'DZ' | 'AS' | 'AD' | 'AO' | 'AI' | 'AQ' | 'AG' | 'AR' | 'AM' | 'AW' | 'AU' | 'AT' | 'AZ' | 'BS' | 'BH' | 'BD' | 'BB' | 'BY' | 'BE' | 'BZ' | 'BJ' | 'BM' | 'BT' | 'BO' | 'BQ' | 'BA' | 'BW' | 'BV' | 'BR' | 'IO' | 'BN' | 'BG' | 'BF' | 'BI' | 'KH' | 'CM' | 'CA' | 'CV' | 'KY' | 'CF' | 'TD' | 'CL' | 'CN' | 'CX' | 'CC' | 'CO' | 'KM' | 'CG' | 'CD' | 'CK' | 'CR' | 'CI' | 'HR' | 'CU' | 'CW' | 'CY' | 'CZ' | 'DK' | 'DJ' | 'DM' | 'DO' | 'EC' | 'EG' | 'SV' | 'GQ' | 'ER' | 'EE' | 'ET' | 'FK' | 'FO' | 'FJ' | 'FI' | 'FR' | 'GF' | 'PF' | 'TF' | 'GA' | 'GM' | 'GE' | 'DE' | 'GH' | 'GI' | 'GR' | 'GL' | 'GD' | 'GP' | 'GU' | 'GT' | 'GG' | 'GN' | 'GW' | 'GY' | 'HT' | 'HM' | 'VA' | 'HN' | 'HK' | 'HU' | 'IS' | 'IN' | 'ID' | 'IR' | 'IQ' | 'IE' | 'IM' | 'IL' | 'IT' | 'JM' | 'JP' | 'JE' | 'JO' | 'KZ' | 'KE' | 'KI' | 'KP' | 'KR' | 'KW' | 'KG' | 'LA' | 'LV' | 'LB' | 'LS' | 'LR' | 'LY' | 'LI' | 'LT' | 'LU' | 'MO' | 'MK' | 'MG' | 'MW' | 'MY' | 'MV' | 'ML' | 'MT' | 'MH' | 'MQ' | 'MR' | 'MU' | 'TN' | 'TR' | 'TM' | 'TC' | 'TV' | 'UG' | 'UA' | 'AE' | 'GB' | 'US' | 'UM' | 'UY' | 'UZ' | 'VU' | 'VE' | 'VN' | 'VG' | 'VI' | 'WF' | 'EH' | 'YE' | 'ZM' | 'ZW' | 'YT' | 'MX' | 'FM' | 'MD' | 'MC' | 'MN' | 'ME' | 'MS' | 'MA' | 'MZ' | 'MM' | 'NA' | 'NR' | 'NP' | 'NL' | 'NC' | 'NZ' | 'NI' | 'NE' | 'NG' | 'NU' | 'NF' | 'MP' | 'NO' | 'OM' | 'PK' | 'PW' | 'PS' | 'PA' | 'PG' | 'PY' | 'PE' | 'PH' | 'PN' | 'PL' | 'PT' | 'PR' | 'QA' | 'RE' | 'RO' | 'RU' | 'RW' | 'BL' | 'SH' | 'KN' | 'LC' | 'MF' | 'PM' | 'VC' | 'WS' | 'SM' | 'ST' | 'SA' | 'SN' | 'RS' | 'SC' | 'SL' | 'SG' | 'SX' | 'SK' | 'SI' | 'SB' | 'SO' | 'ZA' | 'GS' | 'SS' | 'ES' | 'LK' | 'SD' | 'SR' | 'SJ' | 'SZ' | 'SE' | 'CH' | 'SY' | 'TW' | 'TJ' | 'TZ' | 'TH' | 'TL' | 'TG' | 'TK' | 'TO' | 'TT'");
            }
            if (userId !== undefined) {
                localVarQueryParameters['userId'] = models_1.ObjectSerializer.serialize(userId, "string");
            }
            if (currentPage !== undefined) {
                localVarQueryParameters['currentPage'] = models_1.ObjectSerializer.serialize(currentPage, "number");
            }
            if (perPage !== undefined) {
                localVarQueryParameters['perPage'] = models_1.ObjectSerializer.serialize(perPage, "number");
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarUseFormData = false;
            let localVarRequestOptions = {
                method: 'GET',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.jwt.accessToken) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.jwt.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    if (localVarUseFormData) {
                        localVarRequestOptions.formData = localVarFormParams;
                    }
                    else {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    (0, request_1.default)(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = models_1.ObjectSerializer.deserialize(body, "DomainContactFind200Response");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new apis_1.HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Retrieves a specific domain contact associated with a company based on the provided parameters. This endpoint allows you to retrieve a specific domain contact by specifying its \'id\' and the \'companyId\' it belongs to. It returns detailed information about the domain contact.
     * @summary Get a domain contacts
     * @param id The ID of the domain contact.
     * @param companyId The ID of the company associated with the domain contact.
     */
    domainContactGet(id_1, companyId_1) {
        return __awaiter(this, arguments, void 0, function* (id, companyId, options = { headers: {} }) {
            const localVarPath = this.basePath + '/domain-contacts/{id}'
                .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new Error('Required parameter id was null or undefined when calling domainContactGet.');
            }
            // verify required parameter 'companyId' is not null or undefined
            if (companyId === null || companyId === undefined) {
                throw new Error('Required parameter companyId was null or undefined when calling domainContactGet.');
            }
            if (companyId !== undefined) {
                localVarQueryParameters['companyId'] = models_1.ObjectSerializer.serialize(companyId, "string");
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarUseFormData = false;
            let localVarRequestOptions = {
                method: 'GET',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.jwt.accessToken) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.jwt.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    if (localVarUseFormData) {
                        localVarRequestOptions.formData = localVarFormParams;
                    }
                    else {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    (0, request_1.default)(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = models_1.ObjectSerializer.deserialize(body, "DomainContactCreate200Response");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new apis_1.HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Updates an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact you want to update and the \'companyId\' it belongs to as path parameters. You should include the updated domain contact details in the request body using \'DomainContactDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
     * @summary Update domain contact
     * @param companyId The ID of the company associated with the domain contact.
     * @param id The ID of the domain contact to update.
     * @param domainContactDto
     */
    domainContactUpdate(companyId_1, id_1, domainContactDto_1) {
        return __awaiter(this, arguments, void 0, function* (companyId, id, domainContactDto, options = { headers: {} }) {
            const localVarPath = this.basePath + '/domain-contacts/{id}'
                .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'companyId' is not null or undefined
            if (companyId === null || companyId === undefined) {
                throw new Error('Required parameter companyId was null or undefined when calling domainContactUpdate.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new Error('Required parameter id was null or undefined when calling domainContactUpdate.');
            }
            // verify required parameter 'domainContactDto' is not null or undefined
            if (domainContactDto === null || domainContactDto === undefined) {
                throw new Error('Required parameter domainContactDto was null or undefined when calling domainContactUpdate.');
            }
            if (companyId !== undefined) {
                localVarQueryParameters['companyId'] = models_1.ObjectSerializer.serialize(companyId, "string");
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarUseFormData = false;
            let localVarRequestOptions = {
                method: 'PUT',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: models_1.ObjectSerializer.serialize(domainContactDto, "DomainContactDto")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.jwt.accessToken) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.jwt.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    if (localVarUseFormData) {
                        localVarRequestOptions.formData = localVarFormParams;
                    }
                    else {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    (0, request_1.default)(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = models_1.ObjectSerializer.deserialize(body, "DomainContactCreate200Response");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new apis_1.HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'AfnicAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
     * @summary Update afnic additional data
     * @param id The ID of the domain contact to update additional data for.
     * @param companyId The ID of the company associated with the domain contact.
     * @param afnicAdditionalDataDto
     */
    updateAfnicAdditionalData(id_1, companyId_1, afnicAdditionalDataDto_1) {
        return __awaiter(this, arguments, void 0, function* (id, companyId, afnicAdditionalDataDto, options = { headers: {} }) {
            const localVarPath = this.basePath + '/domain-contacts/{id}/additional/afnic'
                .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new Error('Required parameter id was null or undefined when calling updateAfnicAdditionalData.');
            }
            // verify required parameter 'companyId' is not null or undefined
            if (companyId === null || companyId === undefined) {
                throw new Error('Required parameter companyId was null or undefined when calling updateAfnicAdditionalData.');
            }
            // verify required parameter 'afnicAdditionalDataDto' is not null or undefined
            if (afnicAdditionalDataDto === null || afnicAdditionalDataDto === undefined) {
                throw new Error('Required parameter afnicAdditionalDataDto was null or undefined when calling updateAfnicAdditionalData.');
            }
            if (companyId !== undefined) {
                localVarQueryParameters['companyId'] = models_1.ObjectSerializer.serialize(companyId, "string");
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarUseFormData = false;
            let localVarRequestOptions = {
                method: 'PATCH',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: models_1.ObjectSerializer.serialize(afnicAdditionalDataDto, "AfnicAdditionalDataDto")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.jwt.accessToken) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.jwt.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    if (localVarUseFormData) {
                        localVarRequestOptions.formData = localVarFormParams;
                    }
                    else {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    (0, request_1.default)(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = models_1.ObjectSerializer.deserialize(body, "DomainContactCreate200Response");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new apis_1.HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'CatAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
     * @summary Update Cat additional data
     * @param id The ID of the domain contact to update additional data for.
     * @param companyId The ID of the company associated with the domain contact.
     * @param catAdditionalDataDto
     */
    updateCatAdditionalData(id_1, companyId_1, catAdditionalDataDto_1) {
        return __awaiter(this, arguments, void 0, function* (id, companyId, catAdditionalDataDto, options = { headers: {} }) {
            const localVarPath = this.basePath + '/domain-contacts/{id}/additional/cat'
                .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new Error('Required parameter id was null or undefined when calling updateCatAdditionalData.');
            }
            // verify required parameter 'companyId' is not null or undefined
            if (companyId === null || companyId === undefined) {
                throw new Error('Required parameter companyId was null or undefined when calling updateCatAdditionalData.');
            }
            // verify required parameter 'catAdditionalDataDto' is not null or undefined
            if (catAdditionalDataDto === null || catAdditionalDataDto === undefined) {
                throw new Error('Required parameter catAdditionalDataDto was null or undefined when calling updateCatAdditionalData.');
            }
            if (companyId !== undefined) {
                localVarQueryParameters['companyId'] = models_1.ObjectSerializer.serialize(companyId, "string");
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarUseFormData = false;
            let localVarRequestOptions = {
                method: 'PATCH',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: models_1.ObjectSerializer.serialize(catAdditionalDataDto, "CatAdditionalDataDto")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.jwt.accessToken) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.jwt.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    if (localVarUseFormData) {
                        localVarRequestOptions.formData = localVarFormParams;
                    }
                    else {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    (0, request_1.default)(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = models_1.ObjectSerializer.deserialize(body, "DomainContactCreate200Response");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new apis_1.HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'DeAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
     * @summary Update de additional data
     * @param id The ID of the domain contact to update additional data for.
     * @param companyId The ID of the company associated with the domain contact.
     * @param deAdditionalDataDto
     */
    updateDeAdditionalData(id_1, companyId_1, deAdditionalDataDto_1) {
        return __awaiter(this, arguments, void 0, function* (id, companyId, deAdditionalDataDto, options = { headers: {} }) {
            const localVarPath = this.basePath + '/domain-contacts/{id}/additional/de'
                .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new Error('Required parameter id was null or undefined when calling updateDeAdditionalData.');
            }
            // verify required parameter 'companyId' is not null or undefined
            if (companyId === null || companyId === undefined) {
                throw new Error('Required parameter companyId was null or undefined when calling updateDeAdditionalData.');
            }
            // verify required parameter 'deAdditionalDataDto' is not null or undefined
            if (deAdditionalDataDto === null || deAdditionalDataDto === undefined) {
                throw new Error('Required parameter deAdditionalDataDto was null or undefined when calling updateDeAdditionalData.');
            }
            if (companyId !== undefined) {
                localVarQueryParameters['companyId'] = models_1.ObjectSerializer.serialize(companyId, "string");
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarUseFormData = false;
            let localVarRequestOptions = {
                method: 'PATCH',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: models_1.ObjectSerializer.serialize(deAdditionalDataDto, "DeAdditionalDataDto")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.jwt.accessToken) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.jwt.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    if (localVarUseFormData) {
                        localVarRequestOptions.formData = localVarFormParams;
                    }
                    else {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    (0, request_1.default)(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = models_1.ObjectSerializer.deserialize(body, "DomainContactCreate200Response");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new apis_1.HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'EsAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
     * @summary Update es additional data
     * @param id The ID of the domain contact to update additional data for.
     * @param companyId The ID of the company associated with the domain contact.
     * @param esAdditionalDataDto
     */
    updateEsAdditionalData(id_1, companyId_1, esAdditionalDataDto_1) {
        return __awaiter(this, arguments, void 0, function* (id, companyId, esAdditionalDataDto, options = { headers: {} }) {
            const localVarPath = this.basePath + '/domain-contacts/{id}/additional/es'
                .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new Error('Required parameter id was null or undefined when calling updateEsAdditionalData.');
            }
            // verify required parameter 'companyId' is not null or undefined
            if (companyId === null || companyId === undefined) {
                throw new Error('Required parameter companyId was null or undefined when calling updateEsAdditionalData.');
            }
            // verify required parameter 'esAdditionalDataDto' is not null or undefined
            if (esAdditionalDataDto === null || esAdditionalDataDto === undefined) {
                throw new Error('Required parameter esAdditionalDataDto was null or undefined when calling updateEsAdditionalData.');
            }
            if (companyId !== undefined) {
                localVarQueryParameters['companyId'] = models_1.ObjectSerializer.serialize(companyId, "string");
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarUseFormData = false;
            let localVarRequestOptions = {
                method: 'PATCH',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: models_1.ObjectSerializer.serialize(esAdditionalDataDto, "EsAdditionalDataDto")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.jwt.accessToken) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.jwt.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    if (localVarUseFormData) {
                        localVarRequestOptions.formData = localVarFormParams;
                    }
                    else {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    (0, request_1.default)(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = models_1.ObjectSerializer.deserialize(body, "DomainContactCreate200Response");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new apis_1.HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'EuBeAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
     * @summary Update eu-be additional data
     * @param id The ID of the domain contact to update additional data for.
     * @param companyId The ID of the company associated with the domain contact.
     * @param euBeAdditionalDataDto
     */
    updateEuBeAdditionalData(id_1, companyId_1, euBeAdditionalDataDto_1) {
        return __awaiter(this, arguments, void 0, function* (id, companyId, euBeAdditionalDataDto, options = { headers: {} }) {
            const localVarPath = this.basePath + '/domain-contacts/{id}/additional/eu-be'
                .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new Error('Required parameter id was null or undefined when calling updateEuBeAdditionalData.');
            }
            // verify required parameter 'companyId' is not null or undefined
            if (companyId === null || companyId === undefined) {
                throw new Error('Required parameter companyId was null or undefined when calling updateEuBeAdditionalData.');
            }
            // verify required parameter 'euBeAdditionalDataDto' is not null or undefined
            if (euBeAdditionalDataDto === null || euBeAdditionalDataDto === undefined) {
                throw new Error('Required parameter euBeAdditionalDataDto was null or undefined when calling updateEuBeAdditionalData.');
            }
            if (companyId !== undefined) {
                localVarQueryParameters['companyId'] = models_1.ObjectSerializer.serialize(companyId, "string");
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarUseFormData = false;
            let localVarRequestOptions = {
                method: 'PATCH',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: models_1.ObjectSerializer.serialize(euBeAdditionalDataDto, "EuBeAdditionalDataDto")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.jwt.accessToken) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.jwt.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    if (localVarUseFormData) {
                        localVarRequestOptions.formData = localVarFormParams;
                    }
                    else {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    (0, request_1.default)(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = models_1.ObjectSerializer.deserialize(body, "DomainContactCreate200Response");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new apis_1.HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'ItAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
     * @summary Update IT additional data
     * @param id The ID of the domain contact to update additional data for.
     * @param companyId The ID of the company associated with the domain contact.
     * @param itAdditionalDataDto
     */
    updateItAdditionalData(id_1, companyId_1, itAdditionalDataDto_1) {
        return __awaiter(this, arguments, void 0, function* (id, companyId, itAdditionalDataDto, options = { headers: {} }) {
            const localVarPath = this.basePath + '/domain-contacts/{id}/additional/it'
                .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new Error('Required parameter id was null or undefined when calling updateItAdditionalData.');
            }
            // verify required parameter 'companyId' is not null or undefined
            if (companyId === null || companyId === undefined) {
                throw new Error('Required parameter companyId was null or undefined when calling updateItAdditionalData.');
            }
            // verify required parameter 'itAdditionalDataDto' is not null or undefined
            if (itAdditionalDataDto === null || itAdditionalDataDto === undefined) {
                throw new Error('Required parameter itAdditionalDataDto was null or undefined when calling updateItAdditionalData.');
            }
            if (companyId !== undefined) {
                localVarQueryParameters['companyId'] = models_1.ObjectSerializer.serialize(companyId, "string");
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarUseFormData = false;
            let localVarRequestOptions = {
                method: 'PATCH',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: models_1.ObjectSerializer.serialize(itAdditionalDataDto, "ItAdditionalDataDto")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.jwt.accessToken) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.jwt.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    if (localVarUseFormData) {
                        localVarRequestOptions.formData = localVarFormParams;
                    }
                    else {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    (0, request_1.default)(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = models_1.ObjectSerializer.deserialize(body, "DomainContactCreate200Response");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new apis_1.HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'ItAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
     * @summary Update IT additional data
     * @param id The ID of the domain contact to update additional data for.
     * @param companyId The ID of the company associated with the domain contact.
     * @param lvAdditionalDataDto
     */
    updateLvAdditionalData(id_1, companyId_1, lvAdditionalDataDto_1) {
        return __awaiter(this, arguments, void 0, function* (id, companyId, lvAdditionalDataDto, options = { headers: {} }) {
            const localVarPath = this.basePath + '/domain-contacts/{id}/additional/lv'
                .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new Error('Required parameter id was null or undefined when calling updateLvAdditionalData.');
            }
            // verify required parameter 'companyId' is not null or undefined
            if (companyId === null || companyId === undefined) {
                throw new Error('Required parameter companyId was null or undefined when calling updateLvAdditionalData.');
            }
            // verify required parameter 'lvAdditionalDataDto' is not null or undefined
            if (lvAdditionalDataDto === null || lvAdditionalDataDto === undefined) {
                throw new Error('Required parameter lvAdditionalDataDto was null or undefined when calling updateLvAdditionalData.');
            }
            if (companyId !== undefined) {
                localVarQueryParameters['companyId'] = models_1.ObjectSerializer.serialize(companyId, "string");
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarUseFormData = false;
            let localVarRequestOptions = {
                method: 'PATCH',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: models_1.ObjectSerializer.serialize(lvAdditionalDataDto, "LvAdditionalDataDto")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.jwt.accessToken) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.jwt.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    if (localVarUseFormData) {
                        localVarRequestOptions.formData = localVarFormParams;
                    }
                    else {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    (0, request_1.default)(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = models_1.ObjectSerializer.deserialize(body, "DomainContactCreate200Response");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new apis_1.HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Updates the additional data for an existing domain contact associated with a specific company. Provide the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. You should include the updated additional data in the request body using \'NlAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
     * @summary Update NL additional data
     * @param id The ID of the domain contact to update additional data for.
     * @param companyId The ID of the company associated with the domain contact.
     * @param nlAdditionalDataDto
     */
    updateNlAdditionalData(id_1, companyId_1, nlAdditionalDataDto_1) {
        return __awaiter(this, arguments, void 0, function* (id, companyId, nlAdditionalDataDto, options = { headers: {} }) {
            const localVarPath = this.basePath + '/domain-contacts/{id}/additional/nl'
                .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new Error('Required parameter id was null or undefined when calling updateNlAdditionalData.');
            }
            // verify required parameter 'companyId' is not null or undefined
            if (companyId === null || companyId === undefined) {
                throw new Error('Required parameter companyId was null or undefined when calling updateNlAdditionalData.');
            }
            // verify required parameter 'nlAdditionalDataDto' is not null or undefined
            if (nlAdditionalDataDto === null || nlAdditionalDataDto === undefined) {
                throw new Error('Required parameter nlAdditionalDataDto was null or undefined when calling updateNlAdditionalData.');
            }
            if (companyId !== undefined) {
                localVarQueryParameters['companyId'] = models_1.ObjectSerializer.serialize(companyId, "string");
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarUseFormData = false;
            let localVarRequestOptions = {
                method: 'PATCH',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: models_1.ObjectSerializer.serialize(nlAdditionalDataDto, "NlAdditionalDataDto")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.jwt.accessToken) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.jwt.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    if (localVarUseFormData) {
                        localVarRequestOptions.formData = localVarFormParams;
                    }
                    else {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    (0, request_1.default)(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = models_1.ObjectSerializer.deserialize(body, "DomainContactCreate200Response");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new apis_1.HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Update additional data for a domain contact in the \'Pro\' category associated with a specific company. Specify the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. Include the updated additional data details in the request body using \'ProAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
     * @summary Update Pro additional data
     * @param id The ID of the domain contact to update.
     * @param companyId The ID of the company associated with the domain contact.
     * @param proAdditionalDataDto
     */
    updateProAdditionalData(id_1, companyId_1, proAdditionalDataDto_1) {
        return __awaiter(this, arguments, void 0, function* (id, companyId, proAdditionalDataDto, options = { headers: {} }) {
            const localVarPath = this.basePath + '/domain-contacts/{id}/additional/pro'
                .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new Error('Required parameter id was null or undefined when calling updateProAdditionalData.');
            }
            // verify required parameter 'companyId' is not null or undefined
            if (companyId === null || companyId === undefined) {
                throw new Error('Required parameter companyId was null or undefined when calling updateProAdditionalData.');
            }
            // verify required parameter 'proAdditionalDataDto' is not null or undefined
            if (proAdditionalDataDto === null || proAdditionalDataDto === undefined) {
                throw new Error('Required parameter proAdditionalDataDto was null or undefined when calling updateProAdditionalData.');
            }
            if (companyId !== undefined) {
                localVarQueryParameters['companyId'] = models_1.ObjectSerializer.serialize(companyId, "string");
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarUseFormData = false;
            let localVarRequestOptions = {
                method: 'PATCH',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: models_1.ObjectSerializer.serialize(proAdditionalDataDto, "ProAdditionalDataDto")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.jwt.accessToken) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.jwt.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    if (localVarUseFormData) {
                        localVarRequestOptions.formData = localVarFormParams;
                    }
                    else {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    (0, request_1.default)(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = models_1.ObjectSerializer.deserialize(body, "DomainContactCreate200Response");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new apis_1.HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Update additional data for a domain contact in the \'UK\' category associated with a specific company. Specify the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. Include the updated additional data details in the request body using \'UkAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
     * @summary Update UK additional data
     * @param id The ID of the domain contact to update.
     * @param companyId The ID of the company associated with the domain contact.
     * @param ukAdditionalDataDto
     */
    updateUkAdditionalData(id_1, companyId_1, ukAdditionalDataDto_1) {
        return __awaiter(this, arguments, void 0, function* (id, companyId, ukAdditionalDataDto, options = { headers: {} }) {
            const localVarPath = this.basePath + '/domain-contacts/{id}/additional/uk'
                .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new Error('Required parameter id was null or undefined when calling updateUkAdditionalData.');
            }
            // verify required parameter 'companyId' is not null or undefined
            if (companyId === null || companyId === undefined) {
                throw new Error('Required parameter companyId was null or undefined when calling updateUkAdditionalData.');
            }
            // verify required parameter 'ukAdditionalDataDto' is not null or undefined
            if (ukAdditionalDataDto === null || ukAdditionalDataDto === undefined) {
                throw new Error('Required parameter ukAdditionalDataDto was null or undefined when calling updateUkAdditionalData.');
            }
            if (companyId !== undefined) {
                localVarQueryParameters['companyId'] = models_1.ObjectSerializer.serialize(companyId, "string");
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarUseFormData = false;
            let localVarRequestOptions = {
                method: 'PATCH',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: models_1.ObjectSerializer.serialize(ukAdditionalDataDto, "UkAdditionalDataDto")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.jwt.accessToken) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.jwt.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    if (localVarUseFormData) {
                        localVarRequestOptions.formData = localVarFormParams;
                    }
                    else {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    (0, request_1.default)(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = models_1.ObjectSerializer.deserialize(body, "DomainContactCreate200Response");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new apis_1.HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
    /**
     * Update additional data for a domain contact in the \'US\' category associated with a specific company. Specify the \'id\' of the domain contact and the \'companyId\' it belongs to as path parameters. Include the updated additional data details in the request body using \'UsAdditionalDataDto\'. This endpoint returns the updated domain contact data (\'DomainContactDto\') with a 200 status code upon success.
     * @summary Update US additional data
     * @param id The ID of the domain contact to update.
     * @param companyId The ID of the company associated with the domain contact.
     * @param usAdditionalDataDto
     */
    updateUsAdditionalData(id_1, companyId_1, usAdditionalDataDto_1) {
        return __awaiter(this, arguments, void 0, function* (id, companyId, usAdditionalDataDto, options = { headers: {} }) {
            const localVarPath = this.basePath + '/domain-contacts/{id}/additional/us'
                .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
            let localVarQueryParameters = {};
            let localVarHeaderParams = Object.assign({}, this._defaultHeaders);
            const produces = ['application/json'];
            // give precedence to 'application/json'
            if (produces.indexOf('application/json') >= 0) {
                localVarHeaderParams.Accept = 'application/json';
            }
            else {
                localVarHeaderParams.Accept = produces.join(',');
            }
            let localVarFormParams = {};
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new Error('Required parameter id was null or undefined when calling updateUsAdditionalData.');
            }
            // verify required parameter 'companyId' is not null or undefined
            if (companyId === null || companyId === undefined) {
                throw new Error('Required parameter companyId was null or undefined when calling updateUsAdditionalData.');
            }
            // verify required parameter 'usAdditionalDataDto' is not null or undefined
            if (usAdditionalDataDto === null || usAdditionalDataDto === undefined) {
                throw new Error('Required parameter usAdditionalDataDto was null or undefined when calling updateUsAdditionalData.');
            }
            if (companyId !== undefined) {
                localVarQueryParameters['companyId'] = models_1.ObjectSerializer.serialize(companyId, "string");
            }
            Object.assign(localVarHeaderParams, options.headers);
            let localVarUseFormData = false;
            let localVarRequestOptions = {
                method: 'PATCH',
                qs: localVarQueryParameters,
                headers: localVarHeaderParams,
                uri: localVarPath,
                useQuerystring: this._useQuerystring,
                json: true,
                body: models_1.ObjectSerializer.serialize(usAdditionalDataDto, "UsAdditionalDataDto")
            };
            let authenticationPromise = Promise.resolve();
            if (this.authentications.jwt.accessToken) {
                authenticationPromise = authenticationPromise.then(() => this.authentications.jwt.applyToRequest(localVarRequestOptions));
            }
            authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
            let interceptorPromise = authenticationPromise;
            for (const interceptor of this.interceptors) {
                interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
            }
            return interceptorPromise.then(() => {
                if (Object.keys(localVarFormParams).length) {
                    if (localVarUseFormData) {
                        localVarRequestOptions.formData = localVarFormParams;
                    }
                    else {
                        localVarRequestOptions.form = localVarFormParams;
                    }
                }
                return new Promise((resolve, reject) => {
                    (0, request_1.default)(localVarRequestOptions, (error, response, body) => {
                        if (error) {
                            reject(error);
                        }
                        else {
                            if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                                body = models_1.ObjectSerializer.deserialize(body, "DomainContactCreate200Response");
                                resolve({ response: response, body: body });
                            }
                            else {
                                reject(new apis_1.HttpError(response, body, response.statusCode));
                            }
                        }
                    });
                });
            });
        });
    }
}
exports.DomainContactsApi = DomainContactsApi;
